(function () {
  'use strict';

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties$1(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass$1(e, r, t) {
    return r && _defineProperties$1(e.prototype, r), t && _defineProperties$1(e, t), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var n = 0,
          F = function () {};
        return {
          s: F,
          n: function () {
            return n >= r.length ? {
              done: !0
            } : {
              done: !1,
              value: r[n++]
            };
          },
          e: function (r) {
            throw r;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o,
      a = !0,
      u = !1;
    return {
      s: function () {
        t = t.call(r);
      },
      n: function () {
        var r = t.next();
        return a = r.done, r;
      },
      e: function (r) {
        u = !0, o = r;
      },
      f: function () {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var jquery = {exports: {}};

  /*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   */

  (function (module) {
  	( function( global, factory ) {

  		{

  			// For CommonJS and CommonJS-like environments where a proper `window`
  			// is present, execute the factory and get jQuery.
  			// For environments that do not have a `window` with a `document`
  			// (such as Node.js), expose a factory as module.exports.
  			// This accentuates the need for the creation of a real `window`.
  			// e.g. var jQuery = require("jquery")(window);
  			// See ticket trac-14549 for more info.
  			module.exports = global.document ?
  				factory( global, true ) :
  				function( w ) {
  					if ( !w.document ) {
  						throw new Error( "jQuery requires a window with a document" );
  					}
  					return factory( w );
  				};
  		}

  	// Pass this if window is not defined yet
  	} )( typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

  	var arr = [];

  	var getProto = Object.getPrototypeOf;

  	var slice = arr.slice;

  	var flat = arr.flat ? function( array ) {
  		return arr.flat.call( array );
  	} : function( array ) {
  		return arr.concat.apply( [], array );
  	};


  	var push = arr.push;

  	var indexOf = arr.indexOf;

  	var class2type = {};

  	var toString = class2type.toString;

  	var hasOwn = class2type.hasOwnProperty;

  	var fnToString = hasOwn.toString;

  	var ObjectFunctionString = fnToString.call( Object );

  	var support = {};

  	var isFunction = function isFunction( obj ) {

  			// Support: Chrome <=57, Firefox <=52
  			// In some browsers, typeof returns "function" for HTML <object> elements
  			// (i.e., `typeof document.createElement( "object" ) === "function"`).
  			// We don't want to classify *any* DOM node as a function.
  			// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
  			// Plus for old WebKit, typeof returns "function" for HTML collections
  			// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
  			return typeof obj === "function" && typeof obj.nodeType !== "number" &&
  				typeof obj.item !== "function";
  		};


  	var isWindow = function isWindow( obj ) {
  			return obj != null && obj === obj.window;
  		};


  	var document = window.document;



  		var preservedScriptAttributes = {
  			type: true,
  			src: true,
  			nonce: true,
  			noModule: true
  		};

  		function DOMEval( code, node, doc ) {
  			doc = doc || document;

  			var i, val,
  				script = doc.createElement( "script" );

  			script.text = code;
  			if ( node ) {
  				for ( i in preservedScriptAttributes ) {

  					// Support: Firefox 64+, Edge 18+
  					// Some browsers don't support the "nonce" property on scripts.
  					// On the other hand, just using `getAttribute` is not enough as
  					// the `nonce` attribute is reset to an empty string whenever it
  					// becomes browsing-context connected.
  					// See https://github.com/whatwg/html/issues/2369
  					// See https://html.spec.whatwg.org/#nonce-attributes
  					// The `node.getAttribute` check was added for the sake of
  					// `jQuery.globalEval` so that it can fake a nonce-containing node
  					// via an object.
  					val = node[ i ] || node.getAttribute && node.getAttribute( i );
  					if ( val ) {
  						script.setAttribute( i, val );
  					}
  				}
  			}
  			doc.head.appendChild( script ).parentNode.removeChild( script );
  		}


  	function toType( obj ) {
  		if ( obj == null ) {
  			return obj + "";
  		}

  		// Support: Android <=2.3 only (functionish RegExp)
  		return typeof obj === "object" || typeof obj === "function" ?
  			class2type[ toString.call( obj ) ] || "object" :
  			typeof obj;
  	}
  	/* global Symbol */
  	// Defining this global in .eslintrc.json would create a danger of using the global
  	// unguarded in another place, it seems safer to define global only for this module



  	var version = "3.7.1",

  		rhtmlSuffix = /HTML$/i,

  		// Define a local copy of jQuery
  		jQuery = function( selector, context ) {

  			// The jQuery object is actually just the init constructor 'enhanced'
  			// Need init if jQuery is called (just allow error to be thrown if not included)
  			return new jQuery.fn.init( selector, context );
  		};

  	jQuery.fn = jQuery.prototype = {

  		// The current version of jQuery being used
  		jquery: version,

  		constructor: jQuery,

  		// The default length of a jQuery object is 0
  		length: 0,

  		toArray: function() {
  			return slice.call( this );
  		},

  		// Get the Nth element in the matched element set OR
  		// Get the whole matched element set as a clean array
  		get: function( num ) {

  			// Return all the elements in a clean array
  			if ( num == null ) {
  				return slice.call( this );
  			}

  			// Return just the one element from the set
  			return num < 0 ? this[ num + this.length ] : this[ num ];
  		},

  		// Take an array of elements and push it onto the stack
  		// (returning the new matched element set)
  		pushStack: function( elems ) {

  			// Build a new jQuery matched element set
  			var ret = jQuery.merge( this.constructor(), elems );

  			// Add the old object onto the stack (as a reference)
  			ret.prevObject = this;

  			// Return the newly-formed element set
  			return ret;
  		},

  		// Execute a callback for every element in the matched set.
  		each: function( callback ) {
  			return jQuery.each( this, callback );
  		},

  		map: function( callback ) {
  			return this.pushStack( jQuery.map( this, function( elem, i ) {
  				return callback.call( elem, i, elem );
  			} ) );
  		},

  		slice: function() {
  			return this.pushStack( slice.apply( this, arguments ) );
  		},

  		first: function() {
  			return this.eq( 0 );
  		},

  		last: function() {
  			return this.eq( -1 );
  		},

  		even: function() {
  			return this.pushStack( jQuery.grep( this, function( _elem, i ) {
  				return ( i + 1 ) % 2;
  			} ) );
  		},

  		odd: function() {
  			return this.pushStack( jQuery.grep( this, function( _elem, i ) {
  				return i % 2;
  			} ) );
  		},

  		eq: function( i ) {
  			var len = this.length,
  				j = +i + ( i < 0 ? len : 0 );
  			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
  		},

  		end: function() {
  			return this.prevObject || this.constructor();
  		},

  		// For internal use only.
  		// Behaves like an Array's method, not like a jQuery method.
  		push: push,
  		sort: arr.sort,
  		splice: arr.splice
  	};

  	jQuery.extend = jQuery.fn.extend = function() {
  		var options, name, src, copy, copyIsArray, clone,
  			target = arguments[ 0 ] || {},
  			i = 1,
  			length = arguments.length,
  			deep = false;

  		// Handle a deep copy situation
  		if ( typeof target === "boolean" ) {
  			deep = target;

  			// Skip the boolean and the target
  			target = arguments[ i ] || {};
  			i++;
  		}

  		// Handle case when target is a string or something (possible in deep copy)
  		if ( typeof target !== "object" && !isFunction( target ) ) {
  			target = {};
  		}

  		// Extend jQuery itself if only one argument is passed
  		if ( i === length ) {
  			target = this;
  			i--;
  		}

  		for ( ; i < length; i++ ) {

  			// Only deal with non-null/undefined values
  			if ( ( options = arguments[ i ] ) != null ) {

  				// Extend the base object
  				for ( name in options ) {
  					copy = options[ name ];

  					// Prevent Object.prototype pollution
  					// Prevent never-ending loop
  					if ( name === "__proto__" || target === copy ) {
  						continue;
  					}

  					// Recurse if we're merging plain objects or arrays
  					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
  						( copyIsArray = Array.isArray( copy ) ) ) ) {
  						src = target[ name ];

  						// Ensure proper type for the source value
  						if ( copyIsArray && !Array.isArray( src ) ) {
  							clone = [];
  						} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
  							clone = {};
  						} else {
  							clone = src;
  						}
  						copyIsArray = false;

  						// Never move original objects, clone them
  						target[ name ] = jQuery.extend( deep, clone, copy );

  					// Don't bring in undefined values
  					} else if ( copy !== undefined ) {
  						target[ name ] = copy;
  					}
  				}
  			}
  		}

  		// Return the modified object
  		return target;
  	};

  	jQuery.extend( {

  		// Unique for each copy of jQuery on the page
  		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

  		// Assume jQuery is ready without the ready module
  		isReady: true,

  		error: function( msg ) {
  			throw new Error( msg );
  		},

  		noop: function() {},

  		isPlainObject: function( obj ) {
  			var proto, Ctor;

  			// Detect obvious negatives
  			// Use toString instead of jQuery.type to catch host objects
  			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
  				return false;
  			}

  			proto = getProto( obj );

  			// Objects with no prototype (e.g., `Object.create( null )`) are plain
  			if ( !proto ) {
  				return true;
  			}

  			// Objects with prototype are plain iff they were constructed by a global Object function
  			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
  			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
  		},

  		isEmptyObject: function( obj ) {
  			var name;

  			for ( name in obj ) {
  				return false;
  			}
  			return true;
  		},

  		// Evaluates a script in a provided context; falls back to the global one
  		// if not specified.
  		globalEval: function( code, options, doc ) {
  			DOMEval( code, { nonce: options && options.nonce }, doc );
  		},

  		each: function( obj, callback ) {
  			var length, i = 0;

  			if ( isArrayLike( obj ) ) {
  				length = obj.length;
  				for ( ; i < length; i++ ) {
  					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  						break;
  					}
  				}
  			} else {
  				for ( i in obj ) {
  					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  						break;
  					}
  				}
  			}

  			return obj;
  		},


  		// Retrieve the text value of an array of DOM nodes
  		text: function( elem ) {
  			var node,
  				ret = "",
  				i = 0,
  				nodeType = elem.nodeType;

  			if ( !nodeType ) {

  				// If no nodeType, this is expected to be an array
  				while ( ( node = elem[ i++ ] ) ) {

  					// Do not traverse comment nodes
  					ret += jQuery.text( node );
  				}
  			}
  			if ( nodeType === 1 || nodeType === 11 ) {
  				return elem.textContent;
  			}
  			if ( nodeType === 9 ) {
  				return elem.documentElement.textContent;
  			}
  			if ( nodeType === 3 || nodeType === 4 ) {
  				return elem.nodeValue;
  			}

  			// Do not include comment or processing instruction nodes

  			return ret;
  		},

  		// results is for internal usage only
  		makeArray: function( arr, results ) {
  			var ret = results || [];

  			if ( arr != null ) {
  				if ( isArrayLike( Object( arr ) ) ) {
  					jQuery.merge( ret,
  						typeof arr === "string" ?
  							[ arr ] : arr
  					);
  				} else {
  					push.call( ret, arr );
  				}
  			}

  			return ret;
  		},

  		inArray: function( elem, arr, i ) {
  			return arr == null ? -1 : indexOf.call( arr, elem, i );
  		},

  		isXMLDoc: function( elem ) {
  			var namespace = elem && elem.namespaceURI,
  				docElem = elem && ( elem.ownerDocument || elem ).documentElement;

  			// Assume HTML when documentElement doesn't yet exist, such as inside
  			// document fragments.
  			return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
  		},

  		// Support: Android <=4.0 only, PhantomJS 1 only
  		// push.apply(_, arraylike) throws on ancient WebKit
  		merge: function( first, second ) {
  			var len = +second.length,
  				j = 0,
  				i = first.length;

  			for ( ; j < len; j++ ) {
  				first[ i++ ] = second[ j ];
  			}

  			first.length = i;

  			return first;
  		},

  		grep: function( elems, callback, invert ) {
  			var callbackInverse,
  				matches = [],
  				i = 0,
  				length = elems.length,
  				callbackExpect = !invert;

  			// Go through the array, only saving the items
  			// that pass the validator function
  			for ( ; i < length; i++ ) {
  				callbackInverse = !callback( elems[ i ], i );
  				if ( callbackInverse !== callbackExpect ) {
  					matches.push( elems[ i ] );
  				}
  			}

  			return matches;
  		},

  		// arg is for internal usage only
  		map: function( elems, callback, arg ) {
  			var length, value,
  				i = 0,
  				ret = [];

  			// Go through the array, translating each of the items to their new values
  			if ( isArrayLike( elems ) ) {
  				length = elems.length;
  				for ( ; i < length; i++ ) {
  					value = callback( elems[ i ], i, arg );

  					if ( value != null ) {
  						ret.push( value );
  					}
  				}

  			// Go through every key on the object,
  			} else {
  				for ( i in elems ) {
  					value = callback( elems[ i ], i, arg );

  					if ( value != null ) {
  						ret.push( value );
  					}
  				}
  			}

  			// Flatten any nested arrays
  			return flat( ret );
  		},

  		// A global GUID counter for objects
  		guid: 1,

  		// jQuery.support is not used in Core but other projects attach their
  		// properties to it so it needs to exist.
  		support: support
  	} );

  	if ( typeof Symbol === "function" ) {
  		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
  	}

  	// Populate the class2type map
  	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
  		function( _i, name ) {
  			class2type[ "[object " + name + "]" ] = name.toLowerCase();
  		} );

  	function isArrayLike( obj ) {

  		// Support: real iOS 8.2 only (not reproducible in simulator)
  		// `in` check used to prevent JIT error (gh-2145)
  		// hasOwn isn't used here due to false negatives
  		// regarding Nodelist length in IE
  		var length = !!obj && "length" in obj && obj.length,
  			type = toType( obj );

  		if ( isFunction( obj ) || isWindow( obj ) ) {
  			return false;
  		}

  		return type === "array" || length === 0 ||
  			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
  	}


  	function nodeName( elem, name ) {

  		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

  	}
  	var pop = arr.pop;


  	var sort = arr.sort;


  	var splice = arr.splice;


  	var whitespace = "[\\x20\\t\\r\\n\\f]";


  	var rtrimCSS = new RegExp(
  		"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
  		"g"
  	);




  	// Note: an element does not contain itself
  	jQuery.contains = function( a, b ) {
  		var bup = b && b.parentNode;

  		return a === bup || !!( bup && bup.nodeType === 1 && (

  			// Support: IE 9 - 11+
  			// IE doesn't have `contains` on SVG.
  			a.contains ?
  				a.contains( bup ) :
  				a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
  		) );
  	};




  	// CSS string/identifier serialization
  	// https://drafts.csswg.org/cssom/#common-serializing-idioms
  	var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

  	function fcssescape( ch, asCodePoint ) {
  		if ( asCodePoint ) {

  			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
  			if ( ch === "\0" ) {
  				return "\uFFFD";
  			}

  			// Control characters and (dependent upon position) numbers get escaped as code points
  			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
  		}

  		// Other potentially-special ASCII characters get backslash-escaped
  		return "\\" + ch;
  	}

  	jQuery.escapeSelector = function( sel ) {
  		return ( sel + "" ).replace( rcssescape, fcssescape );
  	};




  	var preferredDoc = document,
  		pushNative = push;

  	( function() {

  	var i,
  		Expr,
  		outermostContext,
  		sortInput,
  		hasDuplicate,
  		push = pushNative,

  		// Local document vars
  		document,
  		documentElement,
  		documentIsHTML,
  		rbuggyQSA,
  		matches,

  		// Instance-specific data
  		expando = jQuery.expando,
  		dirruns = 0,
  		done = 0,
  		classCache = createCache(),
  		tokenCache = createCache(),
  		compilerCache = createCache(),
  		nonnativeSelectorCache = createCache(),
  		sortOrder = function( a, b ) {
  			if ( a === b ) {
  				hasDuplicate = true;
  			}
  			return 0;
  		},

  		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
  			"loop|multiple|open|readonly|required|scoped",

  		// Regular expressions

  		// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
  		identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
  			"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

  		// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
  		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

  			// Operator (capture 2)
  			"*([*^$|!~]?=)" + whitespace +

  			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
  			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
  			whitespace + "*\\]",

  		pseudos = ":(" + identifier + ")(?:\\((" +

  			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
  			// 1. quoted (capture 3; capture 4 or capture 5)
  			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

  			// 2. simple (capture 6)
  			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

  			// 3. anything else (capture 2)
  			".*" +
  			")\\)|)",

  		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  		rwhitespace = new RegExp( whitespace + "+", "g" ),

  		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  		rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
  			whitespace + "*" ),
  		rdescend = new RegExp( whitespace + "|>" ),

  		rpseudo = new RegExp( pseudos ),
  		ridentifier = new RegExp( "^" + identifier + "$" ),

  		matchExpr = {
  			ID: new RegExp( "^#(" + identifier + ")" ),
  			CLASS: new RegExp( "^\\.(" + identifier + ")" ),
  			TAG: new RegExp( "^(" + identifier + "|[*])" ),
  			ATTR: new RegExp( "^" + attributes ),
  			PSEUDO: new RegExp( "^" + pseudos ),
  			CHILD: new RegExp(
  				"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
  					whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
  					whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
  			bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

  			// For use in libraries implementing .is()
  			// We use this for POS matching in `select`
  			needsContext: new RegExp( "^" + whitespace +
  				"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
  				"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
  		},

  		rinputs = /^(?:input|select|textarea|button)$/i,
  		rheader = /^h\d$/i,

  		// Easily-parseable/retrievable ID or TAG or CLASS selectors
  		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  		rsibling = /[+~]/,

  		// CSS escapes
  		// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  		runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
  			"?|\\\\([^\\r\\n\\f])", "g" ),
  		funescape = function( escape, nonHex ) {
  			var high = "0x" + escape.slice( 1 ) - 0x10000;

  			if ( nonHex ) {

  				// Strip the backslash prefix from a non-hex escape sequence
  				return nonHex;
  			}

  			// Replace a hexadecimal escape sequence with the encoded Unicode code point
  			// Support: IE <=11+
  			// For values outside the Basic Multilingual Plane (BMP), manually construct a
  			// surrogate pair
  			return high < 0 ?
  				String.fromCharCode( high + 0x10000 ) :
  				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
  		},

  		// Used for iframes; see `setDocument`.
  		// Support: IE 9 - 11+, Edge 12 - 18+
  		// Removing the function wrapper causes a "Permission Denied"
  		// error in IE/Edge.
  		unloadHandler = function() {
  			setDocument();
  		},

  		inDisabledFieldset = addCombinator(
  			function( elem ) {
  				return elem.disabled === true && nodeName( elem, "fieldset" );
  			},
  			{ dir: "parentNode", next: "legend" }
  		);

  	// Support: IE <=9 only
  	// Accessing document.activeElement can throw unexpectedly
  	// https://bugs.jquery.com/ticket/13393
  	function safeActiveElement() {
  		try {
  			return document.activeElement;
  		} catch ( err ) { }
  	}

  	// Optimize for push.apply( _, NodeList )
  	try {
  		push.apply(
  			( arr = slice.call( preferredDoc.childNodes ) ),
  			preferredDoc.childNodes
  		);

  		// Support: Android <=4.0
  		// Detect silently failing push.apply
  		// eslint-disable-next-line no-unused-expressions
  		arr[ preferredDoc.childNodes.length ].nodeType;
  	} catch ( e ) {
  		push = {
  			apply: function( target, els ) {
  				pushNative.apply( target, slice.call( els ) );
  			},
  			call: function( target ) {
  				pushNative.apply( target, slice.call( arguments, 1 ) );
  			}
  		};
  	}

  	function find( selector, context, results, seed ) {
  		var m, i, elem, nid, match, groups, newSelector,
  			newContext = context && context.ownerDocument,

  			// nodeType defaults to 9, since context defaults to document
  			nodeType = context ? context.nodeType : 9;

  		results = results || [];

  		// Return early from calls with invalid selector or context
  		if ( typeof selector !== "string" || !selector ||
  			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

  			return results;
  		}

  		// Try to shortcut find operations (as opposed to filters) in HTML documents
  		if ( !seed ) {
  			setDocument( context );
  			context = context || document;

  			if ( documentIsHTML ) {

  				// If the selector is sufficiently simple, try using a "get*By*" DOM method
  				// (excepting DocumentFragment context, where the methods don't exist)
  				if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

  					// ID selector
  					if ( ( m = match[ 1 ] ) ) {

  						// Document context
  						if ( nodeType === 9 ) {
  							if ( ( elem = context.getElementById( m ) ) ) {

  								// Support: IE 9 only
  								// getElementById can match elements by name instead of ID
  								if ( elem.id === m ) {
  									push.call( results, elem );
  									return results;
  								}
  							} else {
  								return results;
  							}

  						// Element context
  						} else {

  							// Support: IE 9 only
  							// getElementById can match elements by name instead of ID
  							if ( newContext && ( elem = newContext.getElementById( m ) ) &&
  								find.contains( context, elem ) &&
  								elem.id === m ) {

  								push.call( results, elem );
  								return results;
  							}
  						}

  					// Type selector
  					} else if ( match[ 2 ] ) {
  						push.apply( results, context.getElementsByTagName( selector ) );
  						return results;

  					// Class selector
  					} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
  						push.apply( results, context.getElementsByClassName( m ) );
  						return results;
  					}
  				}

  				// Take advantage of querySelectorAll
  				if ( !nonnativeSelectorCache[ selector + " " ] &&
  					( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

  					newSelector = selector;
  					newContext = context;

  					// qSA considers elements outside a scoping root when evaluating child or
  					// descendant combinators, which is not what we want.
  					// In such cases, we work around the behavior by prefixing every selector in the
  					// list with an ID selector referencing the scope context.
  					// The technique has to be used as well when a leading combinator is used
  					// as such selectors are not recognized by querySelectorAll.
  					// Thanks to Andrew Dupont for this technique.
  					if ( nodeType === 1 &&
  						( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

  						// Expand context for sibling selectors
  						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
  							context;

  						// We can use :scope instead of the ID hack if the browser
  						// supports it & if we're not changing the context.
  						// Support: IE 11+, Edge 17 - 18+
  						// IE/Edge sometimes throw a "Permission denied" error when
  						// strict-comparing two documents; shallow comparisons work.
  						// eslint-disable-next-line eqeqeq
  						if ( newContext != context || !support.scope ) {

  							// Capture the context ID, setting it first if necessary
  							if ( ( nid = context.getAttribute( "id" ) ) ) {
  								nid = jQuery.escapeSelector( nid );
  							} else {
  								context.setAttribute( "id", ( nid = expando ) );
  							}
  						}

  						// Prefix every selector in the list
  						groups = tokenize( selector );
  						i = groups.length;
  						while ( i-- ) {
  							groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
  								toSelector( groups[ i ] );
  						}
  						newSelector = groups.join( "," );
  					}

  					try {
  						push.apply( results,
  							newContext.querySelectorAll( newSelector )
  						);
  						return results;
  					} catch ( qsaError ) {
  						nonnativeSelectorCache( selector, true );
  					} finally {
  						if ( nid === expando ) {
  							context.removeAttribute( "id" );
  						}
  					}
  				}
  			}
  		}

  		// All others
  		return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
  	}

  	/**
  	 * Create key-value caches of limited size
  	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
  	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
  	 *	deleting the oldest entry
  	 */
  	function createCache() {
  		var keys = [];

  		function cache( key, value ) {

  			// Use (key + " ") to avoid collision with native prototype properties
  			// (see https://github.com/jquery/sizzle/issues/157)
  			if ( keys.push( key + " " ) > Expr.cacheLength ) {

  				// Only keep the most recent entries
  				delete cache[ keys.shift() ];
  			}
  			return ( cache[ key + " " ] = value );
  		}
  		return cache;
  	}

  	/**
  	 * Mark a function for special use by jQuery selector module
  	 * @param {Function} fn The function to mark
  	 */
  	function markFunction( fn ) {
  		fn[ expando ] = true;
  		return fn;
  	}

  	/**
  	 * Support testing using an element
  	 * @param {Function} fn Passed the created element and returns a boolean result
  	 */
  	function assert( fn ) {
  		var el = document.createElement( "fieldset" );

  		try {
  			return !!fn( el );
  		} catch ( e ) {
  			return false;
  		} finally {

  			// Remove from its parent by default
  			if ( el.parentNode ) {
  				el.parentNode.removeChild( el );
  			}

  			// release memory in IE
  			el = null;
  		}
  	}

  	/**
  	 * Returns a function to use in pseudos for input types
  	 * @param {String} type
  	 */
  	function createInputPseudo( type ) {
  		return function( elem ) {
  			return nodeName( elem, "input" ) && elem.type === type;
  		};
  	}

  	/**
  	 * Returns a function to use in pseudos for buttons
  	 * @param {String} type
  	 */
  	function createButtonPseudo( type ) {
  		return function( elem ) {
  			return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
  				elem.type === type;
  		};
  	}

  	/**
  	 * Returns a function to use in pseudos for :enabled/:disabled
  	 * @param {Boolean} disabled true for :disabled; false for :enabled
  	 */
  	function createDisabledPseudo( disabled ) {

  		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
  		return function( elem ) {

  			// Only certain elements can match :enabled or :disabled
  			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
  			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
  			if ( "form" in elem ) {

  				// Check for inherited disabledness on relevant non-disabled elements:
  				// * listed form-associated elements in a disabled fieldset
  				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
  				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
  				// * option elements in a disabled optgroup
  				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
  				// All such elements have a "form" property.
  				if ( elem.parentNode && elem.disabled === false ) {

  					// Option elements defer to a parent optgroup if present
  					if ( "label" in elem ) {
  						if ( "label" in elem.parentNode ) {
  							return elem.parentNode.disabled === disabled;
  						} else {
  							return elem.disabled === disabled;
  						}
  					}

  					// Support: IE 6 - 11+
  					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
  					return elem.isDisabled === disabled ||

  						// Where there is no isDisabled, check manually
  						elem.isDisabled !== !disabled &&
  							inDisabledFieldset( elem ) === disabled;
  				}

  				return elem.disabled === disabled;

  			// Try to winnow out elements that can't be disabled before trusting the disabled property.
  			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
  			// even exist on them, let alone have a boolean value.
  			} else if ( "label" in elem ) {
  				return elem.disabled === disabled;
  			}

  			// Remaining elements are neither :enabled nor :disabled
  			return false;
  		};
  	}

  	/**
  	 * Returns a function to use in pseudos for positionals
  	 * @param {Function} fn
  	 */
  	function createPositionalPseudo( fn ) {
  		return markFunction( function( argument ) {
  			argument = +argument;
  			return markFunction( function( seed, matches ) {
  				var j,
  					matchIndexes = fn( [], seed.length, argument ),
  					i = matchIndexes.length;

  				// Match elements found at the specified indexes
  				while ( i-- ) {
  					if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
  						seed[ j ] = !( matches[ j ] = seed[ j ] );
  					}
  				}
  			} );
  		} );
  	}

  	/**
  	 * Checks a node for validity as a jQuery selector context
  	 * @param {Element|Object=} context
  	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
  	 */
  	function testContext( context ) {
  		return context && typeof context.getElementsByTagName !== "undefined" && context;
  	}

  	/**
  	 * Sets document-related variables once based on the current document
  	 * @param {Element|Object} [node] An element or document object to use to set the document
  	 * @returns {Object} Returns the current document
  	 */
  	function setDocument( node ) {
  		var subWindow,
  			doc = node ? node.ownerDocument || node : preferredDoc;

  		// Return early if doc is invalid or already selected
  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
  			return document;
  		}

  		// Update global variables
  		document = doc;
  		documentElement = document.documentElement;
  		documentIsHTML = !jQuery.isXMLDoc( document );

  		// Support: iOS 7 only, IE 9 - 11+
  		// Older browsers didn't support unprefixed `matches`.
  		matches = documentElement.matches ||
  			documentElement.webkitMatchesSelector ||
  			documentElement.msMatchesSelector;

  		// Support: IE 9 - 11+, Edge 12 - 18+
  		// Accessing iframe documents after unload throws "permission denied" errors
  		// (see trac-13936).
  		// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
  		// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
  		if ( documentElement.msMatchesSelector &&

  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			// eslint-disable-next-line eqeqeq
  			preferredDoc != document &&
  			( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

  			// Support: IE 9 - 11+, Edge 12 - 18+
  			subWindow.addEventListener( "unload", unloadHandler );
  		}

  		// Support: IE <10
  		// Check if getElementById returns elements by name
  		// The broken getElementById methods don't pick up programmatically-set names,
  		// so use a roundabout getElementsByName test
  		support.getById = assert( function( el ) {
  			documentElement.appendChild( el ).id = jQuery.expando;
  			return !document.getElementsByName ||
  				!document.getElementsByName( jQuery.expando ).length;
  		} );

  		// Support: IE 9 only
  		// Check to see if it's possible to do matchesSelector
  		// on a disconnected node.
  		support.disconnectedMatch = assert( function( el ) {
  			return matches.call( el, "*" );
  		} );

  		// Support: IE 9 - 11+, Edge 12 - 18+
  		// IE/Edge don't support the :scope pseudo-class.
  		support.scope = assert( function() {
  			return document.querySelectorAll( ":scope" );
  		} );

  		// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
  		// Make sure the `:has()` argument is parsed unforgivingly.
  		// We include `*` in the test to detect buggy implementations that are
  		// _selectively_ forgiving (specifically when the list includes at least
  		// one valid selector).
  		// Note that we treat complete lack of support for `:has()` as if it were
  		// spec-compliant support, which is fine because use of `:has()` in such
  		// environments will fail in the qSA path and fall back to jQuery traversal
  		// anyway.
  		support.cssHas = assert( function() {
  			try {
  				document.querySelector( ":has(*,:jqfake)" );
  				return false;
  			} catch ( e ) {
  				return true;
  			}
  		} );

  		// ID filter and find
  		if ( support.getById ) {
  			Expr.filter.ID = function( id ) {
  				var attrId = id.replace( runescape, funescape );
  				return function( elem ) {
  					return elem.getAttribute( "id" ) === attrId;
  				};
  			};
  			Expr.find.ID = function( id, context ) {
  				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  					var elem = context.getElementById( id );
  					return elem ? [ elem ] : [];
  				}
  			};
  		} else {
  			Expr.filter.ID =  function( id ) {
  				var attrId = id.replace( runescape, funescape );
  				return function( elem ) {
  					var node = typeof elem.getAttributeNode !== "undefined" &&
  						elem.getAttributeNode( "id" );
  					return node && node.value === attrId;
  				};
  			};

  			// Support: IE 6 - 7 only
  			// getElementById is not reliable as a find shortcut
  			Expr.find.ID = function( id, context ) {
  				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  					var node, i, elems,
  						elem = context.getElementById( id );

  					if ( elem ) {

  						// Verify the id attribute
  						node = elem.getAttributeNode( "id" );
  						if ( node && node.value === id ) {
  							return [ elem ];
  						}

  						// Fall back on getElementsByName
  						elems = context.getElementsByName( id );
  						i = 0;
  						while ( ( elem = elems[ i++ ] ) ) {
  							node = elem.getAttributeNode( "id" );
  							if ( node && node.value === id ) {
  								return [ elem ];
  							}
  						}
  					}

  					return [];
  				}
  			};
  		}

  		// Tag
  		Expr.find.TAG = function( tag, context ) {
  			if ( typeof context.getElementsByTagName !== "undefined" ) {
  				return context.getElementsByTagName( tag );

  			// DocumentFragment nodes don't have gEBTN
  			} else {
  				return context.querySelectorAll( tag );
  			}
  		};

  		// Class
  		Expr.find.CLASS = function( className, context ) {
  			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
  				return context.getElementsByClassName( className );
  			}
  		};

  		/* QSA/matchesSelector
  		---------------------------------------------------------------------- */

  		// QSA and matchesSelector support

  		rbuggyQSA = [];

  		// Build QSA regex
  		// Regex strategy adopted from Diego Perini
  		assert( function( el ) {

  			var input;

  			documentElement.appendChild( el ).innerHTML =
  				"<a id='" + expando + "' href='' disabled='disabled'></a>" +
  				"<select id='" + expando + "-\r\\' disabled='disabled'>" +
  				"<option selected=''></option></select>";

  			// Support: iOS <=7 - 8 only
  			// Boolean attributes and "value" are not treated correctly in some XML documents
  			if ( !el.querySelectorAll( "[selected]" ).length ) {
  				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
  			}

  			// Support: iOS <=7 - 8 only
  			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
  				rbuggyQSA.push( "~=" );
  			}

  			// Support: iOS 8 only
  			// https://bugs.webkit.org/show_bug.cgi?id=136851
  			// In-page `selector#id sibling-combinator selector` fails
  			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
  				rbuggyQSA.push( ".#.+[+~]" );
  			}

  			// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
  			// In some of the document kinds, these selectors wouldn't work natively.
  			// This is probably OK but for backwards compatibility we want to maintain
  			// handling them through jQuery traversal in jQuery 3.x.
  			if ( !el.querySelectorAll( ":checked" ).length ) {
  				rbuggyQSA.push( ":checked" );
  			}

  			// Support: Windows 8 Native Apps
  			// The type and name attributes are restricted during .innerHTML assignment
  			input = document.createElement( "input" );
  			input.setAttribute( "type", "hidden" );
  			el.appendChild( input ).setAttribute( "name", "D" );

  			// Support: IE 9 - 11+
  			// IE's :disabled selector does not pick up the children of disabled fieldsets
  			// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
  			// In some of the document kinds, these selectors wouldn't work natively.
  			// This is probably OK but for backwards compatibility we want to maintain
  			// handling them through jQuery traversal in jQuery 3.x.
  			documentElement.appendChild( el ).disabled = true;
  			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
  				rbuggyQSA.push( ":enabled", ":disabled" );
  			}

  			// Support: IE 11+, Edge 15 - 18+
  			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
  			// Adding a temporary attribute to the document before the selection works
  			// around the issue.
  			// Interestingly, IE 10 & older don't seem to have the issue.
  			input = document.createElement( "input" );
  			input.setAttribute( "name", "" );
  			el.appendChild( input );
  			if ( !el.querySelectorAll( "[name='']" ).length ) {
  				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
  					whitespace + "*(?:''|\"\")" );
  			}
  		} );

  		if ( !support.cssHas ) {

  			// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
  			// Our regular `try-catch` mechanism fails to detect natively-unsupported
  			// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
  			// in browsers that parse the `:has()` argument as a forgiving selector list.
  			// https://drafts.csswg.org/selectors/#relational now requires the argument
  			// to be parsed unforgivingly, but browsers have not yet fully adjusted.
  			rbuggyQSA.push( ":has" );
  		}

  		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

  		/* Sorting
  		---------------------------------------------------------------------- */

  		// Document order sorting
  		sortOrder = function( a, b ) {

  			// Flag for duplicate removal
  			if ( a === b ) {
  				hasDuplicate = true;
  				return 0;
  			}

  			// Sort on method existence if only one input has compareDocumentPosition
  			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
  			if ( compare ) {
  				return compare;
  			}

  			// Calculate position if both inputs belong to the same document
  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			// eslint-disable-next-line eqeqeq
  			compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
  				a.compareDocumentPosition( b ) :

  				// Otherwise we know they are disconnected
  				1;

  			// Disconnected nodes
  			if ( compare & 1 ||
  				( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

  				// Choose the first element that is related to our preferred document
  				// Support: IE 11+, Edge 17 - 18+
  				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  				// two documents; shallow comparisons work.
  				// eslint-disable-next-line eqeqeq
  				if ( a === document || a.ownerDocument == preferredDoc &&
  					find.contains( preferredDoc, a ) ) {
  					return -1;
  				}

  				// Support: IE 11+, Edge 17 - 18+
  				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  				// two documents; shallow comparisons work.
  				// eslint-disable-next-line eqeqeq
  				if ( b === document || b.ownerDocument == preferredDoc &&
  					find.contains( preferredDoc, b ) ) {
  					return 1;
  				}

  				// Maintain original order
  				return sortInput ?
  					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
  					0;
  			}

  			return compare & 4 ? -1 : 1;
  		};

  		return document;
  	}

  	find.matches = function( expr, elements ) {
  		return find( expr, null, null, elements );
  	};

  	find.matchesSelector = function( elem, expr ) {
  		setDocument( elem );

  		if ( documentIsHTML &&
  			!nonnativeSelectorCache[ expr + " " ] &&
  			( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

  			try {
  				var ret = matches.call( elem, expr );

  				// IE 9's matchesSelector returns false on disconnected nodes
  				if ( ret || support.disconnectedMatch ||

  						// As well, disconnected nodes are said to be in a document
  						// fragment in IE 9
  						elem.document && elem.document.nodeType !== 11 ) {
  					return ret;
  				}
  			} catch ( e ) {
  				nonnativeSelectorCache( expr, true );
  			}
  		}

  		return find( expr, document, null, [ elem ] ).length > 0;
  	};

  	find.contains = function( context, elem ) {

  		// Set document vars if needed
  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		if ( ( context.ownerDocument || context ) != document ) {
  			setDocument( context );
  		}
  		return jQuery.contains( context, elem );
  	};


  	find.attr = function( elem, name ) {

  		// Set document vars if needed
  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		if ( ( elem.ownerDocument || elem ) != document ) {
  			setDocument( elem );
  		}

  		var fn = Expr.attrHandle[ name.toLowerCase() ],

  			// Don't get fooled by Object.prototype properties (see trac-13807)
  			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
  				fn( elem, name, !documentIsHTML ) :
  				undefined;

  		if ( val !== undefined ) {
  			return val;
  		}

  		return elem.getAttribute( name );
  	};

  	find.error = function( msg ) {
  		throw new Error( "Syntax error, unrecognized expression: " + msg );
  	};

  	/**
  	 * Document sorting and removing duplicates
  	 * @param {ArrayLike} results
  	 */
  	jQuery.uniqueSort = function( results ) {
  		var elem,
  			duplicates = [],
  			j = 0,
  			i = 0;

  		// Unless we *know* we can detect duplicates, assume their presence
  		//
  		// Support: Android <=4.0+
  		// Testing for detecting duplicates is unpredictable so instead assume we can't
  		// depend on duplicate detection in all browsers without a stable sort.
  		hasDuplicate = !support.sortStable;
  		sortInput = !support.sortStable && slice.call( results, 0 );
  		sort.call( results, sortOrder );

  		if ( hasDuplicate ) {
  			while ( ( elem = results[ i++ ] ) ) {
  				if ( elem === results[ i ] ) {
  					j = duplicates.push( i );
  				}
  			}
  			while ( j-- ) {
  				splice.call( results, duplicates[ j ], 1 );
  			}
  		}

  		// Clear input after sorting to release objects
  		// See https://github.com/jquery/sizzle/pull/225
  		sortInput = null;

  		return results;
  	};

  	jQuery.fn.uniqueSort = function() {
  		return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
  	};

  	Expr = jQuery.expr = {

  		// Can be adjusted by the user
  		cacheLength: 50,

  		createPseudo: markFunction,

  		match: matchExpr,

  		attrHandle: {},

  		find: {},

  		relative: {
  			">": { dir: "parentNode", first: true },
  			" ": { dir: "parentNode" },
  			"+": { dir: "previousSibling", first: true },
  			"~": { dir: "previousSibling" }
  		},

  		preFilter: {
  			ATTR: function( match ) {
  				match[ 1 ] = match[ 1 ].replace( runescape, funescape );

  				// Move the given value to match[3] whether quoted or unquoted
  				match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
  					.replace( runescape, funescape );

  				if ( match[ 2 ] === "~=" ) {
  					match[ 3 ] = " " + match[ 3 ] + " ";
  				}

  				return match.slice( 0, 4 );
  			},

  			CHILD: function( match ) {

  				/* matches from matchExpr["CHILD"]
  					1 type (only|nth|...)
  					2 what (child|of-type)
  					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
  					4 xn-component of xn+y argument ([+-]?\d*n|)
  					5 sign of xn-component
  					6 x of xn-component
  					7 sign of y-component
  					8 y of y-component
  				*/
  				match[ 1 ] = match[ 1 ].toLowerCase();

  				if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

  					// nth-* requires argument
  					if ( !match[ 3 ] ) {
  						find.error( match[ 0 ] );
  					}

  					// numeric x and y parameters for Expr.filter.CHILD
  					// remember that false/true cast respectively to 0/1
  					match[ 4 ] = +( match[ 4 ] ?
  						match[ 5 ] + ( match[ 6 ] || 1 ) :
  						2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
  					);
  					match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

  				// other types prohibit arguments
  				} else if ( match[ 3 ] ) {
  					find.error( match[ 0 ] );
  				}

  				return match;
  			},

  			PSEUDO: function( match ) {
  				var excess,
  					unquoted = !match[ 6 ] && match[ 2 ];

  				if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
  					return null;
  				}

  				// Accept quoted arguments as-is
  				if ( match[ 3 ] ) {
  					match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

  				// Strip excess characters from unquoted arguments
  				} else if ( unquoted && rpseudo.test( unquoted ) &&

  					// Get excess from tokenize (recursively)
  					( excess = tokenize( unquoted, true ) ) &&

  					// advance to the next closing parenthesis
  					( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

  					// excess is a negative index
  					match[ 0 ] = match[ 0 ].slice( 0, excess );
  					match[ 2 ] = unquoted.slice( 0, excess );
  				}

  				// Return only captures needed by the pseudo filter method (type and argument)
  				return match.slice( 0, 3 );
  			}
  		},

  		filter: {

  			TAG: function( nodeNameSelector ) {
  				var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
  				return nodeNameSelector === "*" ?
  					function() {
  						return true;
  					} :
  					function( elem ) {
  						return nodeName( elem, expectedNodeName );
  					};
  			},

  			CLASS: function( className ) {
  				var pattern = classCache[ className + " " ];

  				return pattern ||
  					( pattern = new RegExp( "(^|" + whitespace + ")" + className +
  						"(" + whitespace + "|$)" ) ) &&
  					classCache( className, function( elem ) {
  						return pattern.test(
  							typeof elem.className === "string" && elem.className ||
  								typeof elem.getAttribute !== "undefined" &&
  									elem.getAttribute( "class" ) ||
  								""
  						);
  					} );
  			},

  			ATTR: function( name, operator, check ) {
  				return function( elem ) {
  					var result = find.attr( elem, name );

  					if ( result == null ) {
  						return operator === "!=";
  					}
  					if ( !operator ) {
  						return true;
  					}

  					result += "";

  					if ( operator === "=" ) {
  						return result === check;
  					}
  					if ( operator === "!=" ) {
  						return result !== check;
  					}
  					if ( operator === "^=" ) {
  						return check && result.indexOf( check ) === 0;
  					}
  					if ( operator === "*=" ) {
  						return check && result.indexOf( check ) > -1;
  					}
  					if ( operator === "$=" ) {
  						return check && result.slice( -check.length ) === check;
  					}
  					if ( operator === "~=" ) {
  						return ( " " + result.replace( rwhitespace, " " ) + " " )
  							.indexOf( check ) > -1;
  					}
  					if ( operator === "|=" ) {
  						return result === check || result.slice( 0, check.length + 1 ) === check + "-";
  					}

  					return false;
  				};
  			},

  			CHILD: function( type, what, _argument, first, last ) {
  				var simple = type.slice( 0, 3 ) !== "nth",
  					forward = type.slice( -4 ) !== "last",
  					ofType = what === "of-type";

  				return first === 1 && last === 0 ?

  					// Shortcut for :nth-*(n)
  					function( elem ) {
  						return !!elem.parentNode;
  					} :

  					function( elem, _context, xml ) {
  						var cache, outerCache, node, nodeIndex, start,
  							dir = simple !== forward ? "nextSibling" : "previousSibling",
  							parent = elem.parentNode,
  							name = ofType && elem.nodeName.toLowerCase(),
  							useCache = !xml && !ofType,
  							diff = false;

  						if ( parent ) {

  							// :(first|last|only)-(child|of-type)
  							if ( simple ) {
  								while ( dir ) {
  									node = elem;
  									while ( ( node = node[ dir ] ) ) {
  										if ( ofType ?
  											nodeName( node, name ) :
  											node.nodeType === 1 ) {

  											return false;
  										}
  									}

  									// Reverse direction for :only-* (if we haven't yet done so)
  									start = dir = type === "only" && !start && "nextSibling";
  								}
  								return true;
  							}

  							start = [ forward ? parent.firstChild : parent.lastChild ];

  							// non-xml :nth-child(...) stores cache data on `parent`
  							if ( forward && useCache ) {

  								// Seek `elem` from a previously-cached index
  								outerCache = parent[ expando ] || ( parent[ expando ] = {} );
  								cache = outerCache[ type ] || [];
  								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  								diff = nodeIndex && cache[ 2 ];
  								node = nodeIndex && parent.childNodes[ nodeIndex ];

  								while ( ( node = ++nodeIndex && node && node[ dir ] ||

  									// Fallback to seeking `elem` from the start
  									( diff = nodeIndex = 0 ) || start.pop() ) ) {

  									// When found, cache indexes on `parent` and break
  									if ( node.nodeType === 1 && ++diff && node === elem ) {
  										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
  										break;
  									}
  								}

  							} else {

  								// Use previously-cached element index if available
  								if ( useCache ) {
  									outerCache = elem[ expando ] || ( elem[ expando ] = {} );
  									cache = outerCache[ type ] || [];
  									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  									diff = nodeIndex;
  								}

  								// xml :nth-child(...)
  								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
  								if ( diff === false ) {

  									// Use the same loop as above to seek `elem` from the start
  									while ( ( node = ++nodeIndex && node && node[ dir ] ||
  										( diff = nodeIndex = 0 ) || start.pop() ) ) {

  										if ( ( ofType ?
  											nodeName( node, name ) :
  											node.nodeType === 1 ) &&
  											++diff ) {

  											// Cache the index of each encountered element
  											if ( useCache ) {
  												outerCache = node[ expando ] ||
  													( node[ expando ] = {} );
  												outerCache[ type ] = [ dirruns, diff ];
  											}

  											if ( node === elem ) {
  												break;
  											}
  										}
  									}
  								}
  							}

  							// Incorporate the offset, then check against cycle size
  							diff -= last;
  							return diff === first || ( diff % first === 0 && diff / first >= 0 );
  						}
  					};
  			},

  			PSEUDO: function( pseudo, argument ) {

  				// pseudo-class names are case-insensitive
  				// https://www.w3.org/TR/selectors/#pseudo-classes
  				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
  				// Remember that setFilters inherits from pseudos
  				var args,
  					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
  						find.error( "unsupported pseudo: " + pseudo );

  				// The user may use createPseudo to indicate that
  				// arguments are needed to create the filter function
  				// just as jQuery does
  				if ( fn[ expando ] ) {
  					return fn( argument );
  				}

  				// But maintain support for old signatures
  				if ( fn.length > 1 ) {
  					args = [ pseudo, pseudo, "", argument ];
  					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
  						markFunction( function( seed, matches ) {
  							var idx,
  								matched = fn( seed, argument ),
  								i = matched.length;
  							while ( i-- ) {
  								idx = indexOf.call( seed, matched[ i ] );
  								seed[ idx ] = !( matches[ idx ] = matched[ i ] );
  							}
  						} ) :
  						function( elem ) {
  							return fn( elem, 0, args );
  						};
  				}

  				return fn;
  			}
  		},

  		pseudos: {

  			// Potentially complex pseudos
  			not: markFunction( function( selector ) {

  				// Trim the selector passed to compile
  				// to avoid treating leading and trailing
  				// spaces as combinators
  				var input = [],
  					results = [],
  					matcher = compile( selector.replace( rtrimCSS, "$1" ) );

  				return matcher[ expando ] ?
  					markFunction( function( seed, matches, _context, xml ) {
  						var elem,
  							unmatched = matcher( seed, null, xml, [] ),
  							i = seed.length;

  						// Match elements unmatched by `matcher`
  						while ( i-- ) {
  							if ( ( elem = unmatched[ i ] ) ) {
  								seed[ i ] = !( matches[ i ] = elem );
  							}
  						}
  					} ) :
  					function( elem, _context, xml ) {
  						input[ 0 ] = elem;
  						matcher( input, null, xml, results );

  						// Don't keep the element
  						// (see https://github.com/jquery/sizzle/issues/299)
  						input[ 0 ] = null;
  						return !results.pop();
  					};
  			} ),

  			has: markFunction( function( selector ) {
  				return function( elem ) {
  					return find( selector, elem ).length > 0;
  				};
  			} ),

  			contains: markFunction( function( text ) {
  				text = text.replace( runescape, funescape );
  				return function( elem ) {
  					return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
  				};
  			} ),

  			// "Whether an element is represented by a :lang() selector
  			// is based solely on the element's language value
  			// being equal to the identifier C,
  			// or beginning with the identifier C immediately followed by "-".
  			// The matching of C against the element's language value is performed case-insensitively.
  			// The identifier C does not have to be a valid language name."
  			// https://www.w3.org/TR/selectors/#lang-pseudo
  			lang: markFunction( function( lang ) {

  				// lang value must be a valid identifier
  				if ( !ridentifier.test( lang || "" ) ) {
  					find.error( "unsupported lang: " + lang );
  				}
  				lang = lang.replace( runescape, funescape ).toLowerCase();
  				return function( elem ) {
  					var elemLang;
  					do {
  						if ( ( elemLang = documentIsHTML ?
  							elem.lang :
  							elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

  							elemLang = elemLang.toLowerCase();
  							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
  						}
  					} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
  					return false;
  				};
  			} ),

  			// Miscellaneous
  			target: function( elem ) {
  				var hash = window.location && window.location.hash;
  				return hash && hash.slice( 1 ) === elem.id;
  			},

  			root: function( elem ) {
  				return elem === documentElement;
  			},

  			focus: function( elem ) {
  				return elem === safeActiveElement() &&
  					document.hasFocus() &&
  					!!( elem.type || elem.href || ~elem.tabIndex );
  			},

  			// Boolean properties
  			enabled: createDisabledPseudo( false ),
  			disabled: createDisabledPseudo( true ),

  			checked: function( elem ) {

  				// In CSS3, :checked should return both checked and selected elements
  				// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  				return ( nodeName( elem, "input" ) && !!elem.checked ) ||
  					( nodeName( elem, "option" ) && !!elem.selected );
  			},

  			selected: function( elem ) {

  				// Support: IE <=11+
  				// Accessing the selectedIndex property
  				// forces the browser to treat the default option as
  				// selected when in an optgroup.
  				if ( elem.parentNode ) {
  					// eslint-disable-next-line no-unused-expressions
  					elem.parentNode.selectedIndex;
  				}

  				return elem.selected === true;
  			},

  			// Contents
  			empty: function( elem ) {

  				// https://www.w3.org/TR/selectors/#empty-pseudo
  				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
  				//   but not by others (comment: 8; processing instruction: 7; etc.)
  				// nodeType < 6 works because attributes (2) do not appear as children
  				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  					if ( elem.nodeType < 6 ) {
  						return false;
  					}
  				}
  				return true;
  			},

  			parent: function( elem ) {
  				return !Expr.pseudos.empty( elem );
  			},

  			// Element/input types
  			header: function( elem ) {
  				return rheader.test( elem.nodeName );
  			},

  			input: function( elem ) {
  				return rinputs.test( elem.nodeName );
  			},

  			button: function( elem ) {
  				return nodeName( elem, "input" ) && elem.type === "button" ||
  					nodeName( elem, "button" );
  			},

  			text: function( elem ) {
  				var attr;
  				return nodeName( elem, "input" ) && elem.type === "text" &&

  					// Support: IE <10 only
  					// New HTML5 attribute values (e.g., "search") appear
  					// with elem.type === "text"
  					( ( attr = elem.getAttribute( "type" ) ) == null ||
  						attr.toLowerCase() === "text" );
  			},

  			// Position-in-collection
  			first: createPositionalPseudo( function() {
  				return [ 0 ];
  			} ),

  			last: createPositionalPseudo( function( _matchIndexes, length ) {
  				return [ length - 1 ];
  			} ),

  			eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
  				return [ argument < 0 ? argument + length : argument ];
  			} ),

  			even: createPositionalPseudo( function( matchIndexes, length ) {
  				var i = 0;
  				for ( ; i < length; i += 2 ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} ),

  			odd: createPositionalPseudo( function( matchIndexes, length ) {
  				var i = 1;
  				for ( ; i < length; i += 2 ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} ),

  			lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
  				var i;

  				if ( argument < 0 ) {
  					i = argument + length;
  				} else if ( argument > length ) {
  					i = length;
  				} else {
  					i = argument;
  				}

  				for ( ; --i >= 0; ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} ),

  			gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
  				var i = argument < 0 ? argument + length : argument;
  				for ( ; ++i < length; ) {
  					matchIndexes.push( i );
  				}
  				return matchIndexes;
  			} )
  		}
  	};

  	Expr.pseudos.nth = Expr.pseudos.eq;

  	// Add button/input type pseudos
  	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
  		Expr.pseudos[ i ] = createInputPseudo( i );
  	}
  	for ( i in { submit: true, reset: true } ) {
  		Expr.pseudos[ i ] = createButtonPseudo( i );
  	}

  	// Easy API for creating new setFilters
  	function setFilters() {}
  	setFilters.prototype = Expr.filters = Expr.pseudos;
  	Expr.setFilters = new setFilters();

  	function tokenize( selector, parseOnly ) {
  		var matched, match, tokens, type,
  			soFar, groups, preFilters,
  			cached = tokenCache[ selector + " " ];

  		if ( cached ) {
  			return parseOnly ? 0 : cached.slice( 0 );
  		}

  		soFar = selector;
  		groups = [];
  		preFilters = Expr.preFilter;

  		while ( soFar ) {

  			// Comma and first run
  			if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
  				if ( match ) {

  					// Don't consume trailing commas as valid
  					soFar = soFar.slice( match[ 0 ].length ) || soFar;
  				}
  				groups.push( ( tokens = [] ) );
  			}

  			matched = false;

  			// Combinators
  			if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
  				matched = match.shift();
  				tokens.push( {
  					value: matched,

  					// Cast descendant combinators to space
  					type: match[ 0 ].replace( rtrimCSS, " " )
  				} );
  				soFar = soFar.slice( matched.length );
  			}

  			// Filters
  			for ( type in Expr.filter ) {
  				if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
  					( match = preFilters[ type ]( match ) ) ) ) {
  					matched = match.shift();
  					tokens.push( {
  						value: matched,
  						type: type,
  						matches: match
  					} );
  					soFar = soFar.slice( matched.length );
  				}
  			}

  			if ( !matched ) {
  				break;
  			}
  		}

  		// Return the length of the invalid excess
  		// if we're just parsing
  		// Otherwise, throw an error or return tokens
  		if ( parseOnly ) {
  			return soFar.length;
  		}

  		return soFar ?
  			find.error( selector ) :

  			// Cache the tokens
  			tokenCache( selector, groups ).slice( 0 );
  	}

  	function toSelector( tokens ) {
  		var i = 0,
  			len = tokens.length,
  			selector = "";
  		for ( ; i < len; i++ ) {
  			selector += tokens[ i ].value;
  		}
  		return selector;
  	}

  	function addCombinator( matcher, combinator, base ) {
  		var dir = combinator.dir,
  			skip = combinator.next,
  			key = skip || dir,
  			checkNonElements = base && key === "parentNode",
  			doneName = done++;

  		return combinator.first ?

  			// Check against closest ancestor/preceding element
  			function( elem, context, xml ) {
  				while ( ( elem = elem[ dir ] ) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						return matcher( elem, context, xml );
  					}
  				}
  				return false;
  			} :

  			// Check against all ancestor/preceding elements
  			function( elem, context, xml ) {
  				var oldCache, outerCache,
  					newCache = [ dirruns, doneName ];

  				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
  				if ( xml ) {
  					while ( ( elem = elem[ dir ] ) ) {
  						if ( elem.nodeType === 1 || checkNonElements ) {
  							if ( matcher( elem, context, xml ) ) {
  								return true;
  							}
  						}
  					}
  				} else {
  					while ( ( elem = elem[ dir ] ) ) {
  						if ( elem.nodeType === 1 || checkNonElements ) {
  							outerCache = elem[ expando ] || ( elem[ expando ] = {} );

  							if ( skip && nodeName( elem, skip ) ) {
  								elem = elem[ dir ] || elem;
  							} else if ( ( oldCache = outerCache[ key ] ) &&
  								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

  								// Assign to newCache so results back-propagate to previous elements
  								return ( newCache[ 2 ] = oldCache[ 2 ] );
  							} else {

  								// Reuse newcache so results back-propagate to previous elements
  								outerCache[ key ] = newCache;

  								// A match means we're done; a fail means we have to keep checking
  								if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
  									return true;
  								}
  							}
  						}
  					}
  				}
  				return false;
  			};
  	}

  	function elementMatcher( matchers ) {
  		return matchers.length > 1 ?
  			function( elem, context, xml ) {
  				var i = matchers.length;
  				while ( i-- ) {
  					if ( !matchers[ i ]( elem, context, xml ) ) {
  						return false;
  					}
  				}
  				return true;
  			} :
  			matchers[ 0 ];
  	}

  	function multipleContexts( selector, contexts, results ) {
  		var i = 0,
  			len = contexts.length;
  		for ( ; i < len; i++ ) {
  			find( selector, contexts[ i ], results );
  		}
  		return results;
  	}

  	function condense( unmatched, map, filter, context, xml ) {
  		var elem,
  			newUnmatched = [],
  			i = 0,
  			len = unmatched.length,
  			mapped = map != null;

  		for ( ; i < len; i++ ) {
  			if ( ( elem = unmatched[ i ] ) ) {
  				if ( !filter || filter( elem, context, xml ) ) {
  					newUnmatched.push( elem );
  					if ( mapped ) {
  						map.push( i );
  					}
  				}
  			}
  		}

  		return newUnmatched;
  	}

  	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  		if ( postFilter && !postFilter[ expando ] ) {
  			postFilter = setMatcher( postFilter );
  		}
  		if ( postFinder && !postFinder[ expando ] ) {
  			postFinder = setMatcher( postFinder, postSelector );
  		}
  		return markFunction( function( seed, results, context, xml ) {
  			var temp, i, elem, matcherOut,
  				preMap = [],
  				postMap = [],
  				preexisting = results.length,

  				// Get initial elements from seed or context
  				elems = seed ||
  					multipleContexts( selector || "*",
  						context.nodeType ? [ context ] : context, [] ),

  				// Prefilter to get matcher input, preserving a map for seed-results synchronization
  				matcherIn = preFilter && ( seed || !selector ) ?
  					condense( elems, preMap, preFilter, context, xml ) :
  					elems;

  			if ( matcher ) {

  				// If we have a postFinder, or filtered seed, or non-seed postFilter
  				// or preexisting results,
  				matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

  					// ...intermediate processing is necessary
  					[] :

  					// ...otherwise use results directly
  					results;

  				// Find primary matches
  				matcher( matcherIn, matcherOut, context, xml );
  			} else {
  				matcherOut = matcherIn;
  			}

  			// Apply postFilter
  			if ( postFilter ) {
  				temp = condense( matcherOut, postMap );
  				postFilter( temp, [], context, xml );

  				// Un-match failing elements by moving them back to matcherIn
  				i = temp.length;
  				while ( i-- ) {
  					if ( ( elem = temp[ i ] ) ) {
  						matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
  					}
  				}
  			}

  			if ( seed ) {
  				if ( postFinder || preFilter ) {
  					if ( postFinder ) {

  						// Get the final matcherOut by condensing this intermediate into postFinder contexts
  						temp = [];
  						i = matcherOut.length;
  						while ( i-- ) {
  							if ( ( elem = matcherOut[ i ] ) ) {

  								// Restore matcherIn since elem is not yet a final match
  								temp.push( ( matcherIn[ i ] = elem ) );
  							}
  						}
  						postFinder( null, ( matcherOut = [] ), temp, xml );
  					}

  					// Move matched elements from seed to results to keep them synchronized
  					i = matcherOut.length;
  					while ( i-- ) {
  						if ( ( elem = matcherOut[ i ] ) &&
  							( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

  							seed[ temp ] = !( results[ temp ] = elem );
  						}
  					}
  				}

  			// Add elements to results, through postFinder if defined
  			} else {
  				matcherOut = condense(
  					matcherOut === results ?
  						matcherOut.splice( preexisting, matcherOut.length ) :
  						matcherOut
  				);
  				if ( postFinder ) {
  					postFinder( null, results, matcherOut, xml );
  				} else {
  					push.apply( results, matcherOut );
  				}
  			}
  		} );
  	}

  	function matcherFromTokens( tokens ) {
  		var checkContext, matcher, j,
  			len = tokens.length,
  			leadingRelative = Expr.relative[ tokens[ 0 ].type ],
  			implicitRelative = leadingRelative || Expr.relative[ " " ],
  			i = leadingRelative ? 1 : 0,

  			// The foundational matcher ensures that elements are reachable from top-level context(s)
  			matchContext = addCombinator( function( elem ) {
  				return elem === checkContext;
  			}, implicitRelative, true ),
  			matchAnyContext = addCombinator( function( elem ) {
  				return indexOf.call( checkContext, elem ) > -1;
  			}, implicitRelative, true ),
  			matchers = [ function( elem, context, xml ) {

  				// Support: IE 11+, Edge 17 - 18+
  				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  				// two documents; shallow comparisons work.
  				// eslint-disable-next-line eqeqeq
  				var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
  					( checkContext = context ).nodeType ?
  						matchContext( elem, context, xml ) :
  						matchAnyContext( elem, context, xml ) );

  				// Avoid hanging onto element
  				// (see https://github.com/jquery/sizzle/issues/299)
  				checkContext = null;
  				return ret;
  			} ];

  		for ( ; i < len; i++ ) {
  			if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
  				matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
  			} else {
  				matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

  				// Return special upon seeing a positional matcher
  				if ( matcher[ expando ] ) {

  					// Find the next relative operator (if any) for proper handling
  					j = ++i;
  					for ( ; j < len; j++ ) {
  						if ( Expr.relative[ tokens[ j ].type ] ) {
  							break;
  						}
  					}
  					return setMatcher(
  						i > 1 && elementMatcher( matchers ),
  						i > 1 && toSelector(

  							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
  							tokens.slice( 0, i - 1 )
  								.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
  						).replace( rtrimCSS, "$1" ),
  						matcher,
  						i < j && matcherFromTokens( tokens.slice( i, j ) ),
  						j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
  						j < len && toSelector( tokens )
  					);
  				}
  				matchers.push( matcher );
  			}
  		}

  		return elementMatcher( matchers );
  	}

  	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  		var bySet = setMatchers.length > 0,
  			byElement = elementMatchers.length > 0,
  			superMatcher = function( seed, context, xml, results, outermost ) {
  				var elem, j, matcher,
  					matchedCount = 0,
  					i = "0",
  					unmatched = seed && [],
  					setMatched = [],
  					contextBackup = outermostContext,

  					// We must always have either seed elements or outermost context
  					elems = seed || byElement && Expr.find.TAG( "*", outermost ),

  					// Use integer dirruns iff this is the outermost matcher
  					dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
  					len = elems.length;

  				if ( outermost ) {

  					// Support: IE 11+, Edge 17 - 18+
  					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  					// two documents; shallow comparisons work.
  					// eslint-disable-next-line eqeqeq
  					outermostContext = context == document || context || outermost;
  				}

  				// Add elements passing elementMatchers directly to results
  				// Support: iOS <=7 - 9 only
  				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
  				// elements by id. (see trac-14142)
  				for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
  					if ( byElement && elem ) {
  						j = 0;

  						// Support: IE 11+, Edge 17 - 18+
  						// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  						// two documents; shallow comparisons work.
  						// eslint-disable-next-line eqeqeq
  						if ( !context && elem.ownerDocument != document ) {
  							setDocument( elem );
  							xml = !documentIsHTML;
  						}
  						while ( ( matcher = elementMatchers[ j++ ] ) ) {
  							if ( matcher( elem, context || document, xml ) ) {
  								push.call( results, elem );
  								break;
  							}
  						}
  						if ( outermost ) {
  							dirruns = dirrunsUnique;
  						}
  					}

  					// Track unmatched elements for set filters
  					if ( bySet ) {

  						// They will have gone through all possible matchers
  						if ( ( elem = !matcher && elem ) ) {
  							matchedCount--;
  						}

  						// Lengthen the array for every element, matched or not
  						if ( seed ) {
  							unmatched.push( elem );
  						}
  					}
  				}

  				// `i` is now the count of elements visited above, and adding it to `matchedCount`
  				// makes the latter nonnegative.
  				matchedCount += i;

  				// Apply set filters to unmatched elements
  				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
  				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
  				// no element matchers and no seed.
  				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
  				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
  				// numerically zero.
  				if ( bySet && i !== matchedCount ) {
  					j = 0;
  					while ( ( matcher = setMatchers[ j++ ] ) ) {
  						matcher( unmatched, setMatched, context, xml );
  					}

  					if ( seed ) {

  						// Reintegrate element matches to eliminate the need for sorting
  						if ( matchedCount > 0 ) {
  							while ( i-- ) {
  								if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
  									setMatched[ i ] = pop.call( results );
  								}
  							}
  						}

  						// Discard index placeholder values to get only actual matches
  						setMatched = condense( setMatched );
  					}

  					// Add matches to results
  					push.apply( results, setMatched );

  					// Seedless set matches succeeding multiple successful matchers stipulate sorting
  					if ( outermost && !seed && setMatched.length > 0 &&
  						( matchedCount + setMatchers.length ) > 1 ) {

  						jQuery.uniqueSort( results );
  					}
  				}

  				// Override manipulation of globals by nested matchers
  				if ( outermost ) {
  					dirruns = dirrunsUnique;
  					outermostContext = contextBackup;
  				}

  				return unmatched;
  			};

  		return bySet ?
  			markFunction( superMatcher ) :
  			superMatcher;
  	}

  	function compile( selector, match /* Internal Use Only */ ) {
  		var i,
  			setMatchers = [],
  			elementMatchers = [],
  			cached = compilerCache[ selector + " " ];

  		if ( !cached ) {

  			// Generate a function of recursive functions that can be used to check each element
  			if ( !match ) {
  				match = tokenize( selector );
  			}
  			i = match.length;
  			while ( i-- ) {
  				cached = matcherFromTokens( match[ i ] );
  				if ( cached[ expando ] ) {
  					setMatchers.push( cached );
  				} else {
  					elementMatchers.push( cached );
  				}
  			}

  			// Cache the compiled function
  			cached = compilerCache( selector,
  				matcherFromGroupMatchers( elementMatchers, setMatchers ) );

  			// Save selector and tokenization
  			cached.selector = selector;
  		}
  		return cached;
  	}

  	/**
  	 * A low-level selection function that works with jQuery's compiled
  	 *  selector functions
  	 * @param {String|Function} selector A selector or a pre-compiled
  	 *  selector function built with jQuery selector compile
  	 * @param {Element} context
  	 * @param {Array} [results]
  	 * @param {Array} [seed] A set of elements to match against
  	 */
  	function select( selector, context, results, seed ) {
  		var i, tokens, token, type, find,
  			compiled = typeof selector === "function" && selector,
  			match = !seed && tokenize( ( selector = compiled.selector || selector ) );

  		results = results || [];

  		// Try to minimize operations if there is only one selector in the list and no seed
  		// (the latter of which guarantees us context)
  		if ( match.length === 1 ) {

  			// Reduce context if the leading compound selector is an ID
  			tokens = match[ 0 ] = match[ 0 ].slice( 0 );
  			if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
  					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

  				context = ( Expr.find.ID(
  					token.matches[ 0 ].replace( runescape, funescape ),
  					context
  				) || [] )[ 0 ];
  				if ( !context ) {
  					return results;

  				// Precompiled matchers will still verify ancestry, so step up a level
  				} else if ( compiled ) {
  					context = context.parentNode;
  				}

  				selector = selector.slice( tokens.shift().value.length );
  			}

  			// Fetch a seed set for right-to-left matching
  			i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
  			while ( i-- ) {
  				token = tokens[ i ];

  				// Abort if we hit a combinator
  				if ( Expr.relative[ ( type = token.type ) ] ) {
  					break;
  				}
  				if ( ( find = Expr.find[ type ] ) ) {

  					// Search, expanding context for leading sibling combinators
  					if ( ( seed = find(
  						token.matches[ 0 ].replace( runescape, funescape ),
  						rsibling.test( tokens[ 0 ].type ) &&
  							testContext( context.parentNode ) || context
  					) ) ) {

  						// If seed is empty or no tokens remain, we can return early
  						tokens.splice( i, 1 );
  						selector = seed.length && toSelector( tokens );
  						if ( !selector ) {
  							push.apply( results, seed );
  							return results;
  						}

  						break;
  					}
  				}
  			}
  		}

  		// Compile and execute a filtering function if one is not provided
  		// Provide `match` to avoid retokenization if we modified the selector above
  		( compiled || compile( selector, match ) )(
  			seed,
  			context,
  			!documentIsHTML,
  			results,
  			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
  		);
  		return results;
  	}

  	// One-time assignments

  	// Support: Android <=4.0 - 4.1+
  	// Sort stability
  	support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

  	// Initialize against the default document
  	setDocument();

  	// Support: Android <=4.0 - 4.1+
  	// Detached nodes confoundingly follow *each other*
  	support.sortDetached = assert( function( el ) {

  		// Should return 1, but returns 4 (following)
  		return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
  	} );

  	jQuery.find = find;

  	// Deprecated
  	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
  	jQuery.unique = jQuery.uniqueSort;

  	// These have always been private, but they used to be documented as part of
  	// Sizzle so let's maintain them for now for backwards compatibility purposes.
  	find.compile = compile;
  	find.select = select;
  	find.setDocument = setDocument;
  	find.tokenize = tokenize;

  	find.escape = jQuery.escapeSelector;
  	find.getText = jQuery.text;
  	find.isXML = jQuery.isXMLDoc;
  	find.selectors = jQuery.expr;
  	find.support = jQuery.support;
  	find.uniqueSort = jQuery.uniqueSort;

  		/* eslint-enable */

  	} )();


  	var dir = function( elem, dir, until ) {
  		var matched = [],
  			truncate = until !== undefined;

  		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
  			if ( elem.nodeType === 1 ) {
  				if ( truncate && jQuery( elem ).is( until ) ) {
  					break;
  				}
  				matched.push( elem );
  			}
  		}
  		return matched;
  	};


  	var siblings = function( n, elem ) {
  		var matched = [];

  		for ( ; n; n = n.nextSibling ) {
  			if ( n.nodeType === 1 && n !== elem ) {
  				matched.push( n );
  			}
  		}

  		return matched;
  	};


  	var rneedsContext = jQuery.expr.match.needsContext;

  	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



  	// Implement the identical functionality for filter and not
  	function winnow( elements, qualifier, not ) {
  		if ( isFunction( qualifier ) ) {
  			return jQuery.grep( elements, function( elem, i ) {
  				return !!qualifier.call( elem, i, elem ) !== not;
  			} );
  		}

  		// Single element
  		if ( qualifier.nodeType ) {
  			return jQuery.grep( elements, function( elem ) {
  				return ( elem === qualifier ) !== not;
  			} );
  		}

  		// Arraylike of elements (jQuery, arguments, Array)
  		if ( typeof qualifier !== "string" ) {
  			return jQuery.grep( elements, function( elem ) {
  				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
  			} );
  		}

  		// Filtered directly for both simple and complex selectors
  		return jQuery.filter( qualifier, elements, not );
  	}

  	jQuery.filter = function( expr, elems, not ) {
  		var elem = elems[ 0 ];

  		if ( not ) {
  			expr = ":not(" + expr + ")";
  		}

  		if ( elems.length === 1 && elem.nodeType === 1 ) {
  			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
  		}

  		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
  			return elem.nodeType === 1;
  		} ) );
  	};

  	jQuery.fn.extend( {
  		find: function( selector ) {
  			var i, ret,
  				len = this.length,
  				self = this;

  			if ( typeof selector !== "string" ) {
  				return this.pushStack( jQuery( selector ).filter( function() {
  					for ( i = 0; i < len; i++ ) {
  						if ( jQuery.contains( self[ i ], this ) ) {
  							return true;
  						}
  					}
  				} ) );
  			}

  			ret = this.pushStack( [] );

  			for ( i = 0; i < len; i++ ) {
  				jQuery.find( selector, self[ i ], ret );
  			}

  			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
  		},
  		filter: function( selector ) {
  			return this.pushStack( winnow( this, selector || [], false ) );
  		},
  		not: function( selector ) {
  			return this.pushStack( winnow( this, selector || [], true ) );
  		},
  		is: function( selector ) {
  			return !!winnow(
  				this,

  				// If this is a positional/relative selector, check membership in the returned set
  				// so $("p:first").is("p:last") won't return true for a doc with two "p".
  				typeof selector === "string" && rneedsContext.test( selector ) ?
  					jQuery( selector ) :
  					selector || [],
  				false
  			).length;
  		}
  	} );


  	// Initialize a jQuery object


  	// A central reference to the root jQuery(document)
  	var rootjQuery,

  		// A simple way to check for HTML strings
  		// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
  		// Strict HTML recognition (trac-11290: must start with <)
  		// Shortcut simple #id case for speed
  		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

  		init = jQuery.fn.init = function( selector, context, root ) {
  			var match, elem;

  			// HANDLE: $(""), $(null), $(undefined), $(false)
  			if ( !selector ) {
  				return this;
  			}

  			// Method init() accepts an alternate rootjQuery
  			// so migrate can support jQuery.sub (gh-2101)
  			root = root || rootjQuery;

  			// Handle HTML strings
  			if ( typeof selector === "string" ) {
  				if ( selector[ 0 ] === "<" &&
  					selector[ selector.length - 1 ] === ">" &&
  					selector.length >= 3 ) {

  					// Assume that strings that start and end with <> are HTML and skip the regex check
  					match = [ null, selector, null ];

  				} else {
  					match = rquickExpr.exec( selector );
  				}

  				// Match html or make sure no context is specified for #id
  				if ( match && ( match[ 1 ] || !context ) ) {

  					// HANDLE: $(html) -> $(array)
  					if ( match[ 1 ] ) {
  						context = context instanceof jQuery ? context[ 0 ] : context;

  						// Option to run scripts is true for back-compat
  						// Intentionally let the error be thrown if parseHTML is not present
  						jQuery.merge( this, jQuery.parseHTML(
  							match[ 1 ],
  							context && context.nodeType ? context.ownerDocument || context : document,
  							true
  						) );

  						// HANDLE: $(html, props)
  						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
  							for ( match in context ) {

  								// Properties of context are called as methods if possible
  								if ( isFunction( this[ match ] ) ) {
  									this[ match ]( context[ match ] );

  								// ...and otherwise set as attributes
  								} else {
  									this.attr( match, context[ match ] );
  								}
  							}
  						}

  						return this;

  					// HANDLE: $(#id)
  					} else {
  						elem = document.getElementById( match[ 2 ] );

  						if ( elem ) {

  							// Inject the element directly into the jQuery object
  							this[ 0 ] = elem;
  							this.length = 1;
  						}
  						return this;
  					}

  				// HANDLE: $(expr, $(...))
  				} else if ( !context || context.jquery ) {
  					return ( context || root ).find( selector );

  				// HANDLE: $(expr, context)
  				// (which is just equivalent to: $(context).find(expr)
  				} else {
  					return this.constructor( context ).find( selector );
  				}

  			// HANDLE: $(DOMElement)
  			} else if ( selector.nodeType ) {
  				this[ 0 ] = selector;
  				this.length = 1;
  				return this;

  			// HANDLE: $(function)
  			// Shortcut for document ready
  			} else if ( isFunction( selector ) ) {
  				return root.ready !== undefined ?
  					root.ready( selector ) :

  					// Execute immediately if ready is not present
  					selector( jQuery );
  			}

  			return jQuery.makeArray( selector, this );
  		};

  	// Give the init function the jQuery prototype for later instantiation
  	init.prototype = jQuery.fn;

  	// Initialize central reference
  	rootjQuery = jQuery( document );


  	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

  		// Methods guaranteed to produce a unique set when starting from a unique set
  		guaranteedUnique = {
  			children: true,
  			contents: true,
  			next: true,
  			prev: true
  		};

  	jQuery.fn.extend( {
  		has: function( target ) {
  			var targets = jQuery( target, this ),
  				l = targets.length;

  			return this.filter( function() {
  				var i = 0;
  				for ( ; i < l; i++ ) {
  					if ( jQuery.contains( this, targets[ i ] ) ) {
  						return true;
  					}
  				}
  			} );
  		},

  		closest: function( selectors, context ) {
  			var cur,
  				i = 0,
  				l = this.length,
  				matched = [],
  				targets = typeof selectors !== "string" && jQuery( selectors );

  			// Positional selectors never match, since there's no _selection_ context
  			if ( !rneedsContext.test( selectors ) ) {
  				for ( ; i < l; i++ ) {
  					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

  						// Always skip document fragments
  						if ( cur.nodeType < 11 && ( targets ?
  							targets.index( cur ) > -1 :

  							// Don't pass non-elements to jQuery#find
  							cur.nodeType === 1 &&
  								jQuery.find.matchesSelector( cur, selectors ) ) ) {

  							matched.push( cur );
  							break;
  						}
  					}
  				}
  			}

  			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
  		},

  		// Determine the position of an element within the set
  		index: function( elem ) {

  			// No argument, return index in parent
  			if ( !elem ) {
  				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
  			}

  			// Index in selector
  			if ( typeof elem === "string" ) {
  				return indexOf.call( jQuery( elem ), this[ 0 ] );
  			}

  			// Locate the position of the desired element
  			return indexOf.call( this,

  				// If it receives a jQuery object, the first element is used
  				elem.jquery ? elem[ 0 ] : elem
  			);
  		},

  		add: function( selector, context ) {
  			return this.pushStack(
  				jQuery.uniqueSort(
  					jQuery.merge( this.get(), jQuery( selector, context ) )
  				)
  			);
  		},

  		addBack: function( selector ) {
  			return this.add( selector == null ?
  				this.prevObject : this.prevObject.filter( selector )
  			);
  		}
  	} );

  	function sibling( cur, dir ) {
  		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
  		return cur;
  	}

  	jQuery.each( {
  		parent: function( elem ) {
  			var parent = elem.parentNode;
  			return parent && parent.nodeType !== 11 ? parent : null;
  		},
  		parents: function( elem ) {
  			return dir( elem, "parentNode" );
  		},
  		parentsUntil: function( elem, _i, until ) {
  			return dir( elem, "parentNode", until );
  		},
  		next: function( elem ) {
  			return sibling( elem, "nextSibling" );
  		},
  		prev: function( elem ) {
  			return sibling( elem, "previousSibling" );
  		},
  		nextAll: function( elem ) {
  			return dir( elem, "nextSibling" );
  		},
  		prevAll: function( elem ) {
  			return dir( elem, "previousSibling" );
  		},
  		nextUntil: function( elem, _i, until ) {
  			return dir( elem, "nextSibling", until );
  		},
  		prevUntil: function( elem, _i, until ) {
  			return dir( elem, "previousSibling", until );
  		},
  		siblings: function( elem ) {
  			return siblings( ( elem.parentNode || {} ).firstChild, elem );
  		},
  		children: function( elem ) {
  			return siblings( elem.firstChild );
  		},
  		contents: function( elem ) {
  			if ( elem.contentDocument != null &&

  				// Support: IE 11+
  				// <object> elements with no `data` attribute has an object
  				// `contentDocument` with a `null` prototype.
  				getProto( elem.contentDocument ) ) {

  				return elem.contentDocument;
  			}

  			// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
  			// Treat the template element as a regular one in browsers that
  			// don't support it.
  			if ( nodeName( elem, "template" ) ) {
  				elem = elem.content || elem;
  			}

  			return jQuery.merge( [], elem.childNodes );
  		}
  	}, function( name, fn ) {
  		jQuery.fn[ name ] = function( until, selector ) {
  			var matched = jQuery.map( this, fn, until );

  			if ( name.slice( -5 ) !== "Until" ) {
  				selector = until;
  			}

  			if ( selector && typeof selector === "string" ) {
  				matched = jQuery.filter( selector, matched );
  			}

  			if ( this.length > 1 ) {

  				// Remove duplicates
  				if ( !guaranteedUnique[ name ] ) {
  					jQuery.uniqueSort( matched );
  				}

  				// Reverse order for parents* and prev-derivatives
  				if ( rparentsprev.test( name ) ) {
  					matched.reverse();
  				}
  			}

  			return this.pushStack( matched );
  		};
  	} );
  	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



  	// Convert String-formatted options into Object-formatted ones
  	function createOptions( options ) {
  		var object = {};
  		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
  			object[ flag ] = true;
  		} );
  		return object;
  	}

  	/*
  	 * Create a callback list using the following parameters:
  	 *
  	 *	options: an optional list of space-separated options that will change how
  	 *			the callback list behaves or a more traditional option object
  	 *
  	 * By default a callback list will act like an event callback list and can be
  	 * "fired" multiple times.
  	 *
  	 * Possible options:
  	 *
  	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
  	 *
  	 *	memory:			will keep track of previous values and will call any callback added
  	 *					after the list has been fired right away with the latest "memorized"
  	 *					values (like a Deferred)
  	 *
  	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  	 *
  	 *	stopOnFalse:	interrupt callings when a callback returns false
  	 *
  	 */
  	jQuery.Callbacks = function( options ) {

  		// Convert options from String-formatted to Object-formatted if needed
  		// (we check in cache first)
  		options = typeof options === "string" ?
  			createOptions( options ) :
  			jQuery.extend( {}, options );

  		var // Flag to know if list is currently firing
  			firing,

  			// Last fire value for non-forgettable lists
  			memory,

  			// Flag to know if list was already fired
  			fired,

  			// Flag to prevent firing
  			locked,

  			// Actual callback list
  			list = [],

  			// Queue of execution data for repeatable lists
  			queue = [],

  			// Index of currently firing callback (modified by add/remove as needed)
  			firingIndex = -1,

  			// Fire callbacks
  			fire = function() {

  				// Enforce single-firing
  				locked = locked || options.once;

  				// Execute callbacks for all pending executions,
  				// respecting firingIndex overrides and runtime changes
  				fired = firing = true;
  				for ( ; queue.length; firingIndex = -1 ) {
  					memory = queue.shift();
  					while ( ++firingIndex < list.length ) {

  						// Run callback and check for early termination
  						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
  							options.stopOnFalse ) {

  							// Jump to end and forget the data so .add doesn't re-fire
  							firingIndex = list.length;
  							memory = false;
  						}
  					}
  				}

  				// Forget the data if we're done with it
  				if ( !options.memory ) {
  					memory = false;
  				}

  				firing = false;

  				// Clean up if we're done firing for good
  				if ( locked ) {

  					// Keep an empty list if we have data for future add calls
  					if ( memory ) {
  						list = [];

  					// Otherwise, this object is spent
  					} else {
  						list = "";
  					}
  				}
  			},

  			// Actual Callbacks object
  			self = {

  				// Add a callback or a collection of callbacks to the list
  				add: function() {
  					if ( list ) {

  						// If we have memory from a past run, we should fire after adding
  						if ( memory && !firing ) {
  							firingIndex = list.length - 1;
  							queue.push( memory );
  						}

  						( function add( args ) {
  							jQuery.each( args, function( _, arg ) {
  								if ( isFunction( arg ) ) {
  									if ( !options.unique || !self.has( arg ) ) {
  										list.push( arg );
  									}
  								} else if ( arg && arg.length && toType( arg ) !== "string" ) {

  									// Inspect recursively
  									add( arg );
  								}
  							} );
  						} )( arguments );

  						if ( memory && !firing ) {
  							fire();
  						}
  					}
  					return this;
  				},

  				// Remove a callback from the list
  				remove: function() {
  					jQuery.each( arguments, function( _, arg ) {
  						var index;
  						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
  							list.splice( index, 1 );

  							// Handle firing indexes
  							if ( index <= firingIndex ) {
  								firingIndex--;
  							}
  						}
  					} );
  					return this;
  				},

  				// Check if a given callback is in the list.
  				// If no argument is given, return whether or not list has callbacks attached.
  				has: function( fn ) {
  					return fn ?
  						jQuery.inArray( fn, list ) > -1 :
  						list.length > 0;
  				},

  				// Remove all callbacks from the list
  				empty: function() {
  					if ( list ) {
  						list = [];
  					}
  					return this;
  				},

  				// Disable .fire and .add
  				// Abort any current/pending executions
  				// Clear all callbacks and values
  				disable: function() {
  					locked = queue = [];
  					list = memory = "";
  					return this;
  				},
  				disabled: function() {
  					return !list;
  				},

  				// Disable .fire
  				// Also disable .add unless we have memory (since it would have no effect)
  				// Abort any pending executions
  				lock: function() {
  					locked = queue = [];
  					if ( !memory && !firing ) {
  						list = memory = "";
  					}
  					return this;
  				},
  				locked: function() {
  					return !!locked;
  				},

  				// Call all callbacks with the given context and arguments
  				fireWith: function( context, args ) {
  					if ( !locked ) {
  						args = args || [];
  						args = [ context, args.slice ? args.slice() : args ];
  						queue.push( args );
  						if ( !firing ) {
  							fire();
  						}
  					}
  					return this;
  				},

  				// Call all the callbacks with the given arguments
  				fire: function() {
  					self.fireWith( this, arguments );
  					return this;
  				},

  				// To know if the callbacks have already been called at least once
  				fired: function() {
  					return !!fired;
  				}
  			};

  		return self;
  	};


  	function Identity( v ) {
  		return v;
  	}
  	function Thrower( ex ) {
  		throw ex;
  	}

  	function adoptValue( value, resolve, reject, noValue ) {
  		var method;

  		try {

  			// Check for promise aspect first to privilege synchronous behavior
  			if ( value && isFunction( ( method = value.promise ) ) ) {
  				method.call( value ).done( resolve ).fail( reject );

  			// Other thenables
  			} else if ( value && isFunction( ( method = value.then ) ) ) {
  				method.call( value, resolve, reject );

  			// Other non-thenables
  			} else {

  				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
  				// * false: [ value ].slice( 0 ) => resolve( value )
  				// * true: [ value ].slice( 1 ) => resolve()
  				resolve.apply( undefined, [ value ].slice( noValue ) );
  			}

  		// For Promises/A+, convert exceptions into rejections
  		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
  		// Deferred#then to conditionally suppress rejection.
  		} catch ( value ) {

  			// Support: Android 4.0 only
  			// Strict mode functions invoked without .call/.apply get global-object context
  			reject.apply( undefined, [ value ] );
  		}
  	}

  	jQuery.extend( {

  		Deferred: function( func ) {
  			var tuples = [

  					// action, add listener, callbacks,
  					// ... .then handlers, argument index, [final state]
  					[ "notify", "progress", jQuery.Callbacks( "memory" ),
  						jQuery.Callbacks( "memory" ), 2 ],
  					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
  						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
  					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
  						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
  				],
  				state = "pending",
  				promise = {
  					state: function() {
  						return state;
  					},
  					always: function() {
  						deferred.done( arguments ).fail( arguments );
  						return this;
  					},
  					"catch": function( fn ) {
  						return promise.then( null, fn );
  					},

  					// Keep pipe for back-compat
  					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
  						var fns = arguments;

  						return jQuery.Deferred( function( newDefer ) {
  							jQuery.each( tuples, function( _i, tuple ) {

  								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
  								var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

  								// deferred.progress(function() { bind to newDefer or newDefer.notify })
  								// deferred.done(function() { bind to newDefer or newDefer.resolve })
  								// deferred.fail(function() { bind to newDefer or newDefer.reject })
  								deferred[ tuple[ 1 ] ]( function() {
  									var returned = fn && fn.apply( this, arguments );
  									if ( returned && isFunction( returned.promise ) ) {
  										returned.promise()
  											.progress( newDefer.notify )
  											.done( newDefer.resolve )
  											.fail( newDefer.reject );
  									} else {
  										newDefer[ tuple[ 0 ] + "With" ](
  											this,
  											fn ? [ returned ] : arguments
  										);
  									}
  								} );
  							} );
  							fns = null;
  						} ).promise();
  					},
  					then: function( onFulfilled, onRejected, onProgress ) {
  						var maxDepth = 0;
  						function resolve( depth, deferred, handler, special ) {
  							return function() {
  								var that = this,
  									args = arguments,
  									mightThrow = function() {
  										var returned, then;

  										// Support: Promises/A+ section 2.3.3.3.3
  										// https://promisesaplus.com/#point-59
  										// Ignore double-resolution attempts
  										if ( depth < maxDepth ) {
  											return;
  										}

  										returned = handler.apply( that, args );

  										// Support: Promises/A+ section 2.3.1
  										// https://promisesaplus.com/#point-48
  										if ( returned === deferred.promise() ) {
  											throw new TypeError( "Thenable self-resolution" );
  										}

  										// Support: Promises/A+ sections 2.3.3.1, 3.5
  										// https://promisesaplus.com/#point-54
  										// https://promisesaplus.com/#point-75
  										// Retrieve `then` only once
  										then = returned &&

  											// Support: Promises/A+ section 2.3.4
  											// https://promisesaplus.com/#point-64
  											// Only check objects and functions for thenability
  											( typeof returned === "object" ||
  												typeof returned === "function" ) &&
  											returned.then;

  										// Handle a returned thenable
  										if ( isFunction( then ) ) {

  											// Special processors (notify) just wait for resolution
  											if ( special ) {
  												then.call(
  													returned,
  													resolve( maxDepth, deferred, Identity, special ),
  													resolve( maxDepth, deferred, Thrower, special )
  												);

  											// Normal processors (resolve) also hook into progress
  											} else {

  												// ...and disregard older resolution values
  												maxDepth++;

  												then.call(
  													returned,
  													resolve( maxDepth, deferred, Identity, special ),
  													resolve( maxDepth, deferred, Thrower, special ),
  													resolve( maxDepth, deferred, Identity,
  														deferred.notifyWith )
  												);
  											}

  										// Handle all other returned values
  										} else {

  											// Only substitute handlers pass on context
  											// and multiple values (non-spec behavior)
  											if ( handler !== Identity ) {
  												that = undefined;
  												args = [ returned ];
  											}

  											// Process the value(s)
  											// Default process is resolve
  											( special || deferred.resolveWith )( that, args );
  										}
  									},

  									// Only normal processors (resolve) catch and reject exceptions
  									process = special ?
  										mightThrow :
  										function() {
  											try {
  												mightThrow();
  											} catch ( e ) {

  												if ( jQuery.Deferred.exceptionHook ) {
  													jQuery.Deferred.exceptionHook( e,
  														process.error );
  												}

  												// Support: Promises/A+ section 2.3.3.3.4.1
  												// https://promisesaplus.com/#point-61
  												// Ignore post-resolution exceptions
  												if ( depth + 1 >= maxDepth ) {

  													// Only substitute handlers pass on context
  													// and multiple values (non-spec behavior)
  													if ( handler !== Thrower ) {
  														that = undefined;
  														args = [ e ];
  													}

  													deferred.rejectWith( that, args );
  												}
  											}
  										};

  								// Support: Promises/A+ section 2.3.3.3.1
  								// https://promisesaplus.com/#point-57
  								// Re-resolve promises immediately to dodge false rejection from
  								// subsequent errors
  								if ( depth ) {
  									process();
  								} else {

  									// Call an optional hook to record the error, in case of exception
  									// since it's otherwise lost when execution goes async
  									if ( jQuery.Deferred.getErrorHook ) {
  										process.error = jQuery.Deferred.getErrorHook();

  									// The deprecated alias of the above. While the name suggests
  									// returning the stack, not an error instance, jQuery just passes
  									// it directly to `console.warn` so both will work; an instance
  									// just better cooperates with source maps.
  									} else if ( jQuery.Deferred.getStackHook ) {
  										process.error = jQuery.Deferred.getStackHook();
  									}
  									window.setTimeout( process );
  								}
  							};
  						}

  						return jQuery.Deferred( function( newDefer ) {

  							// progress_handlers.add( ... )
  							tuples[ 0 ][ 3 ].add(
  								resolve(
  									0,
  									newDefer,
  									isFunction( onProgress ) ?
  										onProgress :
  										Identity,
  									newDefer.notifyWith
  								)
  							);

  							// fulfilled_handlers.add( ... )
  							tuples[ 1 ][ 3 ].add(
  								resolve(
  									0,
  									newDefer,
  									isFunction( onFulfilled ) ?
  										onFulfilled :
  										Identity
  								)
  							);

  							// rejected_handlers.add( ... )
  							tuples[ 2 ][ 3 ].add(
  								resolve(
  									0,
  									newDefer,
  									isFunction( onRejected ) ?
  										onRejected :
  										Thrower
  								)
  							);
  						} ).promise();
  					},

  					// Get a promise for this deferred
  					// If obj is provided, the promise aspect is added to the object
  					promise: function( obj ) {
  						return obj != null ? jQuery.extend( obj, promise ) : promise;
  					}
  				},
  				deferred = {};

  			// Add list-specific methods
  			jQuery.each( tuples, function( i, tuple ) {
  				var list = tuple[ 2 ],
  					stateString = tuple[ 5 ];

  				// promise.progress = list.add
  				// promise.done = list.add
  				// promise.fail = list.add
  				promise[ tuple[ 1 ] ] = list.add;

  				// Handle state
  				if ( stateString ) {
  					list.add(
  						function() {

  							// state = "resolved" (i.e., fulfilled)
  							// state = "rejected"
  							state = stateString;
  						},

  						// rejected_callbacks.disable
  						// fulfilled_callbacks.disable
  						tuples[ 3 - i ][ 2 ].disable,

  						// rejected_handlers.disable
  						// fulfilled_handlers.disable
  						tuples[ 3 - i ][ 3 ].disable,

  						// progress_callbacks.lock
  						tuples[ 0 ][ 2 ].lock,

  						// progress_handlers.lock
  						tuples[ 0 ][ 3 ].lock
  					);
  				}

  				// progress_handlers.fire
  				// fulfilled_handlers.fire
  				// rejected_handlers.fire
  				list.add( tuple[ 3 ].fire );

  				// deferred.notify = function() { deferred.notifyWith(...) }
  				// deferred.resolve = function() { deferred.resolveWith(...) }
  				// deferred.reject = function() { deferred.rejectWith(...) }
  				deferred[ tuple[ 0 ] ] = function() {
  					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
  					return this;
  				};

  				// deferred.notifyWith = list.fireWith
  				// deferred.resolveWith = list.fireWith
  				// deferred.rejectWith = list.fireWith
  				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
  			} );

  			// Make the deferred a promise
  			promise.promise( deferred );

  			// Call given func if any
  			if ( func ) {
  				func.call( deferred, deferred );
  			}

  			// All done!
  			return deferred;
  		},

  		// Deferred helper
  		when: function( singleValue ) {
  			var

  				// count of uncompleted subordinates
  				remaining = arguments.length,

  				// count of unprocessed arguments
  				i = remaining,

  				// subordinate fulfillment data
  				resolveContexts = Array( i ),
  				resolveValues = slice.call( arguments ),

  				// the primary Deferred
  				primary = jQuery.Deferred(),

  				// subordinate callback factory
  				updateFunc = function( i ) {
  					return function( value ) {
  						resolveContexts[ i ] = this;
  						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
  						if ( !( --remaining ) ) {
  							primary.resolveWith( resolveContexts, resolveValues );
  						}
  					};
  				};

  			// Single- and empty arguments are adopted like Promise.resolve
  			if ( remaining <= 1 ) {
  				adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
  					!remaining );

  				// Use .then() to unwrap secondary thenables (cf. gh-3000)
  				if ( primary.state() === "pending" ||
  					isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

  					return primary.then();
  				}
  			}

  			// Multiple arguments are aggregated like Promise.all array elements
  			while ( i-- ) {
  				adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
  			}

  			return primary.promise();
  		}
  	} );


  	// These usually indicate a programmer mistake during development,
  	// warn about them ASAP rather than swallowing them by default.
  	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  	// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
  	// captured before the async barrier to get the original error cause
  	// which may otherwise be hidden.
  	jQuery.Deferred.exceptionHook = function( error, asyncError ) {

  		// Support: IE 8 - 9 only
  		// Console exists when dev tools are open, which can happen at any time
  		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
  			window.console.warn( "jQuery.Deferred exception: " + error.message,
  				error.stack, asyncError );
  		}
  	};




  	jQuery.readyException = function( error ) {
  		window.setTimeout( function() {
  			throw error;
  		} );
  	};




  	// The deferred used on DOM ready
  	var readyList = jQuery.Deferred();

  	jQuery.fn.ready = function( fn ) {

  		readyList
  			.then( fn )

  			// Wrap jQuery.readyException in a function so that the lookup
  			// happens at the time of error handling instead of callback
  			// registration.
  			.catch( function( error ) {
  				jQuery.readyException( error );
  			} );

  		return this;
  	};

  	jQuery.extend( {

  		// Is the DOM ready to be used? Set to true once it occurs.
  		isReady: false,

  		// A counter to track how many items to wait for before
  		// the ready event fires. See trac-6781
  		readyWait: 1,

  		// Handle when the DOM is ready
  		ready: function( wait ) {

  			// Abort if there are pending holds or we're already ready
  			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
  				return;
  			}

  			// Remember that the DOM is ready
  			jQuery.isReady = true;

  			// If a normal DOM Ready event fired, decrement, and wait if need be
  			if ( wait !== true && --jQuery.readyWait > 0 ) {
  				return;
  			}

  			// If there are functions bound, to execute
  			readyList.resolveWith( document, [ jQuery ] );
  		}
  	} );

  	jQuery.ready.then = readyList.then;

  	// The ready event handler and self cleanup method
  	function completed() {
  		document.removeEventListener( "DOMContentLoaded", completed );
  		window.removeEventListener( "load", completed );
  		jQuery.ready();
  	}

  	// Catch cases where $(document).ready() is called
  	// after the browser event has already occurred.
  	// Support: IE <=9 - 10 only
  	// Older IE sometimes signals "interactive" too soon
  	if ( document.readyState === "complete" ||
  		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

  		// Handle it asynchronously to allow scripts the opportunity to delay ready
  		window.setTimeout( jQuery.ready );

  	} else {

  		// Use the handy event callback
  		document.addEventListener( "DOMContentLoaded", completed );

  		// A fallback to window.onload, that will always work
  		window.addEventListener( "load", completed );
  	}




  	// Multifunctional method to get and set values of a collection
  	// The value/s can optionally be executed if it's a function
  	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
  		var i = 0,
  			len = elems.length,
  			bulk = key == null;

  		// Sets many values
  		if ( toType( key ) === "object" ) {
  			chainable = true;
  			for ( i in key ) {
  				access( elems, fn, i, key[ i ], true, emptyGet, raw );
  			}

  		// Sets one value
  		} else if ( value !== undefined ) {
  			chainable = true;

  			if ( !isFunction( value ) ) {
  				raw = true;
  			}

  			if ( bulk ) {

  				// Bulk operations run against the entire set
  				if ( raw ) {
  					fn.call( elems, value );
  					fn = null;

  				// ...except when executing function values
  				} else {
  					bulk = fn;
  					fn = function( elem, _key, value ) {
  						return bulk.call( jQuery( elem ), value );
  					};
  				}
  			}

  			if ( fn ) {
  				for ( ; i < len; i++ ) {
  					fn(
  						elems[ i ], key, raw ?
  							value :
  							value.call( elems[ i ], i, fn( elems[ i ], key ) )
  					);
  				}
  			}
  		}

  		if ( chainable ) {
  			return elems;
  		}

  		// Gets
  		if ( bulk ) {
  			return fn.call( elems );
  		}

  		return len ? fn( elems[ 0 ], key ) : emptyGet;
  	};


  	// Matches dashed string for camelizing
  	var rmsPrefix = /^-ms-/,
  		rdashAlpha = /-([a-z])/g;

  	// Used by camelCase as callback to replace()
  	function fcamelCase( _all, letter ) {
  		return letter.toUpperCase();
  	}

  	// Convert dashed to camelCase; used by the css and data modules
  	// Support: IE <=9 - 11, Edge 12 - 15
  	// Microsoft forgot to hump their vendor prefix (trac-9572)
  	function camelCase( string ) {
  		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  	}
  	var acceptData = function( owner ) {

  		// Accepts only:
  		//  - Node
  		//    - Node.ELEMENT_NODE
  		//    - Node.DOCUMENT_NODE
  		//  - Object
  		//    - Any
  		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
  	};




  	function Data() {
  		this.expando = jQuery.expando + Data.uid++;
  	}

  	Data.uid = 1;

  	Data.prototype = {

  		cache: function( owner ) {

  			// Check if the owner object already has a cache
  			var value = owner[ this.expando ];

  			// If not, create one
  			if ( !value ) {
  				value = {};

  				// We can accept data for non-element nodes in modern browsers,
  				// but we should not, see trac-8335.
  				// Always return an empty object.
  				if ( acceptData( owner ) ) {

  					// If it is a node unlikely to be stringify-ed or looped over
  					// use plain assignment
  					if ( owner.nodeType ) {
  						owner[ this.expando ] = value;

  					// Otherwise secure it in a non-enumerable property
  					// configurable must be true to allow the property to be
  					// deleted when data is removed
  					} else {
  						Object.defineProperty( owner, this.expando, {
  							value: value,
  							configurable: true
  						} );
  					}
  				}
  			}

  			return value;
  		},
  		set: function( owner, data, value ) {
  			var prop,
  				cache = this.cache( owner );

  			// Handle: [ owner, key, value ] args
  			// Always use camelCase key (gh-2257)
  			if ( typeof data === "string" ) {
  				cache[ camelCase( data ) ] = value;

  			// Handle: [ owner, { properties } ] args
  			} else {

  				// Copy the properties one-by-one to the cache object
  				for ( prop in data ) {
  					cache[ camelCase( prop ) ] = data[ prop ];
  				}
  			}
  			return cache;
  		},
  		get: function( owner, key ) {
  			return key === undefined ?
  				this.cache( owner ) :

  				// Always use camelCase key (gh-2257)
  				owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
  		},
  		access: function( owner, key, value ) {

  			// In cases where either:
  			//
  			//   1. No key was specified
  			//   2. A string key was specified, but no value provided
  			//
  			// Take the "read" path and allow the get method to determine
  			// which value to return, respectively either:
  			//
  			//   1. The entire cache object
  			//   2. The data stored at the key
  			//
  			if ( key === undefined ||
  					( ( key && typeof key === "string" ) && value === undefined ) ) {

  				return this.get( owner, key );
  			}

  			// When the key is not a string, or both a key and value
  			// are specified, set or extend (existing objects) with either:
  			//
  			//   1. An object of properties
  			//   2. A key and value
  			//
  			this.set( owner, key, value );

  			// Since the "set" path can have two possible entry points
  			// return the expected data based on which path was taken[*]
  			return value !== undefined ? value : key;
  		},
  		remove: function( owner, key ) {
  			var i,
  				cache = owner[ this.expando ];

  			if ( cache === undefined ) {
  				return;
  			}

  			if ( key !== undefined ) {

  				// Support array or space separated string of keys
  				if ( Array.isArray( key ) ) {

  					// If key is an array of keys...
  					// We always set camelCase keys, so remove that.
  					key = key.map( camelCase );
  				} else {
  					key = camelCase( key );

  					// If a key with the spaces exists, use it.
  					// Otherwise, create an array by matching non-whitespace
  					key = key in cache ?
  						[ key ] :
  						( key.match( rnothtmlwhite ) || [] );
  				}

  				i = key.length;

  				while ( i-- ) {
  					delete cache[ key[ i ] ];
  				}
  			}

  			// Remove the expando if there's no more data
  			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

  				// Support: Chrome <=35 - 45
  				// Webkit & Blink performance suffers when deleting properties
  				// from DOM nodes, so set to undefined instead
  				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
  				if ( owner.nodeType ) {
  					owner[ this.expando ] = undefined;
  				} else {
  					delete owner[ this.expando ];
  				}
  			}
  		},
  		hasData: function( owner ) {
  			var cache = owner[ this.expando ];
  			return cache !== undefined && !jQuery.isEmptyObject( cache );
  		}
  	};
  	var dataPriv = new Data();

  	var dataUser = new Data();



  	//	Implementation Summary
  	//
  	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
  	//	2. Improve the module's maintainability by reducing the storage
  	//		paths to a single mechanism.
  	//	3. Use the same single mechanism to support "private" and "user" data.
  	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
  	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  		rmultiDash = /[A-Z]/g;

  	function getData( data ) {
  		if ( data === "true" ) {
  			return true;
  		}

  		if ( data === "false" ) {
  			return false;
  		}

  		if ( data === "null" ) {
  			return null;
  		}

  		// Only convert to a number if it doesn't change the string
  		if ( data === +data + "" ) {
  			return +data;
  		}

  		if ( rbrace.test( data ) ) {
  			return JSON.parse( data );
  		}

  		return data;
  	}

  	function dataAttr( elem, key, data ) {
  		var name;

  		// If nothing was found internally, try to fetch any
  		// data from the HTML5 data-* attribute
  		if ( data === undefined && elem.nodeType === 1 ) {
  			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
  			data = elem.getAttribute( name );

  			if ( typeof data === "string" ) {
  				try {
  					data = getData( data );
  				} catch ( e ) {}

  				// Make sure we set the data so it isn't changed later
  				dataUser.set( elem, key, data );
  			} else {
  				data = undefined;
  			}
  		}
  		return data;
  	}

  	jQuery.extend( {
  		hasData: function( elem ) {
  			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
  		},

  		data: function( elem, name, data ) {
  			return dataUser.access( elem, name, data );
  		},

  		removeData: function( elem, name ) {
  			dataUser.remove( elem, name );
  		},

  		// TODO: Now that all calls to _data and _removeData have been replaced
  		// with direct calls to dataPriv methods, these can be deprecated.
  		_data: function( elem, name, data ) {
  			return dataPriv.access( elem, name, data );
  		},

  		_removeData: function( elem, name ) {
  			dataPriv.remove( elem, name );
  		}
  	} );

  	jQuery.fn.extend( {
  		data: function( key, value ) {
  			var i, name, data,
  				elem = this[ 0 ],
  				attrs = elem && elem.attributes;

  			// Gets all values
  			if ( key === undefined ) {
  				if ( this.length ) {
  					data = dataUser.get( elem );

  					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
  						i = attrs.length;
  						while ( i-- ) {

  							// Support: IE 11 only
  							// The attrs elements can be null (trac-14894)
  							if ( attrs[ i ] ) {
  								name = attrs[ i ].name;
  								if ( name.indexOf( "data-" ) === 0 ) {
  									name = camelCase( name.slice( 5 ) );
  									dataAttr( elem, name, data[ name ] );
  								}
  							}
  						}
  						dataPriv.set( elem, "hasDataAttrs", true );
  					}
  				}

  				return data;
  			}

  			// Sets multiple values
  			if ( typeof key === "object" ) {
  				return this.each( function() {
  					dataUser.set( this, key );
  				} );
  			}

  			return access( this, function( value ) {
  				var data;

  				// The calling jQuery object (element matches) is not empty
  				// (and therefore has an element appears at this[ 0 ]) and the
  				// `value` parameter was not undefined. An empty jQuery object
  				// will result in `undefined` for elem = this[ 0 ] which will
  				// throw an exception if an attempt to read a data cache is made.
  				if ( elem && value === undefined ) {

  					// Attempt to get data from the cache
  					// The key will always be camelCased in Data
  					data = dataUser.get( elem, key );
  					if ( data !== undefined ) {
  						return data;
  					}

  					// Attempt to "discover" the data in
  					// HTML5 custom data-* attrs
  					data = dataAttr( elem, key );
  					if ( data !== undefined ) {
  						return data;
  					}

  					// We tried really hard, but the data doesn't exist.
  					return;
  				}

  				// Set the data...
  				this.each( function() {

  					// We always store the camelCased key
  					dataUser.set( this, key, value );
  				} );
  			}, null, value, arguments.length > 1, null, true );
  		},

  		removeData: function( key ) {
  			return this.each( function() {
  				dataUser.remove( this, key );
  			} );
  		}
  	} );


  	jQuery.extend( {
  		queue: function( elem, type, data ) {
  			var queue;

  			if ( elem ) {
  				type = ( type || "fx" ) + "queue";
  				queue = dataPriv.get( elem, type );

  				// Speed up dequeue by getting out quickly if this is just a lookup
  				if ( data ) {
  					if ( !queue || Array.isArray( data ) ) {
  						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
  					} else {
  						queue.push( data );
  					}
  				}
  				return queue || [];
  			}
  		},

  		dequeue: function( elem, type ) {
  			type = type || "fx";

  			var queue = jQuery.queue( elem, type ),
  				startLength = queue.length,
  				fn = queue.shift(),
  				hooks = jQuery._queueHooks( elem, type ),
  				next = function() {
  					jQuery.dequeue( elem, type );
  				};

  			// If the fx queue is dequeued, always remove the progress sentinel
  			if ( fn === "inprogress" ) {
  				fn = queue.shift();
  				startLength--;
  			}

  			if ( fn ) {

  				// Add a progress sentinel to prevent the fx queue from being
  				// automatically dequeued
  				if ( type === "fx" ) {
  					queue.unshift( "inprogress" );
  				}

  				// Clear up the last queue stop function
  				delete hooks.stop;
  				fn.call( elem, next, hooks );
  			}

  			if ( !startLength && hooks ) {
  				hooks.empty.fire();
  			}
  		},

  		// Not public - generate a queueHooks object, or return the current one
  		_queueHooks: function( elem, type ) {
  			var key = type + "queueHooks";
  			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
  				empty: jQuery.Callbacks( "once memory" ).add( function() {
  					dataPriv.remove( elem, [ type + "queue", key ] );
  				} )
  			} );
  		}
  	} );

  	jQuery.fn.extend( {
  		queue: function( type, data ) {
  			var setter = 2;

  			if ( typeof type !== "string" ) {
  				data = type;
  				type = "fx";
  				setter--;
  			}

  			if ( arguments.length < setter ) {
  				return jQuery.queue( this[ 0 ], type );
  			}

  			return data === undefined ?
  				this :
  				this.each( function() {
  					var queue = jQuery.queue( this, type, data );

  					// Ensure a hooks for this queue
  					jQuery._queueHooks( this, type );

  					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
  						jQuery.dequeue( this, type );
  					}
  				} );
  		},
  		dequeue: function( type ) {
  			return this.each( function() {
  				jQuery.dequeue( this, type );
  			} );
  		},
  		clearQueue: function( type ) {
  			return this.queue( type || "fx", [] );
  		},

  		// Get a promise resolved when queues of a certain type
  		// are emptied (fx is the type by default)
  		promise: function( type, obj ) {
  			var tmp,
  				count = 1,
  				defer = jQuery.Deferred(),
  				elements = this,
  				i = this.length,
  				resolve = function() {
  					if ( !( --count ) ) {
  						defer.resolveWith( elements, [ elements ] );
  					}
  				};

  			if ( typeof type !== "string" ) {
  				obj = type;
  				type = undefined;
  			}
  			type = type || "fx";

  			while ( i-- ) {
  				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
  				if ( tmp && tmp.empty ) {
  					count++;
  					tmp.empty.add( resolve );
  				}
  			}
  			resolve();
  			return defer.promise( obj );
  		}
  	} );
  	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

  	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


  	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

  	var documentElement = document.documentElement;



  		var isAttached = function( elem ) {
  				return jQuery.contains( elem.ownerDocument, elem );
  			},
  			composed = { composed: true };

  		// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  		// Check attachment across shadow DOM boundaries when possible (gh-3504)
  		// Support: iOS 10.0-10.2 only
  		// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  		// leading to errors. We need to check for `getRootNode`.
  		if ( documentElement.getRootNode ) {
  			isAttached = function( elem ) {
  				return jQuery.contains( elem.ownerDocument, elem ) ||
  					elem.getRootNode( composed ) === elem.ownerDocument;
  			};
  		}
  	var isHiddenWithinTree = function( elem, el ) {

  			// isHiddenWithinTree might be called from jQuery#filter function;
  			// in that case, element will be second argument
  			elem = el || elem;

  			// Inline style trumps all
  			return elem.style.display === "none" ||
  				elem.style.display === "" &&

  				// Otherwise, check computed style
  				// Support: Firefox <=43 - 45
  				// Disconnected elements can have computed display: none, so first confirm that elem is
  				// in the document.
  				isAttached( elem ) &&

  				jQuery.css( elem, "display" ) === "none";
  		};



  	function adjustCSS( elem, prop, valueParts, tween ) {
  		var adjusted, scale,
  			maxIterations = 20,
  			currentValue = tween ?
  				function() {
  					return tween.cur();
  				} :
  				function() {
  					return jQuery.css( elem, prop, "" );
  				},
  			initial = currentValue(),
  			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

  			// Starting value computation is required for potential unit mismatches
  			initialInUnit = elem.nodeType &&
  				( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
  				rcssNum.exec( jQuery.css( elem, prop ) );

  		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

  			// Support: Firefox <=54
  			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
  			initial = initial / 2;

  			// Trust units reported by jQuery.css
  			unit = unit || initialInUnit[ 3 ];

  			// Iteratively approximate from a nonzero starting point
  			initialInUnit = +initial || 1;

  			while ( maxIterations-- ) {

  				// Evaluate and update our best guess (doubling guesses that zero out).
  				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
  				jQuery.style( elem, prop, initialInUnit + unit );
  				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
  					maxIterations = 0;
  				}
  				initialInUnit = initialInUnit / scale;

  			}

  			initialInUnit = initialInUnit * 2;
  			jQuery.style( elem, prop, initialInUnit + unit );

  			// Make sure we update the tween properties later on
  			valueParts = valueParts || [];
  		}

  		if ( valueParts ) {
  			initialInUnit = +initialInUnit || +initial || 0;

  			// Apply relative offset (+=/-=) if specified
  			adjusted = valueParts[ 1 ] ?
  				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
  				+valueParts[ 2 ];
  			if ( tween ) {
  				tween.unit = unit;
  				tween.start = initialInUnit;
  				tween.end = adjusted;
  			}
  		}
  		return adjusted;
  	}


  	var defaultDisplayMap = {};

  	function getDefaultDisplay( elem ) {
  		var temp,
  			doc = elem.ownerDocument,
  			nodeName = elem.nodeName,
  			display = defaultDisplayMap[ nodeName ];

  		if ( display ) {
  			return display;
  		}

  		temp = doc.body.appendChild( doc.createElement( nodeName ) );
  		display = jQuery.css( temp, "display" );

  		temp.parentNode.removeChild( temp );

  		if ( display === "none" ) {
  			display = "block";
  		}
  		defaultDisplayMap[ nodeName ] = display;

  		return display;
  	}

  	function showHide( elements, show ) {
  		var display, elem,
  			values = [],
  			index = 0,
  			length = elements.length;

  		// Determine new display value for elements that need to change
  		for ( ; index < length; index++ ) {
  			elem = elements[ index ];
  			if ( !elem.style ) {
  				continue;
  			}

  			display = elem.style.display;
  			if ( show ) {

  				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
  				// check is required in this first loop unless we have a nonempty display value (either
  				// inline or about-to-be-restored)
  				if ( display === "none" ) {
  					values[ index ] = dataPriv.get( elem, "display" ) || null;
  					if ( !values[ index ] ) {
  						elem.style.display = "";
  					}
  				}
  				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
  					values[ index ] = getDefaultDisplay( elem );
  				}
  			} else {
  				if ( display !== "none" ) {
  					values[ index ] = "none";

  					// Remember what we're overwriting
  					dataPriv.set( elem, "display", display );
  				}
  			}
  		}

  		// Set the display of the elements in a second loop to avoid constant reflow
  		for ( index = 0; index < length; index++ ) {
  			if ( values[ index ] != null ) {
  				elements[ index ].style.display = values[ index ];
  			}
  		}

  		return elements;
  	}

  	jQuery.fn.extend( {
  		show: function() {
  			return showHide( this, true );
  		},
  		hide: function() {
  			return showHide( this );
  		},
  		toggle: function( state ) {
  			if ( typeof state === "boolean" ) {
  				return state ? this.show() : this.hide();
  			}

  			return this.each( function() {
  				if ( isHiddenWithinTree( this ) ) {
  					jQuery( this ).show();
  				} else {
  					jQuery( this ).hide();
  				}
  			} );
  		}
  	} );
  	var rcheckableType = ( /^(?:checkbox|radio)$/i );

  	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

  	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



  	( function() {
  		var fragment = document.createDocumentFragment(),
  			div = fragment.appendChild( document.createElement( "div" ) ),
  			input = document.createElement( "input" );

  		// Support: Android 4.0 - 4.3 only
  		// Check state lost if the name is set (trac-11217)
  		// Support: Windows Web Apps (WWA)
  		// `name` and `type` must use .setAttribute for WWA (trac-14901)
  		input.setAttribute( "type", "radio" );
  		input.setAttribute( "checked", "checked" );
  		input.setAttribute( "name", "t" );

  		div.appendChild( input );

  		// Support: Android <=4.1 only
  		// Older WebKit doesn't clone checked state correctly in fragments
  		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

  		// Support: IE <=11 only
  		// Make sure textarea (and checkbox) defaultValue is properly cloned
  		div.innerHTML = "<textarea>x</textarea>";
  		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

  		// Support: IE <=9 only
  		// IE <=9 replaces <option> tags with their contents when inserted outside of
  		// the select element.
  		div.innerHTML = "<option></option>";
  		support.option = !!div.lastChild;
  	} )();


  	// We have to close these tags to support XHTML (trac-13200)
  	var wrapMap = {

  		// XHTML parsers do not magically insert elements in the
  		// same way that tag soup parsers do. So we cannot shorten
  		// this by omitting <tbody> or other required elements.
  		thead: [ 1, "<table>", "</table>" ],
  		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
  		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
  		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

  		_default: [ 0, "", "" ]
  	};

  	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  	wrapMap.th = wrapMap.td;

  	// Support: IE <=9 only
  	if ( !support.option ) {
  		wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
  	}


  	function getAll( context, tag ) {

  		// Support: IE <=9 - 11 only
  		// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
  		var ret;

  		if ( typeof context.getElementsByTagName !== "undefined" ) {
  			ret = context.getElementsByTagName( tag || "*" );

  		} else if ( typeof context.querySelectorAll !== "undefined" ) {
  			ret = context.querySelectorAll( tag || "*" );

  		} else {
  			ret = [];
  		}

  		if ( tag === undefined || tag && nodeName( context, tag ) ) {
  			return jQuery.merge( [ context ], ret );
  		}

  		return ret;
  	}


  	// Mark scripts as having already been evaluated
  	function setGlobalEval( elems, refElements ) {
  		var i = 0,
  			l = elems.length;

  		for ( ; i < l; i++ ) {
  			dataPriv.set(
  				elems[ i ],
  				"globalEval",
  				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
  			);
  		}
  	}


  	var rhtml = /<|&#?\w+;/;

  	function buildFragment( elems, context, scripts, selection, ignored ) {
  		var elem, tmp, tag, wrap, attached, j,
  			fragment = context.createDocumentFragment(),
  			nodes = [],
  			i = 0,
  			l = elems.length;

  		for ( ; i < l; i++ ) {
  			elem = elems[ i ];

  			if ( elem || elem === 0 ) {

  				// Add nodes directly
  				if ( toType( elem ) === "object" ) {

  					// Support: Android <=4.0 only, PhantomJS 1 only
  					// push.apply(_, arraylike) throws on ancient WebKit
  					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

  				// Convert non-html into a text node
  				} else if ( !rhtml.test( elem ) ) {
  					nodes.push( context.createTextNode( elem ) );

  				// Convert html into DOM nodes
  				} else {
  					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

  					// Deserialize a standard representation
  					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
  					wrap = wrapMap[ tag ] || wrapMap._default;
  					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

  					// Descend through wrappers to the right content
  					j = wrap[ 0 ];
  					while ( j-- ) {
  						tmp = tmp.lastChild;
  					}

  					// Support: Android <=4.0 only, PhantomJS 1 only
  					// push.apply(_, arraylike) throws on ancient WebKit
  					jQuery.merge( nodes, tmp.childNodes );

  					// Remember the top-level container
  					tmp = fragment.firstChild;

  					// Ensure the created nodes are orphaned (trac-12392)
  					tmp.textContent = "";
  				}
  			}
  		}

  		// Remove wrapper from fragment
  		fragment.textContent = "";

  		i = 0;
  		while ( ( elem = nodes[ i++ ] ) ) {

  			// Skip elements already in the context collection (trac-4087)
  			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
  				if ( ignored ) {
  					ignored.push( elem );
  				}
  				continue;
  			}

  			attached = isAttached( elem );

  			// Append to fragment
  			tmp = getAll( fragment.appendChild( elem ), "script" );

  			// Preserve script evaluation history
  			if ( attached ) {
  				setGlobalEval( tmp );
  			}

  			// Capture executables
  			if ( scripts ) {
  				j = 0;
  				while ( ( elem = tmp[ j++ ] ) ) {
  					if ( rscriptType.test( elem.type || "" ) ) {
  						scripts.push( elem );
  					}
  				}
  			}
  		}

  		return fragment;
  	}


  	var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  	function returnTrue() {
  		return true;
  	}

  	function returnFalse() {
  		return false;
  	}

  	function on( elem, types, selector, data, fn, one ) {
  		var origFn, type;

  		// Types can be a map of types/handlers
  		if ( typeof types === "object" ) {

  			// ( types-Object, selector, data )
  			if ( typeof selector !== "string" ) {

  				// ( types-Object, data )
  				data = data || selector;
  				selector = undefined;
  			}
  			for ( type in types ) {
  				on( elem, type, selector, data, types[ type ], one );
  			}
  			return elem;
  		}

  		if ( data == null && fn == null ) {

  			// ( types, fn )
  			fn = selector;
  			data = selector = undefined;
  		} else if ( fn == null ) {
  			if ( typeof selector === "string" ) {

  				// ( types, selector, fn )
  				fn = data;
  				data = undefined;
  			} else {

  				// ( types, data, fn )
  				fn = data;
  				data = selector;
  				selector = undefined;
  			}
  		}
  		if ( fn === false ) {
  			fn = returnFalse;
  		} else if ( !fn ) {
  			return elem;
  		}

  		if ( one === 1 ) {
  			origFn = fn;
  			fn = function( event ) {

  				// Can use an empty set, since event contains the info
  				jQuery().off( event );
  				return origFn.apply( this, arguments );
  			};

  			// Use same guid so caller can remove using origFn
  			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
  		}
  		return elem.each( function() {
  			jQuery.event.add( this, types, fn, data, selector );
  		} );
  	}

  	/*
  	 * Helper functions for managing events -- not part of the public interface.
  	 * Props to Dean Edwards' addEvent library for many of the ideas.
  	 */
  	jQuery.event = {

  		global: {},

  		add: function( elem, types, handler, data, selector ) {

  			var handleObjIn, eventHandle, tmp,
  				events, t, handleObj,
  				special, handlers, type, namespaces, origType,
  				elemData = dataPriv.get( elem );

  			// Only attach events to objects that accept data
  			if ( !acceptData( elem ) ) {
  				return;
  			}

  			// Caller can pass in an object of custom data in lieu of the handler
  			if ( handler.handler ) {
  				handleObjIn = handler;
  				handler = handleObjIn.handler;
  				selector = handleObjIn.selector;
  			}

  			// Ensure that invalid selectors throw exceptions at attach time
  			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
  			if ( selector ) {
  				jQuery.find.matchesSelector( documentElement, selector );
  			}

  			// Make sure that the handler has a unique ID, used to find/remove it later
  			if ( !handler.guid ) {
  				handler.guid = jQuery.guid++;
  			}

  			// Init the element's event structure and main handler, if this is the first
  			if ( !( events = elemData.events ) ) {
  				events = elemData.events = Object.create( null );
  			}
  			if ( !( eventHandle = elemData.handle ) ) {
  				eventHandle = elemData.handle = function( e ) {

  					// Discard the second event of a jQuery.event.trigger() and
  					// when an event is called after a page has unloaded
  					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
  						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
  				};
  			}

  			// Handle multiple events separated by a space
  			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  			t = types.length;
  			while ( t-- ) {
  				tmp = rtypenamespace.exec( types[ t ] ) || [];
  				type = origType = tmp[ 1 ];
  				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  				// There *must* be a type, no attaching namespace-only handlers
  				if ( !type ) {
  					continue;
  				}

  				// If event changes its type, use the special event handlers for the changed type
  				special = jQuery.event.special[ type ] || {};

  				// If selector defined, determine special event api type, otherwise given type
  				type = ( selector ? special.delegateType : special.bindType ) || type;

  				// Update special based on newly reset type
  				special = jQuery.event.special[ type ] || {};

  				// handleObj is passed to all event handlers
  				handleObj = jQuery.extend( {
  					type: type,
  					origType: origType,
  					data: data,
  					handler: handler,
  					guid: handler.guid,
  					selector: selector,
  					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
  					namespace: namespaces.join( "." )
  				}, handleObjIn );

  				// Init the event handler queue if we're the first
  				if ( !( handlers = events[ type ] ) ) {
  					handlers = events[ type ] = [];
  					handlers.delegateCount = 0;

  					// Only use addEventListener if the special events handler returns false
  					if ( !special.setup ||
  						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

  						if ( elem.addEventListener ) {
  							elem.addEventListener( type, eventHandle );
  						}
  					}
  				}

  				if ( special.add ) {
  					special.add.call( elem, handleObj );

  					if ( !handleObj.handler.guid ) {
  						handleObj.handler.guid = handler.guid;
  					}
  				}

  				// Add to the element's handler list, delegates in front
  				if ( selector ) {
  					handlers.splice( handlers.delegateCount++, 0, handleObj );
  				} else {
  					handlers.push( handleObj );
  				}

  				// Keep track of which events have ever been used, for event optimization
  				jQuery.event.global[ type ] = true;
  			}

  		},

  		// Detach an event or set of events from an element
  		remove: function( elem, types, handler, selector, mappedTypes ) {

  			var j, origCount, tmp,
  				events, t, handleObj,
  				special, handlers, type, namespaces, origType,
  				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

  			if ( !elemData || !( events = elemData.events ) ) {
  				return;
  			}

  			// Once for each type.namespace in types; type may be omitted
  			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  			t = types.length;
  			while ( t-- ) {
  				tmp = rtypenamespace.exec( types[ t ] ) || [];
  				type = origType = tmp[ 1 ];
  				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  				// Unbind all events (on this namespace, if provided) for the element
  				if ( !type ) {
  					for ( type in events ) {
  						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
  					}
  					continue;
  				}

  				special = jQuery.event.special[ type ] || {};
  				type = ( selector ? special.delegateType : special.bindType ) || type;
  				handlers = events[ type ] || [];
  				tmp = tmp[ 2 ] &&
  					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

  				// Remove matching events
  				origCount = j = handlers.length;
  				while ( j-- ) {
  					handleObj = handlers[ j ];

  					if ( ( mappedTypes || origType === handleObj.origType ) &&
  						( !handler || handler.guid === handleObj.guid ) &&
  						( !tmp || tmp.test( handleObj.namespace ) ) &&
  						( !selector || selector === handleObj.selector ||
  							selector === "**" && handleObj.selector ) ) {
  						handlers.splice( j, 1 );

  						if ( handleObj.selector ) {
  							handlers.delegateCount--;
  						}
  						if ( special.remove ) {
  							special.remove.call( elem, handleObj );
  						}
  					}
  				}

  				// Remove generic event handler if we removed something and no more handlers exist
  				// (avoids potential for endless recursion during removal of special event handlers)
  				if ( origCount && !handlers.length ) {
  					if ( !special.teardown ||
  						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

  						jQuery.removeEvent( elem, type, elemData.handle );
  					}

  					delete events[ type ];
  				}
  			}

  			// Remove data and the expando if it's no longer used
  			if ( jQuery.isEmptyObject( events ) ) {
  				dataPriv.remove( elem, "handle events" );
  			}
  		},

  		dispatch: function( nativeEvent ) {

  			var i, j, ret, matched, handleObj, handlerQueue,
  				args = new Array( arguments.length ),

  				// Make a writable jQuery.Event from the native event object
  				event = jQuery.event.fix( nativeEvent ),

  				handlers = (
  					dataPriv.get( this, "events" ) || Object.create( null )
  				)[ event.type ] || [],
  				special = jQuery.event.special[ event.type ] || {};

  			// Use the fix-ed jQuery.Event rather than the (read-only) native event
  			args[ 0 ] = event;

  			for ( i = 1; i < arguments.length; i++ ) {
  				args[ i ] = arguments[ i ];
  			}

  			event.delegateTarget = this;

  			// Call the preDispatch hook for the mapped type, and let it bail if desired
  			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
  				return;
  			}

  			// Determine handlers
  			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

  			// Run delegates first; they may want to stop propagation beneath us
  			i = 0;
  			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
  				event.currentTarget = matched.elem;

  				j = 0;
  				while ( ( handleObj = matched.handlers[ j++ ] ) &&
  					!event.isImmediatePropagationStopped() ) {

  					// If the event is namespaced, then each handler is only invoked if it is
  					// specially universal or its namespaces are a superset of the event's.
  					if ( !event.rnamespace || handleObj.namespace === false ||
  						event.rnamespace.test( handleObj.namespace ) ) {

  						event.handleObj = handleObj;
  						event.data = handleObj.data;

  						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
  							handleObj.handler ).apply( matched.elem, args );

  						if ( ret !== undefined ) {
  							if ( ( event.result = ret ) === false ) {
  								event.preventDefault();
  								event.stopPropagation();
  							}
  						}
  					}
  				}
  			}

  			// Call the postDispatch hook for the mapped type
  			if ( special.postDispatch ) {
  				special.postDispatch.call( this, event );
  			}

  			return event.result;
  		},

  		handlers: function( event, handlers ) {
  			var i, handleObj, sel, matchedHandlers, matchedSelectors,
  				handlerQueue = [],
  				delegateCount = handlers.delegateCount,
  				cur = event.target;

  			// Find delegate handlers
  			if ( delegateCount &&

  				// Support: IE <=9
  				// Black-hole SVG <use> instance trees (trac-13180)
  				cur.nodeType &&

  				// Support: Firefox <=42
  				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
  				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
  				// Support: IE 11 only
  				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
  				!( event.type === "click" && event.button >= 1 ) ) {

  				for ( ; cur !== this; cur = cur.parentNode || this ) {

  					// Don't check non-elements (trac-13208)
  					// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
  					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
  						matchedHandlers = [];
  						matchedSelectors = {};
  						for ( i = 0; i < delegateCount; i++ ) {
  							handleObj = handlers[ i ];

  							// Don't conflict with Object.prototype properties (trac-13203)
  							sel = handleObj.selector + " ";

  							if ( matchedSelectors[ sel ] === undefined ) {
  								matchedSelectors[ sel ] = handleObj.needsContext ?
  									jQuery( sel, this ).index( cur ) > -1 :
  									jQuery.find( sel, this, null, [ cur ] ).length;
  							}
  							if ( matchedSelectors[ sel ] ) {
  								matchedHandlers.push( handleObj );
  							}
  						}
  						if ( matchedHandlers.length ) {
  							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
  						}
  					}
  				}
  			}

  			// Add the remaining (directly-bound) handlers
  			cur = this;
  			if ( delegateCount < handlers.length ) {
  				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
  			}

  			return handlerQueue;
  		},

  		addProp: function( name, hook ) {
  			Object.defineProperty( jQuery.Event.prototype, name, {
  				enumerable: true,
  				configurable: true,

  				get: isFunction( hook ) ?
  					function() {
  						if ( this.originalEvent ) {
  							return hook( this.originalEvent );
  						}
  					} :
  					function() {
  						if ( this.originalEvent ) {
  							return this.originalEvent[ name ];
  						}
  					},

  				set: function( value ) {
  					Object.defineProperty( this, name, {
  						enumerable: true,
  						configurable: true,
  						writable: true,
  						value: value
  					} );
  				}
  			} );
  		},

  		fix: function( originalEvent ) {
  			return originalEvent[ jQuery.expando ] ?
  				originalEvent :
  				new jQuery.Event( originalEvent );
  		},

  		special: {
  			load: {

  				// Prevent triggered image.load events from bubbling to window.load
  				noBubble: true
  			},
  			click: {

  				// Utilize native event to ensure correct state for checkable inputs
  				setup: function( data ) {

  					// For mutual compressibility with _default, replace `this` access with a local var.
  					// `|| data` is dead code meant only to preserve the variable through minification.
  					var el = this || data;

  					// Claim the first handler
  					if ( rcheckableType.test( el.type ) &&
  						el.click && nodeName( el, "input" ) ) {

  						// dataPriv.set( el, "click", ... )
  						leverageNative( el, "click", true );
  					}

  					// Return false to allow normal processing in the caller
  					return false;
  				},
  				trigger: function( data ) {

  					// For mutual compressibility with _default, replace `this` access with a local var.
  					// `|| data` is dead code meant only to preserve the variable through minification.
  					var el = this || data;

  					// Force setup before triggering a click
  					if ( rcheckableType.test( el.type ) &&
  						el.click && nodeName( el, "input" ) ) {

  						leverageNative( el, "click" );
  					}

  					// Return non-false to allow normal event-path propagation
  					return true;
  				},

  				// For cross-browser consistency, suppress native .click() on links
  				// Also prevent it if we're currently inside a leveraged native-event stack
  				_default: function( event ) {
  					var target = event.target;
  					return rcheckableType.test( target.type ) &&
  						target.click && nodeName( target, "input" ) &&
  						dataPriv.get( target, "click" ) ||
  						nodeName( target, "a" );
  				}
  			},

  			beforeunload: {
  				postDispatch: function( event ) {

  					// Support: Firefox 20+
  					// Firefox doesn't alert if the returnValue field is not set.
  					if ( event.result !== undefined && event.originalEvent ) {
  						event.originalEvent.returnValue = event.result;
  					}
  				}
  			}
  		}
  	};

  	// Ensure the presence of an event listener that handles manually-triggered
  	// synthetic events by interrupting progress until reinvoked in response to
  	// *native* events that it fires directly, ensuring that state changes have
  	// already occurred before other listeners are invoked.
  	function leverageNative( el, type, isSetup ) {

  		// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
  		if ( !isSetup ) {
  			if ( dataPriv.get( el, type ) === undefined ) {
  				jQuery.event.add( el, type, returnTrue );
  			}
  			return;
  		}

  		// Register the controller as a special universal handler for all event namespaces
  		dataPriv.set( el, type, false );
  		jQuery.event.add( el, type, {
  			namespace: false,
  			handler: function( event ) {
  				var result,
  					saved = dataPriv.get( this, type );

  				if ( ( event.isTrigger & 1 ) && this[ type ] ) {

  					// Interrupt processing of the outer synthetic .trigger()ed event
  					if ( !saved ) {

  						// Store arguments for use when handling the inner native event
  						// There will always be at least one argument (an event object), so this array
  						// will not be confused with a leftover capture object.
  						saved = slice.call( arguments );
  						dataPriv.set( this, type, saved );

  						// Trigger the native event and capture its result
  						this[ type ]();
  						result = dataPriv.get( this, type );
  						dataPriv.set( this, type, false );

  						if ( saved !== result ) {

  							// Cancel the outer synthetic event
  							event.stopImmediatePropagation();
  							event.preventDefault();

  							return result;
  						}

  					// If this is an inner synthetic event for an event with a bubbling surrogate
  					// (focus or blur), assume that the surrogate already propagated from triggering
  					// the native event and prevent that from happening again here.
  					// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
  					// bubbling surrogate propagates *after* the non-bubbling base), but that seems
  					// less bad than duplication.
  					} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
  						event.stopPropagation();
  					}

  				// If this is a native event triggered above, everything is now in order
  				// Fire an inner synthetic event with the original arguments
  				} else if ( saved ) {

  					// ...and capture the result
  					dataPriv.set( this, type, jQuery.event.trigger(
  						saved[ 0 ],
  						saved.slice( 1 ),
  						this
  					) );

  					// Abort handling of the native event by all jQuery handlers while allowing
  					// native handlers on the same element to run. On target, this is achieved
  					// by stopping immediate propagation just on the jQuery event. However,
  					// the native event is re-wrapped by a jQuery one on each level of the
  					// propagation so the only way to stop it for jQuery is to stop it for
  					// everyone via native `stopPropagation()`. This is not a problem for
  					// focus/blur which don't bubble, but it does also stop click on checkboxes
  					// and radios. We accept this limitation.
  					event.stopPropagation();
  					event.isImmediatePropagationStopped = returnTrue;
  				}
  			}
  		} );
  	}

  	jQuery.removeEvent = function( elem, type, handle ) {

  		// This "if" is needed for plain objects
  		if ( elem.removeEventListener ) {
  			elem.removeEventListener( type, handle );
  		}
  	};

  	jQuery.Event = function( src, props ) {

  		// Allow instantiation without the 'new' keyword
  		if ( !( this instanceof jQuery.Event ) ) {
  			return new jQuery.Event( src, props );
  		}

  		// Event object
  		if ( src && src.type ) {
  			this.originalEvent = src;
  			this.type = src.type;

  			// Events bubbling up the document may have been marked as prevented
  			// by a handler lower down the tree; reflect the correct value.
  			this.isDefaultPrevented = src.defaultPrevented ||
  					src.defaultPrevented === undefined &&

  					// Support: Android <=2.3 only
  					src.returnValue === false ?
  				returnTrue :
  				returnFalse;

  			// Create target properties
  			// Support: Safari <=6 - 7 only
  			// Target should not be a text node (trac-504, trac-13143)
  			this.target = ( src.target && src.target.nodeType === 3 ) ?
  				src.target.parentNode :
  				src.target;

  			this.currentTarget = src.currentTarget;
  			this.relatedTarget = src.relatedTarget;

  		// Event type
  		} else {
  			this.type = src;
  		}

  		// Put explicitly provided properties onto the event object
  		if ( props ) {
  			jQuery.extend( this, props );
  		}

  		// Create a timestamp if incoming event doesn't have one
  		this.timeStamp = src && src.timeStamp || Date.now();

  		// Mark it as fixed
  		this[ jQuery.expando ] = true;
  	};

  	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  	jQuery.Event.prototype = {
  		constructor: jQuery.Event,
  		isDefaultPrevented: returnFalse,
  		isPropagationStopped: returnFalse,
  		isImmediatePropagationStopped: returnFalse,
  		isSimulated: false,

  		preventDefault: function() {
  			var e = this.originalEvent;

  			this.isDefaultPrevented = returnTrue;

  			if ( e && !this.isSimulated ) {
  				e.preventDefault();
  			}
  		},
  		stopPropagation: function() {
  			var e = this.originalEvent;

  			this.isPropagationStopped = returnTrue;

  			if ( e && !this.isSimulated ) {
  				e.stopPropagation();
  			}
  		},
  		stopImmediatePropagation: function() {
  			var e = this.originalEvent;

  			this.isImmediatePropagationStopped = returnTrue;

  			if ( e && !this.isSimulated ) {
  				e.stopImmediatePropagation();
  			}

  			this.stopPropagation();
  		}
  	};

  	// Includes all common event props including KeyEvent and MouseEvent specific props
  	jQuery.each( {
  		altKey: true,
  		bubbles: true,
  		cancelable: true,
  		changedTouches: true,
  		ctrlKey: true,
  		detail: true,
  		eventPhase: true,
  		metaKey: true,
  		pageX: true,
  		pageY: true,
  		shiftKey: true,
  		view: true,
  		"char": true,
  		code: true,
  		charCode: true,
  		key: true,
  		keyCode: true,
  		button: true,
  		buttons: true,
  		clientX: true,
  		clientY: true,
  		offsetX: true,
  		offsetY: true,
  		pointerId: true,
  		pointerType: true,
  		screenX: true,
  		screenY: true,
  		targetTouches: true,
  		toElement: true,
  		touches: true,
  		which: true
  	}, jQuery.event.addProp );

  	jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

  		function focusMappedHandler( nativeEvent ) {
  			if ( document.documentMode ) {

  				// Support: IE 11+
  				// Attach a single focusin/focusout handler on the document while someone wants
  				// focus/blur. This is because the former are synchronous in IE while the latter
  				// are async. In other browsers, all those handlers are invoked synchronously.

  				// `handle` from private data would already wrap the event, but we need
  				// to change the `type` here.
  				var handle = dataPriv.get( this, "handle" ),
  					event = jQuery.event.fix( nativeEvent );
  				event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
  				event.isSimulated = true;

  				// First, handle focusin/focusout
  				handle( nativeEvent );

  				// ...then, handle focus/blur
  				//
  				// focus/blur don't bubble while focusin/focusout do; simulate the former by only
  				// invoking the handler at the lower level.
  				if ( event.target === event.currentTarget ) {

  					// The setup part calls `leverageNative`, which, in turn, calls
  					// `jQuery.event.add`, so event handle will already have been set
  					// by this point.
  					handle( event );
  				}
  			} else {

  				// For non-IE browsers, attach a single capturing handler on the document
  				// while someone wants focusin/focusout.
  				jQuery.event.simulate( delegateType, nativeEvent.target,
  					jQuery.event.fix( nativeEvent ) );
  			}
  		}

  		jQuery.event.special[ type ] = {

  			// Utilize native event if possible so blur/focus sequence is correct
  			setup: function() {

  				var attaches;

  				// Claim the first handler
  				// dataPriv.set( this, "focus", ... )
  				// dataPriv.set( this, "blur", ... )
  				leverageNative( this, type, true );

  				if ( document.documentMode ) {

  					// Support: IE 9 - 11+
  					// We use the same native handler for focusin & focus (and focusout & blur)
  					// so we need to coordinate setup & teardown parts between those events.
  					// Use `delegateType` as the key as `type` is already used by `leverageNative`.
  					attaches = dataPriv.get( this, delegateType );
  					if ( !attaches ) {
  						this.addEventListener( delegateType, focusMappedHandler );
  					}
  					dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
  				} else {

  					// Return false to allow normal processing in the caller
  					return false;
  				}
  			},
  			trigger: function() {

  				// Force setup before trigger
  				leverageNative( this, type );

  				// Return non-false to allow normal event-path propagation
  				return true;
  			},

  			teardown: function() {
  				var attaches;

  				if ( document.documentMode ) {
  					attaches = dataPriv.get( this, delegateType ) - 1;
  					if ( !attaches ) {
  						this.removeEventListener( delegateType, focusMappedHandler );
  						dataPriv.remove( this, delegateType );
  					} else {
  						dataPriv.set( this, delegateType, attaches );
  					}
  				} else {

  					// Return false to indicate standard teardown should be applied
  					return false;
  				}
  			},

  			// Suppress native focus or blur if we're currently inside
  			// a leveraged native-event stack
  			_default: function( event ) {
  				return dataPriv.get( event.target, type );
  			},

  			delegateType: delegateType
  		};

  		// Support: Firefox <=44
  		// Firefox doesn't have focus(in | out) events
  		// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  		//
  		// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  		// focus(in | out) events fire after focus & blur events,
  		// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  		// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
  		//
  		// Support: IE 9 - 11+
  		// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
  		// attach a single handler for both events in IE.
  		jQuery.event.special[ delegateType ] = {
  			setup: function() {

  				// Handle: regular nodes (via `this.ownerDocument`), window
  				// (via `this.document`) & document (via `this`).
  				var doc = this.ownerDocument || this.document || this,
  					dataHolder = document.documentMode ? this : doc,
  					attaches = dataPriv.get( dataHolder, delegateType );

  				// Support: IE 9 - 11+
  				// We use the same native handler for focusin & focus (and focusout & blur)
  				// so we need to coordinate setup & teardown parts between those events.
  				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
  				if ( !attaches ) {
  					if ( document.documentMode ) {
  						this.addEventListener( delegateType, focusMappedHandler );
  					} else {
  						doc.addEventListener( type, focusMappedHandler, true );
  					}
  				}
  				dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
  			},
  			teardown: function() {
  				var doc = this.ownerDocument || this.document || this,
  					dataHolder = document.documentMode ? this : doc,
  					attaches = dataPriv.get( dataHolder, delegateType ) - 1;

  				if ( !attaches ) {
  					if ( document.documentMode ) {
  						this.removeEventListener( delegateType, focusMappedHandler );
  					} else {
  						doc.removeEventListener( type, focusMappedHandler, true );
  					}
  					dataPriv.remove( dataHolder, delegateType );
  				} else {
  					dataPriv.set( dataHolder, delegateType, attaches );
  				}
  			}
  		};
  	} );

  	// Create mouseenter/leave events using mouseover/out and event-time checks
  	// so that event delegation works in jQuery.
  	// Do the same for pointerenter/pointerleave and pointerover/pointerout
  	//
  	// Support: Safari 7 only
  	// Safari sends mouseenter too often; see:
  	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  	// for the description of the bug (it existed in older Chrome versions as well).
  	jQuery.each( {
  		mouseenter: "mouseover",
  		mouseleave: "mouseout",
  		pointerenter: "pointerover",
  		pointerleave: "pointerout"
  	}, function( orig, fix ) {
  		jQuery.event.special[ orig ] = {
  			delegateType: fix,
  			bindType: fix,

  			handle: function( event ) {
  				var ret,
  					target = this,
  					related = event.relatedTarget,
  					handleObj = event.handleObj;

  				// For mouseenter/leave call the handler if related is outside the target.
  				// NB: No relatedTarget if the mouse left/entered the browser window
  				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
  					event.type = handleObj.origType;
  					ret = handleObj.handler.apply( this, arguments );
  					event.type = fix;
  				}
  				return ret;
  			}
  		};
  	} );

  	jQuery.fn.extend( {

  		on: function( types, selector, data, fn ) {
  			return on( this, types, selector, data, fn );
  		},
  		one: function( types, selector, data, fn ) {
  			return on( this, types, selector, data, fn, 1 );
  		},
  		off: function( types, selector, fn ) {
  			var handleObj, type;
  			if ( types && types.preventDefault && types.handleObj ) {

  				// ( event )  dispatched jQuery.Event
  				handleObj = types.handleObj;
  				jQuery( types.delegateTarget ).off(
  					handleObj.namespace ?
  						handleObj.origType + "." + handleObj.namespace :
  						handleObj.origType,
  					handleObj.selector,
  					handleObj.handler
  				);
  				return this;
  			}
  			if ( typeof types === "object" ) {

  				// ( types-object [, selector] )
  				for ( type in types ) {
  					this.off( type, selector, types[ type ] );
  				}
  				return this;
  			}
  			if ( selector === false || typeof selector === "function" ) {

  				// ( types [, fn] )
  				fn = selector;
  				selector = undefined;
  			}
  			if ( fn === false ) {
  				fn = returnFalse;
  			}
  			return this.each( function() {
  				jQuery.event.remove( this, types, fn, selector );
  			} );
  		}
  	} );


  	var

  		// Support: IE <=10 - 11, Edge 12 - 13 only
  		// In IE/Edge using regex groups here causes severe slowdowns.
  		// See https://connect.microsoft.com/IE/feedback/details/1736512/
  		rnoInnerhtml = /<script|<style|<link/i,

  		// checked="checked" or checked
  		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

  		rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

  	// Prefer a tbody over its parent table for containing new rows
  	function manipulationTarget( elem, content ) {
  		if ( nodeName( elem, "table" ) &&
  			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

  			return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
  		}

  		return elem;
  	}

  	// Replace/restore the type attribute of script elements for safe DOM manipulation
  	function disableScript( elem ) {
  		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
  		return elem;
  	}
  	function restoreScript( elem ) {
  		if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
  			elem.type = elem.type.slice( 5 );
  		} else {
  			elem.removeAttribute( "type" );
  		}

  		return elem;
  	}

  	function cloneCopyEvent( src, dest ) {
  		var i, l, type, pdataOld, udataOld, udataCur, events;

  		if ( dest.nodeType !== 1 ) {
  			return;
  		}

  		// 1. Copy private data: events, handlers, etc.
  		if ( dataPriv.hasData( src ) ) {
  			pdataOld = dataPriv.get( src );
  			events = pdataOld.events;

  			if ( events ) {
  				dataPriv.remove( dest, "handle events" );

  				for ( type in events ) {
  					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
  						jQuery.event.add( dest, type, events[ type ][ i ] );
  					}
  				}
  			}
  		}

  		// 2. Copy user data
  		if ( dataUser.hasData( src ) ) {
  			udataOld = dataUser.access( src );
  			udataCur = jQuery.extend( {}, udataOld );

  			dataUser.set( dest, udataCur );
  		}
  	}

  	// Fix IE bugs, see support tests
  	function fixInput( src, dest ) {
  		var nodeName = dest.nodeName.toLowerCase();

  		// Fails to persist the checked state of a cloned checkbox or radio button.
  		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
  			dest.checked = src.checked;

  		// Fails to return the selected option to the default selected state when cloning options
  		} else if ( nodeName === "input" || nodeName === "textarea" ) {
  			dest.defaultValue = src.defaultValue;
  		}
  	}

  	function domManip( collection, args, callback, ignored ) {

  		// Flatten any nested arrays
  		args = flat( args );

  		var fragment, first, scripts, hasScripts, node, doc,
  			i = 0,
  			l = collection.length,
  			iNoClone = l - 1,
  			value = args[ 0 ],
  			valueIsFunction = isFunction( value );

  		// We can't cloneNode fragments that contain checked, in WebKit
  		if ( valueIsFunction ||
  				( l > 1 && typeof value === "string" &&
  					!support.checkClone && rchecked.test( value ) ) ) {
  			return collection.each( function( index ) {
  				var self = collection.eq( index );
  				if ( valueIsFunction ) {
  					args[ 0 ] = value.call( this, index, self.html() );
  				}
  				domManip( self, args, callback, ignored );
  			} );
  		}

  		if ( l ) {
  			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
  			first = fragment.firstChild;

  			if ( fragment.childNodes.length === 1 ) {
  				fragment = first;
  			}

  			// Require either new content or an interest in ignored elements to invoke the callback
  			if ( first || ignored ) {
  				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
  				hasScripts = scripts.length;

  				// Use the original fragment for the last item
  				// instead of the first because it can end up
  				// being emptied incorrectly in certain situations (trac-8070).
  				for ( ; i < l; i++ ) {
  					node = fragment;

  					if ( i !== iNoClone ) {
  						node = jQuery.clone( node, true, true );

  						// Keep references to cloned scripts for later restoration
  						if ( hasScripts ) {

  							// Support: Android <=4.0 only, PhantomJS 1 only
  							// push.apply(_, arraylike) throws on ancient WebKit
  							jQuery.merge( scripts, getAll( node, "script" ) );
  						}
  					}

  					callback.call( collection[ i ], node, i );
  				}

  				if ( hasScripts ) {
  					doc = scripts[ scripts.length - 1 ].ownerDocument;

  					// Re-enable scripts
  					jQuery.map( scripts, restoreScript );

  					// Evaluate executable scripts on first document insertion
  					for ( i = 0; i < hasScripts; i++ ) {
  						node = scripts[ i ];
  						if ( rscriptType.test( node.type || "" ) &&
  							!dataPriv.access( node, "globalEval" ) &&
  							jQuery.contains( doc, node ) ) {

  							if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

  								// Optional AJAX dependency, but won't run scripts if not present
  								if ( jQuery._evalUrl && !node.noModule ) {
  									jQuery._evalUrl( node.src, {
  										nonce: node.nonce || node.getAttribute( "nonce" )
  									}, doc );
  								}
  							} else {

  								// Unwrap a CDATA section containing script contents. This shouldn't be
  								// needed as in XML documents they're already not visible when
  								// inspecting element contents and in HTML documents they have no
  								// meaning but we're preserving that logic for backwards compatibility.
  								// This will be removed completely in 4.0. See gh-4904.
  								DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
  							}
  						}
  					}
  				}
  			}
  		}

  		return collection;
  	}

  	function remove( elem, selector, keepData ) {
  		var node,
  			nodes = selector ? jQuery.filter( selector, elem ) : elem,
  			i = 0;

  		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
  			if ( !keepData && node.nodeType === 1 ) {
  				jQuery.cleanData( getAll( node ) );
  			}

  			if ( node.parentNode ) {
  				if ( keepData && isAttached( node ) ) {
  					setGlobalEval( getAll( node, "script" ) );
  				}
  				node.parentNode.removeChild( node );
  			}
  		}

  		return elem;
  	}

  	jQuery.extend( {
  		htmlPrefilter: function( html ) {
  			return html;
  		},

  		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
  			var i, l, srcElements, destElements,
  				clone = elem.cloneNode( true ),
  				inPage = isAttached( elem );

  			// Fix IE cloning issues
  			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
  					!jQuery.isXMLDoc( elem ) ) {

  				// We eschew jQuery#find here for performance reasons:
  				// https://jsperf.com/getall-vs-sizzle/2
  				destElements = getAll( clone );
  				srcElements = getAll( elem );

  				for ( i = 0, l = srcElements.length; i < l; i++ ) {
  					fixInput( srcElements[ i ], destElements[ i ] );
  				}
  			}

  			// Copy the events from the original to the clone
  			if ( dataAndEvents ) {
  				if ( deepDataAndEvents ) {
  					srcElements = srcElements || getAll( elem );
  					destElements = destElements || getAll( clone );

  					for ( i = 0, l = srcElements.length; i < l; i++ ) {
  						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
  					}
  				} else {
  					cloneCopyEvent( elem, clone );
  				}
  			}

  			// Preserve script evaluation history
  			destElements = getAll( clone, "script" );
  			if ( destElements.length > 0 ) {
  				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
  			}

  			// Return the cloned set
  			return clone;
  		},

  		cleanData: function( elems ) {
  			var data, elem, type,
  				special = jQuery.event.special,
  				i = 0;

  			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
  				if ( acceptData( elem ) ) {
  					if ( ( data = elem[ dataPriv.expando ] ) ) {
  						if ( data.events ) {
  							for ( type in data.events ) {
  								if ( special[ type ] ) {
  									jQuery.event.remove( elem, type );

  								// This is a shortcut to avoid jQuery.event.remove's overhead
  								} else {
  									jQuery.removeEvent( elem, type, data.handle );
  								}
  							}
  						}

  						// Support: Chrome <=35 - 45+
  						// Assign undefined instead of using delete, see Data#remove
  						elem[ dataPriv.expando ] = undefined;
  					}
  					if ( elem[ dataUser.expando ] ) {

  						// Support: Chrome <=35 - 45+
  						// Assign undefined instead of using delete, see Data#remove
  						elem[ dataUser.expando ] = undefined;
  					}
  				}
  			}
  		}
  	} );

  	jQuery.fn.extend( {
  		detach: function( selector ) {
  			return remove( this, selector, true );
  		},

  		remove: function( selector ) {
  			return remove( this, selector );
  		},

  		text: function( value ) {
  			return access( this, function( value ) {
  				return value === undefined ?
  					jQuery.text( this ) :
  					this.empty().each( function() {
  						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  							this.textContent = value;
  						}
  					} );
  			}, null, value, arguments.length );
  		},

  		append: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  					var target = manipulationTarget( this, elem );
  					target.appendChild( elem );
  				}
  			} );
  		},

  		prepend: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  					var target = manipulationTarget( this, elem );
  					target.insertBefore( elem, target.firstChild );
  				}
  			} );
  		},

  		before: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.parentNode ) {
  					this.parentNode.insertBefore( elem, this );
  				}
  			} );
  		},

  		after: function() {
  			return domManip( this, arguments, function( elem ) {
  				if ( this.parentNode ) {
  					this.parentNode.insertBefore( elem, this.nextSibling );
  				}
  			} );
  		},

  		empty: function() {
  			var elem,
  				i = 0;

  			for ( ; ( elem = this[ i ] ) != null; i++ ) {
  				if ( elem.nodeType === 1 ) {

  					// Prevent memory leaks
  					jQuery.cleanData( getAll( elem, false ) );

  					// Remove any remaining nodes
  					elem.textContent = "";
  				}
  			}

  			return this;
  		},

  		clone: function( dataAndEvents, deepDataAndEvents ) {
  			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
  			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

  			return this.map( function() {
  				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
  			} );
  		},

  		html: function( value ) {
  			return access( this, function( value ) {
  				var elem = this[ 0 ] || {},
  					i = 0,
  					l = this.length;

  				if ( value === undefined && elem.nodeType === 1 ) {
  					return elem.innerHTML;
  				}

  				// See if we can take a shortcut and just use innerHTML
  				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
  					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

  					value = jQuery.htmlPrefilter( value );

  					try {
  						for ( ; i < l; i++ ) {
  							elem = this[ i ] || {};

  							// Remove element nodes and prevent memory leaks
  							if ( elem.nodeType === 1 ) {
  								jQuery.cleanData( getAll( elem, false ) );
  								elem.innerHTML = value;
  							}
  						}

  						elem = 0;

  					// If using innerHTML throws an exception, use the fallback method
  					} catch ( e ) {}
  				}

  				if ( elem ) {
  					this.empty().append( value );
  				}
  			}, null, value, arguments.length );
  		},

  		replaceWith: function() {
  			var ignored = [];

  			// Make the changes, replacing each non-ignored context element with the new content
  			return domManip( this, arguments, function( elem ) {
  				var parent = this.parentNode;

  				if ( jQuery.inArray( this, ignored ) < 0 ) {
  					jQuery.cleanData( getAll( this ) );
  					if ( parent ) {
  						parent.replaceChild( elem, this );
  					}
  				}

  			// Force callback invocation
  			}, ignored );
  		}
  	} );

  	jQuery.each( {
  		appendTo: "append",
  		prependTo: "prepend",
  		insertBefore: "before",
  		insertAfter: "after",
  		replaceAll: "replaceWith"
  	}, function( name, original ) {
  		jQuery.fn[ name ] = function( selector ) {
  			var elems,
  				ret = [],
  				insert = jQuery( selector ),
  				last = insert.length - 1,
  				i = 0;

  			for ( ; i <= last; i++ ) {
  				elems = i === last ? this : this.clone( true );
  				jQuery( insert[ i ] )[ original ]( elems );

  				// Support: Android <=4.0 only, PhantomJS 1 only
  				// .get() because push.apply(_, arraylike) throws on ancient WebKit
  				push.apply( ret, elems.get() );
  			}

  			return this.pushStack( ret );
  		};
  	} );
  	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

  	var rcustomProp = /^--/;


  	var getStyles = function( elem ) {

  			// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
  			// IE throws on elements created in popups
  			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
  			var view = elem.ownerDocument.defaultView;

  			if ( !view || !view.opener ) {
  				view = window;
  			}

  			return view.getComputedStyle( elem );
  		};

  	var swap = function( elem, options, callback ) {
  		var ret, name,
  			old = {};

  		// Remember the old values, and insert the new ones
  		for ( name in options ) {
  			old[ name ] = elem.style[ name ];
  			elem.style[ name ] = options[ name ];
  		}

  		ret = callback.call( elem );

  		// Revert the old values
  		for ( name in options ) {
  			elem.style[ name ] = old[ name ];
  		}

  		return ret;
  	};


  	var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



  	( function() {

  		// Executing both pixelPosition & boxSizingReliable tests require only one layout
  		// so they're executed at the same time to save the second computation.
  		function computeStyleTests() {

  			// This is a singleton, we need to execute it only once
  			if ( !div ) {
  				return;
  			}

  			container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
  				"margin-top:1px;padding:0;border:0";
  			div.style.cssText =
  				"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
  				"margin:auto;border:1px;padding:1px;" +
  				"width:60%;top:1%";
  			documentElement.appendChild( container ).appendChild( div );

  			var divStyle = window.getComputedStyle( div );
  			pixelPositionVal = divStyle.top !== "1%";

  			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
  			reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

  			// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
  			// Some styles come back with percentage values, even though they shouldn't
  			div.style.right = "60%";
  			pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

  			// Support: IE 9 - 11 only
  			// Detect misreporting of content dimensions for box-sizing:border-box elements
  			boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

  			// Support: IE 9 only
  			// Detect overflow:scroll screwiness (gh-3699)
  			// Support: Chrome <=64
  			// Don't get tricked when zoom affects offsetWidth (gh-4029)
  			div.style.position = "absolute";
  			scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

  			documentElement.removeChild( container );

  			// Nullify the div so it wouldn't be stored in the memory and
  			// it will also be a sign that checks already performed
  			div = null;
  		}

  		function roundPixelMeasures( measure ) {
  			return Math.round( parseFloat( measure ) );
  		}

  		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
  			reliableTrDimensionsVal, reliableMarginLeftVal,
  			container = document.createElement( "div" ),
  			div = document.createElement( "div" );

  		// Finish early in limited (non-browser) environments
  		if ( !div.style ) {
  			return;
  		}

  		// Support: IE <=9 - 11 only
  		// Style of cloned element affects source element cloned (trac-8908)
  		div.style.backgroundClip = "content-box";
  		div.cloneNode( true ).style.backgroundClip = "";
  		support.clearCloneStyle = div.style.backgroundClip === "content-box";

  		jQuery.extend( support, {
  			boxSizingReliable: function() {
  				computeStyleTests();
  				return boxSizingReliableVal;
  			},
  			pixelBoxStyles: function() {
  				computeStyleTests();
  				return pixelBoxStylesVal;
  			},
  			pixelPosition: function() {
  				computeStyleTests();
  				return pixelPositionVal;
  			},
  			reliableMarginLeft: function() {
  				computeStyleTests();
  				return reliableMarginLeftVal;
  			},
  			scrollboxSize: function() {
  				computeStyleTests();
  				return scrollboxSizeVal;
  			},

  			// Support: IE 9 - 11+, Edge 15 - 18+
  			// IE/Edge misreport `getComputedStyle` of table rows with width/height
  			// set in CSS while `offset*` properties report correct values.
  			// Behavior in IE 9 is more subtle than in newer versions & it passes
  			// some versions of this test; make sure not to make it pass there!
  			//
  			// Support: Firefox 70+
  			// Only Firefox includes border widths
  			// in computed dimensions. (gh-4529)
  			reliableTrDimensions: function() {
  				var table, tr, trChild, trStyle;
  				if ( reliableTrDimensionsVal == null ) {
  					table = document.createElement( "table" );
  					tr = document.createElement( "tr" );
  					trChild = document.createElement( "div" );

  					table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
  					tr.style.cssText = "box-sizing:content-box;border:1px solid";

  					// Support: Chrome 86+
  					// Height set through cssText does not get applied.
  					// Computed height then comes back as 0.
  					tr.style.height = "1px";
  					trChild.style.height = "9px";

  					// Support: Android 8 Chrome 86+
  					// In our bodyBackground.html iframe,
  					// display for all div elements is set to "inline",
  					// which causes a problem only in Android 8 Chrome 86.
  					// Ensuring the div is `display: block`
  					// gets around this issue.
  					trChild.style.display = "block";

  					documentElement
  						.appendChild( table )
  						.appendChild( tr )
  						.appendChild( trChild );

  					trStyle = window.getComputedStyle( tr );
  					reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
  						parseInt( trStyle.borderTopWidth, 10 ) +
  						parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

  					documentElement.removeChild( table );
  				}
  				return reliableTrDimensionsVal;
  			}
  		} );
  	} )();


  	function curCSS( elem, name, computed ) {
  		var width, minWidth, maxWidth, ret,
  			isCustomProp = rcustomProp.test( name ),

  			// Support: Firefox 51+
  			// Retrieving style before computed somehow
  			// fixes an issue with getting wrong values
  			// on detached elements
  			style = elem.style;

  		computed = computed || getStyles( elem );

  		// getPropertyValue is needed for:
  		//   .css('filter') (IE 9 only, trac-12537)
  		//   .css('--customProperty) (gh-3144)
  		if ( computed ) {

  			// Support: IE <=9 - 11+
  			// IE only supports `"float"` in `getPropertyValue`; in computed styles
  			// it's only available as `"cssFloat"`. We no longer modify properties
  			// sent to `.css()` apart from camelCasing, so we need to check both.
  			// Normally, this would create difference in behavior: if
  			// `getPropertyValue` returns an empty string, the value returned
  			// by `.css()` would be `undefined`. This is usually the case for
  			// disconnected elements. However, in IE even disconnected elements
  			// with no styles return `"none"` for `getPropertyValue( "float" )`
  			ret = computed.getPropertyValue( name ) || computed[ name ];

  			if ( isCustomProp && ret ) {

  				// Support: Firefox 105+, Chrome <=105+
  				// Spec requires trimming whitespace for custom properties (gh-4926).
  				// Firefox only trims leading whitespace. Chrome just collapses
  				// both leading & trailing whitespace to a single space.
  				//
  				// Fall back to `undefined` if empty string returned.
  				// This collapses a missing definition with property defined
  				// and set to an empty string but there's no standard API
  				// allowing us to differentiate them without a performance penalty
  				// and returning `undefined` aligns with older jQuery.
  				//
  				// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
  				// as whitespace while CSS does not, but this is not a problem
  				// because CSS preprocessing replaces them with U+000A LINE FEED
  				// (which *is* CSS whitespace)
  				// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
  				ret = ret.replace( rtrimCSS, "$1" ) || undefined;
  			}

  			if ( ret === "" && !isAttached( elem ) ) {
  				ret = jQuery.style( elem, name );
  			}

  			// A tribute to the "awesome hack by Dean Edwards"
  			// Android Browser returns percentage for some values,
  			// but width seems to be reliably pixels.
  			// This is against the CSSOM draft spec:
  			// https://drafts.csswg.org/cssom/#resolved-values
  			if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

  				// Remember the original values
  				width = style.width;
  				minWidth = style.minWidth;
  				maxWidth = style.maxWidth;

  				// Put in the new values to get a computed value out
  				style.minWidth = style.maxWidth = style.width = ret;
  				ret = computed.width;

  				// Revert the changed values
  				style.width = width;
  				style.minWidth = minWidth;
  				style.maxWidth = maxWidth;
  			}
  		}

  		return ret !== undefined ?

  			// Support: IE <=9 - 11 only
  			// IE returns zIndex value as an integer.
  			ret + "" :
  			ret;
  	}


  	function addGetHookIf( conditionFn, hookFn ) {

  		// Define the hook, we'll check on the first run if it's really needed.
  		return {
  			get: function() {
  				if ( conditionFn() ) {

  					// Hook not needed (or it's not possible to use it due
  					// to missing dependency), remove it.
  					delete this.get;
  					return;
  				}

  				// Hook needed; redefine it so that the support test is not executed again.
  				return ( this.get = hookFn ).apply( this, arguments );
  			}
  		};
  	}


  	var cssPrefixes = [ "Webkit", "Moz", "ms" ],
  		emptyStyle = document.createElement( "div" ).style,
  		vendorProps = {};

  	// Return a vendor-prefixed property or undefined
  	function vendorPropName( name ) {

  		// Check for vendor prefixed names
  		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
  			i = cssPrefixes.length;

  		while ( i-- ) {
  			name = cssPrefixes[ i ] + capName;
  			if ( name in emptyStyle ) {
  				return name;
  			}
  		}
  	}

  	// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
  	function finalPropName( name ) {
  		var final = jQuery.cssProps[ name ] || vendorProps[ name ];

  		if ( final ) {
  			return final;
  		}
  		if ( name in emptyStyle ) {
  			return name;
  		}
  		return vendorProps[ name ] = vendorPropName( name ) || name;
  	}


  	var

  		// Swappable if display is none or starts with table
  		// except "table", "table-cell", or "table-caption"
  		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  		cssNormalTransform = {
  			letterSpacing: "0",
  			fontWeight: "400"
  		};

  	function setPositiveNumber( _elem, value, subtract ) {

  		// Any relative (+/-) values have already been
  		// normalized at this point
  		var matches = rcssNum.exec( value );
  		return matches ?

  			// Guard against undefined "subtract", e.g., when used as in cssHooks
  			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
  			value;
  	}

  	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
  		var i = dimension === "width" ? 1 : 0,
  			extra = 0,
  			delta = 0,
  			marginDelta = 0;

  		// Adjustment may not be necessary
  		if ( box === ( isBorderBox ? "border" : "content" ) ) {
  			return 0;
  		}

  		for ( ; i < 4; i += 2 ) {

  			// Both box models exclude margin
  			// Count margin delta separately to only add it after scroll gutter adjustment.
  			// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
  			if ( box === "margin" ) {
  				marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
  			}

  			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
  			if ( !isBorderBox ) {

  				// Add padding
  				delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

  				// For "border" or "margin", add border
  				if ( box !== "padding" ) {
  					delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

  				// But still keep track of it otherwise
  				} else {
  					extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  				}

  			// If we get here with a border-box (content + padding + border), we're seeking "content" or
  			// "padding" or "margin"
  			} else {

  				// For "content", subtract padding
  				if ( box === "content" ) {
  					delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
  				}

  				// For "content" or "padding", subtract border
  				if ( box !== "margin" ) {
  					delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  				}
  			}
  		}

  		// Account for positive content-box scroll gutter when requested by providing computedVal
  		if ( !isBorderBox && computedVal >= 0 ) {

  			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
  			// Assuming integer scroll gutter, subtract the rest and round down
  			delta += Math.max( 0, Math.ceil(
  				elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  				computedVal -
  				delta -
  				extra -
  				0.5

  			// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
  			// Use an explicit zero to avoid NaN (gh-3964)
  			) ) || 0;
  		}

  		return delta + marginDelta;
  	}

  	function getWidthOrHeight( elem, dimension, extra ) {

  		// Start with computed style
  		var styles = getStyles( elem ),

  			// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
  			// Fake content-box until we know it's needed to know the true value.
  			boxSizingNeeded = !support.boxSizingReliable() || extra,
  			isBorderBox = boxSizingNeeded &&
  				jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  			valueIsBorderBox = isBorderBox,

  			val = curCSS( elem, dimension, styles ),
  			offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

  		// Support: Firefox <=54
  		// Return a confounding non-pixel value or feign ignorance, as appropriate.
  		if ( rnumnonpx.test( val ) ) {
  			if ( !extra ) {
  				return val;
  			}
  			val = "auto";
  		}


  		// Support: IE 9 - 11 only
  		// Use offsetWidth/offsetHeight for when box sizing is unreliable.
  		// In those cases, the computed value can be trusted to be border-box.
  		if ( ( !support.boxSizingReliable() && isBorderBox ||

  			// Support: IE 10 - 11+, Edge 15 - 18+
  			// IE/Edge misreport `getComputedStyle` of table rows with width/height
  			// set in CSS while `offset*` properties report correct values.
  			// Interestingly, in some cases IE 9 doesn't suffer from this issue.
  			!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

  			// Fall back to offsetWidth/offsetHeight when value is "auto"
  			// This happens for inline elements with no explicit setting (gh-3571)
  			val === "auto" ||

  			// Support: Android <=4.1 - 4.3 only
  			// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
  			!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

  			// Make sure the element is visible & connected
  			elem.getClientRects().length ) {

  			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

  			// Where available, offsetWidth/offsetHeight approximate border box dimensions.
  			// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
  			// retrieved value as a content box dimension.
  			valueIsBorderBox = offsetProp in elem;
  			if ( valueIsBorderBox ) {
  				val = elem[ offsetProp ];
  			}
  		}

  		// Normalize "" and auto
  		val = parseFloat( val ) || 0;

  		// Adjust for the element's box model
  		return ( val +
  			boxModelAdjustment(
  				elem,
  				dimension,
  				extra || ( isBorderBox ? "border" : "content" ),
  				valueIsBorderBox,
  				styles,

  				// Provide the current computed size to request scroll gutter calculation (gh-3589)
  				val
  			)
  		) + "px";
  	}

  	jQuery.extend( {

  		// Add in style property hooks for overriding the default
  		// behavior of getting and setting a style property
  		cssHooks: {
  			opacity: {
  				get: function( elem, computed ) {
  					if ( computed ) {

  						// We should always get a number back from opacity
  						var ret = curCSS( elem, "opacity" );
  						return ret === "" ? "1" : ret;
  					}
  				}
  			}
  		},

  		// Don't automatically add "px" to these possibly-unitless properties
  		cssNumber: {
  			animationIterationCount: true,
  			aspectRatio: true,
  			borderImageSlice: true,
  			columnCount: true,
  			flexGrow: true,
  			flexShrink: true,
  			fontWeight: true,
  			gridArea: true,
  			gridColumn: true,
  			gridColumnEnd: true,
  			gridColumnStart: true,
  			gridRow: true,
  			gridRowEnd: true,
  			gridRowStart: true,
  			lineHeight: true,
  			opacity: true,
  			order: true,
  			orphans: true,
  			scale: true,
  			widows: true,
  			zIndex: true,
  			zoom: true,

  			// SVG-related
  			fillOpacity: true,
  			floodOpacity: true,
  			stopOpacity: true,
  			strokeMiterlimit: true,
  			strokeOpacity: true
  		},

  		// Add in properties whose names you wish to fix before
  		// setting or getting the value
  		cssProps: {},

  		// Get and set the style property on a DOM Node
  		style: function( elem, name, value, extra ) {

  			// Don't set styles on text and comment nodes
  			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
  				return;
  			}

  			// Make sure that we're working with the right name
  			var ret, type, hooks,
  				origName = camelCase( name ),
  				isCustomProp = rcustomProp.test( name ),
  				style = elem.style;

  			// Make sure that we're working with the right name. We don't
  			// want to query the value if it is a CSS custom property
  			// since they are user-defined.
  			if ( !isCustomProp ) {
  				name = finalPropName( origName );
  			}

  			// Gets hook for the prefixed version, then unprefixed version
  			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  			// Check if we're setting a value
  			if ( value !== undefined ) {
  				type = typeof value;

  				// Convert "+=" or "-=" to relative numbers (trac-7345)
  				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
  					value = adjustCSS( elem, name, ret );

  					// Fixes bug trac-9237
  					type = "number";
  				}

  				// Make sure that null and NaN values aren't set (trac-7116)
  				if ( value == null || value !== value ) {
  					return;
  				}

  				// If a number was passed in, add the unit (except for certain CSS properties)
  				// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
  				// "px" to a few hardcoded values.
  				if ( type === "number" && !isCustomProp ) {
  					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
  				}

  				// background-* props affect original clone's values
  				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
  					style[ name ] = "inherit";
  				}

  				// If a hook was provided, use that value, otherwise just set the specified value
  				if ( !hooks || !( "set" in hooks ) ||
  					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

  					if ( isCustomProp ) {
  						style.setProperty( name, value );
  					} else {
  						style[ name ] = value;
  					}
  				}

  			} else {

  				// If a hook was provided get the non-computed value from there
  				if ( hooks && "get" in hooks &&
  					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

  					return ret;
  				}

  				// Otherwise just get the value from the style object
  				return style[ name ];
  			}
  		},

  		css: function( elem, name, extra, styles ) {
  			var val, num, hooks,
  				origName = camelCase( name ),
  				isCustomProp = rcustomProp.test( name );

  			// Make sure that we're working with the right name. We don't
  			// want to modify the value if it is a CSS custom property
  			// since they are user-defined.
  			if ( !isCustomProp ) {
  				name = finalPropName( origName );
  			}

  			// Try prefixed name followed by the unprefixed name
  			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  			// If a hook was provided get the computed value from there
  			if ( hooks && "get" in hooks ) {
  				val = hooks.get( elem, true, extra );
  			}

  			// Otherwise, if a way to get the computed value exists, use that
  			if ( val === undefined ) {
  				val = curCSS( elem, name, styles );
  			}

  			// Convert "normal" to computed value
  			if ( val === "normal" && name in cssNormalTransform ) {
  				val = cssNormalTransform[ name ];
  			}

  			// Make numeric if forced or a qualifier was provided and val looks numeric
  			if ( extra === "" || extra ) {
  				num = parseFloat( val );
  				return extra === true || isFinite( num ) ? num || 0 : val;
  			}

  			return val;
  		}
  	} );

  	jQuery.each( [ "height", "width" ], function( _i, dimension ) {
  		jQuery.cssHooks[ dimension ] = {
  			get: function( elem, computed, extra ) {
  				if ( computed ) {

  					// Certain elements can have dimension info if we invisibly show them
  					// but it must have a current display style that would benefit
  					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

  						// Support: Safari 8+
  						// Table columns in Safari have non-zero offsetWidth & zero
  						// getBoundingClientRect().width unless display is changed.
  						// Support: IE <=11 only
  						// Running getBoundingClientRect on a disconnected node
  						// in IE throws an error.
  						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
  						swap( elem, cssShow, function() {
  							return getWidthOrHeight( elem, dimension, extra );
  						} ) :
  						getWidthOrHeight( elem, dimension, extra );
  				}
  			},

  			set: function( elem, value, extra ) {
  				var matches,
  					styles = getStyles( elem ),

  					// Only read styles.position if the test has a chance to fail
  					// to avoid forcing a reflow.
  					scrollboxSizeBuggy = !support.scrollboxSize() &&
  						styles.position === "absolute",

  					// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
  					boxSizingNeeded = scrollboxSizeBuggy || extra,
  					isBorderBox = boxSizingNeeded &&
  						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  					subtract = extra ?
  						boxModelAdjustment(
  							elem,
  							dimension,
  							extra,
  							isBorderBox,
  							styles
  						) :
  						0;

  				// Account for unreliable border-box dimensions by comparing offset* to computed and
  				// faking a content-box to get border and padding (gh-3699)
  				if ( isBorderBox && scrollboxSizeBuggy ) {
  					subtract -= Math.ceil(
  						elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  						parseFloat( styles[ dimension ] ) -
  						boxModelAdjustment( elem, dimension, "border", false, styles ) -
  						0.5
  					);
  				}

  				// Convert to pixels if value adjustment is needed
  				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
  					( matches[ 3 ] || "px" ) !== "px" ) {

  					elem.style[ dimension ] = value;
  					value = jQuery.css( elem, dimension );
  				}

  				return setPositiveNumber( elem, value, subtract );
  			}
  		};
  	} );

  	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
  		function( elem, computed ) {
  			if ( computed ) {
  				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
  					elem.getBoundingClientRect().left -
  						swap( elem, { marginLeft: 0 }, function() {
  							return elem.getBoundingClientRect().left;
  						} )
  				) + "px";
  			}
  		}
  	);

  	// These hooks are used by animate to expand properties
  	jQuery.each( {
  		margin: "",
  		padding: "",
  		border: "Width"
  	}, function( prefix, suffix ) {
  		jQuery.cssHooks[ prefix + suffix ] = {
  			expand: function( value ) {
  				var i = 0,
  					expanded = {},

  					// Assumes a single number if not a string
  					parts = typeof value === "string" ? value.split( " " ) : [ value ];

  				for ( ; i < 4; i++ ) {
  					expanded[ prefix + cssExpand[ i ] + suffix ] =
  						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
  				}

  				return expanded;
  			}
  		};

  		if ( prefix !== "margin" ) {
  			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  		}
  	} );

  	jQuery.fn.extend( {
  		css: function( name, value ) {
  			return access( this, function( elem, name, value ) {
  				var styles, len,
  					map = {},
  					i = 0;

  				if ( Array.isArray( name ) ) {
  					styles = getStyles( elem );
  					len = name.length;

  					for ( ; i < len; i++ ) {
  						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
  					}

  					return map;
  				}

  				return value !== undefined ?
  					jQuery.style( elem, name, value ) :
  					jQuery.css( elem, name );
  			}, name, value, arguments.length > 1 );
  		}
  	} );


  	function Tween( elem, options, prop, end, easing ) {
  		return new Tween.prototype.init( elem, options, prop, end, easing );
  	}
  	jQuery.Tween = Tween;

  	Tween.prototype = {
  		constructor: Tween,
  		init: function( elem, options, prop, end, easing, unit ) {
  			this.elem = elem;
  			this.prop = prop;
  			this.easing = easing || jQuery.easing._default;
  			this.options = options;
  			this.start = this.now = this.cur();
  			this.end = end;
  			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
  		},
  		cur: function() {
  			var hooks = Tween.propHooks[ this.prop ];

  			return hooks && hooks.get ?
  				hooks.get( this ) :
  				Tween.propHooks._default.get( this );
  		},
  		run: function( percent ) {
  			var eased,
  				hooks = Tween.propHooks[ this.prop ];

  			if ( this.options.duration ) {
  				this.pos = eased = jQuery.easing[ this.easing ](
  					percent, this.options.duration * percent, 0, 1, this.options.duration
  				);
  			} else {
  				this.pos = eased = percent;
  			}
  			this.now = ( this.end - this.start ) * eased + this.start;

  			if ( this.options.step ) {
  				this.options.step.call( this.elem, this.now, this );
  			}

  			if ( hooks && hooks.set ) {
  				hooks.set( this );
  			} else {
  				Tween.propHooks._default.set( this );
  			}
  			return this;
  		}
  	};

  	Tween.prototype.init.prototype = Tween.prototype;

  	Tween.propHooks = {
  		_default: {
  			get: function( tween ) {
  				var result;

  				// Use a property on the element directly when it is not a DOM element,
  				// or when there is no matching style property that exists.
  				if ( tween.elem.nodeType !== 1 ||
  					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
  					return tween.elem[ tween.prop ];
  				}

  				// Passing an empty string as a 3rd parameter to .css will automatically
  				// attempt a parseFloat and fallback to a string if the parse fails.
  				// Simple values such as "10px" are parsed to Float;
  				// complex values such as "rotate(1rad)" are returned as-is.
  				result = jQuery.css( tween.elem, tween.prop, "" );

  				// Empty strings, null, undefined and "auto" are converted to 0.
  				return !result || result === "auto" ? 0 : result;
  			},
  			set: function( tween ) {

  				// Use step hook for back compat.
  				// Use cssHook if its there.
  				// Use .style if available and use plain properties where available.
  				if ( jQuery.fx.step[ tween.prop ] ) {
  					jQuery.fx.step[ tween.prop ]( tween );
  				} else if ( tween.elem.nodeType === 1 && (
  					jQuery.cssHooks[ tween.prop ] ||
  						tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
  					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
  				} else {
  					tween.elem[ tween.prop ] = tween.now;
  				}
  			}
  		}
  	};

  	// Support: IE <=9 only
  	// Panic based approach to setting things on disconnected nodes
  	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
  		set: function( tween ) {
  			if ( tween.elem.nodeType && tween.elem.parentNode ) {
  				tween.elem[ tween.prop ] = tween.now;
  			}
  		}
  	};

  	jQuery.easing = {
  		linear: function( p ) {
  			return p;
  		},
  		swing: function( p ) {
  			return 0.5 - Math.cos( p * Math.PI ) / 2;
  		},
  		_default: "swing"
  	};

  	jQuery.fx = Tween.prototype.init;

  	// Back compat <1.8 extension point
  	jQuery.fx.step = {};




  	var
  		fxNow, inProgress,
  		rfxtypes = /^(?:toggle|show|hide)$/,
  		rrun = /queueHooks$/;

  	function schedule() {
  		if ( inProgress ) {
  			if ( document.hidden === false && window.requestAnimationFrame ) {
  				window.requestAnimationFrame( schedule );
  			} else {
  				window.setTimeout( schedule, jQuery.fx.interval );
  			}

  			jQuery.fx.tick();
  		}
  	}

  	// Animations created synchronously will run synchronously
  	function createFxNow() {
  		window.setTimeout( function() {
  			fxNow = undefined;
  		} );
  		return ( fxNow = Date.now() );
  	}

  	// Generate parameters to create a standard animation
  	function genFx( type, includeWidth ) {
  		var which,
  			i = 0,
  			attrs = { height: type };

  		// If we include width, step value is 1 to do all cssExpand values,
  		// otherwise step value is 2 to skip over Left and Right
  		includeWidth = includeWidth ? 1 : 0;
  		for ( ; i < 4; i += 2 - includeWidth ) {
  			which = cssExpand[ i ];
  			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
  		}

  		if ( includeWidth ) {
  			attrs.opacity = attrs.width = type;
  		}

  		return attrs;
  	}

  	function createTween( value, prop, animation ) {
  		var tween,
  			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
  			index = 0,
  			length = collection.length;
  		for ( ; index < length; index++ ) {
  			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

  				// We're done with this property
  				return tween;
  			}
  		}
  	}

  	function defaultPrefilter( elem, props, opts ) {
  		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
  			isBox = "width" in props || "height" in props,
  			anim = this,
  			orig = {},
  			style = elem.style,
  			hidden = elem.nodeType && isHiddenWithinTree( elem ),
  			dataShow = dataPriv.get( elem, "fxshow" );

  		// Queue-skipping animations hijack the fx hooks
  		if ( !opts.queue ) {
  			hooks = jQuery._queueHooks( elem, "fx" );
  			if ( hooks.unqueued == null ) {
  				hooks.unqueued = 0;
  				oldfire = hooks.empty.fire;
  				hooks.empty.fire = function() {
  					if ( !hooks.unqueued ) {
  						oldfire();
  					}
  				};
  			}
  			hooks.unqueued++;

  			anim.always( function() {

  				// Ensure the complete handler is called before this completes
  				anim.always( function() {
  					hooks.unqueued--;
  					if ( !jQuery.queue( elem, "fx" ).length ) {
  						hooks.empty.fire();
  					}
  				} );
  			} );
  		}

  		// Detect show/hide animations
  		for ( prop in props ) {
  			value = props[ prop ];
  			if ( rfxtypes.test( value ) ) {
  				delete props[ prop ];
  				toggle = toggle || value === "toggle";
  				if ( value === ( hidden ? "hide" : "show" ) ) {

  					// Pretend to be hidden if this is a "show" and
  					// there is still data from a stopped show/hide
  					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
  						hidden = true;

  					// Ignore all other no-op show/hide data
  					} else {
  						continue;
  					}
  				}
  				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
  			}
  		}

  		// Bail out if this is a no-op like .hide().hide()
  		propTween = !jQuery.isEmptyObject( props );
  		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
  			return;
  		}

  		// Restrict "overflow" and "display" styles during box animations
  		if ( isBox && elem.nodeType === 1 ) {

  			// Support: IE <=9 - 11, Edge 12 - 15
  			// Record all 3 overflow attributes because IE does not infer the shorthand
  			// from identically-valued overflowX and overflowY and Edge just mirrors
  			// the overflowX value there.
  			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

  			// Identify a display type, preferring old show/hide data over the CSS cascade
  			restoreDisplay = dataShow && dataShow.display;
  			if ( restoreDisplay == null ) {
  				restoreDisplay = dataPriv.get( elem, "display" );
  			}
  			display = jQuery.css( elem, "display" );
  			if ( display === "none" ) {
  				if ( restoreDisplay ) {
  					display = restoreDisplay;
  				} else {

  					// Get nonempty value(s) by temporarily forcing visibility
  					showHide( [ elem ], true );
  					restoreDisplay = elem.style.display || restoreDisplay;
  					display = jQuery.css( elem, "display" );
  					showHide( [ elem ] );
  				}
  			}

  			// Animate inline elements as inline-block
  			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
  				if ( jQuery.css( elem, "float" ) === "none" ) {

  					// Restore the original display value at the end of pure show/hide animations
  					if ( !propTween ) {
  						anim.done( function() {
  							style.display = restoreDisplay;
  						} );
  						if ( restoreDisplay == null ) {
  							display = style.display;
  							restoreDisplay = display === "none" ? "" : display;
  						}
  					}
  					style.display = "inline-block";
  				}
  			}
  		}

  		if ( opts.overflow ) {
  			style.overflow = "hidden";
  			anim.always( function() {
  				style.overflow = opts.overflow[ 0 ];
  				style.overflowX = opts.overflow[ 1 ];
  				style.overflowY = opts.overflow[ 2 ];
  			} );
  		}

  		// Implement show/hide animations
  		propTween = false;
  		for ( prop in orig ) {

  			// General show/hide setup for this element animation
  			if ( !propTween ) {
  				if ( dataShow ) {
  					if ( "hidden" in dataShow ) {
  						hidden = dataShow.hidden;
  					}
  				} else {
  					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
  				}

  				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
  				if ( toggle ) {
  					dataShow.hidden = !hidden;
  				}

  				// Show elements before animating them
  				if ( hidden ) {
  					showHide( [ elem ], true );
  				}

  				/* eslint-disable no-loop-func */

  				anim.done( function() {

  					/* eslint-enable no-loop-func */

  					// The final step of a "hide" animation is actually hiding the element
  					if ( !hidden ) {
  						showHide( [ elem ] );
  					}
  					dataPriv.remove( elem, "fxshow" );
  					for ( prop in orig ) {
  						jQuery.style( elem, prop, orig[ prop ] );
  					}
  				} );
  			}

  			// Per-property setup
  			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
  			if ( !( prop in dataShow ) ) {
  				dataShow[ prop ] = propTween.start;
  				if ( hidden ) {
  					propTween.end = propTween.start;
  					propTween.start = 0;
  				}
  			}
  		}
  	}

  	function propFilter( props, specialEasing ) {
  		var index, name, easing, value, hooks;

  		// camelCase, specialEasing and expand cssHook pass
  		for ( index in props ) {
  			name = camelCase( index );
  			easing = specialEasing[ name ];
  			value = props[ index ];
  			if ( Array.isArray( value ) ) {
  				easing = value[ 1 ];
  				value = props[ index ] = value[ 0 ];
  			}

  			if ( index !== name ) {
  				props[ name ] = value;
  				delete props[ index ];
  			}

  			hooks = jQuery.cssHooks[ name ];
  			if ( hooks && "expand" in hooks ) {
  				value = hooks.expand( value );
  				delete props[ name ];

  				// Not quite $.extend, this won't overwrite existing keys.
  				// Reusing 'index' because we have the correct "name"
  				for ( index in value ) {
  					if ( !( index in props ) ) {
  						props[ index ] = value[ index ];
  						specialEasing[ index ] = easing;
  					}
  				}
  			} else {
  				specialEasing[ name ] = easing;
  			}
  		}
  	}

  	function Animation( elem, properties, options ) {
  		var result,
  			stopped,
  			index = 0,
  			length = Animation.prefilters.length,
  			deferred = jQuery.Deferred().always( function() {

  				// Don't match elem in the :animated selector
  				delete tick.elem;
  			} ),
  			tick = function() {
  				if ( stopped ) {
  					return false;
  				}
  				var currentTime = fxNow || createFxNow(),
  					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

  					// Support: Android 2.3 only
  					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
  					temp = remaining / animation.duration || 0,
  					percent = 1 - temp,
  					index = 0,
  					length = animation.tweens.length;

  				for ( ; index < length; index++ ) {
  					animation.tweens[ index ].run( percent );
  				}

  				deferred.notifyWith( elem, [ animation, percent, remaining ] );

  				// If there's more to do, yield
  				if ( percent < 1 && length ) {
  					return remaining;
  				}

  				// If this was an empty animation, synthesize a final progress notification
  				if ( !length ) {
  					deferred.notifyWith( elem, [ animation, 1, 0 ] );
  				}

  				// Resolve the animation and report its conclusion
  				deferred.resolveWith( elem, [ animation ] );
  				return false;
  			},
  			animation = deferred.promise( {
  				elem: elem,
  				props: jQuery.extend( {}, properties ),
  				opts: jQuery.extend( true, {
  					specialEasing: {},
  					easing: jQuery.easing._default
  				}, options ),
  				originalProperties: properties,
  				originalOptions: options,
  				startTime: fxNow || createFxNow(),
  				duration: options.duration,
  				tweens: [],
  				createTween: function( prop, end ) {
  					var tween = jQuery.Tween( elem, animation.opts, prop, end,
  						animation.opts.specialEasing[ prop ] || animation.opts.easing );
  					animation.tweens.push( tween );
  					return tween;
  				},
  				stop: function( gotoEnd ) {
  					var index = 0,

  						// If we are going to the end, we want to run all the tweens
  						// otherwise we skip this part
  						length = gotoEnd ? animation.tweens.length : 0;
  					if ( stopped ) {
  						return this;
  					}
  					stopped = true;
  					for ( ; index < length; index++ ) {
  						animation.tweens[ index ].run( 1 );
  					}

  					// Resolve when we played the last frame; otherwise, reject
  					if ( gotoEnd ) {
  						deferred.notifyWith( elem, [ animation, 1, 0 ] );
  						deferred.resolveWith( elem, [ animation, gotoEnd ] );
  					} else {
  						deferred.rejectWith( elem, [ animation, gotoEnd ] );
  					}
  					return this;
  				}
  			} ),
  			props = animation.props;

  		propFilter( props, animation.opts.specialEasing );

  		for ( ; index < length; index++ ) {
  			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
  			if ( result ) {
  				if ( isFunction( result.stop ) ) {
  					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
  						result.stop.bind( result );
  				}
  				return result;
  			}
  		}

  		jQuery.map( props, createTween, animation );

  		if ( isFunction( animation.opts.start ) ) {
  			animation.opts.start.call( elem, animation );
  		}

  		// Attach callbacks from options
  		animation
  			.progress( animation.opts.progress )
  			.done( animation.opts.done, animation.opts.complete )
  			.fail( animation.opts.fail )
  			.always( animation.opts.always );

  		jQuery.fx.timer(
  			jQuery.extend( tick, {
  				elem: elem,
  				anim: animation,
  				queue: animation.opts.queue
  			} )
  		);

  		return animation;
  	}

  	jQuery.Animation = jQuery.extend( Animation, {

  		tweeners: {
  			"*": [ function( prop, value ) {
  				var tween = this.createTween( prop, value );
  				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
  				return tween;
  			} ]
  		},

  		tweener: function( props, callback ) {
  			if ( isFunction( props ) ) {
  				callback = props;
  				props = [ "*" ];
  			} else {
  				props = props.match( rnothtmlwhite );
  			}

  			var prop,
  				index = 0,
  				length = props.length;

  			for ( ; index < length; index++ ) {
  				prop = props[ index ];
  				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
  				Animation.tweeners[ prop ].unshift( callback );
  			}
  		},

  		prefilters: [ defaultPrefilter ],

  		prefilter: function( callback, prepend ) {
  			if ( prepend ) {
  				Animation.prefilters.unshift( callback );
  			} else {
  				Animation.prefilters.push( callback );
  			}
  		}
  	} );

  	jQuery.speed = function( speed, easing, fn ) {
  		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
  			complete: fn || !fn && easing ||
  				isFunction( speed ) && speed,
  			duration: speed,
  			easing: fn && easing || easing && !isFunction( easing ) && easing
  		};

  		// Go to the end state if fx are off
  		if ( jQuery.fx.off ) {
  			opt.duration = 0;

  		} else {
  			if ( typeof opt.duration !== "number" ) {
  				if ( opt.duration in jQuery.fx.speeds ) {
  					opt.duration = jQuery.fx.speeds[ opt.duration ];

  				} else {
  					opt.duration = jQuery.fx.speeds._default;
  				}
  			}
  		}

  		// Normalize opt.queue - true/undefined/null -> "fx"
  		if ( opt.queue == null || opt.queue === true ) {
  			opt.queue = "fx";
  		}

  		// Queueing
  		opt.old = opt.complete;

  		opt.complete = function() {
  			if ( isFunction( opt.old ) ) {
  				opt.old.call( this );
  			}

  			if ( opt.queue ) {
  				jQuery.dequeue( this, opt.queue );
  			}
  		};

  		return opt;
  	};

  	jQuery.fn.extend( {
  		fadeTo: function( speed, to, easing, callback ) {

  			// Show any hidden elements after setting opacity to 0
  			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

  				// Animate to the value specified
  				.end().animate( { opacity: to }, speed, easing, callback );
  		},
  		animate: function( prop, speed, easing, callback ) {
  			var empty = jQuery.isEmptyObject( prop ),
  				optall = jQuery.speed( speed, easing, callback ),
  				doAnimation = function() {

  					// Operate on a copy of prop so per-property easing won't be lost
  					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

  					// Empty animations, or finishing resolves immediately
  					if ( empty || dataPriv.get( this, "finish" ) ) {
  						anim.stop( true );
  					}
  				};

  			doAnimation.finish = doAnimation;

  			return empty || optall.queue === false ?
  				this.each( doAnimation ) :
  				this.queue( optall.queue, doAnimation );
  		},
  		stop: function( type, clearQueue, gotoEnd ) {
  			var stopQueue = function( hooks ) {
  				var stop = hooks.stop;
  				delete hooks.stop;
  				stop( gotoEnd );
  			};

  			if ( typeof type !== "string" ) {
  				gotoEnd = clearQueue;
  				clearQueue = type;
  				type = undefined;
  			}
  			if ( clearQueue ) {
  				this.queue( type || "fx", [] );
  			}

  			return this.each( function() {
  				var dequeue = true,
  					index = type != null && type + "queueHooks",
  					timers = jQuery.timers,
  					data = dataPriv.get( this );

  				if ( index ) {
  					if ( data[ index ] && data[ index ].stop ) {
  						stopQueue( data[ index ] );
  					}
  				} else {
  					for ( index in data ) {
  						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
  							stopQueue( data[ index ] );
  						}
  					}
  				}

  				for ( index = timers.length; index--; ) {
  					if ( timers[ index ].elem === this &&
  						( type == null || timers[ index ].queue === type ) ) {

  						timers[ index ].anim.stop( gotoEnd );
  						dequeue = false;
  						timers.splice( index, 1 );
  					}
  				}

  				// Start the next in the queue if the last step wasn't forced.
  				// Timers currently will call their complete callbacks, which
  				// will dequeue but only if they were gotoEnd.
  				if ( dequeue || !gotoEnd ) {
  					jQuery.dequeue( this, type );
  				}
  			} );
  		},
  		finish: function( type ) {
  			if ( type !== false ) {
  				type = type || "fx";
  			}
  			return this.each( function() {
  				var index,
  					data = dataPriv.get( this ),
  					queue = data[ type + "queue" ],
  					hooks = data[ type + "queueHooks" ],
  					timers = jQuery.timers,
  					length = queue ? queue.length : 0;

  				// Enable finishing flag on private data
  				data.finish = true;

  				// Empty the queue first
  				jQuery.queue( this, type, [] );

  				if ( hooks && hooks.stop ) {
  					hooks.stop.call( this, true );
  				}

  				// Look for any active animations, and finish them
  				for ( index = timers.length; index--; ) {
  					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
  						timers[ index ].anim.stop( true );
  						timers.splice( index, 1 );
  					}
  				}

  				// Look for any animations in the old queue and finish them
  				for ( index = 0; index < length; index++ ) {
  					if ( queue[ index ] && queue[ index ].finish ) {
  						queue[ index ].finish.call( this );
  					}
  				}

  				// Turn off finishing flag
  				delete data.finish;
  			} );
  		}
  	} );

  	jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
  		var cssFn = jQuery.fn[ name ];
  		jQuery.fn[ name ] = function( speed, easing, callback ) {
  			return speed == null || typeof speed === "boolean" ?
  				cssFn.apply( this, arguments ) :
  				this.animate( genFx( name, true ), speed, easing, callback );
  		};
  	} );

  	// Generate shortcuts for custom animations
  	jQuery.each( {
  		slideDown: genFx( "show" ),
  		slideUp: genFx( "hide" ),
  		slideToggle: genFx( "toggle" ),
  		fadeIn: { opacity: "show" },
  		fadeOut: { opacity: "hide" },
  		fadeToggle: { opacity: "toggle" }
  	}, function( name, props ) {
  		jQuery.fn[ name ] = function( speed, easing, callback ) {
  			return this.animate( props, speed, easing, callback );
  		};
  	} );

  	jQuery.timers = [];
  	jQuery.fx.tick = function() {
  		var timer,
  			i = 0,
  			timers = jQuery.timers;

  		fxNow = Date.now();

  		for ( ; i < timers.length; i++ ) {
  			timer = timers[ i ];

  			// Run the timer and safely remove it when done (allowing for external removal)
  			if ( !timer() && timers[ i ] === timer ) {
  				timers.splice( i--, 1 );
  			}
  		}

  		if ( !timers.length ) {
  			jQuery.fx.stop();
  		}
  		fxNow = undefined;
  	};

  	jQuery.fx.timer = function( timer ) {
  		jQuery.timers.push( timer );
  		jQuery.fx.start();
  	};

  	jQuery.fx.interval = 13;
  	jQuery.fx.start = function() {
  		if ( inProgress ) {
  			return;
  		}

  		inProgress = true;
  		schedule();
  	};

  	jQuery.fx.stop = function() {
  		inProgress = null;
  	};

  	jQuery.fx.speeds = {
  		slow: 600,
  		fast: 200,

  		// Default speed
  		_default: 400
  	};


  	// Based off of the plugin by Clint Helfers, with permission.
  	jQuery.fn.delay = function( time, type ) {
  		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
  		type = type || "fx";

  		return this.queue( type, function( next, hooks ) {
  			var timeout = window.setTimeout( next, time );
  			hooks.stop = function() {
  				window.clearTimeout( timeout );
  			};
  		} );
  	};


  	( function() {
  		var input = document.createElement( "input" ),
  			select = document.createElement( "select" ),
  			opt = select.appendChild( document.createElement( "option" ) );

  		input.type = "checkbox";

  		// Support: Android <=4.3 only
  		// Default value for a checkbox should be "on"
  		support.checkOn = input.value !== "";

  		// Support: IE <=11 only
  		// Must access selectedIndex to make default options select
  		support.optSelected = opt.selected;

  		// Support: IE <=11 only
  		// An input loses its value after becoming a radio
  		input = document.createElement( "input" );
  		input.value = "t";
  		input.type = "radio";
  		support.radioValue = input.value === "t";
  	} )();


  	var boolHook,
  		attrHandle = jQuery.expr.attrHandle;

  	jQuery.fn.extend( {
  		attr: function( name, value ) {
  			return access( this, jQuery.attr, name, value, arguments.length > 1 );
  		},

  		removeAttr: function( name ) {
  			return this.each( function() {
  				jQuery.removeAttr( this, name );
  			} );
  		}
  	} );

  	jQuery.extend( {
  		attr: function( elem, name, value ) {
  			var ret, hooks,
  				nType = elem.nodeType;

  			// Don't get/set attributes on text, comment and attribute nodes
  			if ( nType === 3 || nType === 8 || nType === 2 ) {
  				return;
  			}

  			// Fallback to prop when attributes are not supported
  			if ( typeof elem.getAttribute === "undefined" ) {
  				return jQuery.prop( elem, name, value );
  			}

  			// Attribute hooks are determined by the lowercase version
  			// Grab necessary hook if one is defined
  			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
  				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
  					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
  			}

  			if ( value !== undefined ) {
  				if ( value === null ) {
  					jQuery.removeAttr( elem, name );
  					return;
  				}

  				if ( hooks && "set" in hooks &&
  					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  					return ret;
  				}

  				elem.setAttribute( name, value + "" );
  				return value;
  			}

  			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  				return ret;
  			}

  			ret = jQuery.find.attr( elem, name );

  			// Non-existent attributes return null, we normalize to undefined
  			return ret == null ? undefined : ret;
  		},

  		attrHooks: {
  			type: {
  				set: function( elem, value ) {
  					if ( !support.radioValue && value === "radio" &&
  						nodeName( elem, "input" ) ) {
  						var val = elem.value;
  						elem.setAttribute( "type", value );
  						if ( val ) {
  							elem.value = val;
  						}
  						return value;
  					}
  				}
  			}
  		},

  		removeAttr: function( elem, value ) {
  			var name,
  				i = 0,

  				// Attribute names can contain non-HTML whitespace characters
  				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
  				attrNames = value && value.match( rnothtmlwhite );

  			if ( attrNames && elem.nodeType === 1 ) {
  				while ( ( name = attrNames[ i++ ] ) ) {
  					elem.removeAttribute( name );
  				}
  			}
  		}
  	} );

  	// Hooks for boolean attributes
  	boolHook = {
  		set: function( elem, value, name ) {
  			if ( value === false ) {

  				// Remove boolean attributes when set to false
  				jQuery.removeAttr( elem, name );
  			} else {
  				elem.setAttribute( name, name );
  			}
  			return name;
  		}
  	};

  	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
  		var getter = attrHandle[ name ] || jQuery.find.attr;

  		attrHandle[ name ] = function( elem, name, isXML ) {
  			var ret, handle,
  				lowercaseName = name.toLowerCase();

  			if ( !isXML ) {

  				// Avoid an infinite loop by temporarily removing this function from the getter
  				handle = attrHandle[ lowercaseName ];
  				attrHandle[ lowercaseName ] = ret;
  				ret = getter( elem, name, isXML ) != null ?
  					lowercaseName :
  					null;
  				attrHandle[ lowercaseName ] = handle;
  			}
  			return ret;
  		};
  	} );




  	var rfocusable = /^(?:input|select|textarea|button)$/i,
  		rclickable = /^(?:a|area)$/i;

  	jQuery.fn.extend( {
  		prop: function( name, value ) {
  			return access( this, jQuery.prop, name, value, arguments.length > 1 );
  		},

  		removeProp: function( name ) {
  			return this.each( function() {
  				delete this[ jQuery.propFix[ name ] || name ];
  			} );
  		}
  	} );

  	jQuery.extend( {
  		prop: function( elem, name, value ) {
  			var ret, hooks,
  				nType = elem.nodeType;

  			// Don't get/set properties on text, comment and attribute nodes
  			if ( nType === 3 || nType === 8 || nType === 2 ) {
  				return;
  			}

  			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

  				// Fix name and attach hooks
  				name = jQuery.propFix[ name ] || name;
  				hooks = jQuery.propHooks[ name ];
  			}

  			if ( value !== undefined ) {
  				if ( hooks && "set" in hooks &&
  					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  					return ret;
  				}

  				return ( elem[ name ] = value );
  			}

  			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  				return ret;
  			}

  			return elem[ name ];
  		},

  		propHooks: {
  			tabIndex: {
  				get: function( elem ) {

  					// Support: IE <=9 - 11 only
  					// elem.tabIndex doesn't always return the
  					// correct value when it hasn't been explicitly set
  					// Use proper attribute retrieval (trac-12072)
  					var tabindex = jQuery.find.attr( elem, "tabindex" );

  					if ( tabindex ) {
  						return parseInt( tabindex, 10 );
  					}

  					if (
  						rfocusable.test( elem.nodeName ) ||
  						rclickable.test( elem.nodeName ) &&
  						elem.href
  					) {
  						return 0;
  					}

  					return -1;
  				}
  			}
  		},

  		propFix: {
  			"for": "htmlFor",
  			"class": "className"
  		}
  	} );

  	// Support: IE <=11 only
  	// Accessing the selectedIndex property
  	// forces the browser to respect setting selected
  	// on the option
  	// The getter ensures a default option is selected
  	// when in an optgroup
  	// eslint rule "no-unused-expressions" is disabled for this code
  	// since it considers such accessions noop
  	if ( !support.optSelected ) {
  		jQuery.propHooks.selected = {
  			get: function( elem ) {

  				/* eslint no-unused-expressions: "off" */

  				var parent = elem.parentNode;
  				if ( parent && parent.parentNode ) {
  					parent.parentNode.selectedIndex;
  				}
  				return null;
  			},
  			set: function( elem ) {

  				/* eslint no-unused-expressions: "off" */

  				var parent = elem.parentNode;
  				if ( parent ) {
  					parent.selectedIndex;

  					if ( parent.parentNode ) {
  						parent.parentNode.selectedIndex;
  					}
  				}
  			}
  		};
  	}

  	jQuery.each( [
  		"tabIndex",
  		"readOnly",
  		"maxLength",
  		"cellSpacing",
  		"cellPadding",
  		"rowSpan",
  		"colSpan",
  		"useMap",
  		"frameBorder",
  		"contentEditable"
  	], function() {
  		jQuery.propFix[ this.toLowerCase() ] = this;
  	} );




  		// Strip and collapse whitespace according to HTML spec
  		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
  		function stripAndCollapse( value ) {
  			var tokens = value.match( rnothtmlwhite ) || [];
  			return tokens.join( " " );
  		}


  	function getClass( elem ) {
  		return elem.getAttribute && elem.getAttribute( "class" ) || "";
  	}

  	function classesToArray( value ) {
  		if ( Array.isArray( value ) ) {
  			return value;
  		}
  		if ( typeof value === "string" ) {
  			return value.match( rnothtmlwhite ) || [];
  		}
  		return [];
  	}

  	jQuery.fn.extend( {
  		addClass: function( value ) {
  			var classNames, cur, curValue, className, i, finalValue;

  			if ( isFunction( value ) ) {
  				return this.each( function( j ) {
  					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
  				} );
  			}

  			classNames = classesToArray( value );

  			if ( classNames.length ) {
  				return this.each( function() {
  					curValue = getClass( this );
  					cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  					if ( cur ) {
  						for ( i = 0; i < classNames.length; i++ ) {
  							className = classNames[ i ];
  							if ( cur.indexOf( " " + className + " " ) < 0 ) {
  								cur += className + " ";
  							}
  						}

  						// Only assign if different to avoid unneeded rendering.
  						finalValue = stripAndCollapse( cur );
  						if ( curValue !== finalValue ) {
  							this.setAttribute( "class", finalValue );
  						}
  					}
  				} );
  			}

  			return this;
  		},

  		removeClass: function( value ) {
  			var classNames, cur, curValue, className, i, finalValue;

  			if ( isFunction( value ) ) {
  				return this.each( function( j ) {
  					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
  				} );
  			}

  			if ( !arguments.length ) {
  				return this.attr( "class", "" );
  			}

  			classNames = classesToArray( value );

  			if ( classNames.length ) {
  				return this.each( function() {
  					curValue = getClass( this );

  					// This expression is here for better compressibility (see addClass)
  					cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  					if ( cur ) {
  						for ( i = 0; i < classNames.length; i++ ) {
  							className = classNames[ i ];

  							// Remove *all* instances
  							while ( cur.indexOf( " " + className + " " ) > -1 ) {
  								cur = cur.replace( " " + className + " ", " " );
  							}
  						}

  						// Only assign if different to avoid unneeded rendering.
  						finalValue = stripAndCollapse( cur );
  						if ( curValue !== finalValue ) {
  							this.setAttribute( "class", finalValue );
  						}
  					}
  				} );
  			}

  			return this;
  		},

  		toggleClass: function( value, stateVal ) {
  			var classNames, className, i, self,
  				type = typeof value,
  				isValidValue = type === "string" || Array.isArray( value );

  			if ( isFunction( value ) ) {
  				return this.each( function( i ) {
  					jQuery( this ).toggleClass(
  						value.call( this, i, getClass( this ), stateVal ),
  						stateVal
  					);
  				} );
  			}

  			if ( typeof stateVal === "boolean" && isValidValue ) {
  				return stateVal ? this.addClass( value ) : this.removeClass( value );
  			}

  			classNames = classesToArray( value );

  			return this.each( function() {
  				if ( isValidValue ) {

  					// Toggle individual class names
  					self = jQuery( this );

  					for ( i = 0; i < classNames.length; i++ ) {
  						className = classNames[ i ];

  						// Check each className given, space separated list
  						if ( self.hasClass( className ) ) {
  							self.removeClass( className );
  						} else {
  							self.addClass( className );
  						}
  					}

  				// Toggle whole class name
  				} else if ( value === undefined || type === "boolean" ) {
  					className = getClass( this );
  					if ( className ) {

  						// Store className if set
  						dataPriv.set( this, "__className__", className );
  					}

  					// If the element has a class name or if we're passed `false`,
  					// then remove the whole classname (if there was one, the above saved it).
  					// Otherwise bring back whatever was previously saved (if anything),
  					// falling back to the empty string if nothing was stored.
  					if ( this.setAttribute ) {
  						this.setAttribute( "class",
  							className || value === false ?
  								"" :
  								dataPriv.get( this, "__className__" ) || ""
  						);
  					}
  				}
  			} );
  		},

  		hasClass: function( selector ) {
  			var className, elem,
  				i = 0;

  			className = " " + selector + " ";
  			while ( ( elem = this[ i++ ] ) ) {
  				if ( elem.nodeType === 1 &&
  					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
  					return true;
  				}
  			}

  			return false;
  		}
  	} );




  	var rreturn = /\r/g;

  	jQuery.fn.extend( {
  		val: function( value ) {
  			var hooks, ret, valueIsFunction,
  				elem = this[ 0 ];

  			if ( !arguments.length ) {
  				if ( elem ) {
  					hooks = jQuery.valHooks[ elem.type ] ||
  						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

  					if ( hooks &&
  						"get" in hooks &&
  						( ret = hooks.get( elem, "value" ) ) !== undefined
  					) {
  						return ret;
  					}

  					ret = elem.value;

  					// Handle most common string cases
  					if ( typeof ret === "string" ) {
  						return ret.replace( rreturn, "" );
  					}

  					// Handle cases where value is null/undef or number
  					return ret == null ? "" : ret;
  				}

  				return;
  			}

  			valueIsFunction = isFunction( value );

  			return this.each( function( i ) {
  				var val;

  				if ( this.nodeType !== 1 ) {
  					return;
  				}

  				if ( valueIsFunction ) {
  					val = value.call( this, i, jQuery( this ).val() );
  				} else {
  					val = value;
  				}

  				// Treat null/undefined as ""; convert numbers to string
  				if ( val == null ) {
  					val = "";

  				} else if ( typeof val === "number" ) {
  					val += "";

  				} else if ( Array.isArray( val ) ) {
  					val = jQuery.map( val, function( value ) {
  						return value == null ? "" : value + "";
  					} );
  				}

  				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

  				// If set returns undefined, fall back to normal setting
  				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
  					this.value = val;
  				}
  			} );
  		}
  	} );

  	jQuery.extend( {
  		valHooks: {
  			option: {
  				get: function( elem ) {

  					var val = jQuery.find.attr( elem, "value" );
  					return val != null ?
  						val :

  						// Support: IE <=10 - 11 only
  						// option.text throws exceptions (trac-14686, trac-14858)
  						// Strip and collapse whitespace
  						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
  						stripAndCollapse( jQuery.text( elem ) );
  				}
  			},
  			select: {
  				get: function( elem ) {
  					var value, option, i,
  						options = elem.options,
  						index = elem.selectedIndex,
  						one = elem.type === "select-one",
  						values = one ? null : [],
  						max = one ? index + 1 : options.length;

  					if ( index < 0 ) {
  						i = max;

  					} else {
  						i = one ? index : 0;
  					}

  					// Loop through all the selected options
  					for ( ; i < max; i++ ) {
  						option = options[ i ];

  						// Support: IE <=9 only
  						// IE8-9 doesn't update selected after form reset (trac-2551)
  						if ( ( option.selected || i === index ) &&

  								// Don't return options that are disabled or in a disabled optgroup
  								!option.disabled &&
  								( !option.parentNode.disabled ||
  									!nodeName( option.parentNode, "optgroup" ) ) ) {

  							// Get the specific value for the option
  							value = jQuery( option ).val();

  							// We don't need an array for one selects
  							if ( one ) {
  								return value;
  							}

  							// Multi-Selects return an array
  							values.push( value );
  						}
  					}

  					return values;
  				},

  				set: function( elem, value ) {
  					var optionSet, option,
  						options = elem.options,
  						values = jQuery.makeArray( value ),
  						i = options.length;

  					while ( i-- ) {
  						option = options[ i ];

  						/* eslint-disable no-cond-assign */

  						if ( option.selected =
  							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
  						) {
  							optionSet = true;
  						}

  						/* eslint-enable no-cond-assign */
  					}

  					// Force browsers to behave consistently when non-matching value is set
  					if ( !optionSet ) {
  						elem.selectedIndex = -1;
  					}
  					return values;
  				}
  			}
  		}
  	} );

  	// Radios and checkboxes getter/setter
  	jQuery.each( [ "radio", "checkbox" ], function() {
  		jQuery.valHooks[ this ] = {
  			set: function( elem, value ) {
  				if ( Array.isArray( value ) ) {
  					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
  				}
  			}
  		};
  		if ( !support.checkOn ) {
  			jQuery.valHooks[ this ].get = function( elem ) {
  				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
  			};
  		}
  	} );




  	// Return jQuery for attributes-only inclusion
  	var location = window.location;

  	var nonce = { guid: Date.now() };

  	var rquery = ( /\?/ );



  	// Cross-browser xml parsing
  	jQuery.parseXML = function( data ) {
  		var xml, parserErrorElem;
  		if ( !data || typeof data !== "string" ) {
  			return null;
  		}

  		// Support: IE 9 - 11 only
  		// IE throws on parseFromString with invalid input.
  		try {
  			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
  		} catch ( e ) {}

  		parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
  		if ( !xml || parserErrorElem ) {
  			jQuery.error( "Invalid XML: " + (
  				parserErrorElem ?
  					jQuery.map( parserErrorElem.childNodes, function( el ) {
  						return el.textContent;
  					} ).join( "\n" ) :
  					data
  			) );
  		}
  		return xml;
  	};


  	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  		stopPropagationCallback = function( e ) {
  			e.stopPropagation();
  		};

  	jQuery.extend( jQuery.event, {

  		trigger: function( event, data, elem, onlyHandlers ) {

  			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
  				eventPath = [ elem || document ],
  				type = hasOwn.call( event, "type" ) ? event.type : event,
  				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

  			cur = lastElement = tmp = elem = elem || document;

  			// Don't do events on text and comment nodes
  			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
  				return;
  			}

  			// focus/blur morphs to focusin/out; ensure we're not firing them right now
  			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
  				return;
  			}

  			if ( type.indexOf( "." ) > -1 ) {

  				// Namespaced trigger; create a regexp to match event type in handle()
  				namespaces = type.split( "." );
  				type = namespaces.shift();
  				namespaces.sort();
  			}
  			ontype = type.indexOf( ":" ) < 0 && "on" + type;

  			// Caller can pass in a jQuery.Event object, Object, or just an event type string
  			event = event[ jQuery.expando ] ?
  				event :
  				new jQuery.Event( type, typeof event === "object" && event );

  			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
  			event.isTrigger = onlyHandlers ? 2 : 3;
  			event.namespace = namespaces.join( "." );
  			event.rnamespace = event.namespace ?
  				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
  				null;

  			// Clean up the event in case it is being reused
  			event.result = undefined;
  			if ( !event.target ) {
  				event.target = elem;
  			}

  			// Clone any incoming data and prepend the event, creating the handler arg list
  			data = data == null ?
  				[ event ] :
  				jQuery.makeArray( data, [ event ] );

  			// Allow special events to draw outside the lines
  			special = jQuery.event.special[ type ] || {};
  			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
  				return;
  			}

  			// Determine event propagation path in advance, per W3C events spec (trac-9951)
  			// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
  			if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

  				bubbleType = special.delegateType || type;
  				if ( !rfocusMorph.test( bubbleType + type ) ) {
  					cur = cur.parentNode;
  				}
  				for ( ; cur; cur = cur.parentNode ) {
  					eventPath.push( cur );
  					tmp = cur;
  				}

  				// Only add window if we got to document (e.g., not plain obj or detached DOM)
  				if ( tmp === ( elem.ownerDocument || document ) ) {
  					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
  				}
  			}

  			// Fire handlers on the event path
  			i = 0;
  			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
  				lastElement = cur;
  				event.type = i > 1 ?
  					bubbleType :
  					special.bindType || type;

  				// jQuery handler
  				handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
  					dataPriv.get( cur, "handle" );
  				if ( handle ) {
  					handle.apply( cur, data );
  				}

  				// Native handler
  				handle = ontype && cur[ ontype ];
  				if ( handle && handle.apply && acceptData( cur ) ) {
  					event.result = handle.apply( cur, data );
  					if ( event.result === false ) {
  						event.preventDefault();
  					}
  				}
  			}
  			event.type = type;

  			// If nobody prevented the default action, do it now
  			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

  				if ( ( !special._default ||
  					special._default.apply( eventPath.pop(), data ) === false ) &&
  					acceptData( elem ) ) {

  					// Call a native DOM method on the target with the same name as the event.
  					// Don't do default actions on window, that's where global variables be (trac-6170)
  					if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

  						// Don't re-trigger an onFOO event when we call its FOO() method
  						tmp = elem[ ontype ];

  						if ( tmp ) {
  							elem[ ontype ] = null;
  						}

  						// Prevent re-triggering of the same event, since we already bubbled it above
  						jQuery.event.triggered = type;

  						if ( event.isPropagationStopped() ) {
  							lastElement.addEventListener( type, stopPropagationCallback );
  						}

  						elem[ type ]();

  						if ( event.isPropagationStopped() ) {
  							lastElement.removeEventListener( type, stopPropagationCallback );
  						}

  						jQuery.event.triggered = undefined;

  						if ( tmp ) {
  							elem[ ontype ] = tmp;
  						}
  					}
  				}
  			}

  			return event.result;
  		},

  		// Piggyback on a donor event to simulate a different one
  		// Used only for `focus(in | out)` events
  		simulate: function( type, elem, event ) {
  			var e = jQuery.extend(
  				new jQuery.Event(),
  				event,
  				{
  					type: type,
  					isSimulated: true
  				}
  			);

  			jQuery.event.trigger( e, null, elem );
  		}

  	} );

  	jQuery.fn.extend( {

  		trigger: function( type, data ) {
  			return this.each( function() {
  				jQuery.event.trigger( type, data, this );
  			} );
  		},
  		triggerHandler: function( type, data ) {
  			var elem = this[ 0 ];
  			if ( elem ) {
  				return jQuery.event.trigger( type, data, elem, true );
  			}
  		}
  	} );


  	var
  		rbracket = /\[\]$/,
  		rCRLF = /\r?\n/g,
  		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  		rsubmittable = /^(?:input|select|textarea|keygen)/i;

  	function buildParams( prefix, obj, traditional, add ) {
  		var name;

  		if ( Array.isArray( obj ) ) {

  			// Serialize array item.
  			jQuery.each( obj, function( i, v ) {
  				if ( traditional || rbracket.test( prefix ) ) {

  					// Treat each array item as a scalar.
  					add( prefix, v );

  				} else {

  					// Item is non-scalar (array or object), encode its numeric index.
  					buildParams(
  						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
  						v,
  						traditional,
  						add
  					);
  				}
  			} );

  		} else if ( !traditional && toType( obj ) === "object" ) {

  			// Serialize object item.
  			for ( name in obj ) {
  				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
  			}

  		} else {

  			// Serialize scalar item.
  			add( prefix, obj );
  		}
  	}

  	// Serialize an array of form elements or a set of
  	// key/values into a query string
  	jQuery.param = function( a, traditional ) {
  		var prefix,
  			s = [],
  			add = function( key, valueOrFunction ) {

  				// If value is a function, invoke it and use its return value
  				var value = isFunction( valueOrFunction ) ?
  					valueOrFunction() :
  					valueOrFunction;

  				s[ s.length ] = encodeURIComponent( key ) + "=" +
  					encodeURIComponent( value == null ? "" : value );
  			};

  		if ( a == null ) {
  			return "";
  		}

  		// If an array was passed in, assume that it is an array of form elements.
  		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

  			// Serialize the form elements
  			jQuery.each( a, function() {
  				add( this.name, this.value );
  			} );

  		} else {

  			// If traditional, encode the "old" way (the way 1.3.2 or older
  			// did it), otherwise encode params recursively.
  			for ( prefix in a ) {
  				buildParams( prefix, a[ prefix ], traditional, add );
  			}
  		}

  		// Return the resulting serialization
  		return s.join( "&" );
  	};

  	jQuery.fn.extend( {
  		serialize: function() {
  			return jQuery.param( this.serializeArray() );
  		},
  		serializeArray: function() {
  			return this.map( function() {

  				// Can add propHook for "elements" to filter or add form elements
  				var elements = jQuery.prop( this, "elements" );
  				return elements ? jQuery.makeArray( elements ) : this;
  			} ).filter( function() {
  				var type = this.type;

  				// Use .is( ":disabled" ) so that fieldset[disabled] works
  				return this.name && !jQuery( this ).is( ":disabled" ) &&
  					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
  					( this.checked || !rcheckableType.test( type ) );
  			} ).map( function( _i, elem ) {
  				var val = jQuery( this ).val();

  				if ( val == null ) {
  					return null;
  				}

  				if ( Array.isArray( val ) ) {
  					return jQuery.map( val, function( val ) {
  						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  					} );
  				}

  				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  			} ).get();
  		}
  	} );


  	var
  		r20 = /%20/g,
  		rhash = /#.*$/,
  		rantiCache = /([?&])_=[^&]*/,
  		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

  		// trac-7653, trac-8125, trac-8152: local protocol detection
  		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
  		rnoContent = /^(?:GET|HEAD)$/,
  		rprotocol = /^\/\//,

  		/* Prefilters
  		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  		 * 2) These are called:
  		 *    - BEFORE asking for a transport
  		 *    - AFTER param serialization (s.data is a string if s.processData is true)
  		 * 3) key is the dataType
  		 * 4) the catchall symbol "*" can be used
  		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  		 */
  		prefilters = {},

  		/* Transports bindings
  		 * 1) key is the dataType
  		 * 2) the catchall symbol "*" can be used
  		 * 3) selection will start with transport dataType and THEN go to "*" if needed
  		 */
  		transports = {},

  		// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
  		allTypes = "*/".concat( "*" ),

  		// Anchor tag for parsing the document origin
  		originAnchor = document.createElement( "a" );

  	originAnchor.href = location.href;

  	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  	function addToPrefiltersOrTransports( structure ) {

  		// dataTypeExpression is optional and defaults to "*"
  		return function( dataTypeExpression, func ) {

  			if ( typeof dataTypeExpression !== "string" ) {
  				func = dataTypeExpression;
  				dataTypeExpression = "*";
  			}

  			var dataType,
  				i = 0,
  				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

  			if ( isFunction( func ) ) {

  				// For each dataType in the dataTypeExpression
  				while ( ( dataType = dataTypes[ i++ ] ) ) {

  					// Prepend if requested
  					if ( dataType[ 0 ] === "+" ) {
  						dataType = dataType.slice( 1 ) || "*";
  						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

  					// Otherwise append
  					} else {
  						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
  					}
  				}
  			}
  		};
  	}

  	// Base inspection function for prefilters and transports
  	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

  		var inspected = {},
  			seekingTransport = ( structure === transports );

  		function inspect( dataType ) {
  			var selected;
  			inspected[ dataType ] = true;
  			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
  				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
  				if ( typeof dataTypeOrTransport === "string" &&
  					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

  					options.dataTypes.unshift( dataTypeOrTransport );
  					inspect( dataTypeOrTransport );
  					return false;
  				} else if ( seekingTransport ) {
  					return !( selected = dataTypeOrTransport );
  				}
  			} );
  			return selected;
  		}

  		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
  	}

  	// A special extend for ajax options
  	// that takes "flat" options (not to be deep extended)
  	// Fixes trac-9887
  	function ajaxExtend( target, src ) {
  		var key, deep,
  			flatOptions = jQuery.ajaxSettings.flatOptions || {};

  		for ( key in src ) {
  			if ( src[ key ] !== undefined ) {
  				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
  			}
  		}
  		if ( deep ) {
  			jQuery.extend( true, target, deep );
  		}

  		return target;
  	}

  	/* Handles responses to an ajax request:
  	 * - finds the right dataType (mediates between content-type and expected dataType)
  	 * - returns the corresponding response
  	 */
  	function ajaxHandleResponses( s, jqXHR, responses ) {

  		var ct, type, finalDataType, firstDataType,
  			contents = s.contents,
  			dataTypes = s.dataTypes;

  		// Remove auto dataType and get content-type in the process
  		while ( dataTypes[ 0 ] === "*" ) {
  			dataTypes.shift();
  			if ( ct === undefined ) {
  				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
  			}
  		}

  		// Check if we're dealing with a known content-type
  		if ( ct ) {
  			for ( type in contents ) {
  				if ( contents[ type ] && contents[ type ].test( ct ) ) {
  					dataTypes.unshift( type );
  					break;
  				}
  			}
  		}

  		// Check to see if we have a response for the expected dataType
  		if ( dataTypes[ 0 ] in responses ) {
  			finalDataType = dataTypes[ 0 ];
  		} else {

  			// Try convertible dataTypes
  			for ( type in responses ) {
  				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
  					finalDataType = type;
  					break;
  				}
  				if ( !firstDataType ) {
  					firstDataType = type;
  				}
  			}

  			// Or just use first one
  			finalDataType = finalDataType || firstDataType;
  		}

  		// If we found a dataType
  		// We add the dataType to the list if needed
  		// and return the corresponding response
  		if ( finalDataType ) {
  			if ( finalDataType !== dataTypes[ 0 ] ) {
  				dataTypes.unshift( finalDataType );
  			}
  			return responses[ finalDataType ];
  		}
  	}

  	/* Chain conversions given the request and the original response
  	 * Also sets the responseXXX fields on the jqXHR instance
  	 */
  	function ajaxConvert( s, response, jqXHR, isSuccess ) {
  		var conv2, current, conv, tmp, prev,
  			converters = {},

  			// Work with a copy of dataTypes in case we need to modify it for conversion
  			dataTypes = s.dataTypes.slice();

  		// Create converters map with lowercased keys
  		if ( dataTypes[ 1 ] ) {
  			for ( conv in s.converters ) {
  				converters[ conv.toLowerCase() ] = s.converters[ conv ];
  			}
  		}

  		current = dataTypes.shift();

  		// Convert to each sequential dataType
  		while ( current ) {

  			if ( s.responseFields[ current ] ) {
  				jqXHR[ s.responseFields[ current ] ] = response;
  			}

  			// Apply the dataFilter if provided
  			if ( !prev && isSuccess && s.dataFilter ) {
  				response = s.dataFilter( response, s.dataType );
  			}

  			prev = current;
  			current = dataTypes.shift();

  			if ( current ) {

  				// There's only work to do if current dataType is non-auto
  				if ( current === "*" ) {

  					current = prev;

  				// Convert response if prev dataType is non-auto and differs from current
  				} else if ( prev !== "*" && prev !== current ) {

  					// Seek a direct converter
  					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

  					// If none found, seek a pair
  					if ( !conv ) {
  						for ( conv2 in converters ) {

  							// If conv2 outputs current
  							tmp = conv2.split( " " );
  							if ( tmp[ 1 ] === current ) {

  								// If prev can be converted to accepted input
  								conv = converters[ prev + " " + tmp[ 0 ] ] ||
  									converters[ "* " + tmp[ 0 ] ];
  								if ( conv ) {

  									// Condense equivalence converters
  									if ( conv === true ) {
  										conv = converters[ conv2 ];

  									// Otherwise, insert the intermediate dataType
  									} else if ( converters[ conv2 ] !== true ) {
  										current = tmp[ 0 ];
  										dataTypes.unshift( tmp[ 1 ] );
  									}
  									break;
  								}
  							}
  						}
  					}

  					// Apply converter (if not an equivalence)
  					if ( conv !== true ) {

  						// Unless errors are allowed to bubble, catch and return them
  						if ( conv && s.throws ) {
  							response = conv( response );
  						} else {
  							try {
  								response = conv( response );
  							} catch ( e ) {
  								return {
  									state: "parsererror",
  									error: conv ? e : "No conversion from " + prev + " to " + current
  								};
  							}
  						}
  					}
  				}
  			}
  		}

  		return { state: "success", data: response };
  	}

  	jQuery.extend( {

  		// Counter for holding the number of active queries
  		active: 0,

  		// Last-Modified header cache for next request
  		lastModified: {},
  		etag: {},

  		ajaxSettings: {
  			url: location.href,
  			type: "GET",
  			isLocal: rlocalProtocol.test( location.protocol ),
  			global: true,
  			processData: true,
  			async: true,
  			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

  			/*
  			timeout: 0,
  			data: null,
  			dataType: null,
  			username: null,
  			password: null,
  			cache: null,
  			throws: false,
  			traditional: false,
  			headers: {},
  			*/

  			accepts: {
  				"*": allTypes,
  				text: "text/plain",
  				html: "text/html",
  				xml: "application/xml, text/xml",
  				json: "application/json, text/javascript"
  			},

  			contents: {
  				xml: /\bxml\b/,
  				html: /\bhtml/,
  				json: /\bjson\b/
  			},

  			responseFields: {
  				xml: "responseXML",
  				text: "responseText",
  				json: "responseJSON"
  			},

  			// Data converters
  			// Keys separate source (or catchall "*") and destination types with a single space
  			converters: {

  				// Convert anything to text
  				"* text": String,

  				// Text to html (true = no transformation)
  				"text html": true,

  				// Evaluate text as a json expression
  				"text json": JSON.parse,

  				// Parse text as xml
  				"text xml": jQuery.parseXML
  			},

  			// For options that shouldn't be deep extended:
  			// you can add your own custom options here if
  			// and when you create one that shouldn't be
  			// deep extended (see ajaxExtend)
  			flatOptions: {
  				url: true,
  				context: true
  			}
  		},

  		// Creates a full fledged settings object into target
  		// with both ajaxSettings and settings fields.
  		// If target is omitted, writes into ajaxSettings.
  		ajaxSetup: function( target, settings ) {
  			return settings ?

  				// Building a settings object
  				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

  				// Extending ajaxSettings
  				ajaxExtend( jQuery.ajaxSettings, target );
  		},

  		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  		ajaxTransport: addToPrefiltersOrTransports( transports ),

  		// Main method
  		ajax: function( url, options ) {

  			// If url is an object, simulate pre-1.5 signature
  			if ( typeof url === "object" ) {
  				options = url;
  				url = undefined;
  			}

  			// Force options to be an object
  			options = options || {};

  			var transport,

  				// URL without anti-cache param
  				cacheURL,

  				// Response headers
  				responseHeadersString,
  				responseHeaders,

  				// timeout handle
  				timeoutTimer,

  				// Url cleanup var
  				urlAnchor,

  				// Request state (becomes false upon send and true upon completion)
  				completed,

  				// To know if global events are to be dispatched
  				fireGlobals,

  				// Loop variable
  				i,

  				// uncached part of the url
  				uncached,

  				// Create the final options object
  				s = jQuery.ajaxSetup( {}, options ),

  				// Callbacks context
  				callbackContext = s.context || s,

  				// Context for global events is callbackContext if it is a DOM node or jQuery collection
  				globalEventContext = s.context &&
  					( callbackContext.nodeType || callbackContext.jquery ) ?
  					jQuery( callbackContext ) :
  					jQuery.event,

  				// Deferreds
  				deferred = jQuery.Deferred(),
  				completeDeferred = jQuery.Callbacks( "once memory" ),

  				// Status-dependent callbacks
  				statusCode = s.statusCode || {},

  				// Headers (they are sent all at once)
  				requestHeaders = {},
  				requestHeadersNames = {},

  				// Default abort message
  				strAbort = "canceled",

  				// Fake xhr
  				jqXHR = {
  					readyState: 0,

  					// Builds headers hashtable if needed
  					getResponseHeader: function( key ) {
  						var match;
  						if ( completed ) {
  							if ( !responseHeaders ) {
  								responseHeaders = {};
  								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
  									responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
  										( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
  											.concat( match[ 2 ] );
  								}
  							}
  							match = responseHeaders[ key.toLowerCase() + " " ];
  						}
  						return match == null ? null : match.join( ", " );
  					},

  					// Raw string
  					getAllResponseHeaders: function() {
  						return completed ? responseHeadersString : null;
  					},

  					// Caches the header
  					setRequestHeader: function( name, value ) {
  						if ( completed == null ) {
  							name = requestHeadersNames[ name.toLowerCase() ] =
  								requestHeadersNames[ name.toLowerCase() ] || name;
  							requestHeaders[ name ] = value;
  						}
  						return this;
  					},

  					// Overrides response content-type header
  					overrideMimeType: function( type ) {
  						if ( completed == null ) {
  							s.mimeType = type;
  						}
  						return this;
  					},

  					// Status-dependent callbacks
  					statusCode: function( map ) {
  						var code;
  						if ( map ) {
  							if ( completed ) {

  								// Execute the appropriate callbacks
  								jqXHR.always( map[ jqXHR.status ] );
  							} else {

  								// Lazy-add the new callbacks in a way that preserves old ones
  								for ( code in map ) {
  									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
  								}
  							}
  						}
  						return this;
  					},

  					// Cancel the request
  					abort: function( statusText ) {
  						var finalText = statusText || strAbort;
  						if ( transport ) {
  							transport.abort( finalText );
  						}
  						done( 0, finalText );
  						return this;
  					}
  				};

  			// Attach deferreds
  			deferred.promise( jqXHR );

  			// Add protocol if not provided (prefilters might expect it)
  			// Handle falsy url in the settings object (trac-10093: consistency with old signature)
  			// We also use the url parameter if available
  			s.url = ( ( url || s.url || location.href ) + "" )
  				.replace( rprotocol, location.protocol + "//" );

  			// Alias method option to type as per ticket trac-12004
  			s.type = options.method || options.type || s.method || s.type;

  			// Extract dataTypes list
  			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

  			// A cross-domain request is in order when the origin doesn't match the current origin.
  			if ( s.crossDomain == null ) {
  				urlAnchor = document.createElement( "a" );

  				// Support: IE <=8 - 11, Edge 12 - 15
  				// IE throws exception on accessing the href property if url is malformed,
  				// e.g. http://example.com:80x/
  				try {
  					urlAnchor.href = s.url;

  					// Support: IE <=8 - 11 only
  					// Anchor's host property isn't correctly set when s.url is relative
  					urlAnchor.href = urlAnchor.href;
  					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
  						urlAnchor.protocol + "//" + urlAnchor.host;
  				} catch ( e ) {

  					// If there is an error parsing the URL, assume it is crossDomain,
  					// it can be rejected by the transport if it is invalid
  					s.crossDomain = true;
  				}
  			}

  			// Convert data if not already a string
  			if ( s.data && s.processData && typeof s.data !== "string" ) {
  				s.data = jQuery.param( s.data, s.traditional );
  			}

  			// Apply prefilters
  			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

  			// If request was aborted inside a prefilter, stop there
  			if ( completed ) {
  				return jqXHR;
  			}

  			// We can fire global events as of now if asked to
  			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
  			fireGlobals = jQuery.event && s.global;

  			// Watch for a new set of requests
  			if ( fireGlobals && jQuery.active++ === 0 ) {
  				jQuery.event.trigger( "ajaxStart" );
  			}

  			// Uppercase the type
  			s.type = s.type.toUpperCase();

  			// Determine if request has content
  			s.hasContent = !rnoContent.test( s.type );

  			// Save the URL in case we're toying with the If-Modified-Since
  			// and/or If-None-Match header later on
  			// Remove hash to simplify url manipulation
  			cacheURL = s.url.replace( rhash, "" );

  			// More options handling for requests with no content
  			if ( !s.hasContent ) {

  				// Remember the hash so we can put it back
  				uncached = s.url.slice( cacheURL.length );

  				// If data is available and should be processed, append data to url
  				if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
  					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

  					// trac-9682: remove data so that it's not used in an eventual retry
  					delete s.data;
  				}

  				// Add or update anti-cache param if needed
  				if ( s.cache === false ) {
  					cacheURL = cacheURL.replace( rantiCache, "$1" );
  					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
  						uncached;
  				}

  				// Put hash and anti-cache on the URL that will be requested (gh-1732)
  				s.url = cacheURL + uncached;

  			// Change '%20' to '+' if this is encoded form body content (gh-2658)
  			} else if ( s.data && s.processData &&
  				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
  				s.data = s.data.replace( r20, "+" );
  			}

  			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  			if ( s.ifModified ) {
  				if ( jQuery.lastModified[ cacheURL ] ) {
  					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
  				}
  				if ( jQuery.etag[ cacheURL ] ) {
  					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
  				}
  			}

  			// Set the correct header, if data is being sent
  			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
  				jqXHR.setRequestHeader( "Content-Type", s.contentType );
  			}

  			// Set the Accepts header for the server, depending on the dataType
  			jqXHR.setRequestHeader(
  				"Accept",
  				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
  					s.accepts[ s.dataTypes[ 0 ] ] +
  						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
  					s.accepts[ "*" ]
  			);

  			// Check for headers option
  			for ( i in s.headers ) {
  				jqXHR.setRequestHeader( i, s.headers[ i ] );
  			}

  			// Allow custom headers/mimetypes and early abort
  			if ( s.beforeSend &&
  				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

  				// Abort if not done already and return
  				return jqXHR.abort();
  			}

  			// Aborting is no longer a cancellation
  			strAbort = "abort";

  			// Install callbacks on deferreds
  			completeDeferred.add( s.complete );
  			jqXHR.done( s.success );
  			jqXHR.fail( s.error );

  			// Get transport
  			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

  			// If no transport, we auto-abort
  			if ( !transport ) {
  				done( -1, "No Transport" );
  			} else {
  				jqXHR.readyState = 1;

  				// Send global event
  				if ( fireGlobals ) {
  					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
  				}

  				// If request was aborted inside ajaxSend, stop there
  				if ( completed ) {
  					return jqXHR;
  				}

  				// Timeout
  				if ( s.async && s.timeout > 0 ) {
  					timeoutTimer = window.setTimeout( function() {
  						jqXHR.abort( "timeout" );
  					}, s.timeout );
  				}

  				try {
  					completed = false;
  					transport.send( requestHeaders, done );
  				} catch ( e ) {

  					// Rethrow post-completion exceptions
  					if ( completed ) {
  						throw e;
  					}

  					// Propagate others as results
  					done( -1, e );
  				}
  			}

  			// Callback for when everything is done
  			function done( status, nativeStatusText, responses, headers ) {
  				var isSuccess, success, error, response, modified,
  					statusText = nativeStatusText;

  				// Ignore repeat invocations
  				if ( completed ) {
  					return;
  				}

  				completed = true;

  				// Clear timeout if it exists
  				if ( timeoutTimer ) {
  					window.clearTimeout( timeoutTimer );
  				}

  				// Dereference transport for early garbage collection
  				// (no matter how long the jqXHR object will be used)
  				transport = undefined;

  				// Cache response headers
  				responseHeadersString = headers || "";

  				// Set readyState
  				jqXHR.readyState = status > 0 ? 4 : 0;

  				// Determine if successful
  				isSuccess = status >= 200 && status < 300 || status === 304;

  				// Get response data
  				if ( responses ) {
  					response = ajaxHandleResponses( s, jqXHR, responses );
  				}

  				// Use a noop converter for missing script but not if jsonp
  				if ( !isSuccess &&
  					jQuery.inArray( "script", s.dataTypes ) > -1 &&
  					jQuery.inArray( "json", s.dataTypes ) < 0 ) {
  					s.converters[ "text script" ] = function() {};
  				}

  				// Convert no matter what (that way responseXXX fields are always set)
  				response = ajaxConvert( s, response, jqXHR, isSuccess );

  				// If successful, handle type chaining
  				if ( isSuccess ) {

  					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  					if ( s.ifModified ) {
  						modified = jqXHR.getResponseHeader( "Last-Modified" );
  						if ( modified ) {
  							jQuery.lastModified[ cacheURL ] = modified;
  						}
  						modified = jqXHR.getResponseHeader( "etag" );
  						if ( modified ) {
  							jQuery.etag[ cacheURL ] = modified;
  						}
  					}

  					// if no content
  					if ( status === 204 || s.type === "HEAD" ) {
  						statusText = "nocontent";

  					// if not modified
  					} else if ( status === 304 ) {
  						statusText = "notmodified";

  					// If we have data, let's convert it
  					} else {
  						statusText = response.state;
  						success = response.data;
  						error = response.error;
  						isSuccess = !error;
  					}
  				} else {

  					// Extract error from statusText and normalize for non-aborts
  					error = statusText;
  					if ( status || !statusText ) {
  						statusText = "error";
  						if ( status < 0 ) {
  							status = 0;
  						}
  					}
  				}

  				// Set data for the fake xhr object
  				jqXHR.status = status;
  				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

  				// Success/Error
  				if ( isSuccess ) {
  					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
  				} else {
  					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
  				}

  				// Status-dependent callbacks
  				jqXHR.statusCode( statusCode );
  				statusCode = undefined;

  				if ( fireGlobals ) {
  					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
  						[ jqXHR, s, isSuccess ? success : error ] );
  				}

  				// Complete
  				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

  				if ( fireGlobals ) {
  					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

  					// Handle the global AJAX counter
  					if ( !( --jQuery.active ) ) {
  						jQuery.event.trigger( "ajaxStop" );
  					}
  				}
  			}

  			return jqXHR;
  		},

  		getJSON: function( url, data, callback ) {
  			return jQuery.get( url, data, callback, "json" );
  		},

  		getScript: function( url, callback ) {
  			return jQuery.get( url, undefined, callback, "script" );
  		}
  	} );

  	jQuery.each( [ "get", "post" ], function( _i, method ) {
  		jQuery[ method ] = function( url, data, callback, type ) {

  			// Shift arguments if data argument was omitted
  			if ( isFunction( data ) ) {
  				type = type || callback;
  				callback = data;
  				data = undefined;
  			}

  			// The url can be an options object (which then must have .url)
  			return jQuery.ajax( jQuery.extend( {
  				url: url,
  				type: method,
  				dataType: type,
  				data: data,
  				success: callback
  			}, jQuery.isPlainObject( url ) && url ) );
  		};
  	} );

  	jQuery.ajaxPrefilter( function( s ) {
  		var i;
  		for ( i in s.headers ) {
  			if ( i.toLowerCase() === "content-type" ) {
  				s.contentType = s.headers[ i ] || "";
  			}
  		}
  	} );


  	jQuery._evalUrl = function( url, options, doc ) {
  		return jQuery.ajax( {
  			url: url,

  			// Make this explicit, since user can override this through ajaxSetup (trac-11264)
  			type: "GET",
  			dataType: "script",
  			cache: true,
  			async: false,
  			global: false,

  			// Only evaluate the response if it is successful (gh-4126)
  			// dataFilter is not invoked for failure responses, so using it instead
  			// of the default converter is kludgy but it works.
  			converters: {
  				"text script": function() {}
  			},
  			dataFilter: function( response ) {
  				jQuery.globalEval( response, options, doc );
  			}
  		} );
  	};


  	jQuery.fn.extend( {
  		wrapAll: function( html ) {
  			var wrap;

  			if ( this[ 0 ] ) {
  				if ( isFunction( html ) ) {
  					html = html.call( this[ 0 ] );
  				}

  				// The elements to wrap the target around
  				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

  				if ( this[ 0 ].parentNode ) {
  					wrap.insertBefore( this[ 0 ] );
  				}

  				wrap.map( function() {
  					var elem = this;

  					while ( elem.firstElementChild ) {
  						elem = elem.firstElementChild;
  					}

  					return elem;
  				} ).append( this );
  			}

  			return this;
  		},

  		wrapInner: function( html ) {
  			if ( isFunction( html ) ) {
  				return this.each( function( i ) {
  					jQuery( this ).wrapInner( html.call( this, i ) );
  				} );
  			}

  			return this.each( function() {
  				var self = jQuery( this ),
  					contents = self.contents();

  				if ( contents.length ) {
  					contents.wrapAll( html );

  				} else {
  					self.append( html );
  				}
  			} );
  		},

  		wrap: function( html ) {
  			var htmlIsFunction = isFunction( html );

  			return this.each( function( i ) {
  				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
  			} );
  		},

  		unwrap: function( selector ) {
  			this.parent( selector ).not( "body" ).each( function() {
  				jQuery( this ).replaceWith( this.childNodes );
  			} );
  			return this;
  		}
  	} );


  	jQuery.expr.pseudos.hidden = function( elem ) {
  		return !jQuery.expr.pseudos.visible( elem );
  	};
  	jQuery.expr.pseudos.visible = function( elem ) {
  		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
  	};




  	jQuery.ajaxSettings.xhr = function() {
  		try {
  			return new window.XMLHttpRequest();
  		} catch ( e ) {}
  	};

  	var xhrSuccessStatus = {

  			// File protocol always yields status code 0, assume 200
  			0: 200,

  			// Support: IE <=9 only
  			// trac-1450: sometimes IE returns 1223 when it should be 204
  			1223: 204
  		},
  		xhrSupported = jQuery.ajaxSettings.xhr();

  	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
  	support.ajax = xhrSupported = !!xhrSupported;

  	jQuery.ajaxTransport( function( options ) {
  		var callback, errorCallback;

  		// Cross domain only allowed if supported through XMLHttpRequest
  		if ( support.cors || xhrSupported && !options.crossDomain ) {
  			return {
  				send: function( headers, complete ) {
  					var i,
  						xhr = options.xhr();

  					xhr.open(
  						options.type,
  						options.url,
  						options.async,
  						options.username,
  						options.password
  					);

  					// Apply custom fields if provided
  					if ( options.xhrFields ) {
  						for ( i in options.xhrFields ) {
  							xhr[ i ] = options.xhrFields[ i ];
  						}
  					}

  					// Override mime type if needed
  					if ( options.mimeType && xhr.overrideMimeType ) {
  						xhr.overrideMimeType( options.mimeType );
  					}

  					// X-Requested-With header
  					// For cross-domain requests, seeing as conditions for a preflight are
  					// akin to a jigsaw puzzle, we simply never set it to be sure.
  					// (it can always be set on a per-request basis or even using ajaxSetup)
  					// For same-domain requests, won't change header if already provided.
  					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
  						headers[ "X-Requested-With" ] = "XMLHttpRequest";
  					}

  					// Set headers
  					for ( i in headers ) {
  						xhr.setRequestHeader( i, headers[ i ] );
  					}

  					// Callback
  					callback = function( type ) {
  						return function() {
  							if ( callback ) {
  								callback = errorCallback = xhr.onload =
  									xhr.onerror = xhr.onabort = xhr.ontimeout =
  										xhr.onreadystatechange = null;

  								if ( type === "abort" ) {
  									xhr.abort();
  								} else if ( type === "error" ) {

  									// Support: IE <=9 only
  									// On a manual native abort, IE9 throws
  									// errors on any property access that is not readyState
  									if ( typeof xhr.status !== "number" ) {
  										complete( 0, "error" );
  									} else {
  										complete(

  											// File: protocol always yields status 0; see trac-8605, trac-14207
  											xhr.status,
  											xhr.statusText
  										);
  									}
  								} else {
  									complete(
  										xhrSuccessStatus[ xhr.status ] || xhr.status,
  										xhr.statusText,

  										// Support: IE <=9 only
  										// IE9 has no XHR2 but throws on binary (trac-11426)
  										// For XHR2 non-text, let the caller handle it (gh-2498)
  										( xhr.responseType || "text" ) !== "text"  ||
  										typeof xhr.responseText !== "string" ?
  											{ binary: xhr.response } :
  											{ text: xhr.responseText },
  										xhr.getAllResponseHeaders()
  									);
  								}
  							}
  						};
  					};

  					// Listen to events
  					xhr.onload = callback();
  					errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

  					// Support: IE 9 only
  					// Use onreadystatechange to replace onabort
  					// to handle uncaught aborts
  					if ( xhr.onabort !== undefined ) {
  						xhr.onabort = errorCallback;
  					} else {
  						xhr.onreadystatechange = function() {

  							// Check readyState before timeout as it changes
  							if ( xhr.readyState === 4 ) {

  								// Allow onerror to be called first,
  								// but that will not handle a native abort
  								// Also, save errorCallback to a variable
  								// as xhr.onerror cannot be accessed
  								window.setTimeout( function() {
  									if ( callback ) {
  										errorCallback();
  									}
  								} );
  							}
  						};
  					}

  					// Create the abort callback
  					callback = callback( "abort" );

  					try {

  						// Do send the request (this may raise an exception)
  						xhr.send( options.hasContent && options.data || null );
  					} catch ( e ) {

  						// trac-14683: Only rethrow if this hasn't been notified as an error yet
  						if ( callback ) {
  							throw e;
  						}
  					}
  				},

  				abort: function() {
  					if ( callback ) {
  						callback();
  					}
  				}
  			};
  		}
  	} );




  	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
  	jQuery.ajaxPrefilter( function( s ) {
  		if ( s.crossDomain ) {
  			s.contents.script = false;
  		}
  	} );

  	// Install script dataType
  	jQuery.ajaxSetup( {
  		accepts: {
  			script: "text/javascript, application/javascript, " +
  				"application/ecmascript, application/x-ecmascript"
  		},
  		contents: {
  			script: /\b(?:java|ecma)script\b/
  		},
  		converters: {
  			"text script": function( text ) {
  				jQuery.globalEval( text );
  				return text;
  			}
  		}
  	} );

  	// Handle cache's special case and crossDomain
  	jQuery.ajaxPrefilter( "script", function( s ) {
  		if ( s.cache === undefined ) {
  			s.cache = false;
  		}
  		if ( s.crossDomain ) {
  			s.type = "GET";
  		}
  	} );

  	// Bind script tag hack transport
  	jQuery.ajaxTransport( "script", function( s ) {

  		// This transport only deals with cross domain or forced-by-attrs requests
  		if ( s.crossDomain || s.scriptAttrs ) {
  			var script, callback;
  			return {
  				send: function( _, complete ) {
  					script = jQuery( "<script>" )
  						.attr( s.scriptAttrs || {} )
  						.prop( { charset: s.scriptCharset, src: s.url } )
  						.on( "load error", callback = function( evt ) {
  							script.remove();
  							callback = null;
  							if ( evt ) {
  								complete( evt.type === "error" ? 404 : 200, evt.type );
  							}
  						} );

  					// Use native DOM manipulation to avoid our domManip AJAX trickery
  					document.head.appendChild( script[ 0 ] );
  				},
  				abort: function() {
  					if ( callback ) {
  						callback();
  					}
  				}
  			};
  		}
  	} );




  	var oldCallbacks = [],
  		rjsonp = /(=)\?(?=&|$)|\?\?/;

  	// Default jsonp settings
  	jQuery.ajaxSetup( {
  		jsonp: "callback",
  		jsonpCallback: function() {
  			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
  			this[ callback ] = true;
  			return callback;
  		}
  	} );

  	// Detect, normalize options and install callbacks for jsonp requests
  	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  		var callbackName, overwritten, responseContainer,
  			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
  				"url" :
  				typeof s.data === "string" &&
  					( s.contentType || "" )
  						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
  					rjsonp.test( s.data ) && "data"
  			);

  		// Handle iff the expected data type is "jsonp" or we have a parameter to set
  		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

  			// Get callback name, remembering preexisting value associated with it
  			callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
  				s.jsonpCallback() :
  				s.jsonpCallback;

  			// Insert callback into url or form data
  			if ( jsonProp ) {
  				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
  			} else if ( s.jsonp !== false ) {
  				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
  			}

  			// Use data converter to retrieve json after script execution
  			s.converters[ "script json" ] = function() {
  				if ( !responseContainer ) {
  					jQuery.error( callbackName + " was not called" );
  				}
  				return responseContainer[ 0 ];
  			};

  			// Force json dataType
  			s.dataTypes[ 0 ] = "json";

  			// Install callback
  			overwritten = window[ callbackName ];
  			window[ callbackName ] = function() {
  				responseContainer = arguments;
  			};

  			// Clean-up function (fires after converters)
  			jqXHR.always( function() {

  				// If previous value didn't exist - remove it
  				if ( overwritten === undefined ) {
  					jQuery( window ).removeProp( callbackName );

  				// Otherwise restore preexisting value
  				} else {
  					window[ callbackName ] = overwritten;
  				}

  				// Save back as free
  				if ( s[ callbackName ] ) {

  					// Make sure that re-using the options doesn't screw things around
  					s.jsonpCallback = originalSettings.jsonpCallback;

  					// Save the callback name for future use
  					oldCallbacks.push( callbackName );
  				}

  				// Call if it was a function and we have a response
  				if ( responseContainer && isFunction( overwritten ) ) {
  					overwritten( responseContainer[ 0 ] );
  				}

  				responseContainer = overwritten = undefined;
  			} );

  			// Delegate to script
  			return "script";
  		}
  	} );




  	// Support: Safari 8 only
  	// In Safari 8 documents created via document.implementation.createHTMLDocument
  	// collapse sibling forms: the second one becomes a child of the first one.
  	// Because of that, this security measure has to be disabled in Safari 8.
  	// https://bugs.webkit.org/show_bug.cgi?id=137337
  	support.createHTMLDocument = ( function() {
  		var body = document.implementation.createHTMLDocument( "" ).body;
  		body.innerHTML = "<form></form><form></form>";
  		return body.childNodes.length === 2;
  	} )();


  	// Argument "data" should be string of html
  	// context (optional): If specified, the fragment will be created in this context,
  	// defaults to document
  	// keepScripts (optional): If true, will include scripts passed in the html string
  	jQuery.parseHTML = function( data, context, keepScripts ) {
  		if ( typeof data !== "string" ) {
  			return [];
  		}
  		if ( typeof context === "boolean" ) {
  			keepScripts = context;
  			context = false;
  		}

  		var base, parsed, scripts;

  		if ( !context ) {

  			// Stop scripts or inline event handlers from being executed immediately
  			// by using document.implementation
  			if ( support.createHTMLDocument ) {
  				context = document.implementation.createHTMLDocument( "" );

  				// Set the base href for the created document
  				// so any parsed elements with URLs
  				// are based on the document's URL (gh-2965)
  				base = context.createElement( "base" );
  				base.href = document.location.href;
  				context.head.appendChild( base );
  			} else {
  				context = document;
  			}
  		}

  		parsed = rsingleTag.exec( data );
  		scripts = !keepScripts && [];

  		// Single tag
  		if ( parsed ) {
  			return [ context.createElement( parsed[ 1 ] ) ];
  		}

  		parsed = buildFragment( [ data ], context, scripts );

  		if ( scripts && scripts.length ) {
  			jQuery( scripts ).remove();
  		}

  		return jQuery.merge( [], parsed.childNodes );
  	};


  	/**
  	 * Load a url into a page
  	 */
  	jQuery.fn.load = function( url, params, callback ) {
  		var selector, type, response,
  			self = this,
  			off = url.indexOf( " " );

  		if ( off > -1 ) {
  			selector = stripAndCollapse( url.slice( off ) );
  			url = url.slice( 0, off );
  		}

  		// If it's a function
  		if ( isFunction( params ) ) {

  			// We assume that it's the callback
  			callback = params;
  			params = undefined;

  		// Otherwise, build a param string
  		} else if ( params && typeof params === "object" ) {
  			type = "POST";
  		}

  		// If we have elements to modify, make the request
  		if ( self.length > 0 ) {
  			jQuery.ajax( {
  				url: url,

  				// If "type" variable is undefined, then "GET" method will be used.
  				// Make value of this field explicit since
  				// user can override it through ajaxSetup method
  				type: type || "GET",
  				dataType: "html",
  				data: params
  			} ).done( function( responseText ) {

  				// Save response for use in complete callback
  				response = arguments;

  				self.html( selector ?

  					// If a selector was specified, locate the right elements in a dummy div
  					// Exclude scripts to avoid IE 'Permission Denied' errors
  					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

  					// Otherwise use the full result
  					responseText );

  			// If the request succeeds, this function gets "data", "status", "jqXHR"
  			// but they are ignored because response was set above.
  			// If it fails, this function gets "jqXHR", "status", "error"
  			} ).always( callback && function( jqXHR, status ) {
  				self.each( function() {
  					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
  				} );
  			} );
  		}

  		return this;
  	};




  	jQuery.expr.pseudos.animated = function( elem ) {
  		return jQuery.grep( jQuery.timers, function( fn ) {
  			return elem === fn.elem;
  		} ).length;
  	};




  	jQuery.offset = {
  		setOffset: function( elem, options, i ) {
  			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
  				position = jQuery.css( elem, "position" ),
  				curElem = jQuery( elem ),
  				props = {};

  			// Set position first, in-case top/left are set even on static elem
  			if ( position === "static" ) {
  				elem.style.position = "relative";
  			}

  			curOffset = curElem.offset();
  			curCSSTop = jQuery.css( elem, "top" );
  			curCSSLeft = jQuery.css( elem, "left" );
  			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
  				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

  			// Need to be able to calculate position if either
  			// top or left is auto and position is either absolute or fixed
  			if ( calculatePosition ) {
  				curPosition = curElem.position();
  				curTop = curPosition.top;
  				curLeft = curPosition.left;

  			} else {
  				curTop = parseFloat( curCSSTop ) || 0;
  				curLeft = parseFloat( curCSSLeft ) || 0;
  			}

  			if ( isFunction( options ) ) {

  				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
  				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
  			}

  			if ( options.top != null ) {
  				props.top = ( options.top - curOffset.top ) + curTop;
  			}
  			if ( options.left != null ) {
  				props.left = ( options.left - curOffset.left ) + curLeft;
  			}

  			if ( "using" in options ) {
  				options.using.call( elem, props );

  			} else {
  				curElem.css( props );
  			}
  		}
  	};

  	jQuery.fn.extend( {

  		// offset() relates an element's border box to the document origin
  		offset: function( options ) {

  			// Preserve chaining for setter
  			if ( arguments.length ) {
  				return options === undefined ?
  					this :
  					this.each( function( i ) {
  						jQuery.offset.setOffset( this, options, i );
  					} );
  			}

  			var rect, win,
  				elem = this[ 0 ];

  			if ( !elem ) {
  				return;
  			}

  			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
  			// Support: IE <=11 only
  			// Running getBoundingClientRect on a
  			// disconnected node in IE throws an error
  			if ( !elem.getClientRects().length ) {
  				return { top: 0, left: 0 };
  			}

  			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
  			rect = elem.getBoundingClientRect();
  			win = elem.ownerDocument.defaultView;
  			return {
  				top: rect.top + win.pageYOffset,
  				left: rect.left + win.pageXOffset
  			};
  		},

  		// position() relates an element's margin box to its offset parent's padding box
  		// This corresponds to the behavior of CSS absolute positioning
  		position: function() {
  			if ( !this[ 0 ] ) {
  				return;
  			}

  			var offsetParent, offset, doc,
  				elem = this[ 0 ],
  				parentOffset = { top: 0, left: 0 };

  			// position:fixed elements are offset from the viewport, which itself always has zero offset
  			if ( jQuery.css( elem, "position" ) === "fixed" ) {

  				// Assume position:fixed implies availability of getBoundingClientRect
  				offset = elem.getBoundingClientRect();

  			} else {
  				offset = this.offset();

  				// Account for the *real* offset parent, which can be the document or its root element
  				// when a statically positioned element is identified
  				doc = elem.ownerDocument;
  				offsetParent = elem.offsetParent || doc.documentElement;
  				while ( offsetParent &&
  					( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
  					jQuery.css( offsetParent, "position" ) === "static" ) {

  					offsetParent = offsetParent.parentNode;
  				}
  				if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

  					// Incorporate borders into its offset, since they are outside its content origin
  					parentOffset = jQuery( offsetParent ).offset();
  					parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
  					parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
  				}
  			}

  			// Subtract parent offsets and element margins
  			return {
  				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
  				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
  			};
  		},

  		// This method will return documentElement in the following cases:
  		// 1) For the element inside the iframe without offsetParent, this method will return
  		//    documentElement of the parent window
  		// 2) For the hidden or detached element
  		// 3) For body or html element, i.e. in case of the html node - it will return itself
  		//
  		// but those exceptions were never presented as a real life use-cases
  		// and might be considered as more preferable results.
  		//
  		// This logic, however, is not guaranteed and can change at any point in the future
  		offsetParent: function() {
  			return this.map( function() {
  				var offsetParent = this.offsetParent;

  				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
  					offsetParent = offsetParent.offsetParent;
  				}

  				return offsetParent || documentElement;
  			} );
  		}
  	} );

  	// Create scrollLeft and scrollTop methods
  	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
  		var top = "pageYOffset" === prop;

  		jQuery.fn[ method ] = function( val ) {
  			return access( this, function( elem, method, val ) {

  				// Coalesce documents and windows
  				var win;
  				if ( isWindow( elem ) ) {
  					win = elem;
  				} else if ( elem.nodeType === 9 ) {
  					win = elem.defaultView;
  				}

  				if ( val === undefined ) {
  					return win ? win[ prop ] : elem[ method ];
  				}

  				if ( win ) {
  					win.scrollTo(
  						!top ? val : win.pageXOffset,
  						top ? val : win.pageYOffset
  					);

  				} else {
  					elem[ method ] = val;
  				}
  			}, method, val, arguments.length );
  		};
  	} );

  	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
  	// Add the top/left cssHooks using jQuery.fn.position
  	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  	// getComputedStyle returns percent when specified for top/left/bottom/right;
  	// rather than make the css module depend on the offset module, just check for it here
  	jQuery.each( [ "top", "left" ], function( _i, prop ) {
  		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
  			function( elem, computed ) {
  				if ( computed ) {
  					computed = curCSS( elem, prop );

  					// If curCSS returns percentage, fallback to offset
  					return rnumnonpx.test( computed ) ?
  						jQuery( elem ).position()[ prop ] + "px" :
  						computed;
  				}
  			}
  		);
  	} );


  	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  		jQuery.each( {
  			padding: "inner" + name,
  			content: type,
  			"": "outer" + name
  		}, function( defaultExtra, funcName ) {

  			// Margin is only for outerHeight, outerWidth
  			jQuery.fn[ funcName ] = function( margin, value ) {
  				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
  					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

  				return access( this, function( elem, type, value ) {
  					var doc;

  					if ( isWindow( elem ) ) {

  						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
  						return funcName.indexOf( "outer" ) === 0 ?
  							elem[ "inner" + name ] :
  							elem.document.documentElement[ "client" + name ];
  					}

  					// Get document width or height
  					if ( elem.nodeType === 9 ) {
  						doc = elem.documentElement;

  						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
  						// whichever is greatest
  						return Math.max(
  							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
  							elem.body[ "offset" + name ], doc[ "offset" + name ],
  							doc[ "client" + name ]
  						);
  					}

  					return value === undefined ?

  						// Get width or height on the element, requesting but not forcing parseFloat
  						jQuery.css( elem, type, extra ) :

  						// Set width or height on the element
  						jQuery.style( elem, type, value, extra );
  				}, type, chainable ? margin : undefined, chainable );
  			};
  		} );
  	} );


  	jQuery.each( [
  		"ajaxStart",
  		"ajaxStop",
  		"ajaxComplete",
  		"ajaxError",
  		"ajaxSuccess",
  		"ajaxSend"
  	], function( _i, type ) {
  		jQuery.fn[ type ] = function( fn ) {
  			return this.on( type, fn );
  		};
  	} );




  	jQuery.fn.extend( {

  		bind: function( types, data, fn ) {
  			return this.on( types, null, data, fn );
  		},
  		unbind: function( types, fn ) {
  			return this.off( types, null, fn );
  		},

  		delegate: function( selector, types, data, fn ) {
  			return this.on( types, selector, data, fn );
  		},
  		undelegate: function( selector, types, fn ) {

  			// ( namespace ) or ( selector, types [, fn] )
  			return arguments.length === 1 ?
  				this.off( selector, "**" ) :
  				this.off( types, selector || "**", fn );
  		},

  		hover: function( fnOver, fnOut ) {
  			return this
  				.on( "mouseenter", fnOver )
  				.on( "mouseleave", fnOut || fnOver );
  		}
  	} );

  	jQuery.each(
  		( "blur focus focusin focusout resize scroll click dblclick " +
  		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
  		function( _i, name ) {

  			// Handle event binding
  			jQuery.fn[ name ] = function( data, fn ) {
  				return arguments.length > 0 ?
  					this.on( name, null, data, fn ) :
  					this.trigger( name );
  			};
  		}
  	);




  	// Support: Android <=4.0 only
  	// Make sure we trim BOM and NBSP
  	// Require that the "whitespace run" starts from a non-whitespace
  	// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
  	var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

  	// Bind a function to a context, optionally partially applying any
  	// arguments.
  	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  	// However, it is not slated for removal any time soon
  	jQuery.proxy = function( fn, context ) {
  		var tmp, args, proxy;

  		if ( typeof context === "string" ) {
  			tmp = fn[ context ];
  			context = fn;
  			fn = tmp;
  		}

  		// Quick check to determine if target is callable, in the spec
  		// this throws a TypeError, but we will just return undefined.
  		if ( !isFunction( fn ) ) {
  			return undefined;
  		}

  		// Simulated bind
  		args = slice.call( arguments, 2 );
  		proxy = function() {
  			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
  		};

  		// Set the guid of unique handler to the same of original handler, so it can be removed
  		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

  		return proxy;
  	};

  	jQuery.holdReady = function( hold ) {
  		if ( hold ) {
  			jQuery.readyWait++;
  		} else {
  			jQuery.ready( true );
  		}
  	};
  	jQuery.isArray = Array.isArray;
  	jQuery.parseJSON = JSON.parse;
  	jQuery.nodeName = nodeName;
  	jQuery.isFunction = isFunction;
  	jQuery.isWindow = isWindow;
  	jQuery.camelCase = camelCase;
  	jQuery.type = toType;

  	jQuery.now = Date.now;

  	jQuery.isNumeric = function( obj ) {

  		// As of jQuery 3.0, isNumeric is limited to
  		// strings and numbers (primitives or objects)
  		// that can be coerced to finite numbers (gh-2662)
  		var type = jQuery.type( obj );
  		return ( type === "number" || type === "string" ) &&

  			// parseFloat NaNs numeric-cast false positives ("")
  			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
  			// subtraction forces infinities to NaN
  			!isNaN( obj - parseFloat( obj ) );
  	};

  	jQuery.trim = function( text ) {
  		return text == null ?
  			"" :
  			( text + "" ).replace( rtrim, "$1" );
  	};




  	var

  		// Map over jQuery in case of overwrite
  		_jQuery = window.jQuery,

  		// Map over the $ in case of overwrite
  		_$ = window.$;

  	jQuery.noConflict = function( deep ) {
  		if ( window.$ === jQuery ) {
  			window.$ = _$;
  		}

  		if ( deep && window.jQuery === jQuery ) {
  			window.jQuery = _jQuery;
  		}

  		return jQuery;
  	};

  	// Expose jQuery and $ identifiers, even in AMD
  	// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
  	// and CommonJS for browser emulators (trac-13566)
  	if ( typeof noGlobal === "undefined" ) {
  		window.jQuery = window.$ = jQuery;
  	}




  	return jQuery;
  	} ); 
  } (jquery));

  var jqueryExports = jquery.exports;
  var $$1 = /*@__PURE__*/getDefaultExportFromCjs(jqueryExports);

  /*
   * utility
   * 
   */
  var Utility = /*#__PURE__*/function () {
    function Utility() {
      _classCallCheck(this, Utility);
    }
    return _createClass$1(Utility, null, [{
      key: "isSP",
      value: function isSP() {
        return window.matchMedia('screen and (min-width: 320px) and (max-width: 749px)').matches;
      }
    }, {
      key: "isTAB",
      value: function isTAB() {
        return window.matchMedia('screen and (min-width: 750px) and (max-width: 1023px)').matches;
      }
    }, {
      key: "isPC",
      value: function isPC() {
        return window.matchMedia('screen and (min-width: 1024px)').matches;
      }
    }, {
      key: "convertSpiltSpan",
      value: function convertSpiltSpan(selector) {
        // vars
        var target = convertElement(selector);
        var nodes = _toConsumableArray(target.childNodes);
        var spanWrapText = "";

        // functions
        nodes.forEach(function (node) {
          if (node.nodeType == 3) {
            //
            var text = node.textContent.replace(/\r?\n/g, '');
            spanWrapText = spanWrapText + text.split('').reduce(function (acc, v) {
              v = v != ' ' ? v : '&nbsp';
              return acc + "<span>".concat(v, "</span>");
            }, "");
          } else {
            spanWrapText = spanWrapText + node.outerHTML;
          }
        });
        target.innerHTML = spanWrapText;
        function convertElement(element) {
          if (element instanceof HTMLElement) {
            return element;
          }
          return document.querySelector(element);
        }
      }
    }]);
  }();
  _defineProperty(Utility, "getHeight", function (el) {
    var computedStyle = getComputedStyle(el);
    var elementHeight = el.clientHeight; // height with padding
    elementHeight -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
    return elementHeight;
  });

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  /*!
   * GSAP 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */

  /* eslint-disable */
  var _config$1 = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  },
      _defaults$1 = {
    duration: .5,
    overwrite: false,
    delay: 0
  },
      _suppressOverwrites$1,
      _reverting$2,
      _context$2,
      _bigNum$1 = 1e8,
      _tinyNum = 1 / _bigNum$1,
      _2PI = Math.PI * 2,
      _HALF_PI = _2PI / 4,
      _gsID = 0,
      _sqrt$1 = Math.sqrt,
      _cos = Math.cos,
      _sin = Math.sin,
      _isString$2 = function _isString(value) {
    return typeof value === "string";
  },
      _isFunction$2 = function _isFunction(value) {
    return typeof value === "function";
  },
      _isNumber$1 = function _isNumber(value) {
    return typeof value === "number";
  },
      _isUndefined = function _isUndefined(value) {
    return typeof value === "undefined";
  },
      _isObject$1 = function _isObject(value) {
    return typeof value === "object";
  },
      _isNotFalse = function _isNotFalse(value) {
    return value !== false;
  },
      _windowExists$4 = function _windowExists() {
    return typeof window !== "undefined";
  },
      _isFuncOrString = function _isFuncOrString(value) {
    return _isFunction$2(value) || _isString$2(value);
  },
      _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
      // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
  _isArray = Array.isArray,
      _strictNumExp = /(?:-?\.?\d|\.)+/gi,
      //only numbers (including negatives and decimals) but NOT relative values.
  _numExp$1 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
      //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
  _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
      _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
      //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
  _relExp = /[+-]=-?[.\d]+/,
      _delimitedValueExp = /[^,'"\[\]\s]+/gi,
      // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
  _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
      _globalTimeline,
      _win$4,
      _coreInitted$4,
      _doc$3,
      _globals = {},
      _installScope = {},
      _coreReady,
      _install = function _install(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap$4;
  },
      _missingPlugin = function _missingPlugin(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  },
      _warn$1 = function _warn(message, suppress) {
    return !suppress && console.warn(message);
  },
      _addGlobal = function _addGlobal(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  },
      _emptyFunc = function _emptyFunc() {
    return 0;
  },
      _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  },
      _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  },
      _revertConfig = {
    suppressEvents: true
  },
      _reservedProps = {},
      _lazyTweens = [],
      _lazyLookup = {},
      _lastRenderedFrame,
      _plugins = {},
      _effects = {},
      _nextGCFrame = 30,
      _harnessPlugins = [],
      _callbackNames = "",
      _harness = function _harness(targets) {
    var target = targets[0],
        harnessPlugin,
        i;
    _isObject$1(target) || _isFunction$2(target) || (targets = [targets]);

    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
      i = _harnessPlugins.length;

      while (i-- && !_harnessPlugins[i].targetTest(target)) {}

      harnessPlugin = _harnessPlugins[i];
    }

    i = targets.length;

    while (i--) {
      targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
    }

    return targets;
  },
      _getCache = function _getCache(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  },
      _getProperty = function _getProperty(target, property, v) {
    return (v = target[property]) && _isFunction$2(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
  },
      _forEachName = function _forEachName(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  },
      //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
  _round$2 = function _round(value) {
    return Math.round(value * 100000) / 100000 || 0;
  },
      _roundPrecise = function _roundPrecise(value) {
    return Math.round(value * 10000000) / 10000000 || 0;
  },
      // increased precision mostly for timing values.
  _parseRelative = function _parseRelative(start, value) {
    var operator = value.charAt(0),
        end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  },
      _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
    //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
    var l = toFind.length,
        i = 0;

    for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

    return i < l;
  },
      _lazyRender = function _lazyRender() {
    var l = _lazyTweens.length,
        a = _lazyTweens.slice(0),
        i,
        tween;

    _lazyLookup = {};
    _lazyTweens.length = 0;

    for (i = 0; i < l; i++) {
      tween = a[i];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  },
      _isRevertWorthy = function _isRevertWorthy(animation) {
    return !!(animation._initted || animation._startAt || animation.add);
  },
      _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
    _lazyTweens.length && !_reverting$2 && _lazyRender();
    animation.render(time, suppressEvents, force || !!(_reverting$2 && time < 0 && _isRevertWorthy(animation)));
    _lazyTweens.length && !_reverting$2 && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
  },
      _numericIfPossible = function _numericIfPossible(value) {
    var n = parseFloat(value);
    return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString$2(value) ? value.trim() : value;
  },
      _passThrough$1 = function _passThrough(p) {
    return p;
  },
      _setDefaults$1 = function _setDefaults(obj, defaults) {
    for (var p in defaults) {
      p in obj || (obj[p] = defaults[p]);
    }

    return obj;
  },
      _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
    return function (obj, defaults) {
      for (var p in defaults) {
        p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
      }
    };
  },
      _merge = function _merge(base, toMerge) {
    for (var p in toMerge) {
      base[p] = toMerge[p];
    }

    return base;
  },
      _mergeDeep = function _mergeDeep(base, toMerge) {
    for (var p in toMerge) {
      p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject$1(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
    }

    return base;
  },
      _copyExcluding = function _copyExcluding(obj, excluding) {
    var copy = {},
        p;

    for (p in obj) {
      p in excluding || (copy[p] = obj[p]);
    }

    return copy;
  },
      _inheritDefaults = function _inheritDefaults(vars) {
    var parent = vars.parent || _globalTimeline,
        func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults$1;

    if (_isNotFalse(vars.inherit)) {
      while (parent) {
        func(vars, parent.vars.defaults);
        parent = parent.parent || parent._dp;
      }
    }

    return vars;
  },
      _arraysMatch = function _arraysMatch(a1, a2) {
    var i = a1.length,
        match = i === a2.length;

    while (match && i-- && a1[i] === a2[i]) {}

    return i < 0;
  },
      _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }

    if (lastProp === void 0) {
      lastProp = "_last";
    }

    var prev = parent[lastProp],
        t;

    if (sortBy) {
      t = child[sortBy];

      while (prev && prev[sortBy] > t) {
        prev = prev._prev;
      }
    }

    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent[firstProp];
      parent[firstProp] = child;
    }

    if (child._next) {
      child._next._prev = child;
    } else {
      parent[lastProp] = child;
    }

    child._prev = prev;
    child.parent = child._dp = parent;
    return child;
  },
      _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }

    if (lastProp === void 0) {
      lastProp = "_last";
    }

    var prev = child._prev,
        next = child._next;

    if (prev) {
      prev._next = next;
    } else if (parent[firstProp] === child) {
      parent[firstProp] = next;
    }

    if (next) {
      next._prev = prev;
    } else if (parent[lastProp] === child) {
      parent[lastProp] = prev;
    }

    child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
  },
      _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
    child._act = 0;
  },
      _uncache = function _uncache(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
      var a = animation;

      while (a) {
        a._dirty = 1;
        a = a.parent;
      }
    }

    return animation;
  },
      _recacheAncestors = function _recacheAncestors(animation) {
    var parent = animation.parent;

    while (parent && parent.parent) {
      //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
      parent._dirty = 1;
      parent.totalDuration();
      parent = parent.parent;
    }

    return animation;
  },
      _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting$2 ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  },
      _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
  },
      _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  },
      // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
  _animationCycle = function _animationCycle(tTime, cycleDuration) {
    var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));
    return tTime && whole === tTime ? whole - 1 : whole;
  },
      _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  },
      _setEnd = function _setEnd(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  },
      _alignPlayhead = function _alignPlayhead(animation, totalTime) {
    // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
    var parent = animation._dp;

    if (parent && parent.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

      _setEnd(animation);

      parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
    }

    return animation;
  },

  /*
  _totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
  	let cycleDuration = duration + repeatDelay,
  		time = _round(clampedTotalTime % cycleDuration);
  	if (time > duration) {
  		time = duration;
  	}
  	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
  },
  */
  _postAddChecks = function _postAddChecks(timeline, child) {
    var t;

    if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {
      // in case, for example, the _start is moved on a tween that has already rendered, or if it's being inserted into a timeline BEFORE where the playhead is currently. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning. Special case: if it's a timeline (has .add() method) and no duration, we can skip rendering because the user may be populating it AFTER adding it to a parent timeline (unconventional, but possible, and we wouldn't want it to get removed if the parent's autoRemoveChildren is true).
      t = _parentToChildTotalTime(timeline.rawTime(), child);

      if (!child._dur || _clamp$1(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
        child.render(t, true);
      }
    } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


    if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
      //in case any of the ancestors had completed but should now be enabled...
      if (timeline._dur < timeline.duration()) {
        t = timeline;

        while (t._dp) {
          t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

          t = t._dp;
        }
      }

      timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
    }
  },
      _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber$1(position) ? position : position || timeline !== _globalTimeline ? _parsePosition$1(timeline, position, child) : timeline._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

    _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

    _isFromOrFromStart(child) || (timeline._recent = child);
    skipChecks || _postAddChecks(timeline, child);
    timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)

    return timeline;
  },
      _scrollTrigger = function _scrollTrigger(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  },
      _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
    _initTween(tween, time, tTime);

    if (!tween._initted) {
      return 1;
    }

    if (!force && tween._pt && !_reverting$2 && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);

      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  },
      _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
    var parent = _ref.parent;
    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
  },
      // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
  _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  },
      _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio,
        ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
        // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
    repeatDelay = tween._rDelay,
        tTime = 0,
        pt,
        iteration,
        prevIteration;

    if (repeatDelay && tween._repeat) {
      // in case there's a zero-duration tween that has a repeat with a repeatDelay
      tTime = _clamp$1(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        // if iteration changed
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }

    if (ratio !== prevRatio || _reverting$2 || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
        return;
      }

      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

      suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback$1(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback$1(tween, "onRepeat");

      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);

        if (!suppressEvents && !_reverting$2) {
          _callback$1(tween, ratio ? "onComplete" : "onReverseComplete", true);

          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  },
      _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
    var child;

    if (time > prevTime) {
      child = animation._first;

      while (child && child._start <= time) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }

        child = child._next;
      }
    } else {
      child = animation._last;

      while (child && child._start >= time) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }

        child = child._prev;
      }
    }
  },
      _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat,
        dur = _roundPrecise(duration) || 0,
        totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  },
      _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  },
      _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  },
      _parsePosition$1 = function _parsePosition(animation, position, percentAnimation) {
    var labels = animation.labels,
        recent = animation._recent || _zeroPosition,
        clippedDuration = animation.duration() >= _bigNum$1 ? recent.endTime(false) : animation._dur,
        //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
    i,
        offset,
        isPercent;

    if (_isString$2(position) && (isNaN(position) || position in labels)) {
      //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
      offset = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i = position.indexOf("=");

      if (offset === "<" || offset === ">") {
        i >= 0 && (position = position.replace(/=/, ""));
        return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }

      if (i < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }

      offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

      if (isPercent && percentAnimation) {
        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }

      return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
    }

    return position == null ? clippedDuration : +position;
  },
      _createTweenType = function _createTweenType(type, params, timeline) {
    var isLegacy = _isNumber$1(params[1]),
        varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
        vars = params[varsIndex],
        irVars,
        parent;

    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline;

    if (type) {
      irVars = vars;
      parent = timeline;

      while (parent && !("immediateRender" in irVars)) {
        // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
        irVars = parent.vars.defaults || {};
        parent = _isNotFalse(parent.vars.inherit) && parent.parent;
      }

      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
    }

    return new Tween(params[0], vars, params[varsIndex + 1]);
  },
      _conditionalReturn = function _conditionalReturn(value, func) {
    return value || value === 0 ? func(value) : func;
  },
      _clamp$1 = function _clamp(min, max, value) {
    return value < min ? min : value > max ? max : value;
  },
      getUnit = function getUnit(value, v) {
    return !_isString$2(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
  },
      // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
  clamp$1 = function clamp(min, max, value) {
    return _conditionalReturn(value, function (v) {
      return _clamp$1(min, max, v);
    });
  },
      _slice = [].slice,
      _isArrayLike = function _isArrayLike(value, nonEmpty) {
    return value && _isObject$1(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject$1(value[0])) && !value.nodeType && value !== _win$4;
  },
      _flatten = function _flatten(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }

    return ar.forEach(function (value) {
      var _accumulator;

      return _isString$2(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  },
      //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
  toArray = function toArray(value, scope, leaveStrings) {
    return _context$2 && !scope && _context$2.selector ? _context$2.selector(value) : _isString$2(value) && !leaveStrings && (_coreInitted$4 || !_wake()) ? _slice.call((scope || _doc$3).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  },
      selector = function selector(value) {
    value = toArray(value)[0] || _warn$1("Invalid scope") || {};
    return function (v) {
      var el = value.current || value.nativeElement || value;
      return toArray(v, el.querySelectorAll ? el : el === value ? _warn$1("Invalid scope") || _doc$3.createElement("div") : value);
    };
  },
      shuffle = function shuffle(a) {
    return a.sort(function () {
      return .5 - Math.random();
    });
  },
      // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = (Math.random() * i) | 0, v = a[--i], a[i] = a[j], a[j] = v); return a;
  //for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
  distribute = function distribute(v) {
    if (_isFunction$2(v)) {
      return v;
    }

    var vars = _isObject$1(v) ? v : {
      each: v
    },
        //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
    ease = _parseEase(vars.ease),
        from = vars.from || 0,
        base = parseFloat(vars.base) || 0,
        cache = {},
        isDecimal = from > 0 && from < 1,
        ratios = isNaN(from) || isDecimal,
        axis = vars.axis,
        ratioX = from,
        ratioY = from;

    if (_isString$2(from)) {
      ratioX = ratioY = {
        center: .5,
        edges: .5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }

    return function (i, target, a) {
      var l = (a || vars).length,
          distances = cache[l],
          originX,
          originY,
          x,
          y,
          d,
          j,
          max,
          min,
          wrapAt;

      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum$1])[1];

        if (!wrapAt) {
          max = -_bigNum$1;

          while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

          wrapAt < l && wrapAt--;
        }

        distances = cache[l] = [];
        originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
        originY = wrapAt === _bigNum$1 ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum$1;

        for (j = 0; j < l; j++) {
          x = j % wrapAt - originX;
          y = originY - (j / wrapAt | 0);
          distances[j] = d = !axis ? _sqrt$1(x * x + y * y) : Math.abs(axis === "y" ? y : x);
          d > max && (max = d);
          d < min && (min = d);
        }

        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l < 0 ? base - l : base;
        distances.u = getUnit(vars.amount || vars.each) || 0; //unit

        ease = ease && l < 0 ? _invertEase(ease) : ease;
      }

      l = (distances[i] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
    };
  },
      _roundModifier = function _roundModifier(v) {
    //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
    var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

    return function (raw) {
      var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);

      return (n - n % 1) / p + (_isNumber$1(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
    };
  },
      snap = function snap(snapTo, value) {
    var isArray = _isArray(snapTo),
        radius,
        is2D;

    if (!isArray && _isObject$1(snapTo)) {
      radius = isArray = snapTo.radius || _bigNum$1;

      if (snapTo.values) {
        snapTo = toArray(snapTo.values);

        if (is2D = !_isNumber$1(snapTo[0])) {
          radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }

    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction$2(snapTo) ? function (raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function (raw) {
      var x = parseFloat(is2D ? raw.x : raw),
          y = parseFloat(is2D ? raw.y : 0),
          min = _bigNum$1,
          closest = 0,
          i = snapTo.length,
          dx,
          dy;

      while (i--) {
        if (is2D) {
          dx = snapTo[i].x - x;
          dy = snapTo[i].y - y;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i] - x);
        }

        if (dx < min) {
          min = dx;
          closest = i;
        }
      }

      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber$1(raw) ? closest : closest + getUnit(raw);
    });
  },
      random = function random(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  },
      pipe = function pipe() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }

    return function (value) {
      return functions.reduce(function (v, f) {
        return f(v);
      }, value);
    };
  },
      unitize = function unitize(func, unit) {
    return function (value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  },
      normalize$1 = function normalize(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  },
      _wrapArray = function _wrapArray(a, wrapper, value) {
    return _conditionalReturn(value, function (index) {
      return a[~~wrapper(index)];
    });
  },
      wrap = function wrap(min, max, value) {
    // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
      return (range + (value - min) % range) % range + min;
    });
  },
      wrapYoyo = function wrapYoyo(min, max, value) {
    var range = max - min,
        total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
      value = (total + (value - min) % total) % total || 0;
      return min + (value > range ? total - value : value);
    });
  },
      _replaceRandom = function _replaceRandom(value) {
    //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
    var prev = 0,
        s = "",
        i,
        nums,
        end,
        isArray;

    while (~(i = value.indexOf("random(", prev))) {
      end = value.indexOf(")", i);
      isArray = value.charAt(i + 7) === "[";
      nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
      s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
      prev = end + 1;
    }

    return s + value.substr(prev, value.length - prev);
  },
      mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin,
        outRange = outMax - outMin;
    return _conditionalReturn(value, function (value) {
      return outMin + ((value - inMin) / inRange * outRange || 0);
    });
  },
      interpolate = function interpolate(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function (p) {
      return (1 - p) * start + p * end;
    };

    if (!func) {
      var isString = _isString$2(start),
          master = {},
          p,
          i,
          interpolators,
          l,
          il;

      progress === true && (mutate = 1) && (progress = null);

      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l = start.length;
        il = l - 2;

        for (i = 1; i < l; i++) {
          interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
        }

        l--;

        func = function func(p) {
          p *= l;
          var i = Math.min(il, ~~p);
          return interpolators[i](p - i);
        };

        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }

      if (!interpolators) {
        for (p in end) {
          _addPropTween.call(master, start, p, "get", end[p]);
        }

        func = function func(p) {
          return _renderPropTweens(p, master) || (isString ? start.p : start);
        };
      }
    }

    return _conditionalReturn(progress, func);
  },
      _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
    //used for nextLabel() and previousLabel()
    var labels = timeline.labels,
        min = _bigNum$1,
        p,
        distance,
        label;

    for (p in labels) {
      distance = labels[p] - fromTime;

      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p;
        min = distance;
      }
    }

    return label;
  },
      _callback$1 = function _callback(animation, type, executeLazyFirst) {
    var v = animation.vars,
        callback = v[type],
        prevContext = _context$2,
        context = animation._ctx,
        params,
        scope,
        result;

    if (!callback) {
      return;
    }

    params = v[type + "Params"];
    scope = v.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

    context && (_context$2 = context);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context$2 = prevContext;
    return result;
  },
      _interrupt = function _interrupt(animation) {
    _removeFromParent(animation);

    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting$2);
    animation.progress() < 1 && _callback$1(animation, "onInterrupt");
    return animation;
  },
      _quickTween,
      _registerPluginQueue = [],
      _createPlugin = function _createPlugin(config) {
    if (!config) return;
    config = !config.name && config["default"] || config; // UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

    if (_windowExists$4() || config.headless) {
      // edge case: some build tools may pass in a null/undefined value
      var name = config.name,
          isFunc = _isFunction$2(config),
          Plugin = name && !isFunc && config.init ? function () {
        this._props = [];
      } : config,
          //in case someone passes in an object that's not a plugin, like CustomEase
      instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      },
          statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };

      _wake();

      if (config !== Plugin) {
        if (_plugins[name]) {
          return;
        }

        _setDefaults$1(Plugin, _setDefaults$1(_copyExcluding(config, instanceDefaults), statics)); //static methods


        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


        _plugins[Plugin.prop = name] = Plugin;

        if (config.targetTest) {
          _harnessPlugins.push(Plugin);

          _reservedProps[name] = 1;
        }

        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
      }

      _addGlobal(name, Plugin);

      config.register && config.register(gsap$4, Plugin, PropTween);
    } else {
      _registerPluginQueue.push(config);
    }
  },

  /*
   * --------------------------------------------------------------------------------------
   * COLORS
   * --------------------------------------------------------------------------------------
   */
  _255 = 255,
      _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  },
      // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
  // let ctx = _doc.createElement("canvas").getContext("2d");
  // _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
  _hue = function _hue(h, m1, m2) {
    h += h < 0 ? 1 : h > 1 ? -1 : 0;
    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
  },
      splitColor = function splitColor(v, toHSL, forceAlpha) {
    var a = !v ? _colorLookup.black : _isNumber$1(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
        r,
        g,
        b,
        h,
        s,
        l,
        max,
        min,
        d,
        wasHSL;

    if (!a) {
      if (v.substr(-1) === ",") {
        //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
        v = v.substr(0, v.length - 1);
      }

      if (_colorLookup[v]) {
        a = _colorLookup[v];
      } else if (v.charAt(0) === "#") {
        if (v.length < 6) {
          //for shorthand like #9F0 or #9F0F (could have alpha)
          r = v.charAt(1);
          g = v.charAt(2);
          b = v.charAt(3);
          v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
        }

        if (v.length === 9) {
          // hex with alpha, like #fd5e53ff
          a = parseInt(v.substr(1, 6), 16);
          return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
        }

        v = parseInt(v.substr(1), 16);
        a = [v >> 16, v >> 8 & _255, v & _255];
      } else if (v.substr(0, 3) === "hsl") {
        a = wasHSL = v.match(_strictNumExp);

        if (!toHSL) {
          h = +a[0] % 360 / 360;
          s = +a[1] / 100;
          l = +a[2] / 100;
          g = l <= .5 ? l * (s + 1) : l + s - l * s;
          r = l * 2 - g;
          a.length > 3 && (a[3] *= 1); //cast as number

          a[0] = _hue(h + 1 / 3, r, g);
          a[1] = _hue(h, r, g);
          a[2] = _hue(h - 1 / 3, r, g);
        } else if (~v.indexOf("=")) {
          //if relative values are found, just return the raw strings with the relative prefixes in place.
          a = v.match(_numExp$1);
          forceAlpha && a.length < 4 && (a[3] = 1);
          return a;
        }
      } else {
        a = v.match(_strictNumExp) || _colorLookup.transparent;
      }

      a = a.map(Number);
    }

    if (toHSL && !wasHSL) {
      r = a[0] / _255;
      g = a[1] / _255;
      b = a[2] / _255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h *= 60;
      }

      a[0] = ~~(h + .5);
      a[1] = ~~(s * 100 + .5);
      a[2] = ~~(l * 100 + .5);
    }

    forceAlpha && a.length < 4 && (a[3] = 1);
    return a;
  },
      _colorOrderData = function _colorOrderData(v) {
    // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
    var values = [],
        c = [],
        i = -1;
    v.split(_colorExp).forEach(function (v) {
      var a = v.match(_numWithUnitExp) || [];
      values.push.apply(values, a);
      c.push(i += a.length + 1);
    });
    values.c = c;
    return values;
  },
      _formatColors = function _formatColors(s, toHSL, orderMatchData) {
    var result = "",
        colors = (s + result).match(_colorExp),
        type = toHSL ? "hsla(" : "rgba(",
        i = 0,
        c,
        shell,
        d,
        l;

    if (!colors) {
      return s;
    }

    colors = colors.map(function (color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });

    if (orderMatchData) {
      d = _colorOrderData(s);
      c = orderMatchData.c;

      if (c.join(result) !== d.c.join(result)) {
        shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
        l = shell.length - 1;

        for (; i < l; i++) {
          result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
        }
      }
    }

    if (!shell) {
      shell = s.split(_colorExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + colors[i];
      }
    }

    return result + shell[l];
  },
      _colorExp = function () {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
        //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
    p;

    for (p in _colorLookup) {
      s += "|" + p + "\\b";
    }

    return new RegExp(s + ")", "gi");
  }(),
      _hslExp = /hsl[a]?\(/,
      _colorStringFilter = function _colorStringFilter(a) {
    var combined = a.join(" "),
        toHSL;
    _colorExp.lastIndex = 0;

    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a[1] = _formatColors(a[1], toHSL);
      a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

      return true;
    }
  },

  /*
   * --------------------------------------------------------------------------------------
   * TICKER
   * --------------------------------------------------------------------------------------
   */
  _tickerActive,
      _ticker = function () {
    var _getTime = Date.now,
        _lagThreshold = 500,
        _adjustedLag = 33,
        _startTime = _getTime(),
        _lastUpdate = _startTime,
        _gap = 1000 / 240,
        _nextTime = _gap,
        _listeners = [],
        _id,
        _req,
        _raf,
        _self,
        _delta,
        _i,
        _tick = function _tick(v) {
      var elapsed = _getTime() - _lastUpdate,
          manual = v === true,
          overlap,
          dispatch,
          time,
          frame;

      (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time = _lastUpdate - _startTime;
      overlap = time - _nextTime;

      if (overlap > 0 || manual) {
        frame = ++_self.frame;
        _delta = time - _self.time * 1000;
        _self.time = time = time / 1000;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch = 1;
      }

      manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

      if (dispatch) {
        for (_i = 0; _i < _listeners.length; _i++) {
          // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
          _listeners[_i](time, _delta, frame, v);
        }
      }
    };

    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1000 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted$4 && _windowExists$4()) {
            _win$4 = _coreInitted$4 = window;
            _doc$3 = _win$4.document || {};
            _globals.gsap = gsap$4;
            (_win$4.gsapVersions || (_win$4.gsapVersions = [])).push(gsap$4.version);

            _install(_installScope || _win$4.GreenSockGlobals || !_win$4.gsap && _win$4 || {});

            _registerPluginQueue.forEach(_createPlugin);
          }

          _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
          _id && _self.sleep();

          _req = _raf || function (f) {
            return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
          };

          _tickerActive = 1;

          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited

        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1000 / (_fps || 240);
        _nextTime = _self.time * 1000 + _gap;
      },
      add: function add(callback, once, prioritize) {
        var func = once ? function (t, d, f, v) {
          callback(t, d, f, v);

          _self.remove(func);
        } : callback;

        _self.remove(callback);

        _listeners[prioritize ? "unshift" : "push"](func);

        _wake();

        return func;
      },
      remove: function remove(callback, i) {
        ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
      },
      _listeners: _listeners
    };
    return _self;
  }(),
      _wake = function _wake() {
    return !_tickerActive && _ticker.wake();
  },
      //also ensures the core classes are initialized.

  /*
  * -------------------------------------------------
  * EASING
  * -------------------------------------------------
  */
  _easeMap = {},
      _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
      _quotesExp = /["']/g,
      _parseObjectInString = function _parseObjectInString(value) {
    //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
    var obj = {},
        split = value.substr(1, value.length - 3).split(":"),
        key = split[0],
        i = 1,
        l = split.length,
        index,
        val,
        parsedVal;

    for (; i < l; i++) {
      val = split[i];
      index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index + 1).trim();
    }

    return obj;
  },
      _valueInParentheses = function _valueInParentheses(value) {
    var open = value.indexOf("(") + 1,
        close = value.indexOf(")"),
        nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  },
      _configEaseFromString = function _configEaseFromString(name) {
    //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
    var split = (name + "").split("("),
        ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  },
      _invertEase = function _invertEase(ease) {
    return function (p) {
      return 1 - ease(1 - p);
    };
  },
      // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
  _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
    var child = timeline._first,
        ease;

    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }

      child = child._next;
    }
  },
      _parseEase = function _parseEase(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction$2(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  },
      _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut(p) {
        return 1 - easeIn(1 - p);
      };
    }

    if (easeInOut === void 0) {
      easeInOut = function easeInOut(p) {
        return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
      };
    }

    var ease = {
      easeIn: easeIn,
      easeOut: easeOut,
      easeInOut: easeInOut
    },
        lowercaseName;

    _forEachName(names, function (name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

      for (var p in ease) {
        _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
      }
    });

    return ease;
  },
      _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
    return function (p) {
      return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
    };
  },
      _configElastic = function _configElastic(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1,
        //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
    p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
        p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
        easeOut = function easeOut(p) {
      return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
    },
        ease = type === "out" ? easeOut : type === "in" ? function (p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);

    p2 = _2PI / p2; //precalculate to optimize

    ease.config = function (amplitude, period) {
      return _configElastic(type, amplitude, period);
    };

    return ease;
  },
      _configBack = function _configBack(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }

    var easeOut = function easeOut(p) {
      return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
    },
        ease = type === "out" ? easeOut : type === "in" ? function (p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);

    ease.config = function (overshoot) {
      return _configBack(type, overshoot);
    };

    return ease;
  }; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
  // _weightedEase = ratio => {
  // 	let y = 0.5 + ratio / 2;
  // 	return p => (2 * (1 - p) * p * y + p * p);
  // },
  // a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
  // _weightedEaseStrong = ratio => {
  // 	ratio = .5 + ratio / 2;
  // 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
  // 		b = ratio - o,
  // 		c = ratio + o;
  // 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
  // };


  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
    var power = i < 5 ? i + 1 : i;

    _insertEase(name + ",Power" + (power - 1), i ? function (p) {
      return Math.pow(p, power);
    } : function (p) {
      return p;
    }, function (p) {
      return 1 - Math.pow(1 - p, power);
    }, function (p) {
      return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
    });
  });

  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

  (function (n, c) {
    var n1 = 1 / c,
        n2 = 2 * n1,
        n3 = 2.5 * n1,
        easeOut = function easeOut(p) {
      return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
    };

    _insertEase("Bounce", function (p) {
      return 1 - easeOut(1 - p);
    }, easeOut);
  })(7.5625, 2.75);

  _insertEase("Expo", function (p) {
    return Math.pow(2, 10 * (p - 1)) * p + p * p * p * p * p * p * (1 - p);
  }); // previously 2 ** (10 * (p - 1)) but that doesn't end up with the value quite at the right spot so we do a blended ease to ensure it lands where it should perfectly.


  _insertEase("Circ", function (p) {
    return -(_sqrt$1(1 - p * p) - 1);
  });

  _insertEase("Sine", function (p) {
    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
  });

  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }

      var p1 = 1 / steps,
          p2 = steps + (immediateStart ? 0 : 1),
          p3 = immediateStart ? 1 : 0,
          max = 1 - _tinyNum;
      return function (p) {
        return ((p2 * _clamp$1(0, max, p) | 0) + p3) * p1;
      };
    }
  };
  _defaults$1.ease = _easeMap["quad.out"];

  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
    return _callbackNames += name + "," + name + "Params,";
  });
  /*
   * --------------------------------------------------------------------------------------
   * CACHE
   * --------------------------------------------------------------------------------------
   */


  var GSCache = function GSCache(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  /*
   * --------------------------------------------------------------------------------------
   * ANIMATION
   * --------------------------------------------------------------------------------------
   */

  var Animation = /*#__PURE__*/function () {
    function Animation(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;

      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }

      this._ts = 1;

      _setDuration(this, +vars.duration, 1, 1);

      this.data = vars.data;

      if (_context$2) {
        this._ctx = _context$2;

        _context$2.data.push(this);
      }

      _tickerActive || _ticker.wake();
    }

    var _proto = Animation.prototype;

    _proto.delay = function delay(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }

      return this._delay;
    };

    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };

    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }

      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    };

    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();

      if (!arguments.length) {
        return this._tTime;
      }

      var parent = this._dp;

      if (parent && parent.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);

        !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
        //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

        while (parent && parent.parent) {
          if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
            parent.totalTime(parent._tTime, true);
          }

          parent = parent.parent;
        }

        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }

      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
        this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
        //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
        //   this._lock = 1;

        _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
        //}

      }

      return this;
    };

    _proto.time = function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
    };

    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
    };

    _proto.progress = function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    };

    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;

      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    } // potential future addition:
    // isPlayingBackwards() {
    // 	let animation = this,
    // 		orientation = 1; // 1 = forward, -1 = backward
    // 	while (animation) {
    // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
    // 		animation = animation.parent;
    // 	}
    // 	return orientation < 0;
    // }
    ;

    _proto.timeScale = function timeScale(value, suppressEvents) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
      }

      if (this._rts === value) {
        return this;
      }

      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
      // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
      //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
      // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

      this.totalTime(_clamp$1(-Math.abs(this._delay), this.totalDuration(), tTime), suppressEvents !== false);

      _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


      return _recacheAncestors(this);
    };

    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      } // possible future addition - if an animation is removed from its parent and then .restart() or .play() or .resume() is called, perhaps we should force it back into the globalTimeline but be careful because what if it's already at its end? We don't want it to just persist forever and not get released for GC.
      // !this.parent && !value && this._tTime < this._tDur && this !== _globalTimeline && _globalTimeline.add(this);


      if (this._ps !== value) {
        this._ps = value;

        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

          this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
        } else {
          _wake();

          this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
        }
      }

      return this;
    };

    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = value;
        var parent = this.parent || this._dp;
        parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
        return this;
      }

      return this._start;
    };

    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };

    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent = this.parent || this._dp; // _dp = detached parent

      return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
    };

    _proto.revert = function revert(config) {
      if (config === void 0) {
        config = _revertConfig;
      }

      var prevIsReverting = _reverting$2;
      _reverting$2 = config;

      if (_isRevertWorthy(this)) {
        this.timeline && this.timeline.revert(config);
        this.totalTime(-0.01, config.suppressEvents);
      }

      this.data !== "nested" && config.kill !== false && this.kill();
      _reverting$2 = prevIsReverting;
      return this;
    };

    _proto.globalTime = function globalTime(rawTime) {
      var animation = this,
          time = arguments.length ? rawTime : animation.rawTime();

      while (animation) {
        time = animation._start + time / (Math.abs(animation._ts) || 1);
        animation = animation._dp;
      }

      return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). "_sat" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().
    };

    _proto.repeat = function repeat(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }

      return this._repeat === -2 ? Infinity : this._repeat;
    };

    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        var time = this._time;
        this._rDelay = value;

        _onUpdateTotalDuration(this);

        return time ? this.time(time) : this;
      }

      return this._rDelay;
    };

    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }

      return this._yoyo;
    };

    _proto.seek = function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition$1(this, position), _isNotFalse(suppressEvents));
    };

    _proto.restart = function restart(includeDelay, suppressEvents) {
      this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      this._dur || (this._zTime = -_tinyNum); // ensures onComplete fires on a zero-duration animation that gets restarted.

      return this;
    };

    _proto.play = function play(from, suppressEvents) {
      from != null && this.seek(from, suppressEvents);
      return this.reversed(false).paused(false);
    };

    _proto.reverse = function reverse(from, suppressEvents) {
      from != null && this.seek(from || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };

    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };

    _proto.resume = function resume() {
      return this.paused(false);
    };

    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

        return this;
      }

      return this._rts < 0;
    };

    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };

    _proto.isActive = function isActive() {
      var parent = this.parent || this._dp,
          start = this._start,
          rawTime;
      return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };

    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;

      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }

        return this;
      }

      return vars[type];
    };

    _proto.then = function then(onFulfilled) {
      var self = this;
      return new Promise(function (resolve) {
        var f = _isFunction$2(onFulfilled) ? onFulfilled : _passThrough$1,
            _resolve = function _resolve() {
          var _then = self.then;
          self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

          _isFunction$2(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
          resolve(f);
          self.then = _then;
        };

        if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
          _resolve();
        } else {
          self._prom = _resolve;
        }
      });
    };

    _proto.kill = function kill() {
      _interrupt(this);
    };

    return Animation;
  }();

  _setDefaults$1(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  /*
   * -------------------------------------------------
   * TIMELINE
   * -------------------------------------------------
   */


  var Timeline = /*#__PURE__*/function (_Animation) {
    _inheritsLoose(Timeline, _Animation);

    function Timeline(vars, position) {
      var _this;

      if (vars === void 0) {
        vars = {};
      }

      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }

    var _proto2 = Timeline.prototype;

    _proto2.to = function to(targets, vars, position) {
      _createTweenType(0, arguments, this);

      return this;
    };

    _proto2.from = function from(targets, vars, position) {
      _createTweenType(1, arguments, this);

      return this;
    };

    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
      _createTweenType(2, arguments, this);

      return this;
    };

    _proto2.set = function set(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition$1(this, position), 1);
      return this;
    };

    _proto2.call = function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
    } //ONLY for backward compatibility! Maybe delete?
    ;

    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition$1(this, position));
      return this;
    };

    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    };

    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    };

    _proto2.render = function render(totalTime, suppressEvents, force) {
      var prevTime = this._time,
          tDur = this._dirty ? this.totalDuration() : this._tDur,
          dur = this._dur,
          tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
          // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
      crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
          time,
          child,
          next,
          iteration,
          cycleDuration,
          prevPaused,
          pauseTween,
          timeScale,
          prevStart,
          prevIteration,
          yoyo,
          isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }

        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;

        if (crossingStart) {
          dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }

        if (this._repeat) {
          //adjust the time for repeats and yoyos
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;

          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }

          time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

          if (tTime === tDur) {
            // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)

            iteration = ~~prevIteration;

            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            }

            time > dur && (time = dur);
          }

          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://gsap.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005 also, this._tTime - prevIteration * cycleDuration - this._dur <= 0 just checks to make sure it wasn't previously in the "repeatDelay" portion

          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          /*
          make sure children at the end/beginning of the timeline are rendered properly. If, for example,
          a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
          would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
          could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
          we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
          ensure that zero-duration tweens at the very beginning or end of the Timeline work.
          */


          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1,
                doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : tTime % dur ? dur : tTime; // if the playhead is landing exactly at the end of an iteration, use that totalTime rather than only the duration, otherwise it'll skip the 2nd render since it's effectively at the same time.

            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

            !suppressEvents && this.parent && _callback$1(this, "onRepeat");
            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
              return this;
            }

            dur = this._dur; // in case the duration changed in the onRepeat

            tDur = this._tDur;

            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -0.0001;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }

            this._lock = 0;

            if (!this._ts && !prevPaused) {
              return this;
            } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


            _propagateYoyoEase(this, isYoyo);
          }
        }

        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }

        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
        }

        if (!prevTime && tTime && !suppressEvents && !prevIteration) {
          _callback$1(this, "onStart");

          if (this._tTime !== tTime) {
            // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
            return this;
          }
        }

        if (time >= prevTime && totalTime >= 0) {
          child = this._first;

          while (child) {
            next = child._next;

            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                return this.render(totalTime, suppressEvents, force);
              }

              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

              if (time !== this._time || !this._ts && !prevPaused) {
                //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that the next time render() is called it'll be forced (to render any remaining children)

                break;
              }
            }

            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

          while (child) {
            next = child._prev;

            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                return this.render(totalTime, suppressEvents, force);
              }

              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting$2 && _isRevertWorthy(child)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.

              if (time !== this._time || !this._ts && !prevPaused) {
                //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

                break;
              }
            }

            child = next;
          }
        }

        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

          if (this._ts) {
            //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
            this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

            _setEnd(this);

            return this.render(totalTime, suppressEvents, force);
          }
        }

        this._onUpdate && !suppressEvents && _callback$1(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
          // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
          (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

          if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
            _callback$1(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }

      return this;
    };

    _proto2.add = function add(child, position) {
      var _this2 = this;

      _isNumber$1(position) || (position = _parsePosition$1(this, position, child));

      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function (obj) {
            return _this2.add(obj, position);
          });
          return this;
        }

        if (_isString$2(child)) {
          return this.addLabel(child, position);
        }

        if (_isFunction$2(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }

      return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
    };

    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }

      if (tweens === void 0) {
        tweens = true;
      }

      if (timelines === void 0) {
        timelines = true;
      }

      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum$1;
      }

      var a = [],
          child = this._first;

      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a.push(child);
          } else {
            timelines && a.push(child);
            nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
          }
        }

        child = child._next;
      }

      return a;
    };

    _proto2.getById = function getById(id) {
      var animations = this.getChildren(1, 1, 1),
          i = animations.length;

      while (i--) {
        if (animations[i].vars.id === id) {
          return animations[i];
        }
      }
    };

    _proto2.remove = function remove(child) {
      if (_isString$2(child)) {
        return this.removeLabel(child);
      }

      if (_isFunction$2(child)) {
        return this.killTweensOf(child);
      }

      child.parent === this && _removeLinkedListItem(this, child);

      if (child === this._recent) {
        this._recent = this._last;
      }

      return _uncache(this);
    };

    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }

      this._forcing = 1;

      if (!this._dp && this._ts) {
        //special case for the global timeline (or any other that has no parent or detached parent).
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }

      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

      this._forcing = 0;
      return this;
    };

    _proto2.addLabel = function addLabel(label, position) {
      this.labels[label] = _parsePosition$1(this, position);
      return this;
    };

    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };

    _proto2.addPause = function addPause(position, callback, params) {
      var t = Tween.delayedCall(0, callback || _emptyFunc, params);
      t.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t, _parsePosition$1(this, position));
    };

    _proto2.removePause = function removePause(position) {
      var child = this._first;
      position = _parsePosition$1(this, position);

      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }

        child = child._next;
      }
    };

    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive),
          i = tweens.length;

      while (i--) {
        _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
      }

      return this;
    };

    _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
      var a = [],
          parsedTargets = toArray(targets),
          child = this._first,
          isGlobalTime = _isNumber$1(onlyActive),
          // a number is interpreted as a global time. If the animation spans
      children;

      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
            a.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a.push.apply(a, children);
        }

        child = child._next;
      }

      return a;
    } // potential future feature - targets() on timelines
    // targets() {
    // 	let result = [];
    // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
    // 	return result.filter((v, i) => result.indexOf(v) === i);
    // }
    ;

    _proto2.tweenTo = function tweenTo(position, vars) {
      vars = vars || {};

      var tl = this,
          endTime = _parsePosition$1(tl, position),
          _vars = vars,
          startAt = _vars.startAt,
          _onStart = _vars.onStart,
          onStartParams = _vars.onStartParams,
          immediateRender = _vars.immediateRender,
          initted,
          tween = Tween.to(tl, _setDefaults$1({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();

          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }

          _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
        }
      }, vars));

      return immediateRender ? tween.render(0) : tween;
    };

    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults$1({
        startAt: {
          time: _parsePosition$1(this, fromPosition)
        }
      }, vars));
    };

    _proto2.recent = function recent() {
      return this._recent;
    };

    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }

      return _getLabelInDirection(this, _parsePosition$1(this, afterTime));
    };

    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }

      return _getLabelInDirection(this, _parsePosition$1(this, beforeTime), 1);
    };

    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };

    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }

      var child = this._first,
          labels = this.labels,
          p;

      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }

        child = child._next;
      }

      if (adjustLabels) {
        for (p in labels) {
          if (labels[p] >= ignoreBeforeTime) {
            labels[p] += amount;
          }
        }
      }

      return _uncache(this);
    };

    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;

      while (child) {
        child.invalidate(soft);
        child = child._next;
      }

      return _Animation.prototype.invalidate.call(this, soft);
    };

    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }

      var child = this._first,
          next;

      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }

      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };

    _proto2.totalDuration = function totalDuration(value) {
      var max = 0,
          self = this,
          child = self._last,
          prevStart = _bigNum$1,
          prev,
          start,
          parent;

      if (arguments.length) {
        return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
      }

      if (self._dirty) {
        parent = self.parent;

        while (child) {
          prev = child._prev; //record it here in case the tween changes position in the sequence...

          child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

          start = child._start;

          if (start > prevStart && self._sort && child._ts && !self._lock) {
            //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
            self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

            _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }

          if (start < 0 && child._ts) {
            //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
            max -= start;

            if (!parent && !self._dp || parent && parent.smoothChildTiming) {
              self._start += start / self._ts;
              self._time -= start;
              self._tTime -= start;
            }

            self.shiftChildren(-start, false, -1e999);
            prevStart = 0;
          }

          child._end > max && child._ts && (max = child._end);
          child = prev;
        }

        _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

        self._dirty = 0;
      }

      return self._tDur;
    };

    Timeline.updateRoot = function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

        _lastRenderedFrame = _ticker.frame;
      }

      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config$1.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) if (_config$1.autoSleep && _ticker._listeners.length < 2) {
          while (child && !child._ts) {
            child = child._next;
          }

          child || _ticker.sleep();
        }
      }
    };

    return Timeline;
  }(Animation);

  _setDefaults$1(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });

  var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
    //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
        index = 0,
        matchIndex = 0,
        result,
        startNums,
        color,
        endNum,
        chunk,
        startNum,
        hasRandom,
        a;
    pt.b = start;
    pt.e = end;
    start += ""; //ensure values are strings

    end += "";

    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (stringFilter) {
      a = [start, end];
      stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

      start = a[0];
      end = a[1];
    }

    startNums = start.match(_complexStringNumExp) || [];

    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }

      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

    pt.fp = funcParam;

    if (_relExp.test(end) || hasRandom) {
      pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
    }

    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

    return pt;
  },
      _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction$2(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop],
        parsedStart = start !== "get" ? start : !_isFunction$2(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction$2(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
        setter = !_isFunction$2(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
        pt;

    if (_isString$2(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }

      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);

        if (pt || pt === 0) {
          // to avoid isNaN, like if someone passes in a value like "!= whatever"
          end = pt;
        }
      }
    }

    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        // fun fact: any number multiplied by "" is evaluated as the number 0!
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }

      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config$1.stringFilter, funcParam);
    }
  },
      //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
  _processVars = function _processVars(vars, index, target, targets, tween) {
    _isFunction$2(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

    if (!_isObject$1(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString$2(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }

    var copy = {},
        p;

    for (p in vars) {
      copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
    }

    return copy;
  },
      _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i;

    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

        i = plugin._props.length;

        while (i--) {
          ptLookup[plugin._props[i]] = pt;
        }
      }
    }

    return plugin;
  },
      _overwritingTween,
      //store a reference temporarily so we can avoid overwriting itself.
  _forceAllPropTweens,
      _initTween = function _initTween(tween, time, tTime) {
    var vars = tween.vars,
        ease = vars.ease,
        startAt = vars.startAt,
        immediateRender = vars.immediateRender,
        lazy = vars.lazy,
        onUpdate = vars.onUpdate,
        runBackwards = vars.runBackwards,
        yoyoEase = vars.yoyoEase,
        keyframes = vars.keyframes,
        autoRevert = vars.autoRevert,
        dur = tween._dur,
        prevStartAt = tween._startAt,
        targets = tween._targets,
        parent = tween.parent,
        fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets,
        autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites$1,
        tl = tween.timeline,
        cleanVars,
        i,
        p,
        pt,
        target,
        hasPriority,
        gsData,
        harness,
        plugin,
        ptLookup,
        index,
        harnessVars,
        overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults$1.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults$1.ease)) : 0;

    if (yoyoEase && tween._yoyo && !tween._repeat) {
      //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }

    tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

    if (!tl || keyframes && !vars.stagger) {
      //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

      cleanVars = _copyExcluding(vars, _reservedProps);

      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.

        time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a "startAt" (not "from()" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)
        // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for "startAt" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.

        prevStartAt._lazy = 0;
      }

      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults$1({
          data: "isStart",
          overwrite: false,
          parent: parent,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate && function () {
            return _callback$1(tween, "onUpdate");
          },
          stagger: 0
        }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


        tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.

        tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween

        time < 0 && (_reverting$2 || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

        if (immediateRender) {
          if (dur && time <= 0 && tTime <= 0) {
            // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.
            time && (tween._zTime = time);
            return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
          }
        }
      } else if (runBackwards && dur) {
        //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
        if (!prevStartAt) {
          time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

          p = _setDefaults$1({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender: immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})

          }, cleanVars);
          harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

          _removeFromParent(tween._startAt = Tween.set(targets, p));

          tween._startAt._dp = 0; // don't allow it to get put back into root timeline!

          tween._startAt._sat = tween; // used in globalTime()

          time < 0 && (_reverting$2 ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time;

          if (!immediateRender) {
            _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded

          } else if (!time) {
            return;
          }
        }
      }

      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;

      for (i = 0; i < targets.length; i++) {
        target = targets[i];
        gsData = target._gsap || _harness(targets)[i]._gsap;
        tween._ptLookup[i] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

        index = fullTargets === targets ? i : fullTargets.indexOf(target);

        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

          plugin._props.forEach(function (name) {
            ptLookup[name] = pt;
          });

          plugin.priority && (hasPriority = 1);
        }

        if (!harness || harnessVars) {
          for (p in cleanVars) {
            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }

        tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;

          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


          overwritten = !tween.parent;
          _overwritingTween = 0;
        }

        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }

      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
    }

    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

    keyframes && time <= 0 && tl.render(_bigNum$1, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
  },
      _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
        pt,
        rootPT,
        lookup,
        i;

    if (!ptCache) {
      ptCache = tween._ptCache[property] = [];
      lookup = tween._ptLookup;
      i = tween._targets.length;

      while (i--) {
        pt = lookup[i][property];

        if (pt && pt.d && pt.d._pt) {
          // it's a plugin, so find the nested PropTween
          pt = pt.d._pt;

          while (pt && pt.p !== property && pt.fp !== property) {
            // "fp" is functionParam for things like setting CSS variables which require .setProperty("--var-name", value)
            pt = pt._next;
          }
        }

        if (!pt) {
          // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
          // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
          _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.

          tween.vars[property] = "+=0";

          _initTween(tween, time);

          _forceAllPropTweens = 0;
          return skipRecursion ? _warn$1(property + " not eligible for reset") : 1; // if someone tries to do a quickTo() on a special property like borderRadius which must get split into 4 different properties, that's not eligible for .resetTo().
        }

        ptCache.push(pt);
      }
    }

    i = ptCache.length;

    while (i--) {
      rootPT = ptCache[i];
      pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.

      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round$2(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)

      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)
    }
  },
      _addAliasesToVars = function _addAliasesToVars(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0,
        propertyAliases = harness && harness.aliases,
        copy,
        p,
        i,
        aliases;

    if (!propertyAliases) {
      return vars;
    }

    copy = _merge({}, vars);

    for (p in propertyAliases) {
      if (p in copy) {
        aliases = propertyAliases[p].split(",");
        i = aliases.length;

        while (i--) {
          copy[aliases[i]] = copy[p];
        }
      }
    }

    return copy;
  },
      // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
  _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
    var ease = obj.ease || easeEach || "power1.inOut",
        p,
        a;

    if (_isArray(obj)) {
      a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

      obj.forEach(function (value, i) {
        return a.push({
          t: i / (obj.length - 1) * 100,
          v: value,
          e: ease
        });
      });
    } else {
      for (p in obj) {
        a = allProps[p] || (allProps[p] = []);
        p === "ease" || a.push({
          t: parseFloat(prop),
          v: obj[p],
          e: ease
        });
      }
    }
  },
      _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
    return _isFunction$2(value) ? value.call(tween, i, target, targets) : _isString$2(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  },
      _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
      _staggerPropsToSkip = {};

  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
    return _staggerPropsToSkip[name] = 1;
  });
  /*
   * --------------------------------------------------------------------------------------
   * TWEEN
   * --------------------------------------------------------------------------------------
   */


  var Tween = /*#__PURE__*/function (_Animation2) {
    _inheritsLoose(Tween, _Animation2);

    function Tween(targets, vars, position, skipInherit) {
      var _this3;

      if (typeof vars === "number") {
        position.duration = vars;
        vars = position;
        position = null;
      }

      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars,
          duration = _this3$vars.duration,
          delay = _this3$vars.delay,
          immediateRender = _this3$vars.immediateRender,
          stagger = _this3$vars.stagger,
          overwrite = _this3$vars.overwrite,
          keyframes = _this3$vars.keyframes,
          defaults = _this3$vars.defaults,
          scrollTrigger = _this3$vars.scrollTrigger,
          yoyoEase = _this3$vars.yoyoEase,
          parent = vars.parent || _globalTimeline,
          parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber$1(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
          tl,
          i,
          copy,
          l,
          p,
          curTarget,
          staggerFunc,
          staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn$1("GSAP target " + targets + " not found. https://gsap.com", !_config$1.nullTargetWarn) || [];
      _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

      _this3._overwrite = overwrite;

      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults || {},
          targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
        }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.

        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;

        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
          l = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);

          if (_isObject$1(stagger)) {
            //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
            for (p in stagger) {
              if (~_staggerTweenProps.indexOf(p)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p] = stagger[p];
              }
            }
          }

          for (i = 0; i < l; i++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

            if (!stagger && l === 1 && copy.delay) {
              // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
              _this3._delay = delay = copy.delay;
              _this3._start += delay;
              copy.delay = 0;
            }

            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }

          tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
        } else if (keyframes) {
          _inheritDefaults(_setDefaults$1(tl.vars.defaults, {
            ease: "none"
          }));

          tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
          var time = 0,
              a,
              kf,
              v;

          if (_isArray(keyframes)) {
            keyframes.forEach(function (frame) {
              return tl.to(parsedTargets, frame, ">");
            });
            tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.
          } else {
            copy = {};

            for (p in keyframes) {
              p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
            }

            for (p in copy) {
              a = copy[p].sort(function (a, b) {
                return a.t - b.t;
              });
              time = 0;

              for (i = 0; i < a.length; i++) {
                kf = a[i];
                v = {
                  ease: kf.e,
                  duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                };
                v[p] = kf.v;
                tl.to(parsedTargets, v, time);
                time += v.duration;
              }
            }

            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            }); // in case keyframes didn't go to 100%
          }
        }

        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
      }

      if (overwrite === true && !_suppressOverwrites$1) {
        _overwritingTween = _assertThisInitialized(_this3);

        _globalTimeline.killTweensOf(parsedTargets);

        _overwritingTween = 0;
      }

      _addToTimeline(parent, _assertThisInitialized(_this3), position);

      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);

      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
        _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

        _this3.render(Math.max(0, -delay) || 0); //in case delay is negative

      }

      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }

    var _proto3 = Tween.prototype;

    _proto3.render = function render(totalTime, suppressEvents, force) {
      var prevTime = this._time,
          tDur = this._tDur,
          dur = this._dur,
          isNegative = totalTime < 0,
          tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,
          time,
          pt,
          iteration,
          cycleDuration,
          prevIteration,
          isYoyo,
          ratio,
          timeline,
          yoyoEase;

      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {
        // this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
        time = tTime;
        timeline = this.timeline;

        if (this._repeat) {
          //adjust the time for repeats and yoyos
          cycleDuration = dur + this._rDelay;

          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }

          time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

          if (tTime === tDur) {
            // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)

            iteration = ~~prevIteration;

            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            } else if (time > dur) {
              time = dur;
            }
          }

          isYoyo = this._yoyo && iteration & 1;

          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }

          prevIteration = _animationCycle(this._tTime, cycleDuration);

          if (time === prevTime && !force && this._initted && iteration === prevIteration) {
            //could be during the repeatDelay part. No need to render and fire callbacks.
            this._tTime = tTime;
            return this;
          }

          if (iteration !== prevIteration) {
            timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

            if (this.vars.repeatRefresh && !isYoyo && !this._lock && time !== cycleDuration && this._initted) {
              // this._time will === cycleDuration when we render at EXACTLY the end of an iteration. Without this condition, it'd often do the repeatRefresh render TWICE (again on the very next tick).
              this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }

        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
            this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

            return this;
          }

          if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
            // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values. But we also don't want to dump if we're doing a repeatRefresh render!
            return this;
          }

          if (dur !== this._dur) {
            // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
            return this.render(totalTime, suppressEvents, force);
          }
        }

        this._tTime = tTime;
        this._time = time;

        if (!this._act && this._ts) {
          this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

          this._lazy = 0;
        }

        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }

        if (!prevTime && tTime && !suppressEvents && !prevIteration) {
          _callback$1(this, "onStart");

          if (this._tTime !== tTime) {
            // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
            return this;
          }
        }

        pt = this._pt;

        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }

        timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);

        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

          _callback$1(this, "onUpdate");
        }

        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback$1(this, "onRepeat");

        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
            _callback$1(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }

      return this;
    };

    _proto3.targets = function targets() {
      return this._targets;
    };

    _proto3.invalidate = function invalidate(soft) {
      // "soft" gives us a way to clear out everything EXCEPT the recorded pre-"from" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the "from" values would persist and then on the next render, the from() tweens would initialize and the current value would match the "from" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };

    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
          ratio;
      this._initted || _initTween(this, time);
      ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
      // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
      // if (_isObject(property)) { // performance optimization
      // 	for (p in property) {
      // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
      // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
      // 		}
      // 	}
      // } else {

      if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
        return this.resetTo(property, value, start, startIsRelative, 1); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
      } //}


      _alignPlayhead(this, 0);

      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };

    _proto3.kill = function kill(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }

      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting$2);
        return this;
      }

      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

        return this;
      }

      var parsedTargets = this._targets,
          killingTargets = targets ? toArray(targets) : parsedTargets,
          propTweenLookup = this._ptLookup,
          firstPT = this._pt,
          overwrittenProps,
          curLookup,
          curOverwriteProps,
          props,
          p,
          pt,
          i;

      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }

      overwrittenProps = this._op = this._op || [];

      if (vars !== "all") {
        //so people can pass in a comma-delimited list of property names
        if (_isString$2(vars)) {
          p = {};

          _forEachName(vars, function (name) {
            return p[name] = 1;
          });

          vars = p;
        }

        vars = _addAliasesToVars(parsedTargets, vars);
      }

      i = parsedTargets.length;

      while (i--) {
        if (~killingTargets.indexOf(parsedTargets[i])) {
          curLookup = propTweenLookup[i];

          if (vars === "all") {
            overwrittenProps[i] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
            props = vars;
          }

          for (p in props) {
            pt = curLookup && curLookup[p];

            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }

              delete curLookup[p];
            }

            if (curOverwriteProps !== "all") {
              curOverwriteProps[p] = 1;
            }
          }
        }
      }

      this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

      return this;
    };

    Tween.to = function to(targets, vars) {
      return new Tween(targets, vars, arguments[2]);
    };

    Tween.from = function from(targets, vars) {
      return _createTweenType(1, arguments);
    };

    Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
      return new Tween(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay: delay,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)
    };

    Tween.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };

    Tween.set = function set(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween(targets, vars);
    };

    Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };

    return Tween;
  }(Animation);

  _setDefaults$1(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  }); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
  // _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
  // 	Tween.prototype[name] = function() {
  // 		let tl = new Timeline();
  // 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
  // 	}
  // });
  //for backward compatibility. Leverage the timeline calls.


  _forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
    Tween[name] = function () {
      var tl = new Timeline(),
          params = _slice.call(arguments, 0);

      params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name].apply(tl, params);
    };
  });
  /*
   * --------------------------------------------------------------------------------------
   * PROPTWEEN
   * --------------------------------------------------------------------------------------
   */


  var _setterPlain = function _setterPlain(target, property, value) {
    return target[property] = value;
  },
      _setterFunc = function _setterFunc(target, property, value) {
    return target[property](value);
  },
      _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
    return target[property](data.fp, value);
  },
      _setterAttribute = function _setterAttribute(target, property, value) {
    return target.setAttribute(property, value);
  },
      _getSetter = function _getSetter(target, property) {
    return _isFunction$2(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  },
      _renderPlain = function _renderPlain(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
  },
      _renderBoolean = function _renderBoolean(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  },
      _renderComplexString = function _renderComplexString(ratio, data) {
    var pt = data._pt,
        s = "";

    if (!ratio && data.b) {
      //b = beginning string
      s = data.b;
    } else if (ratio === 1 && data.e) {
      //e = ending string
      s = data.e;
    } else {
      while (pt) {
        s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

        pt = pt._next;
      }

      s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
    }

    data.set(data.t, data.p, s, data);
  },
      _renderPropTweens = function _renderPropTweens(ratio, data) {
    var pt = data._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  },
      _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
    var pt = this._pt,
        next;

    while (pt) {
      next = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next;
    }
  },
      _killPropTweensOf = function _killPropTweensOf(property) {
    var pt = this._pt,
        hasNonDependentRemaining,
        next;

    while (pt) {
      next = pt._next;

      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }

      pt = next;
    }

    return !hasNonDependentRemaining;
  },
      _setterWithModifier = function _setterWithModifier(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  },
      _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
    var pt = parent._pt,
        next,
        pt2,
        first,
        last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

    while (pt) {
      next = pt._next;
      pt2 = first;

      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }

      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }

      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }

      pt = next;
    }

    parent._pt = first;
  }; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


  var PropTween = /*#__PURE__*/function () {
    function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop;
      this.r = renderer || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next;

      if (next) {
        next._prev = this;
      }
    }

    var _proto4 = PropTween.prototype;

    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target; //modifier target

      this.tween = tween;
    };

    return PropTween;
  }(); //Initialization tasks

  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
    return _reservedProps[name] = 1;
  });

  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults$1,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config$1.stringFilter = _colorStringFilter;

  var _media = [],
      _listeners$1 = {},
      _emptyArray$1 = [],
      _lastMediaTime = 0,
      _contextID = 0,
      _dispatch$1 = function _dispatch(type) {
    return (_listeners$1[type] || _emptyArray$1).map(function (f) {
      return f();
    });
  },
      _onMediaChange = function _onMediaChange() {
    var time = Date.now(),
        matches = [];

    if (time - _lastMediaTime > 2) {
      _dispatch$1("matchMediaInit");

      _media.forEach(function (c) {
        var queries = c.queries,
            conditions = c.conditions,
            match,
            p,
            anyMatch,
            toggled;

        for (p in queries) {
          match = _win$4.matchMedia(queries[p]).matches; // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.

          match && (anyMatch = 1);

          if (match !== conditions[p]) {
            conditions[p] = match;
            toggled = 1;
          }
        }

        if (toggled) {
          c.revert();
          anyMatch && matches.push(c);
        }
      });

      _dispatch$1("matchMediaRevert");

      matches.forEach(function (c) {
        return c.onMatch(c, function (func) {
          return c.add(null, func);
        });
      });
      _lastMediaTime = time;

      _dispatch$1("matchMedia");
    }
  };

  var Context = /*#__PURE__*/function () {
    function Context(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = []; // returned/cleanup functions

      this.isReverted = false;
      this.id = _contextID++; // to work around issues that frameworks like Vue cause by making things into Proxies which make it impossible to do something like _media.indexOf(this) because "this" would no longer refer to the Context instance itself - it'd refer to a Proxy! We needed a way to identify the context uniquely

      func && this.add(func);
    }

    var _proto5 = Context.prototype;

    _proto5.add = function add(name, func, scope) {
      // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.
      // if (name && _isFunction(name.revert)) {
      // 	this.data.push(name);
      // 	return (name._ctx = this);
      // }
      if (_isFunction$2(name)) {
        scope = func;
        func = name;
        name = _isFunction$2;
      }

      var self = this,
          f = function f() {
        var prev = _context$2,
            prevSelector = self.selector,
            result;
        prev && prev !== self && prev.data.push(self);
        scope && (self.selector = selector(scope));
        _context$2 = self;
        result = func.apply(self, arguments);
        _isFunction$2(result) && self._r.push(result);
        _context$2 = prev;
        self.selector = prevSelector;
        self.isReverted = false;
        return result;
      };

      self.last = f;
      return name === _isFunction$2 ? f(self, function (func) {
        return self.add(null, func);
      }) : name ? self[name] = f : f;
    };

    _proto5.ignore = function ignore(func) {
      var prev = _context$2;
      _context$2 = null;
      func(this);
      _context$2 = prev;
    };

    _proto5.getTweens = function getTweens() {
      var a = [];
      this.data.forEach(function (e) {
        return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
      });
      return a;
    };

    _proto5.clear = function clear() {
      this._r.length = this.data.length = 0;
    };

    _proto5.kill = function kill(revert, matchMedia) {
      var _this4 = this;

      if (revert) {
        (function () {
          var tweens = _this4.getTweens(),
              i = _this4.data.length,
              t;

          while (i--) {
            // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.
            t = _this4.data[i];

            if (t.data === "isFlip") {
              t.revert();
              t.getChildren(true, true, false).forEach(function (tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          } // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort


          tweens.map(function (t) {
            return {
              g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,
              t: t
            };
          }).sort(function (a, b) {
            return b.g - a.g || -Infinity;
          }).forEach(function (o) {
            return o.t.revert(revert);
          }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the " || -1" in the sort keeps the order properly.

          i = _this4.data.length;

          while (i--) {
            // make sure we loop backwards so that, for example, SplitTexts that were created later on the same element get reverted first
            t = _this4.data[i];

            if (t instanceof Timeline) {
              if (t.data !== "nested") {
                t.scrollTrigger && t.scrollTrigger.revert();
                t.kill(); // don't revert() the timeline because that's duplicating efforts since we already reverted all the tweens
              }
            } else {
              !(t instanceof Tween) && t.revert && t.revert(revert);
            }
          }

          _this4._r.forEach(function (f) {
            return f(revert, _this4);
          });

          _this4.isReverted = true;
        })();
      } else {
        this.data.forEach(function (e) {
          return e.kill && e.kill();
        });
      }

      this.clear();

      if (matchMedia) {
        var i = _media.length;

        while (i--) {
          // previously, we checked _media.indexOf(this), but some frameworks like Vue enforce Proxy objects that make it impossible to get the proper result that way, so we must use a unique ID number instead.
          _media[i].id === this.id && _media.splice(i, 1);
        }
      }
    } // killWithCleanup() {
    // 	this.kill();
    // 	this._r.forEach(f => f(false, this));
    // }
    ;

    _proto5.revert = function revert(config) {
      this.kill(config || {});
    };

    return Context;
  }();

  var MatchMedia = /*#__PURE__*/function () {
    function MatchMedia(scope) {
      this.contexts = [];
      this.scope = scope;
      _context$2 && _context$2.data.push(this);
    }

    var _proto6 = MatchMedia.prototype;

    _proto6.add = function add(conditions, func, scope) {
      _isObject$1(conditions) || (conditions = {
        matches: conditions
      });
      var context = new Context(0, scope || this.scope),
          cond = context.conditions = {},
          mq,
          p,
          active;
      _context$2 && !context.selector && (context.selector = _context$2.selector); // in case a context is created inside a context. Like a gsap.matchMedia() that's inside a scoped gsap.context()

      this.contexts.push(context);
      func = context.add("onMatch", func);
      context.queries = conditions;

      for (p in conditions) {
        if (p === "all") {
          active = 1;
        } else {
          mq = _win$4.matchMedia(conditions[p]);

          if (mq) {
            _media.indexOf(context) < 0 && _media.push(context);
            (cond[p] = mq.matches) && (active = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }

      active && func(context, function (f) {
        return context.add(null, f);
      });
      return this;
    } // refresh() {
    // 	let time = _lastMediaTime,
    // 		media = _media;
    // 	_lastMediaTime = -1;
    // 	_media = this.contexts;
    // 	_onMediaChange();
    // 	_lastMediaTime = time;
    // 	_media = media;
    // }
    ;

    _proto6.revert = function revert(config) {
      this.kill(config || {});
    };

    _proto6.kill = function kill(revert) {
      this.contexts.forEach(function (c) {
        return c.kill(revert, true);
      });
    };

    return MatchMedia;
  }();
  /*
   * --------------------------------------------------------------------------------------
   * GSAP
   * --------------------------------------------------------------------------------------
   */


  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      args.forEach(function (config) {
        return _createPlugin(config);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property, unit, uncache) {
      _isString$2(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

      var getter = _getCache(target || {}).get,
          format = unit ? _passThrough$1 : _numericIfPossible;

      unit === "native" && (unit = "");
      return !target ? target : !property ? function (property, unit, uncache) {
        return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
      } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    },
    quickSetter: function quickSetter(target, property, unit) {
      target = toArray(target);

      if (target.length > 1) {
        var setters = target.map(function (t) {
          return gsap$4.quickSetter(t, property, unit);
        }),
            l = setters.length;
        return function (value) {
          var i = l;

          while (i--) {
            setters[i](value);
          }
        };
      }

      target = target[0] || {};

      var Plugin = _plugins[property],
          cache = _getCache(target),
          p = cache.harness && (cache.harness.aliases || {})[property] || property,
          // in case it's an alias, like "rotate" for "rotation".
      setter = Plugin ? function (value) {
        var p = new Plugin();
        _quickTween._pt = 0;
        p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p.render(1, p);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p);

      return Plugin ? setter : function (value) {
        return setter(target, p, unit ? value + unit : value, cache, 1);
      };
    },
    quickTo: function quickTo(target, property, vars) {
      var _setDefaults2;

      var tween = gsap$4.to(target, _setDefaults$1((_setDefaults2 = {}, _setDefaults2[property] = "+=0.1", _setDefaults2.paused = true, _setDefaults2.stagger = 0, _setDefaults2), vars || {})),
          func = function func(value, start, startIsRelative) {
        return tween.resetTo(property, value, start, startIsRelative);
      };

      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults(value) {
      value && value.ease && (value.ease = _parseEase(value.ease, _defaults$1.ease));
      return _mergeDeep(_defaults$1, value || {});
    },
    config: function config(value) {
      return _mergeDeep(_config$1, value || {});
    },
    registerEffect: function registerEffect(_ref3) {
      var name = _ref3.name,
          effect = _ref3.effect,
          plugins = _ref3.plugins,
          defaults = _ref3.defaults,
          extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function (pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn$1(name + " effect requires " + pluginName + " plugin.");
      });

      _effects[name] = function (targets, vars, tl) {
        return effect(toArray(targets), _setDefaults$1(vars || {}, defaults), tl);
      };

      if (extendTimeline) {
        Timeline.prototype[name] = function (targets, vars, position) {
          return this.add(_effects[name](targets, _isObject$1(vars) ? vars : (position = vars) && {}, this), position);
        };
      }
    },
    registerEase: function registerEase(name, ease) {
      _easeMap[name] = _parseEase(ease);
    },
    parseEase: function parseEase(ease, defaultEase) {
      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }

      var tl = new Timeline(vars),
          child,
          next;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

      _globalTimeline.remove(tl);

      tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;

      while (child) {
        next = child._next;

        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }

        child = next;
      }

      _addToTimeline(_globalTimeline, tl, 0);

      return tl;
    },
    context: function context(func, scope) {
      return func ? new Context(func, scope) : _context$2;
    },
    matchMedia: function matchMedia(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function (c) {
        var cond = c.conditions,
            found,
            p;

        for (p in cond) {
          if (cond[p]) {
            cond[p] = false;
            found = 1;
          }
        }

        found && c.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener(type, callback) {
      var a = _listeners$1[type] || (_listeners$1[type] = []);
      ~a.indexOf(callback) || a.push(callback);
    },
    removeEventListener: function removeEventListener(type, callback) {
      var a = _listeners$1[type],
          i = a && a.indexOf(callback);
      i >= 0 && a.splice(i, 1);
    },
    utils: {
      wrap: wrap,
      wrapYoyo: wrapYoyo,
      distribute: distribute,
      random: random,
      snap: snap,
      normalize: normalize$1,
      getUnit: getUnit,
      clamp: clamp$1,
      splitColor: splitColor,
      toArray: toArray,
      selector: selector,
      mapRange: mapRange,
      pipe: pipe,
      unitize: unitize,
      interpolate: interpolate,
      shuffle: shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween: PropTween,
      globals: _addGlobal,
      Tween: Tween,
      Timeline: Timeline,
      Animation: Animation,
      getCache: _getCache,
      _removeLinkedListItem: _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting$2;
      },
      context: function context(toAdd) {
        if (toAdd && _context$2) {
          _context$2.data.push(toAdd);

          toAdd._ctx = _context$2;
        }

        return _context$2;
      },
      suppressOverwrites: function suppressOverwrites(value) {
        return _suppressOverwrites$1 = value;
      }
    }
  };

  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
    return _gsap[name] = Tween[name];
  });

  _ticker.add(Timeline.updateRoot);

  _quickTween = _gsap.to({}, {
    duration: 0
  }); // ---- EXTRA PLUGINS --------------------------------------------------------

  var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
    var pt = plugin._pt;

    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }

    return pt;
  },
      _addModifiers = function _addModifiers(tween, modifiers) {
    var targets = tween._targets,
        p,
        i,
        pt;

    for (p in modifiers) {
      i = targets.length;

      while (i--) {
        pt = tween._ptLookup[i][p];

        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            // is a plugin
            pt = _getPluginPropTween(pt, p);
          }

          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
        }
      }
    }
  },
      _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
    return {
      name: name,
      headless: 1,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init(target, vars, tween) {
        tween._onInit = function (tween) {
          var temp, p;

          if (_isString$2(vars)) {
            temp = {};

            _forEachName(vars, function (name) {
              return temp[name] = 1;
            }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


            vars = temp;
          }

          if (modifier) {
            temp = {};

            for (p in vars) {
              temp[p] = modifier(vars[p]);
            }

            vars = temp;
          }

          _addModifiers(tween, vars);
        };
      }
    };
  }; //register core plugins


  var gsap$4 = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index, targets) {
      var p, pt, v;
      this.tween = tween;

      for (p in vars) {
        v = target.getAttribute(p) || "";
        pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
        pt.op = p;
        pt.b = v; // record the beginning value so we can revert()

        this._props.push(p);
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt;

      while (pt) {
        _reverting$2 ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)

        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    headless: 1,
    init: function init(target, value) {
      var i = value.length;

      while (i--) {
        this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

  Tween.version = Timeline.version = gsap$4.version = "3.13.0";
  _coreReady = 1;
  _windowExists$4() && _wake();
  _easeMap.Power0;
      _easeMap.Power1;
      _easeMap.Power2;
      _easeMap.Power3;
      _easeMap.Power4;
      _easeMap.Linear;
      _easeMap.Quad;
      _easeMap.Cubic;
      _easeMap.Quart;
      _easeMap.Quint;
      _easeMap.Strong;
      _easeMap.Elastic;
      _easeMap.Back;
      _easeMap.SteppedEase;
      _easeMap.Bounce;
      _easeMap.Sine;
      _easeMap.Expo;
      _easeMap.Circ;

  /*!
   * CSSPlugin 3.13.0
   * https://gsap.com
   *
   * Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */


  var _win$3,
      _doc$2,
      _docElement,
      _pluginInitted,
      _tempDiv,
      _recentSetterPlugin,
      _reverting$1,
      _windowExists$3 = function _windowExists() {
    return typeof window !== "undefined";
  },
      _transformProps = {},
      _RAD2DEG = 180 / Math.PI,
      _DEG2RAD = Math.PI / 180,
      _atan2 = Math.atan2,
      _bigNum = 1e8,
      _capsExp$1 = /([A-Z])/g,
      _horizontalExp = /(left|right|width|margin|padding|x)/i,
      _complexExp = /[\s,\(]\S/,
      _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  },
      _renderCSSProp = function _renderCSSProp(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
  },
      _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
  },
      _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
  },
      //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
  _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
  },
      _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  },
      _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  },
      _setterCSSStyle = function _setterCSSStyle(target, property, value) {
    return target.style[property] = value;
  },
      _setterCSSProp = function _setterCSSProp(target, property, value) {
    return target.style.setProperty(property, value);
  },
      _setterTransform = function _setterTransform(target, property, value) {
    return target._gsap[property] = value;
  },
      _setterScale = function _setterScale(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  },
      _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  },
      _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  },
      _transformProp$1 = "transform",
      _transformOriginProp = _transformProp$1 + "Origin",
      _saveStyle = function _saveStyle(property, isNotCSS) {
    var _this = this;

    var target = this.target,
        style = target.style,
        cache = target._gsap;

    if (property in _transformProps && style) {
      this.tfm = this.tfm || {};

      if (property !== "transform") {
        property = _propertyAliases[property] || property;
        ~property.indexOf(",") ? property.split(",").forEach(function (a) {
          return _this.tfm[a] = _get(target, a);
        }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property); // note: scale would map to "scaleX,scaleY", thus we loop and apply them both.

        property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
      } else {
        return _propertyAliases.transform.split(",").forEach(function (p) {
          return _saveStyle.call(_this, p, isNotCSS);
        });
      }

      if (this.props.indexOf(_transformProp$1) >= 0) {
        return;
      }

      if (cache.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }

      property = _transformProp$1;
    }

    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
  },
      _removeIndependentTransforms = function _removeIndependentTransforms(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  },
      _revertStyle = function _revertStyle() {
    var props = this.props,
        target = this.target,
        style = target.style,
        cache = target._gsap,
        i,
        p;

    for (i = 0; i < props.length; i += 3) {
      // stored like this: property, isNotCSS, value
      if (!props[i + 1]) {
        props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp$1, "-$1").toLowerCase());
      } else if (props[i + 1] === 2) {
        // non-CSS value (function-based)
        target[props[i]](props[i + 2]);
      } else {
        // non-CSS value (not function-based)
        target[props[i]] = props[i + 2];
      }
    }

    if (this.tfm) {
      for (p in this.tfm) {
        cache[p] = this.tfm[p];
      }

      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }

      i = _reverting$1();

      if ((!i || !i.isStart) && !style[_transformProp$1]) {
        _removeIndependentTransforms(style);

        if (cache.zOrigin && style[_transformOriginProp]) {
          style[_transformOriginProp] += " " + cache.zOrigin + "px"; // since we're uncaching, we must put the zOrigin back into the transformOrigin so that we can pull it out accurately when we parse again. Otherwise, we'd lose the z portion of the origin since we extract it to protect from Safari bugs.

          cache.zOrigin = 0;
          cache.renderTransform();
        }

        cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.
      }
    }
  },
      _getStyleSaver$1 = function _getStyleSaver(target, properties) {
    var saver = {
      target: target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    target._gsap || gsap$4.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.

    properties && target.style && target.nodeType && properties.split(",").forEach(function (p) {
      return saver.save(p);
    }); // make sure it's a DOM node too.

    return saver;
  },
      _supports3D,
      _createElement = function _createElement(type, ns) {
    var e = _doc$2.createElementNS ? _doc$2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$2.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

    return e && e.style ? e : _doc$2.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
  },
      _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp$1, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
  },
      _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
      _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
    var e = element || _tempDiv,
        s = e.style,
        i = 5;

    if (property in s && !preferPrefix) {
      return property;
    }

    property = property.charAt(0).toUpperCase() + property.substr(1);

    while (i-- && !(_prefixes[i] + property in s)) {}

    return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
  },
      _initCore$3 = function _initCore() {
    if (_windowExists$3() && window.document) {
      _win$3 = window;
      _doc$2 = _win$3.document;
      _docElement = _doc$2.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _createElement("div");
      _transformProp$1 = _checkPropPrefix(_transformProp$1);
      _transformOriginProp = _transformProp$1 + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

      _supports3D = !!_checkPropPrefix("perspective");
      _reverting$1 = gsap$4.core.reverting;
      _pluginInitted = 1;
    }
  },
      _getReparentedCloneBBox = function _getReparentedCloneBBox(target) {
    //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
    var owner = target.ownerSVGElement,
        svg = _createElement("svg", owner && owner.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
        clone = target.cloneNode(true),
        bbox;

    clone.style.display = "block";
    svg.appendChild(clone);

    _docElement.appendChild(svg);

    try {
      bbox = clone.getBBox();
    } catch (e) {}

    svg.removeChild(clone);

    _docElement.removeChild(svg);

    return bbox;
  },
      _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
    var i = attributesArray.length;

    while (i--) {
      if (target.hasAttribute(attributesArray[i])) {
        return target.getAttribute(attributesArray[i]);
      }
    }
  },
      _getBBox = function _getBBox(target) {
    var bounds, cloned;

    try {
      bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
    } catch (error) {
      bounds = _getReparentedCloneBBox(target);
      cloned = 1;
    }

    bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  },
      _isSVG = function _isSVG(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
  },
      //reports if the element is an SVG on which getBBox() actually works
  _removeProperty = function _removeProperty(target, property) {
    if (property) {
      var style = target.style,
          first2Chars;

      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp$1;
      }

      if (style.removeProperty) {
        first2Chars = property.substr(0, 2);

        if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
          //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
          property = "-" + property;
        }

        style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp$1, "-$1").toLowerCase());
      } else {
        //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
        style.removeAttribute(property);
      }
    }
  },
      _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;

    plugin._props.push(property);

    return pt;
  },
      _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  },
      _nonStandardLayouts = {
    grid: 1,
    flex: 1
  },
      //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
  _convertToUnit = function _convertToUnit(target, property, value, unit) {
    var curValue = parseFloat(value) || 0,
        curUnit = (value + "").trim().substr((curValue + "").length) || "px",
        // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
    style = _tempDiv.style,
        horizontal = _horizontalExp.test(property),
        isRootSVG = target.tagName.toLowerCase() === "svg",
        measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
        amount = 100,
        toPixels = unit === "px",
        toPercent = unit === "%",
        px,
        parent,
        cache,
        isSVG;

    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }

    curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);

    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round$2(toPercent ? curValue / px * amount : curValue / 100 * px);
    }

    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent = unit !== "rem" && ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

    if (isSVG) {
      parent = (target.ownerSVGElement || {}).parentNode;
    }

    if (!parent || parent === _doc$2 || !parent.appendChild) {
      parent = _doc$2.body;
    }

    cache = parent._gsap;

    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
      return _round$2(curValue / cache.width * amount);
    } else {
      if (toPercent && (property === "height" || property === "width")) {
        // if we're dealing with width/height that's inside a container with padding and/or it's a flexbox/grid container, we must apply it to the target itself rather than the _tempDiv in order to ensure complete accuracy, factoring in the parent's padding.
        var v = target.style[property];
        target.style[property] = amount + unit;
        px = target[measureProperty];
        v ? target.style[property] = v : _removeProperty(target, property);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

        parent.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent.removeChild(_tempDiv);
        style.position = "absolute";
      }

      if (horizontal && toPercent) {
        cache = _getCache(parent);
        cache.time = _ticker.time;
        cache.width = parent[measureProperty];
      }
    }

    return _round$2(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  },
      _get = function _get(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore$3();

    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];

      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }

    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];

      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
      }
    }

    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  },
      _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
    // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
    if (!start || start === "none") {
      // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://gsap.com/forums/topic/18310-clippath-doesnt-work-on-ios/
      var p = _checkPropPrefix(prop, target, 1),
          s = p && _getComputedProperty(target, p, 1);

      if (s && s !== start) {
        prop = p;
        start = s;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://gsap.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
      }
    }

    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),
        index = 0,
        matchIndex = 0,
        a,
        result,
        startValues,
        startNum,
        color,
        startValue,
        endValue,
        endNum,
        chunk,
        endUnit,
        startUnit,
        endValues;
    pt.b = start;
    pt.e = end;
    start += ""; // ensure values are strings

    end += "";

    if (end.substring(0, 6) === "var(--") {
      end = _getComputedProperty(target, end.substring(4, end.indexOf(")")));
    }

    if (end === "auto") {
      startValue = target.style[prop];
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
    }

    a = [start, end];

    _colorStringFilter(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


    start = a[0];
    end = a[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];

    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);

        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }

        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _numWithUnitExp.lastIndex - endUnit.length;

          if (!endUnit) {
            //if something like "perspective:300" is passed in and we must add a unit to the end
            endUnit = endUnit || _config$1.units[prop] || startUnit;

            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }

          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }

      pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }

    _relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

    return pt;
  },
      _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  },
      _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
    var split = value.split(" "),
        x = split[0],
        y = split[1] || "50%";

    if (x === "top" || x === "bottom" || y === "left" || y === "right") {
      //the user provided them in the wrong order, so flip them
      value = x;
      x = y;
      y = value;
    }

    split[0] = _keywordToPercent[x] || x;
    split[1] = _keywordToPercent[y] || y;
    return split.join(" ");
  },
      _renderClearProps = function _renderClearProps(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t,
          style = target.style,
          props = data.u,
          cache = target._gsap,
          prop,
          clearTransforms,
          i;

      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i = props.length;

        while (--i > -1) {
          prop = props[i];

          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp$1;
          }

          _removeProperty(target, prop);
        }
      }

      if (clearTransforms) {
        _removeProperty(target, _transformProp$1);

        if (cache) {
          cache.svg && target.removeAttribute("transform");
          style.scale = style.rotate = style.translate = "none";

          _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


          cache.uncache = 1;

          _removeIndependentTransforms(style);
        }
      }
    }
  },
      // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
  _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;

        plugin._props.push(property);

        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */

  },

  /*
   * --------------------------------------------------------------------------------------
   * TRANSFORMS
   * --------------------------------------------------------------------------------------
   */
  _identity2DMatrix = [1, 0, 0, 1, 0, 0],
      _rotationalProperties = {},
      _isNullTransform = function _isNullTransform(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  },
      _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
    var matrixString = _getComputedProperty(target, _transformProp$1);

    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp$1).map(_round$2);
  },
      _getMatrix = function _getMatrix(target, force2D) {
    var cache = target._gsap || _getCache(target),
        style = target.style,
        matrix = _getComputedTransformMatrixAsArray(target),
        parent,
        nextSibling,
        temp,
        addedToDOM;

    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
      //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
      temp = style.display;
      style.display = "block";
      parent = target.parentNode;

      if (!parent || !target.offsetParent && !target.getBoundingClientRect().width) {
        // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375. Note: position: fixed elements report a null offsetParent but they could also be invisible because they're in an ancestor with display: none, so we check getBoundingClientRect(). We only want to alter the DOM if we absolutely have to because it can cause iframe content to reload, like a Vimeo video.
        addedToDOM = 1; //flag

        nextSibling = target.nextElementSibling;

        _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

      }

      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");

      if (addedToDOM) {
        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
      }
    }

    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  },
      _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap,
        matrix = matrixArray || _getMatrix(target, true),
        xOriginOld = cache.xOrigin || 0,
        yOriginOld = cache.yOrigin || 0,
        xOffsetOld = cache.xOffset || 0,
        yOffsetOld = cache.yOffset || 0,
        a = matrix[0],
        b = matrix[1],
        c = matrix[2],
        d = matrix[3],
        tx = matrix[4],
        ty = matrix[5],
        originSplit = origin.split(" "),
        xOrigin = parseFloat(originSplit[0]) || 0,
        yOrigin = parseFloat(originSplit[1]) || 0,
        bounds,
        determinant,
        x,
        y;

    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin); // if (!("xOrigin" in cache) && (xOrigin || yOrigin)) { // added in 3.12.3, reverted in 3.12.4; requires more exploration
      // 	xOrigin -= bounds.x;
      // 	yOrigin -= bounds.y;
      // }
    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
      //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
      x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
      y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
      xOrigin = x;
      yOrigin = y; // theory: we only had to do this for smoothing and it assumes that the previous one was not originIsAbsolute.
    }

    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
      cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }

    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }

    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  },
      _parseTransform = function _parseTransform(target, uncache) {
    var cache = target._gsap || new GSCache(target);

    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }

    var style = target.style,
        invertedScaleX = cache.scaleX < 0,
        px = "px",
        deg = "deg",
        cs = getComputedStyle(target),
        origin = _getComputedProperty(target, _transformOriginProp) || "0",
        x,
        y,
        z,
        scaleX,
        scaleY,
        rotation,
        rotationX,
        rotationY,
        skewX,
        skewY,
        perspective,
        xOrigin,
        yOrigin,
        matrix,
        angle,
        cos,
        sin,
        a,
        b,
        c,
        d,
        a12,
        a22,
        t1,
        t2,
        t3,
        a13,
        a23,
        a33,
        a42,
        a43,
        a32;
    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));

    if (cs.translate) {
      // accommodate independent transforms by combining them into normal ones.
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp$1] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp$1] !== "none" ? cs[_transformProp$1] : "");
      }

      style.scale = style.rotate = style.translate = "none";
    }

    matrix = _getMatrix(target, cache.svg);

    if (cache.svg) {
      if (cache.uncache) {
        // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.
        t2 = target.getBBox();
        origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.
      }

      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }

    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;

    if (matrix !== _identity2DMatrix) {
      a = matrix[0]; //a11

      b = matrix[1]; //a21

      c = matrix[2]; //a31

      d = matrix[3]; //a41

      x = a12 = matrix[4];
      y = a22 = matrix[5]; //2D matrix

      if (matrix.length === 6) {
        scaleX = Math.sqrt(a * a + b * b);
        scaleY = Math.sqrt(d * d + c * c);
        rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

        skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

        if (cache.svg) {
          x -= xOrigin - (xOrigin * a + yOrigin * c);
          y -= yOrigin - (xOrigin * b + yOrigin * d);
        } //3D matrix

      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x = matrix[12];
        y = matrix[13];
        z = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG; //rotationX

        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        } //rotationY


        angle = _atan2(-c, a33);
        rotationY = angle * _RAD2DEG;

        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a * cos - a13 * sin;
          t2 = b * cos - a23 * sin;
          t3 = c * cos - a33 * sin;
          a43 = d * sin + a43 * cos;
          a = t1;
          b = t2;
          c = t3;
        } //rotationZ


        angle = _atan2(b, a);
        rotation = angle * _RAD2DEG;

        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a * cos + b * sin;
          t2 = a12 * cos + a22 * sin;
          b = b * cos - a * sin;
          a22 = a22 * cos - a12 * sin;
          a = t1;
          a12 = t2;
        }

        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }

        scaleX = _round$2(Math.sqrt(a * a + b * b + c * c));
        scaleY = _round$2(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }

      if (cache.svg) {
        //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp$1));
        t1 && target.setAttribute("transform", t1);
      }
    }

    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }

    uncache = uncache || cache.uncache;
    cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z + px;
    cache.scaleX = _round$2(scaleX);
    cache.scaleY = _round$2(scaleY);
    cache.rotation = _round$2(rotation) + deg;
    cache.rotationX = _round$2(rotationX) + deg;
    cache.rotationY = _round$2(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;

    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }

    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config$1.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  },
      _firstTwoOnly = function _firstTwoOnly(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  },
      //for handling transformOrigin values, stripping out the 3rd dimension
  _addPxTranslate = function _addPxTranslate(target, start, value) {
    var unit = getUnit(start);
    return _round$2(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  },
      _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;

    _renderCSSTransforms(ratio, cache);
  },
      _zeroDeg = "0deg",
      _zeroPx = "0px",
      _endParenthesis = ") ",
      _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
    var _ref = cache || this,
        xPercent = _ref.xPercent,
        yPercent = _ref.yPercent,
        x = _ref.x,
        y = _ref.y,
        z = _ref.z,
        rotation = _ref.rotation,
        rotationY = _ref.rotationY,
        rotationX = _ref.rotationX,
        skewX = _ref.skewX,
        skewY = _ref.skewY,
        scaleX = _ref.scaleX,
        scaleY = _ref.scaleY,
        transformPerspective = _ref.transformPerspective,
        force3D = _ref.force3D,
        target = _ref.target,
        zOrigin = _ref.zOrigin,
        transforms = "",
        use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD,
          a13 = Math.sin(angle),
          a33 = Math.cos(angle),
          cos;

      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
      y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
    }

    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }

    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }

    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
      transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
    }

    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }

    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }

    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }

    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }

    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }

    target.style[_transformProp$1] = transforms || "translate(0, 0)";
  },
      _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
    var _ref2 = cache || this,
        xPercent = _ref2.xPercent,
        yPercent = _ref2.yPercent,
        x = _ref2.x,
        y = _ref2.y,
        rotation = _ref2.rotation,
        skewX = _ref2.skewX,
        skewY = _ref2.skewY,
        scaleX = _ref2.scaleX,
        scaleY = _ref2.scaleY,
        target = _ref2.target,
        xOrigin = _ref2.xOrigin,
        yOrigin = _ref2.yOrigin,
        xOffset = _ref2.xOffset,
        yOffset = _ref2.yOffset,
        forceCSS = _ref2.forceCSS,
        tx = parseFloat(x),
        ty = parseFloat(y),
        a11,
        a21,
        a12,
        a22,
        temp;

    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);

    if (skewY) {
      //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }

    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;

      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;

        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }

      a11 = _round$2(a11);
      a21 = _round$2(a21);
      a12 = _round$2(a12);
      a22 = _round$2(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }

    if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x, "px");
      ty = _convertToUnit(target, "y", y, "px");
    }

    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round$2(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round$2(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }

    if (xPercent || yPercent) {
      //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
      temp = target.getBBox();
      tx = _round$2(tx + xPercent / 100 * temp.width);
      ty = _round$2(ty + yPercent / 100 * temp.height);
    }

    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp$1] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)
  },
      _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
    var cap = 360,
        isString = _isString$2(endValue),
        endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
        change = endNum - startNum,
        finalValue = startNum + change + "deg",
        direction,
        pt;

    if (isString) {
      direction = endValue.split("_")[1];

      if (direction === "short") {
        change %= cap;

        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }

      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
      }
    }

    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";

    plugin._props.push(property);

    return pt;
  },
      _assign = function _assign(target, source) {
    // Internet Explorer doesn't have Object.assign(), so we recreate it here.
    for (var p in source) {
      target[p] = source[p];
    }

    return target;
  },
      _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
    //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
    var startCache = _assign({}, target._gsap),
        exclude = "perspective,force3D,transformOrigin,svgOrigin",
        style = target.style,
        endCache,
        p,
        startValue,
        endValue,
        startNum,
        endNum,
        startUnit,
        endUnit;

    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp$1] = transforms;
      endCache = _parseTransform(target, 1);

      _removeProperty(target, _transformProp$1);

      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp$1];
      style[_transformProp$1] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp$1] = startValue;
    }

    for (p in _transformProps) {
      startValue = startCache[p];
      endValue = endCache[p];

      if (startValue !== endValue && exclude.indexOf(p) < 0) {
        //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;

        plugin._props.push(p);
      }
    }

    _assign(endCache, startCache);
  }; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


  _forEachName("padding,margin,Width,Radius", function (name, index) {
    var t = "Top",
        r = "Right",
        b = "Bottom",
        l = "Left",
        props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
      return index < 2 ? name + side : "border" + side + name;
    });

    _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
      var a, vars;

      if (arguments.length < 4) {
        // getter, passed target, property, and unit (from _get())
        a = props.map(function (prop) {
          return _get(plugin, prop, property);
        });
        vars = a.join(" ");
        return vars.split(a[0]).length === 5 ? a[0] : vars;
      }

      a = (endValue + "").split(" ");
      vars = {};
      props.forEach(function (prop, i) {
        return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });

  var CSSPlugin = {
    name: "css",
    register: _initCore$3,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init(target, vars, tween, index, targets) {
      var props = this._props,
          style = target.style,
          startAt = tween.vars.startAt,
          startValue,
          endValue,
          endNum,
          startNum,
          type,
          specialProp,
          p,
          startUnit,
          endUnit,
          relative,
          isTransformRelated,
          transformPropTween,
          cache,
          smooth,
          hasPriority,
          inlineProps;
      _pluginInitted || _initCore$3(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps

      this.styles = this.styles || _getStyleSaver$1(target);
      inlineProps = this.styles.props;
      this.tween = tween;

      for (p in vars) {
        if (p === "autoRound") {
          continue;
        }

        endValue = vars[p];

        if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
          // plugins
          continue;
        }

        type = typeof endValue;
        specialProp = _specialProps[p];

        if (type === "function") {
          endValue = endValue.call(tween, index, target, targets);
          type = typeof endValue;
        }

        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }

        if (specialProp) {
          specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
        } else if (p.substr(0, 2) === "--") {
          //CSS variable
          startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;

          if (!_colorExp.test(startValue)) {
            // colors don't have units
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
          }

          endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
          props.push(p);
          inlineProps.push(p, 0, style[p]);
        } else if (type !== "undefined") {
          if (startAt && p in startAt) {
            // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
            startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
            _isString$2(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || startValue === "auto" || (startValue += _config$1.units[p] || getUnit(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
          } else {
            startValue = _get(target, p);
          }

          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);

          if (p in _propertyAliases) {
            if (p === "autoAlpha") {
              //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
                startNum = 0;
              }

              inlineProps.push("visibility", 0, style.visibility);

              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }

            if (p !== "scale" && p !== "transform") {
              p = _propertyAliases[p];
              ~p.indexOf(",") && (p = p.split(",")[0]);
            }
          }

          isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

          if (isTransformRelated) {
            this.styles.save(p);

            if (type === "string" && endValue.substring(0, 6) === "var(--") {
              endValue = _getComputedProperty(target, endValue.substring(4, endValue.indexOf(")")));
              endNum = parseFloat(endValue);
            }

            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

              smooth = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp$1, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

              transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
            }

            if (p === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p);
              p += "X";
            } else if (p === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

                _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }

              continue;
            } else if (p === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);

              continue;
            } else if (p in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);

              continue;
            } else if (p === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

              continue;
            } else if (p === "force3D") {
              cache[p] = endValue;
              continue;
            } else if (p === "transform") {
              _addRawTransformPTs(this, endValue, target);

              continue;
            }
          } else if (!(p in style)) {
            p = _checkPropPrefix(p) || p;
          }

          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0); // protect against NaN

            endUnit = getUnit(endValue) || (p in _config$1.units ? _config$1.units[p] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;

            if (startUnit !== endUnit && endUnit !== "%") {
              //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p in style)) {
            if (p in target) {
              //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
              this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
            } else if (p !== "parseTransform") {
              _missingPlugin(p, endValue);

              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
          }

          isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : typeof target[p] === "function" ? inlineProps.push(p, 2, target[p]()) : inlineProps.push(p, 1, startValue || target[p]));
          props.push(p);
        }
      }

      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render(ratio, data) {
      if (data.tween._time || !_reverting$1()) {
        var pt = data._pt;

        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property, plugin) {
      //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
      var p = _propertyAliases[property];
      p && p.indexOf(",") < 0 && (property = p);
      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
    },
    core: {
      _removeProperty: _removeProperty,
      _getMatrix: _getMatrix
    }
  };
  gsap$4.utils.checkPrefix = _checkPropPrefix;
  gsap$4.core.getStyleSaver = _getStyleSaver$1;

  (function (positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function (name) {
      _transformProps[name] = 1;
    });

    _forEachName(rotation, function (name) {
      _config$1.units[name] = "deg";
      _rotationalProperties[name] = 1;
    });

    _propertyAliases[all[13]] = positionAndScale + "," + rotation;

    _forEachName(aliases, function (name) {
      var split = name.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
    _config$1.units[name] = "px";
  });

  gsap$4.registerPlugin(CSSPlugin);

  var gsapWithCSS = gsap$4.registerPlugin(CSSPlugin) || gsap$4;
      // to protect from tree shaking
  gsapWithCSS.core.Tween;

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  /*!
   * Observer 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */

  /* eslint-disable */
  var gsap$3,
      _coreInitted$3,
      _win$2,
      _doc$1,
      _docEl$2,
      _body$2,
      _isTouch,
      _pointerType,
      ScrollTrigger$2,
      _root$1,
      _normalizer$1,
      _eventTypes,
      _context$1,
      _getGSAP$3 = function _getGSAP() {
    return gsap$3 || typeof window !== "undefined" && (gsap$3 = window.gsap) && gsap$3.registerPlugin && gsap$3;
  },
      _startup$1 = 1,
      _observers = [],
      _scrollers = [],
      _proxies = [],
      _getTime$1 = Date.now,
      _bridge = function _bridge(name, value) {
    return value;
  },
      _integrate = function _integrate() {
    var core = ScrollTrigger$2.core,
        data = core.bridge || {},
        scrollers = core._scrollers,
        proxies = core._proxies;
    scrollers.push.apply(scrollers, _scrollers);
    proxies.push.apply(proxies, _proxies);
    _scrollers = scrollers;
    _proxies = proxies;

    _bridge = function _bridge(name, value) {
      return data[name](value);
    };
  },
      _getProxyProp = function _getProxyProp(element, property) {
    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
  },
      _isViewport$1 = function _isViewport(el) {
    return !!~_root$1.indexOf(el);
  },
      _addListener$1 = function _addListener(element, type, func, passive, capture) {
    return element.addEventListener(type, func, {
      passive: passive !== false,
      capture: !!capture
    });
  },
      _removeListener$1 = function _removeListener(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  },
      _scrollLeft = "scrollLeft",
      _scrollTop = "scrollTop",
      _onScroll$1 = function _onScroll() {
    return _normalizer$1 && _normalizer$1.isPressed || _scrollers.cache++;
  },
      _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
    var cachingFunc = function cachingFunc(value) {
      // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a "scroll" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when "soft" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)
      if (value || value === 0) {
        _startup$1 && (_win$2.history.scrollRestoration = "manual"); // otherwise the new position will get overwritten by the browser onload.

        var isNormalizing = _normalizer$1 && _normalizer$1.isPressed;
        value = cachingFunc.v = Math.round(value) || (_normalizer$1 && _normalizer$1.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!

        f(value);
        cachingFunc.cacheID = _scrollers.cache;
        isNormalizing && _bridge("ss", value); // set scroll (notify ScrollTrigger so it can dispatch a "scrollStart" event if necessary
      } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
        cachingFunc.cacheID = _scrollers.cache;
        cachingFunc.v = f();
      }

      return cachingFunc.v + cachingFunc.offset;
    };

    cachingFunc.offset = 0;
    return f && cachingFunc;
  },
      _horizontal = {
    s: _scrollLeft,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: _scrollCacheFunc(function (value) {
      return arguments.length ? _win$2.scrollTo(value, _vertical.sc()) : _win$2.pageXOffset || _doc$1[_scrollLeft] || _docEl$2[_scrollLeft] || _body$2[_scrollLeft] || 0;
    })
  },
      _vertical = {
    s: _scrollTop,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: _horizontal,
    sc: _scrollCacheFunc(function (value) {
      return arguments.length ? _win$2.scrollTo(_horizontal.sc(), value) : _win$2.pageYOffset || _doc$1[_scrollTop] || _docEl$2[_scrollTop] || _body$2[_scrollTop] || 0;
    })
  },
      _getTarget = function _getTarget(t, self) {
    return (self && self._ctx && self._ctx.selector || gsap$3.utils.toArray)(t)[0] || (typeof t === "string" && gsap$3.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
  },
      _isWithin = function _isWithin(element, list) {
    // check if the element is in the list or is a descendant of an element in the list.
    var i = list.length;

    while (i--) {
      if (list[i] === element || list[i].contains(element)) {
        return true;
      }
    }

    return false;
  },
      _getScrollFunc = function _getScrollFunc(element, _ref) {
    var s = _ref.s,
        sc = _ref.sc;
    // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.
    _isViewport$1(element) && (element = _doc$1.scrollingElement || _docEl$2);

    var i = _scrollers.indexOf(element),
        offset = sc === _vertical.sc ? 1 : 2;

    !~i && (i = _scrollers.push(element) - 1);
    _scrollers[i + offset] || _addListener$1(element, "scroll", _onScroll$1); // clear the cache when a scroll occurs

    var prev = _scrollers[i + offset],
        func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport$1(element) ? sc : _scrollCacheFunc(function (value) {
      return arguments.length ? element[s] = value : element[s];
    })));
    func.target = element;
    prev || (func.smooth = gsap$3.getProperty(element, "scrollBehavior") === "smooth"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.

    return func;
  },
      _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
    var v1 = value,
        v2 = value,
        t1 = _getTime$1(),
        t2 = t1,
        min = minTimeRefresh || 50,
        dropToZeroTime = Math.max(500, min * 3),
        update = function update(value, force) {
      var t = _getTime$1();

      if (force || t - t1 > min) {
        v2 = v1;
        v1 = value;
        t2 = t1;
        t1 = t;
      } else if (useDelta) {
        v1 += value;
      } else {
        // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.
        v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
      }
    },
        reset = function reset() {
      v2 = v1 = useDelta ? 0 : v1;
      t2 = t1 = 0;
    },
        getVelocity = function getVelocity(latestValue) {
      var tOld = t2,
          vOld = v2,
          t = _getTime$1();

      (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
      return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;
    };

    return {
      update: update,
      reset: reset,
      getVelocity: getVelocity
    };
  },
      _getEvent = function _getEvent(e, preventDefault) {
    preventDefault && !e._gsapAllow && e.preventDefault();
    return e.changedTouches ? e.changedTouches[0] : e;
  },
      _getAbsoluteMax = function _getAbsoluteMax(a) {
    var max = Math.max.apply(Math, a),
        min = Math.min.apply(Math, a);
    return Math.abs(max) >= Math.abs(min) ? max : min;
  },
      _setScrollTrigger = function _setScrollTrigger() {
    ScrollTrigger$2 = gsap$3.core.globals().ScrollTrigger;
    ScrollTrigger$2 && ScrollTrigger$2.core && _integrate();
  },
      _initCore$2 = function _initCore(core) {
    gsap$3 = core || _getGSAP$3();

    if (!_coreInitted$3 && gsap$3 && typeof document !== "undefined" && document.body) {
      _win$2 = window;
      _doc$1 = document;
      _docEl$2 = _doc$1.documentElement;
      _body$2 = _doc$1.body;
      _root$1 = [_win$2, _doc$1, _docEl$2, _body$2];
      gsap$3.utils.clamp;

      _context$1 = gsap$3.core.context || function () {};

      _pointerType = "onpointerenter" in _body$2 ? "pointer" : "mouse"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

      _isTouch = Observer$1.isTouch = _win$2.matchMedia && _win$2.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win$2 || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
      _eventTypes = Observer$1.eventTypes = ("ontouchstart" in _docEl$2 ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl$2) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
      setTimeout(function () {
        return _startup$1 = 0;
      }, 500);

      _setScrollTrigger();

      _coreInitted$3 = 1;
    }

    return _coreInitted$3;
  };

  _horizontal.op = _vertical;
  _scrollers.cache = 0;
  var Observer$1 = /*#__PURE__*/function () {
    function Observer(vars) {
      this.init(vars);
    }

    var _proto = Observer.prototype;

    _proto.init = function init(vars) {
      _coreInitted$3 || _initCore$2(gsap$3) || console.warn("Please gsap.registerPlugin(Observer)");
      ScrollTrigger$2 || _setScrollTrigger();
      var tolerance = vars.tolerance,
          dragMinimum = vars.dragMinimum,
          type = vars.type,
          target = vars.target,
          lineHeight = vars.lineHeight,
          debounce = vars.debounce,
          preventDefault = vars.preventDefault,
          onStop = vars.onStop,
          onStopDelay = vars.onStopDelay,
          ignore = vars.ignore,
          wheelSpeed = vars.wheelSpeed,
          event = vars.event,
          onDragStart = vars.onDragStart,
          onDragEnd = vars.onDragEnd,
          onDrag = vars.onDrag,
          onPress = vars.onPress,
          onRelease = vars.onRelease,
          onRight = vars.onRight,
          onLeft = vars.onLeft,
          onUp = vars.onUp,
          onDown = vars.onDown,
          onChangeX = vars.onChangeX,
          onChangeY = vars.onChangeY,
          onChange = vars.onChange,
          onToggleX = vars.onToggleX,
          onToggleY = vars.onToggleY,
          onHover = vars.onHover,
          onHoverEnd = vars.onHoverEnd,
          onMove = vars.onMove,
          ignoreCheck = vars.ignoreCheck,
          isNormalizer = vars.isNormalizer,
          onGestureStart = vars.onGestureStart,
          onGestureEnd = vars.onGestureEnd,
          onWheel = vars.onWheel,
          onEnable = vars.onEnable,
          onDisable = vars.onDisable,
          onClick = vars.onClick,
          scrollSpeed = vars.scrollSpeed,
          capture = vars.capture,
          allowClicks = vars.allowClicks,
          lockAxis = vars.lockAxis,
          onLockAxis = vars.onLockAxis;
      this.target = target = _getTarget(target) || _docEl$2;
      this.vars = vars;
      ignore && (ignore = gsap$3.utils.toArray(ignore));
      tolerance = tolerance || 1e-9;
      dragMinimum = dragMinimum || 0;
      wheelSpeed = wheelSpeed || 1;
      scrollSpeed = scrollSpeed || 1;
      type = type || "wheel,touch,pointer";
      debounce = debounce !== false;
      lineHeight || (lineHeight = parseFloat(_win$2.getComputedStyle(_body$2).lineHeight) || 22); // note: browser may report "normal", so default to 22.

      var id,
          onStopDelayedCall,
          dragged,
          moved,
          wheeled,
          locked,
          axis,
          self = this,
          prevDeltaX = 0,
          prevDeltaY = 0,
          passive = vars.passive || !preventDefault && vars.passive !== false,
          scrollFuncX = _getScrollFunc(target, _horizontal),
          scrollFuncY = _getScrollFunc(target, _vertical),
          scrollX = scrollFuncX(),
          scrollY = scrollFuncY(),
          limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
          // for devices that accommodate mouse events and touch events, we need to distinguish.
      isViewport = _isViewport$1(target),
          ownerDoc = target.ownerDocument || _doc$1,
          deltaX = [0, 0, 0],
          // wheel, scroll, pointer/touch
      deltaY = [0, 0, 0],
          onClickTime = 0,
          clickCapture = function clickCapture() {
        return onClickTime = _getTime$1();
      },
          _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
        return (self.event = e) && ignore && _isWithin(e.target, ignore) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
      },
          onStopFunc = function onStopFunc() {
        self._vx.reset();

        self._vy.reset();

        onStopDelayedCall.pause();
        onStop && onStop(self);
      },
          update = function update() {
        var dx = self.deltaX = _getAbsoluteMax(deltaX),
            dy = self.deltaY = _getAbsoluteMax(deltaY),
            changedX = Math.abs(dx) >= tolerance,
            changedY = Math.abs(dy) >= tolerance;

        onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.

        if (changedX) {
          onRight && self.deltaX > 0 && onRight(self);
          onLeft && self.deltaX < 0 && onLeft(self);
          onChangeX && onChangeX(self);
          onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
          prevDeltaX = self.deltaX;
          deltaX[0] = deltaX[1] = deltaX[2] = 0;
        }

        if (changedY) {
          onDown && self.deltaY > 0 && onDown(self);
          onUp && self.deltaY < 0 && onUp(self);
          onChangeY && onChangeY(self);
          onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
          prevDeltaY = self.deltaY;
          deltaY[0] = deltaY[1] = deltaY[2] = 0;
        }

        if (moved || dragged) {
          onMove && onMove(self);

          if (dragged) {
            onDragStart && dragged === 1 && onDragStart(self);
            onDrag && onDrag(self);
            dragged = 0;
          }

          moved = false;
        }

        locked && !(locked = false) && onLockAxis && onLockAxis(self);

        if (wheeled) {
          onWheel(self);
          wheeled = false;
        }

        id = 0;
      },
          onDelta = function onDelta(x, y, index) {
        deltaX[index] += x;
        deltaY[index] += y;

        self._vx.update(x);

        self._vy.update(y);

        debounce ? id || (id = requestAnimationFrame(update)) : update();
      },
          onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
        if (lockAxis && !axis) {
          self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
          locked = true;
        }

        if (axis !== "y") {
          deltaX[2] += x;

          self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.

        }

        if (axis !== "x") {
          deltaY[2] += y;

          self._vy.update(y, true);
        }

        debounce ? id || (id = requestAnimationFrame(update)) : update();
      },
          _onDrag = function _onDrag(e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }

        e = _getEvent(e, preventDefault);
        var x = e.clientX,
            y = e.clientY,
            dx = x - self.x,
            dy = y - self.y,
            isDragging = self.isDragging;
        self.x = x;
        self.y = y;

        if (isDragging || (dx || dy) && (Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum)) {
          dragged = isDragging ? 2 : 1; // dragged: 0 = not dragging, 1 = first drag, 2 = normal drag

          isDragging || (self.isDragging = true);
          onTouchOrPointerDelta(dx, dy);
        }
      },
          _onPress = self.onPress = function (e) {
        if (_ignoreCheck(e, 1) || e && e.button) {
          return;
        }

        self.axis = axis = null;
        onStopDelayedCall.pause();
        self.isPressed = true;
        e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.

        prevDeltaX = prevDeltaY = 0;
        self.startX = self.x = e.clientX;
        self.startY = self.y = e.clientY;

        self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.


        self._vy.reset();

        _addListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);

        self.deltaX = self.deltaY = 0;
        onPress && onPress(self);
      },
          _onRelease = self.onRelease = function (e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }

        _removeListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);

        var isTrackingDrag = !isNaN(self.y - self.startY),
            wasDragging = self.isDragging,
            isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
            // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.
        eventData = _getEvent(e);

        if (!isDragNotClick && isTrackingDrag) {
          self._vx.reset();

          self._vy.reset(); //if (preventDefault && allowClicks && self.isPressed) { // check isPressed because in a rare edge case, the inputObserver in ScrollTrigger may stopPropagation() on the press/drag, so the onRelease may get fired without the onPress/onDrag ever getting called, thus it could trigger a click to occur on a link after scroll-dragging it.


          if (preventDefault && allowClicks) {
            gsap$3.delayedCall(0.08, function () {
              // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
              if (_getTime$1() - onClickTime > 300 && !e.defaultPrevented) {
                if (e.target.click) {
                  //some browsers (like mobile Safari) don't properly trigger the click event
                  e.target.click();
                } else if (ownerDoc.createEvent) {
                  var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                  syntheticEvent.initMouseEvent("click", true, true, _win$2, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                  e.target.dispatchEvent(syntheticEvent);
                }
              }
            });
          }
        }

        self.isDragging = self.isGesturing = self.isPressed = false;
        onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);
        dragged && update(); // in case debouncing, we don't want onDrag to fire AFTER onDragEnd().

        onDragEnd && wasDragging && onDragEnd(self);
        onRelease && onRelease(self, isDragNotClick);
      },
          _onGestureStart = function _onGestureStart(e) {
        return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
      },
          _onGestureEnd = function _onGestureEnd() {
        return (self.isGesturing = false) || onGestureEnd(self);
      },
          onScroll = function onScroll(e) {
        if (_ignoreCheck(e)) {
          return;
        }

        var x = scrollFuncX(),
            y = scrollFuncY();
        onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
        scrollX = x;
        scrollY = y;
        onStop && onStopDelayedCall.restart(true);
      },
          _onWheel = function _onWheel(e) {
        if (_ignoreCheck(e)) {
          return;
        }

        e = _getEvent(e, preventDefault);
        onWheel && (wheeled = true);
        var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win$2.innerHeight : 1) * wheelSpeed;
        onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
        onStop && !isNormalizer && onStopDelayedCall.restart(true);
      },
          _onMove = function _onMove(e) {
        if (_ignoreCheck(e)) {
          return;
        }

        var x = e.clientX,
            y = e.clientY,
            dx = x - self.x,
            dy = y - self.y;
        self.x = x;
        self.y = y;
        moved = true;
        onStop && onStopDelayedCall.restart(true);
        (dx || dy) && onTouchOrPointerDelta(dx, dy);
      },
          _onHover = function _onHover(e) {
        self.event = e;
        onHover(self);
      },
          _onHoverEnd = function _onHoverEnd(e) {
        self.event = e;
        onHoverEnd(self);
      },
          _onClick = function _onClick(e) {
        return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
      };

      onStopDelayedCall = self._dc = gsap$3.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
      self.deltaX = self.deltaY = 0;
      self._vx = _getVelocityProp(0, 50, true);
      self._vy = _getVelocityProp(0, 50, true);
      self.scrollX = scrollFuncX;
      self.scrollY = scrollFuncY;
      self.isDragging = self.isGesturing = self.isPressed = false;

      _context$1(this);

      self.enable = function (e) {
        if (!self.isEnabled) {
          _addListener$1(isViewport ? ownerDoc : target, "scroll", _onScroll$1);

          type.indexOf("scroll") >= 0 && _addListener$1(isViewport ? ownerDoc : target, "scroll", onScroll, passive, capture);
          type.indexOf("wheel") >= 0 && _addListener$1(target, "wheel", _onWheel, passive, capture);

          if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
            _addListener$1(target, _eventTypes[0], _onPress, passive, capture);

            _addListener$1(ownerDoc, _eventTypes[2], _onRelease);

            _addListener$1(ownerDoc, _eventTypes[3], _onRelease);

            allowClicks && _addListener$1(target, "click", clickCapture, true, true);
            onClick && _addListener$1(target, "click", _onClick);
            onGestureStart && _addListener$1(ownerDoc, "gesturestart", _onGestureStart);
            onGestureEnd && _addListener$1(ownerDoc, "gestureend", _onGestureEnd);
            onHover && _addListener$1(target, _pointerType + "enter", _onHover);
            onHoverEnd && _addListener$1(target, _pointerType + "leave", _onHoverEnd);
            onMove && _addListener$1(target, _pointerType + "move", _onMove);
          }

          self.isEnabled = true;
          self.isDragging = self.isGesturing = self.isPressed = moved = dragged = false;

          self._vx.reset();

          self._vy.reset();

          scrollX = scrollFuncX();
          scrollY = scrollFuncY();
          e && e.type && _onPress(e);
          onEnable && onEnable(self);
        }

        return self;
      };

      self.disable = function () {
        if (self.isEnabled) {
          // only remove the _onScroll listener if there aren't any others that rely on the functionality.
          _observers.filter(function (o) {
            return o !== self && _isViewport$1(o.target);
          }).length || _removeListener$1(isViewport ? ownerDoc : target, "scroll", _onScroll$1);

          if (self.isPressed) {
            self._vx.reset();

            self._vy.reset();

            _removeListener$1(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
          }

          _removeListener$1(isViewport ? ownerDoc : target, "scroll", onScroll, capture);

          _removeListener$1(target, "wheel", _onWheel, capture);

          _removeListener$1(target, _eventTypes[0], _onPress, capture);

          _removeListener$1(ownerDoc, _eventTypes[2], _onRelease);

          _removeListener$1(ownerDoc, _eventTypes[3], _onRelease);

          _removeListener$1(target, "click", clickCapture, true);

          _removeListener$1(target, "click", _onClick);

          _removeListener$1(ownerDoc, "gesturestart", _onGestureStart);

          _removeListener$1(ownerDoc, "gestureend", _onGestureEnd);

          _removeListener$1(target, _pointerType + "enter", _onHover);

          _removeListener$1(target, _pointerType + "leave", _onHoverEnd);

          _removeListener$1(target, _pointerType + "move", _onMove);

          self.isEnabled = self.isPressed = self.isDragging = false;
          onDisable && onDisable(self);
        }
      };

      self.kill = self.revert = function () {
        self.disable();

        var i = _observers.indexOf(self);

        i >= 0 && _observers.splice(i, 1);
        _normalizer$1 === self && (_normalizer$1 = 0);
      };

      _observers.push(self);

      isNormalizer && _isViewport$1(target) && (_normalizer$1 = self);
      self.enable(event);
    };

    _createClass(Observer, [{
      key: "velocityX",
      get: function get() {
        return this._vx.getVelocity();
      }
    }, {
      key: "velocityY",
      get: function get() {
        return this._vy.getVelocity();
      }
    }]);

    return Observer;
  }();
  Observer$1.version = "3.13.0";

  Observer$1.create = function (vars) {
    return new Observer$1(vars);
  };

  Observer$1.register = _initCore$2;

  Observer$1.getAll = function () {
    return _observers.slice();
  };

  Observer$1.getById = function (id) {
    return _observers.filter(function (o) {
      return o.vars.id === id;
    })[0];
  };

  _getGSAP$3() && gsap$3.registerPlugin(Observer$1);

  /*!
   * ScrollTrigger 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */


  var gsap$2,
      _coreInitted$2,
      _win$1,
      _doc,
      _docEl$1,
      _body$1,
      _root,
      _resizeDelay,
      _toArray$2,
      _clamp,
      _time2,
      _syncInterval,
      _refreshing,
      _pointerIsDown,
      _transformProp,
      _i,
      _prevWidth,
      _prevHeight,
      _autoRefresh,
      _sort,
      _suppressOverwrites,
      _ignoreResize,
      _normalizer,
      _ignoreMobileResize,
      _baseScreenHeight,
      _baseScreenWidth,
      _fixIOSBug,
      _context,
      _scrollRestoration,
      _div100vh,
      _100vh,
      _isReverted,
      _clampingMax,
      _limitCallbacks,
      // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
  _startup = 1,
      _getTime = Date.now,
      _time1 = _getTime(),
      _lastScrollTime = 0,
      _enabled = 0,
      _parseClamp = function _parseClamp(value, type, self) {
    var clamp = _isString$1(value) && (value.substr(0, 6) === "clamp(" || value.indexOf("max") > -1);
    self["_" + type + "Clamp"] = clamp;
    return clamp ? value.substr(6, value.length - 7) : value;
  },
      _keepClamp = function _keepClamp(value, clamp) {
    return clamp && (!_isString$1(value) || value.substr(0, 6) !== "clamp(") ? "clamp(" + value + ")" : value;
  },
      _rafBugFix = function _rafBugFix() {
    return _enabled && requestAnimationFrame(_rafBugFix);
  },
      // in some browsers (like Firefox), screen repaints weren't consistent unless we had SOMETHING queued up in requestAnimationFrame()! So this just creates a super simple loop to keep it alive and smooth out repaints.
  _pointerDownHandler = function _pointerDownHandler() {
    return _pointerIsDown = 1;
  },
      _pointerUpHandler = function _pointerUpHandler() {
    return _pointerIsDown = 0;
  },
      _passThrough = function _passThrough(v) {
    return v;
  },
      _round$1 = function _round(value) {
    return Math.round(value * 100000) / 100000 || 0;
  },
      _windowExists$2 = function _windowExists() {
    return typeof window !== "undefined";
  },
      _getGSAP$2 = function _getGSAP() {
    return gsap$2 || _windowExists$2() && (gsap$2 = window.gsap) && gsap$2.registerPlugin && gsap$2;
  },
      _isViewport = function _isViewport(e) {
    return !!~_root.indexOf(e);
  },
      _getViewportDimension = function _getViewportDimension(dimensionProperty) {
    return (dimensionProperty === "Height" ? _100vh : _win$1["inner" + dimensionProperty]) || _docEl$1["client" + dimensionProperty] || _body$1["client" + dimensionProperty];
  },
      _getBoundsFunc = function _getBoundsFunc(element) {
    return _getProxyProp(element, "getBoundingClientRect") || (_isViewport(element) ? function () {
      _winOffsets.width = _win$1.innerWidth;
      _winOffsets.height = _100vh;
      return _winOffsets;
    } : function () {
      return _getBounds(element);
    });
  },
      _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
    var d = _ref.d,
        d2 = _ref.d2,
        a = _ref.a;
    return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function () {
      return a()[d];
    } : function () {
      return (isViewport ? _getViewportDimension(d2) : scroller["client" + d2]) || 0;
    };
  },
      _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
    return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
      return _winOffsets;
    };
  },
      _maxScroll = function _maxScroll(element, _ref2) {
    var s = _ref2.s,
        d2 = _ref2.d2,
        d = _ref2.d,
        a = _ref2.a;
    return Math.max(0, (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl$1[s] || _body$1[s]) - _getViewportDimension(d2) : element[s] - element["offset" + d2]);
  },
      _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
    for (var i = 0; i < _autoRefresh.length; i += 3) {
      (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
    }
  },
      _isString$1 = function _isString(value) {
    return typeof value === "string";
  },
      _isFunction$1 = function _isFunction(value) {
    return typeof value === "function";
  },
      _isNumber = function _isNumber(value) {
    return typeof value === "number";
  },
      _isObject = function _isObject(value) {
    return typeof value === "object";
  },
      _endAnimation = function _endAnimation(animation, reversed, pause) {
    return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
  },
      _callback = function _callback(self, func) {
    if (self.enabled) {
      var result = self._ctx ? self._ctx.add(function () {
        return func(self);
      }) : func(self);
      result && result.totalTime && (self.callbackAnimation = result);
    }
  },
      _abs = Math.abs,
      _left = "left",
      _top = "top",
      _right = "right",
      _bottom = "bottom",
      _width = "width",
      _height = "height",
      _Right = "Right",
      _Left = "Left",
      _Top = "Top",
      _Bottom = "Bottom",
      _padding = "padding",
      _margin = "margin",
      _Width = "Width",
      _Height = "Height",
      _px = "px",
      _getComputedStyle = function _getComputedStyle(element) {
    return _win$1.getComputedStyle(element);
  },
      _makePositionable = function _makePositionable(element) {
    // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
    var position = _getComputedStyle(element).position;

    element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
  },
      _setDefaults = function _setDefaults(obj, defaults) {
    for (var p in defaults) {
      p in obj || (obj[p] = defaults[p]);
    }

    return obj;
  },
      _getBounds = function _getBounds(element, withoutTransforms) {
    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap$2.to(element, {
      x: 0,
      y: 0,
      xPercent: 0,
      yPercent: 0,
      rotation: 0,
      rotationX: 0,
      rotationY: 0,
      scale: 1,
      skewX: 0,
      skewY: 0
    }).progress(1),
        bounds = element.getBoundingClientRect();
    tween && tween.progress(0).kill();
    return bounds;
  },
      _getSize = function _getSize(element, _ref3) {
    var d2 = _ref3.d2;
    return element["offset" + d2] || element["client" + d2] || 0;
  },
      _getLabelRatioArray = function _getLabelRatioArray(timeline) {
    var a = [],
        labels = timeline.labels,
        duration = timeline.duration(),
        p;

    for (p in labels) {
      a.push(labels[p] / duration);
    }

    return a;
  },
      _getClosestLabel = function _getClosestLabel(animation) {
    return function (value) {
      return gsap$2.utils.snap(_getLabelRatioArray(animation), value);
    };
  },
      _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
    var snap = gsap$2.utils.snap(snapIncrementOrArray),
        a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {
      return a - b;
    });
    return a ? function (value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }

      var i;

      if (!direction) {
        return snap(value);
      }

      if (direction > 0) {
        value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.

        for (i = 0; i < a.length; i++) {
          if (a[i] >= value) {
            return a[i];
          }
        }

        return a[i - 1];
      } else {
        i = a.length;
        value += threshold;

        while (i--) {
          if (a[i] <= value) {
            return a[i];
          }
        }
      }

      return a[0];
    } : function (value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }

      var snapped = snap(value);
      return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
    };
  },
      _getLabelAtDirection = function _getLabelAtDirection(timeline) {
    return function (value, st) {
      return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
    };
  },
      _multiListener = function _multiListener(func, element, types, callback) {
    return types.split(",").forEach(function (type) {
      return func(element, type, callback);
    });
  },
      _addListener = function _addListener(element, type, func, nonPassive, capture) {
    return element.addEventListener(type, func, {
      passive: !nonPassive,
      capture: !!capture
    });
  },
      _removeListener = function _removeListener(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  },
      _wheelListener = function _wheelListener(func, el, scrollFunc) {
    scrollFunc = scrollFunc && scrollFunc.wheelHandler;

    if (scrollFunc) {
      func(el, "wheel", scrollFunc);
      func(el, "touchmove", scrollFunc);
    }
  },
      _markerDefaults = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
  },
      _defaults = {
    toggleActions: "play",
    anticipatePin: 0
  },
      _keywords = {
    top: 0,
    left: 0,
    center: 0.5,
    bottom: 1,
    right: 1
  },
      _offsetToPx = function _offsetToPx(value, size) {
    if (_isString$1(value)) {
      var eqIndex = value.indexOf("="),
          relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;

      if (~eqIndex) {
        value.indexOf("%") > eqIndex && (relative *= size / 100);
        value = value.substr(0, eqIndex - 1);
      }

      value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
    }

    return value;
  },
      _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
    var startColor = _ref4.startColor,
        endColor = _ref4.endColor,
        fontSize = _ref4.fontSize,
        indent = _ref4.indent,
        fontWeight = _ref4.fontWeight;

    var e = _doc.createElement("div"),
        useFixedPosition = _isViewport(container) || _getProxyProp(container, "pinType") === "fixed",
        isScroller = type.indexOf("scroller") !== -1,
        parent = useFixedPosition ? _body$1 : container,
        isStart = type.indexOf("start") !== -1,
        color = isStart ? startColor : endColor,
        css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";

    css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
    (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
    matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
    e._isStart = isStart;
    e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
    e.style.cssText = css;
    e.innerText = name || name === 0 ? type + "-" + name : type;
    parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
    e._offset = e["offset" + direction.op.d2];

    _positionMarker(e, 0, direction, isStart);

    return e;
  },
      _positionMarker = function _positionMarker(marker, start, direction, flipped) {
    var vars = {
      display: "block"
    },
        side = direction[flipped ? "os2" : "p2"],
        oppositeSide = direction[flipped ? "p2" : "os2"];
    marker._isFlipped = flipped;
    vars[direction.a + "Percent"] = flipped ? -100 : 0;
    vars[direction.a] = flipped ? "1px" : 0;
    vars["border" + side + _Width] = 1;
    vars["border" + oppositeSide + _Width] = 0;
    vars[direction.p] = start + "px";
    gsap$2.set(marker, vars);
  },
      _triggers = [],
      _ids = {},
      _rafID,
      _sync = function _sync() {
    return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
  },
      _onScroll = function _onScroll() {
    // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010
    if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body$1.clientWidth) {
      // if the user is dragging the scrollbar, allow it.
      _scrollers.cache++;

      if (_normalizer) {
        _rafID || (_rafID = requestAnimationFrame(_updateAll));
      } else {
        _updateAll(); // Safari in particular (on desktop) NEEDS the immediate update rather than waiting for a requestAnimationFrame() whereas iOS seems to benefit from waiting for the requestAnimationFrame() tick, at least when normalizing. See https://codepen.io/GreenSock/pen/qBYozqO?editors=0110

      }

      _lastScrollTime || _dispatch("scrollStart");
      _lastScrollTime = _getTime();
    }
  },
      _setBaseDimensions = function _setBaseDimensions() {
    _baseScreenWidth = _win$1.innerWidth;
    _baseScreenHeight = _win$1.innerHeight;
  },
      _onResize = function _onResize(force) {
    _scrollers.cache++;
    (force === true || !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win$1.innerWidth || Math.abs(_win$1.innerHeight - _baseScreenHeight) > _win$1.innerHeight * 0.25)) && _resizeDelay.restart(true);
  },
      // ignore resizes triggered by refresh()
  _listeners = {},
      _emptyArray = [],
      _softRefresh = function _softRefresh() {
    return _removeListener(ScrollTrigger$1, "scrollEnd", _softRefresh) || _refreshAll(true);
  },
      _dispatch = function _dispatch(type) {
    return _listeners[type] && _listeners[type].map(function (f) {
      return f();
    }) || _emptyArray;
  },
      _savedStyles = [],
      // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
  _revertRecorded = function _revertRecorded(media) {
    for (var i = 0; i < _savedStyles.length; i += 5) {
      if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
        _savedStyles[i].style.cssText = _savedStyles[i + 1];
        _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
        _savedStyles[i + 3].uncache = 1;
      }
    }
  },
      _revertAll = function _revertAll(kill, media) {
    var trigger;

    for (_i = 0; _i < _triggers.length; _i++) {
      trigger = _triggers[_i];

      if (trigger && (!media || trigger._ctx === media)) {
        if (kill) {
          trigger.kill(1);
        } else {
          trigger.revert(true, true);
        }
      }
    }

    _isReverted = true;
    media && _revertRecorded(media);
    media || _dispatch("revert");
  },
      _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {
    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.
    _scrollers.cache++;
    (force || !_refreshingAll) && _scrollers.forEach(function (obj) {
      return _isFunction$1(obj) && obj.cacheID++ && (obj.rec = 0);
    });
    _isString$1(scrollRestoration) && (_win$1.history.scrollRestoration = _scrollRestoration = scrollRestoration);
  },
      _refreshingAll,
      _refreshID = 0,
      _queueRefreshID,
      _queueRefreshAll = function _queueRefreshAll() {
    // we don't want to call _refreshAll() every time we create a new ScrollTrigger (for performance reasons) - it's better to batch them. Some frameworks dynamically load content and we can't rely on the window's "load" or "DOMContentLoaded" events to trigger it.
    if (_queueRefreshID !== _refreshID) {
      var id = _queueRefreshID = _refreshID;
      requestAnimationFrame(function () {
        return id === _refreshID && _refreshAll(true);
      });
    }
  },
      _refresh100vh = function _refresh100vh() {
    _body$1.appendChild(_div100vh);

    _100vh = !_normalizer && _div100vh.offsetHeight || _win$1.innerHeight;

    _body$1.removeChild(_div100vh);
  },
      _hideAllMarkers = function _hideAllMarkers(hide) {
    return _toArray$2(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function (el) {
      return el.style.display = hide ? "none" : "block";
    });
  },
      _refreshAll = function _refreshAll(force, skipRevert) {
    _docEl$1 = _doc.documentElement; // some frameworks like Astro may cache the <body> and replace it during routing, so we'll just re-record the _docEl and _body for safety (otherwise, the markers may not get added properly).

    _body$1 = _doc.body;
    _root = [_win$1, _doc, _docEl$1, _body$1];

    if (_lastScrollTime && !force && !_isReverted) {
      _addListener(ScrollTrigger$1, "scrollEnd", _softRefresh);

      return;
    }

    _refresh100vh();

    _refreshingAll = ScrollTrigger$1.isRefreshing = true;

    _scrollers.forEach(function (obj) {
      return _isFunction$1(obj) && ++obj.cacheID && (obj.rec = obj());
    }); // force the clearing of the cache because some browsers take a little while to dispatch the "scroll" event and the user may have changed the scroll position and then called ScrollTrigger.refresh() right away


    var refreshInits = _dispatch("refreshInit");

    _sort && ScrollTrigger$1.sort();
    skipRevert || _revertAll();

    _scrollers.forEach(function (obj) {
      if (_isFunction$1(obj)) {
        obj.smooth && (obj.target.style.scrollBehavior = "auto"); // smooth scrolling interferes

        obj(0);
      }
    });

    _triggers.slice(0).forEach(function (t) {
      return t.refresh();
    }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.


    _isReverted = false;

    _triggers.forEach(function (t) {
      // nested pins (pinnedContainer) with pinSpacing may expand the container, so we must accommodate that here.
      if (t._subPinOffset && t.pin) {
        var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
            original = t.pin[prop];
        t.revert(true, 1);
        t.adjustPinSpacing(t.pin[prop] - original);
        t.refresh();
      }
    });

    _clampingMax = 1; // pinSpacing might be propping a page open, thus when we .setPositions() to clamp a ScrollTrigger's end we should leave the pinSpacing alone. That's what this flag is for.

    _hideAllMarkers(true);

    _triggers.forEach(function (t) {
      // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: "max". Same for anything with a clamped end
      var max = _maxScroll(t.scroller, t._dir),
          endClamp = t.vars.end === "max" || t._endClamp && t.end > max,
          startClamp = t._startClamp && t.start >= max;

      (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);
    });

    _hideAllMarkers(false);

    _clampingMax = 0;
    refreshInits.forEach(function (result) {
      return result && result.render && result.render(-1);
    }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.

    _scrollers.forEach(function (obj) {
      if (_isFunction$1(obj)) {
        obj.smooth && requestAnimationFrame(function () {
          return obj.target.style.scrollBehavior = "smooth";
        });
        obj.rec && obj(obj.rec);
      }
    });

    _clearScrollMemory(_scrollRestoration, 1);

    _resizeDelay.pause();

    _refreshID++;
    _refreshingAll = 2;

    _updateAll(2);

    _triggers.forEach(function (t) {
      return _isFunction$1(t.vars.onRefresh) && t.vars.onRefresh(t);
    });

    _refreshingAll = ScrollTrigger$1.isRefreshing = false;

    _dispatch("refresh");
  },
      _lastScroll = 0,
      _direction = 1,
      _primary,
      _updateAll = function _updateAll(force) {
    if (force === 2 || !_refreshingAll && !_isReverted) {
      // _isReverted could be true if, for example, a matchMedia() is in the process of executing. We don't want to update during the time everything is reverted.
      ScrollTrigger$1.isUpdating = true;
      _primary && _primary.update(0); // ScrollSmoother uses refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.

      var l = _triggers.length,
          time = _getTime(),
          recordVelocity = time - _time1 >= 50,
          scroll = l && _triggers[0].scroll();

      _direction = _lastScroll > scroll ? -1 : 1;
      _refreshingAll || (_lastScroll = scroll);

      if (recordVelocity) {
        if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
          _lastScrollTime = 0;

          _dispatch("scrollEnd");
        }

        _time2 = _time1;
        _time1 = time;
      }

      if (_direction < 0) {
        _i = l;

        while (_i-- > 0) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }

        _direction = 1;
      } else {
        for (_i = 0; _i < l; _i++) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
      }

      ScrollTrigger$1.isUpdating = false;
    }

    _rafID = 0;
  },
      _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
      _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
      _swapPinOut = function _swapPinOut(pin, spacer, state) {
    _setState(state);

    var cache = pin._gsap;

    if (cache.spacerIsNative) {
      _setState(cache.spacerState);
    } else if (pin._gsap.swappedIn) {
      var parent = spacer.parentNode;

      if (parent) {
        parent.insertBefore(pin, spacer);
        parent.removeChild(spacer);
      }
    }

    pin._gsap.swappedIn = false;
  },
      _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
    if (!pin._gsap.swappedIn) {
      var i = _propNamesToCopy.length,
          spacerStyle = spacer.style,
          pinStyle = pin.style,
          p;

      while (i--) {
        p = _propNamesToCopy[i];
        spacerStyle[p] = cs[p];
      }

      spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
      cs.display === "inline" && (spacerStyle.display = "inline-block");
      pinStyle[_bottom] = pinStyle[_right] = "auto";
      spacerStyle.flexBasis = cs.flexBasis || "auto";
      spacerStyle.overflow = "visible";
      spacerStyle.boxSizing = "border-box";
      spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
      spacerStyle[_height] = _getSize(pin, _vertical) + _px;
      spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";

      _setState(spacerState);

      pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
      pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
      pinStyle[_padding] = cs[_padding];

      if (pin.parentNode !== spacer) {
        pin.parentNode.insertBefore(spacer, pin);
        spacer.appendChild(pin);
      }

      pin._gsap.swappedIn = true;
    }
  },
      _capsExp = /([A-Z])/g,
      _setState = function _setState(state) {
    if (state) {
      var style = state.t.style,
          l = state.length,
          i = 0,
          p,
          value;
      (state.t._gsap || gsap$2.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off

      for (; i < l; i += 2) {
        value = state[i + 1];
        p = state[i];

        if (value) {
          style[p] = value;
        } else if (style[p]) {
          style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
        }
      }
    }
  },
      _getState = function _getState(element) {
    // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
    var l = _stateProps.length,
        style = element.style,
        state = [],
        i = 0;

    for (; i < l; i++) {
      state.push(_stateProps[i], style[_stateProps[i]]);
    }

    state.t = element;
    return state;
  },
      _copyState = function _copyState(state, override, omitOffsets) {
    var result = [],
        l = state.length,
        i = omitOffsets ? 8 : 0,
        // skip top, left, right, bottom if omitOffsets is true
    p;

    for (; i < l; i += 2) {
      p = state[i];
      result.push(p, p in override ? override[p] : state[i + 1]);
    }

    result.t = state.t;
    return result;
  },
      _winOffsets = {
    left: 0,
    top: 0
  },
      // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition("#id", "top bottom")
  // _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {
  // 	scroller = _getTarget(scroller || _win);
  // 	let direction = horizontal ? _horizontal : _vertical,
  // 		isViewport = _isViewport(scroller);
  // 	_getSizeFunc(scroller, isViewport, direction);
  // 	return _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);
  // },
  _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {
    _isFunction$1(value) && (value = value(self));

    if (_isString$1(value) && value.substr(0, 3) === "max") {
      value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
    }

    var time = containerAnimation ? containerAnimation.time() : 0,
        p1,
        p2,
        element;
    containerAnimation && containerAnimation.seek(0);
    isNaN(value) || (value = +value); // convert a string number like "45" to an actual number

    if (!_isNumber(value)) {
      _isFunction$1(trigger) && (trigger = trigger(self));
      var offsets = (value || "0").split(" "),
          bounds,
          localOffset,
          globalOffset,
          display;
      element = _getTarget(trigger, self) || _body$1;
      bounds = _getBounds(element) || {};

      if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
        // if display is "none", it won't report getBoundingClientRect() properly
        display = element.style.display;
        element.style.display = "block";
        bounds = _getBounds(element);
        display ? element.style.display = display : element.style.removeProperty("display");
      }

      localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
      globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
      value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
      markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
      scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
    } else {
      containerAnimation && (value = gsap$2.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));
      markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);
    }

    if (clampZeroProp) {
      self[clampZeroProp] = value || -0.001;
      value < 0 && (value = 0);
    }

    if (marker) {
      var position = value + scrollerSize,
          isStart = marker._isStart;
      p1 = "scroll" + direction.d2;

      _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body$1[p1], _docEl$1[p1]) : marker.parentNode[p1]) <= position + 1);

      if (useFixedPosition) {
        scrollerBounds = _getBounds(markerScroller);
        useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
      }
    }

    if (containerAnimation && element) {
      p1 = _getBounds(element);
      containerAnimation.seek(scrollerMax);
      p2 = _getBounds(element);
      containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
      value = value / containerAnimation._caScrollDist * scrollerMax;
    }

    containerAnimation && containerAnimation.seek(time);
    return containerAnimation ? value : Math.round(value);
  },
      _prefixExp = /(webkit|moz|length|cssText|inset)/i,
      _reparent = function _reparent(element, parent, top, left) {
    if (element.parentNode !== parent) {
      var style = element.style,
          p,
          cs;

      if (parent === _body$1) {
        element._stOrig = style.cssText; // record original inline styles so we can revert them later

        cs = _getComputedStyle(element);

        for (p in cs) {
          // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
          if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
            style[p] = cs[p];
          }
        }

        style.top = top;
        style.left = left;
      } else {
        style.cssText = element._stOrig;
      }

      gsap$2.core.getCache(element).uncache = 1;
      parent.appendChild(element);
    }
  },
      _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {
    var last1 = initialValue,
        last2 = last1;
    return function (value) {
      var current = Math.round(getValueFunc()); // round because in some [very uncommon] Windows environments, scroll can get reported with decimals even though it was set without.

      if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {
        // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
        value = current;
        onInterrupt && onInterrupt();
      }

      last2 = last1;
      last1 = Math.round(value);
      return last1;
    };
  },
      _shiftMarker = function _shiftMarker(marker, direction, value) {
    var vars = {};
    vars[direction.p] = "+=" + value;
    gsap$2.set(marker, vars);
  },
      // _mergeAnimations = animations => {
  // 	let tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));
  // 	animations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });
  // 	tl.smoothChildTiming = false;
  // 	return tl;
  // },
  // returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
  _getTweenCreator = function _getTweenCreator(scroller, direction) {
    var getScroll = _getScrollFunc(scroller, direction),
        prop = "_scroll" + direction.p2,
        // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
    getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
      var tween = getTween.tween,
          onComplete = vars.onComplete,
          modifiers = {};
      initialValue = initialValue || getScroll();

      var checkForInterruption = _interruptionTracker(getScroll, initialValue, function () {
        tween.kill();
        getTween.tween = 0;
      });

      change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.

      change1 = change1 || scrollTo - initialValue;
      tween && tween.kill();
      vars[prop] = scrollTo;
      vars.inherit = false;
      vars.modifiers = modifiers;

      modifiers[prop] = function () {
        return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);
      };

      vars.onUpdate = function () {
        _scrollers.cache++;
        getTween.tween && _updateAll(); // if it was interrupted/killed, like in a context.revert(), don't force an updateAll()
      };

      vars.onComplete = function () {
        getTween.tween = 0;
        onComplete && onComplete.call(tween);
      };

      tween = getTween.tween = gsap$2.to(scroller, vars);
      return tween;
    };

    scroller[prop] = getScroll;

    getScroll.wheelHandler = function () {
      return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
    };

    _addListener(scroller, "wheel", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.


    ScrollTrigger$1.isTouch && _addListener(scroller, "touchmove", getScroll.wheelHandler);
    return getTween;
  };

  var ScrollTrigger$1 = /*#__PURE__*/function () {
    function ScrollTrigger(vars, animation) {
      _coreInitted$2 || ScrollTrigger.register(gsap$2) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");

      _context(this);

      this.init(vars, animation);
    }

    var _proto = ScrollTrigger.prototype;

    _proto.init = function init(vars, animation) {
      this.progress = this.start = 0;
      this.vars && this.kill(true, true); // in case it's being initted again

      if (!_enabled) {
        this.update = this.refresh = this.kill = _passThrough;
        return;
      }

      vars = _setDefaults(_isString$1(vars) || _isNumber(vars) || vars.nodeType ? {
        trigger: vars
      } : vars, _defaults);

      var _vars = vars,
          onUpdate = _vars.onUpdate,
          toggleClass = _vars.toggleClass,
          id = _vars.id,
          onToggle = _vars.onToggle,
          onRefresh = _vars.onRefresh,
          scrub = _vars.scrub,
          trigger = _vars.trigger,
          pin = _vars.pin,
          pinSpacing = _vars.pinSpacing,
          invalidateOnRefresh = _vars.invalidateOnRefresh,
          anticipatePin = _vars.anticipatePin,
          onScrubComplete = _vars.onScrubComplete,
          onSnapComplete = _vars.onSnapComplete,
          once = _vars.once,
          snap = _vars.snap,
          pinReparent = _vars.pinReparent,
          pinSpacer = _vars.pinSpacer,
          containerAnimation = _vars.containerAnimation,
          fastScrollEnd = _vars.fastScrollEnd,
          preventOverlaps = _vars.preventOverlaps,
          direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical,
          isToggle = !scrub && scrub !== 0,
          scroller = _getTarget(vars.scroller || _win$1),
          scrollerCache = gsap$2.core.getCache(scroller),
          isViewport = _isViewport(scroller),
          useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed",
          callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
          toggleActions = isToggle && vars.toggleActions.split(" "),
          markers = "markers" in vars ? vars.markers : _defaults.markers,
          borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
          self = this,
          onRefreshInit = vars.onRefreshInit && function () {
        return vars.onRefreshInit(self);
      },
          getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
          getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
          lastSnap = 0,
          lastRefresh = 0,
          prevProgress = 0,
          scrollFunc = _getScrollFunc(scroller, direction),
          tweenTo,
          pinCache,
          snapFunc,
          scroll1,
          scroll2,
          start,
          end,
          markerStart,
          markerEnd,
          markerStartTrigger,
          markerEndTrigger,
          markerVars,
          executingOnRefresh,
          change,
          pinOriginalState,
          pinActiveState,
          pinState,
          spacer,
          offset,
          pinGetter,
          pinSetter,
          pinStart,
          pinChange,
          spacingStart,
          spacerState,
          markerStartSetter,
          pinMoves,
          markerEndSetter,
          cs,
          snap1,
          snap2,
          scrubTween,
          scrubSmooth,
          snapDurClamp,
          snapDelayedCall,
          prevScroll,
          prevAnimProgress,
          caMarkerSetter,
          customRevertReturn; // for the sake of efficiency, _startClamp/_endClamp serve like a truthy value indicating that clamping was enabled on the start/end, and ALSO store the actual pre-clamped numeric value. We tap into that in ScrollSmoother for speed effects. So for example, if start="clamp(top bottom)" results in a start of -100 naturally, it would get clamped to 0 but -100 would be stored in _startClamp.


      self._startClamp = self._endClamp = false;
      self._dir = direction;
      anticipatePin *= 45;
      self.scroller = scroller;
      self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
      scroll1 = scrollFunc();
      self.vars = vars;
      animation = animation || vars.animation;

      if ("refreshPriority" in vars) {
        _sort = 1;
        vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother
      }

      scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
        top: _getTweenCreator(scroller, _vertical),
        left: _getTweenCreator(scroller, _horizontal)
      };
      self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];

      self.scrubDuration = function (value) {
        scrubSmooth = _isNumber(value) && value;

        if (!scrubSmooth) {
          scrubTween && scrubTween.progress(1).kill();
          scrubTween = 0;
        } else {
          scrubTween ? scrubTween.duration(value) : scrubTween = gsap$2.to(animation, {
            ease: "expo",
            totalProgress: "+=0",
            inherit: false,
            duration: scrubSmooth,
            paused: true,
            onComplete: function onComplete() {
              return onScrubComplete && onScrubComplete(self);
            }
          });
        }
      };

      if (animation) {
        animation.vars.lazy = false;
        animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true); // special case: if this ScrollTrigger gets re-initted, a from() tween with a stagger could get initted initially and then reverted on the re-init which means it'll need to get rendered again here to properly display things. Otherwise, See https://gsap.com/forums/topic/36777-scrollsmoother-splittext-nextjs/ and https://codepen.io/GreenSock/pen/eYPyPpd?editors=0010

        self.animation = animation.pause();
        animation.scrollTrigger = self;
        self.scrubDuration(scrub);
        snap1 = 0;
        id || (id = animation.vars.id);
      }

      if (snap) {
        // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.
        if (!_isObject(snap) || snap.push) {
          snap = {
            snapTo: snap
          };
        }

        "scrollBehavior" in _body$1.style && gsap$2.set(isViewport ? [_body$1, _docEl$1] : scroller, {
          scrollBehavior: "auto"
        }); // smooth scrolling doesn't work with snap.

        _scrollers.forEach(function (o) {
          return _isFunction$1(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl$1 : scroller) && (o.smooth = false);
        }); // note: set smooth to false on both the vertical and horizontal scroll getters/setters


        snapFunc = _isFunction$1(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {
          return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);
        } : gsap$2.utils.snap(snap.snapTo);
        snapDurClamp = snap.duration || {
          min: 0.1,
          max: 2
        };
        snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);
        snapDelayedCall = gsap$2.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
          var scroll = scrollFunc(),
              refreshedRecently = _getTime() - lastRefresh < 500,
              tween = tweenTo.tween;

          if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
            var progress = (scroll - start) / change,
                totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
                velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,
                change1 = gsap$2.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),
                naturalEnd = progress + (snap.inertia === false ? 0 : change1),
                endValue,
                endScroll,
                _snap = snap,
                onStart = _snap.onStart,
                _onInterrupt = _snap.onInterrupt,
                _onComplete = _snap.onComplete;
            endValue = snapFunc(naturalEnd, self);
            _isNumber(endValue) || (endValue = naturalEnd); // in case the function didn't return a number, fall back to using the naturalEnd

            endScroll = Math.max(0, Math.round(start + endValue * change));

            if (scroll <= end && scroll >= start && endScroll !== scroll) {
              if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
                // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
                return;
              }

              if (snap.inertia === false) {
                change1 = endValue - progress;
              }

              tweenTo(endScroll, {
                duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                ease: snap.ease || "power3",
                data: _abs(endScroll - scroll),
                // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
                onInterrupt: function onInterrupt() {
                  return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
                },
                onComplete: function onComplete() {
                  self.update();
                  lastSnap = scrollFunc();

                  if (animation && !isToggle) {
                    // the resolution of the scrollbar is limited, so we should correct the scrubbed animation's playhead at the end to match EXACTLY where it was supposed to snap
                    scrubTween ? scrubTween.resetTo("totalProgress", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);
                  }

                  snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                  onSnapComplete && onSnapComplete(self);
                  _onComplete && _onComplete(self);
                }
              }, scroll, change1 * change, endScroll - scroll - change1 * change);
              onStart && onStart(self, tweenTo.tween);
            }
          } else if (self.isActive && lastSnap !== scroll) {
            snapDelayedCall.restart(true);
          }
        }).pause();
      }

      id && (_ids[id] = self);
      trigger = self.trigger = _getTarget(trigger || pin !== true && pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the "y" or "x" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.

      customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
      customRevertReturn && (customRevertReturn = customRevertReturn(self));
      pin = pin === true ? trigger : _getTarget(pin);
      _isString$1(toggleClass) && (toggleClass = {
        targets: trigger,
        className: toggleClass
      });

      if (pin) {
        pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default. We should check that pin.parentNode is an element (not shadow dom window)

        self.pin = pin;
        pinCache = gsap$2.core.getCache(pin);

        if (!pinCache.spacer) {
          // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
          if (pinSpacer) {
            pinSpacer = _getTarget(pinSpacer);
            pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular

            pinCache.spacerIsNative = !!pinSpacer;
            pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
          }

          pinCache.spacer = spacer = pinSpacer || _doc.createElement("div");
          spacer.classList.add("pin-spacer");
          id && spacer.classList.add("pin-spacer-" + id);
          pinCache.pinState = pinOriginalState = _getState(pin);
        } else {
          pinOriginalState = pinCache.pinState;
        }

        vars.force3D !== false && gsap$2.set(pin, {
          force3D: true
        });
        self.spacer = spacer = pinCache.spacer;
        cs = _getComputedStyle(pin);
        spacingStart = cs[pinSpacing + direction.os2];
        pinGetter = gsap$2.getProperty(pin);
        pinSetter = gsap$2.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).

        _swapPinIn(pin, spacer, cs);

        pinState = _getState(pin);
      }

      if (markers) {
        markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
        markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
        markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
        offset = markerStartTrigger["offset" + direction.op.d2];

        var content = _getTarget(_getProxyProp(scroller, "content") || scroller);

        markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
        markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
        containerAnimation && (caMarkerSetter = gsap$2.quickSetter([markerStart, markerEnd], direction.a, _px));

        if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
          _makePositionable(isViewport ? _body$1 : scroller);

          gsap$2.set([markerStartTrigger, markerEndTrigger], {
            force3D: true
          });
          markerStartSetter = gsap$2.quickSetter(markerStartTrigger, direction.a, _px);
          markerEndSetter = gsap$2.quickSetter(markerEndTrigger, direction.a, _px);
        }
      }

      if (containerAnimation) {
        var oldOnUpdate = containerAnimation.vars.onUpdate,
            oldParams = containerAnimation.vars.onUpdateParams;
        containerAnimation.eventCallback("onUpdate", function () {
          self.update(0, 0, 1);
          oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);
        });
      }

      self.previous = function () {
        return _triggers[_triggers.indexOf(self) - 1];
      };

      self.next = function () {
        return _triggers[_triggers.indexOf(self) + 1];
      };

      self.revert = function (revert, temp) {
        if (!temp) {
          return self.kill(true);
        } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()


        var r = revert !== false || !self.enabled,
            prevRefreshing = _refreshing;

        if (r !== self.isReverted) {
          if (r) {
            prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.

            prevProgress = self.progress;
            prevAnimProgress = animation && animation.progress();
          }

          markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
            return m.style.display = r ? "none" : "block";
          });

          if (r) {
            _refreshing = self;
            self.update(r); // make sure the pin is back in its original position so that all the measurements are correct. do this BEFORE swapping the pin out
          }

          if (pin && (!pinReparent || !self.isActive)) {
            if (r) {
              _swapPinOut(pin, spacer, pinOriginalState);
            } else {
              _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
            }
          }

          r || self.update(r); // when we're restoring, the update should run AFTER swapping the pin into its pin-spacer.

          _refreshing = prevRefreshing; // restore. We set it to true during the update() so that things fire properly in there.

          self.isReverted = r;
        }
      };

      self.refresh = function (soft, force, position, pinOffset) {
        // position is typically only defined if it's coming from setPositions() - it's a way to skip the normal parsing. pinOffset is also only from setPositions() and is mostly related to fancy stuff we need to do in ScrollSmoother with effects
        if ((_refreshing || !self.enabled) && !force) {
          return;
        }

        if (pin && soft && _lastScrollTime) {
          _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

          return;
        }

        !_refreshingAll && onRefreshInit && onRefreshInit(self);
        _refreshing = self;

        if (tweenTo.tween && !position) {
          // we skip this if a position is passed in because typically that's from .setPositions() and it's best to allow in-progress snapping to continue.
          tweenTo.tween.kill();
          tweenTo.tween = 0;
        }

        scrubTween && scrubTween.pause();

        if (invalidateOnRefresh && animation) {
          animation.revert({
            kill: false
          }).invalidate();
          animation.getChildren && animation.getChildren(true, true, false).forEach(function (t) {
            return t.vars.immediateRender && t.render(0, true, true);
          }); // any from() or fromTo() tweens inside a timeline should render immediately (well, unless they have immediateRender: false)
        }

        self.isReverted || self.revert(true, true);
        self._subPinOffset = false; // we'll set this to true in the sub-pins if we find any

        var size = getScrollerSize(),
            scrollerBounds = getScrollerOffsets(),
            max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
            isFirstRefresh = change <= 0.01 || !change,
            offset = 0,
            otherPinOffset = pinOffset || 0,
            parsedEnd = _isObject(position) ? position.end : vars.end,
            parsedEndTrigger = vars.endTrigger || trigger,
            parsedStart = _isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
            pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer, self),
            triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
            i = triggerIndex,
            cs,
            bounds,
            scroll,
            isVertical,
            override,
            curTrigger,
            curPin,
            oppositeScroll,
            initted,
            revertedPins,
            forcedOverflow,
            markerStartOffset,
            markerEndOffset;

        if (markers && _isObject(position)) {
          // if we alter the start/end positions with .setPositions(), it generally feeds in absolute NUMBERS which don't convey information about where to line up the markers, so to keep it intuitive, we record how far the trigger positions shift after applying the new numbers and then offset by that much in the opposite direction. We do the same to the associated trigger markers too of course.
          markerStartOffset = gsap$2.getProperty(markerStartTrigger, direction.p);
          markerEndOffset = gsap$2.getProperty(markerEndTrigger, direction.p);
        }

        while (i-- > 0) {
          // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
          curTrigger = _triggers[i];
          curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.

          curPin = curTrigger.pin;

          if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {
            revertedPins || (revertedPins = []);
            revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly

            curTrigger.revert(true, true);
          }

          if (curTrigger !== _triggers[i]) {
            // in case it got removed.
            triggerIndex--;
            i--;
          }
        }

        _isFunction$1(parsedStart) && (parsedStart = parsedStart(self));
        parsedStart = _parseClamp(parsedStart, "start", self);
        start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && "_startClamp") || (pin ? -0.001 : 0);
        _isFunction$1(parsedEnd) && (parsedEnd = parsedEnd(self));

        if (_isString$1(parsedEnd) && !parsedEnd.indexOf("+=")) {
          if (~parsedEnd.indexOf(" ")) {
            parsedEnd = (_isString$1(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
          } else {
            offset = _offsetToPx(parsedEnd.substr(2), size);
            parsedEnd = _isString$1(parsedStart) ? parsedStart : (containerAnimation ? gsap$2.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.

            parsedEndTrigger = trigger;
          }
        }

        parsedEnd = _parseClamp(parsedEnd, "end", self);
        end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && "_endClamp")) || -0.001;
        offset = 0;
        i = triggerIndex;

        while (i--) {
          curTrigger = _triggers[i];
          curPin = curTrigger.pin;

          if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
            cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);

            if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {
              // numeric start values shouldn't be offset at all - treat them as absolute
              offset += cs * (1 - curTrigger.progress);
            }

            curPin === pin && (otherPinOffset += cs);
          }
        }

        start += offset;
        end += offset;
        self._startClamp && (self._startClamp += offset);

        if (self._endClamp && !_refreshingAll) {
          self._endClamp = end || -0.001;
          end = Math.min(end, _maxScroll(scroller, direction));
        }

        change = end - start || (start -= 0.01) && 0.001;

        if (isFirstRefresh) {
          // on the very first refresh(), the prevProgress couldn't have been accurate yet because the start/end were never calculated, so we set it here. Before 3.11.5, it could lead to an inaccurate scroll position restoration with snapping.
          prevProgress = gsap$2.utils.clamp(0, 1, gsap$2.utils.normalize(start, end, prevScroll));
        }

        self._pinPush = otherPinOffset;

        if (markerStart && offset) {
          // offset the markers if necessary
          cs = {};
          cs[direction.a] = "+=" + offset;
          pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
          gsap$2.set([markerStart, markerEnd], cs);
        }

        if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {
          cs = _getComputedStyle(pin);
          isVertical = direction === _vertical;
          scroll = scrollFunc(); // recalculate because the triggers can affect the scroll

          pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;

          if (!max && end > 1) {
            // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://gsap.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/
            forcedOverflow = (isViewport ? _doc.scrollingElement || _docEl$1 : scroller).style;
            forcedOverflow = {
              style: forcedOverflow,
              value: forcedOverflow["overflow" + direction.a.toUpperCase()]
            };

            if (isViewport && _getComputedStyle(_body$1)["overflow" + direction.a.toUpperCase()] !== "scroll") {
              // avoid an extra scrollbar if BOTH <html> and <body> have overflow set to "scroll"
              forcedOverflow.style["overflow" + direction.a.toUpperCase()] = "scroll";
            }
          }

          _swapPinIn(pin, spacer, cs);

          pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.

          bounds = _getBounds(pin, true);
          oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();

          if (pinSpacing) {
            spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
            spacerState.t = spacer;
            i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;

            if (i) {
              spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).

              spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
            }

            _setState(spacerState);

            if (pinnedContainer) {
              // in ScrollTrigger.refresh(), we need to re-evaluate the pinContainer's size because this pinSpacing may stretch it out, but we can't just add the exact distance because depending on layout, it may not push things down or it may only do so partially.
              _triggers.forEach(function (t) {
                if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {
                  t._subPinOffset = true;
                }
              });
            }

            useFixedPosition && scrollFunc(prevScroll);
          } else {
            i = _getSize(pin, direction);
            i && spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
          }

          if (useFixedPosition) {
            override = {
              top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
              left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
              boxSizing: "border-box",
              position: "fixed"
            };
            override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
            override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
            override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
            override[_padding] = cs[_padding];
            override[_padding + _Top] = cs[_padding + _Top];
            override[_padding + _Right] = cs[_padding + _Right];
            override[_padding + _Bottom] = cs[_padding + _Bottom];
            override[_padding + _Left] = cs[_padding + _Left];
            pinActiveState = _copyState(pinOriginalState, override, pinReparent);
            _refreshingAll && scrollFunc(0);
          }

          if (animation) {
            // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
            initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.

            _suppressOverwrites(1);

            animation.render(animation.duration(), true, true);
            pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
            pinMoves = Math.abs(change - pinChange) > 1;
            useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.

            animation.render(0, true, true);
            initted || animation.invalidate(true);
            animation.parent || animation.totalTime(animation.totalTime()); // if, for example, a toggleAction called play() and then refresh() happens and when we render(1) above, it would cause the animation to complete and get removed from its parent, so this makes sure it gets put back in.

            _suppressOverwrites(0);
          } else {
            pinChange = change;
          }

          forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
        } else if (trigger && scrollFunc() && !containerAnimation) {
          // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
          bounds = trigger.parentNode;

          while (bounds && bounds !== _body$1) {
            if (bounds._pinOffset) {
              start -= bounds._pinOffset;
              end -= bounds._pinOffset;
            }

            bounds = bounds.parentNode;
          }
        }

        revertedPins && revertedPins.forEach(function (t) {
          return t.revert(false, true);
        });
        self.start = start;
        self.end = end;
        scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(); // reset velocity

        if (!containerAnimation && !_refreshingAll) {
          scroll1 < prevScroll && scrollFunc(prevScroll);
          self.scroll.rec = 0;
        }

        self.revert(false, true);
        lastRefresh = _getTime();

        if (snapDelayedCall) {
          lastSnap = -1; // just so snapping gets re-enabled, clear out any recorded last value
          // self.isActive && scrollFunc(start + change * prevProgress); // previously this line was here to ensure that when snapping kicks in, it's from the previous progress but in some cases that's not desirable, like an all-page ScrollTrigger when new content gets added to the page, that'd totally change the progress.

          snapDelayedCall.restart(true);
        }

        _refreshing = 0;
        animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().

        if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh || animation && !animation._initted) {
          // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
          animation && !isToggle && (animation._initted || prevProgress || animation.vars.immediateRender !== false) && animation.totalProgress(containerAnimation && start < -0.001 && !prevProgress ? gsap$2.utils.normalize(start, end, 0) : prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.

          self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
        }

        pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
        scrubTween && scrubTween.invalidate();

        if (!isNaN(markerStartOffset)) {
          // numbers were passed in for the position which are absolute, so instead of just putting the markers at the very bottom of the viewport, we figure out how far they shifted down (it's safe to assume they were originally positioned in closer relation to the trigger element with values like "top", "center", a percentage or whatever, so we offset that much in the opposite direction to basically revert them to the relative position thy were at previously.
          markerStartOffset -= gsap$2.getProperty(markerStartTrigger, direction.p);
          markerEndOffset -= gsap$2.getProperty(markerEndTrigger, direction.p);

          _shiftMarker(markerStartTrigger, direction, markerStartOffset);

          _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));

          _shiftMarker(markerEndTrigger, direction, markerEndOffset);

          _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));
        }

        isFirstRefresh && !_refreshingAll && self.update(); // edge case - when you reload a page when it's already scrolled down, some browsers fire a "scroll" event before DOMContentLoaded, triggering an updateAll(). If we don't update the self.progress as part of refresh(), then when it happens next, it may record prevProgress as 0 when it really shouldn't, potentially causing a callback in an animation to fire again.

        if (onRefresh && !_refreshingAll && !executingOnRefresh) {
          // when refreshing all, we do extra work to correct pinnedContainer sizes and ensure things don't exceed the maxScroll, so we should do all the refreshes at the end after all that work so that the start/end values are corrected.
          executingOnRefresh = true;
          onRefresh(self);
          executingOnRefresh = false;
        }
      };

      self.getVelocity = function () {
        return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;
      };

      self.endAnimation = function () {
        _endAnimation(self.callbackAnimation);

        if (animation) {
          scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
        }
      };

      self.labelToScroll = function (label) {
        return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
      };

      self.getTrailing = function (name) {
        var i = _triggers.indexOf(self),
            a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);

        return (_isString$1(name) ? a.filter(function (t) {
          return t.vars.preventOverlaps === name;
        }) : a).filter(function (t) {
          return self.direction > 0 ? t.end <= start : t.start >= end;
        });
      };

      self.update = function (reset, recordVelocity, forceFake) {
        if (containerAnimation && !forceFake && !reset) {
          return;
        }

        var scroll = _refreshingAll === true ? prevScroll : self.scroll(),
            p = reset ? 0 : (scroll - start) / change,
            clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
            prevProgress = self.progress,
            isActive,
            wasActive,
            toggleState,
            action,
            stateChanged,
            toggled,
            isAtMax,
            isTakingAction;

        if (recordVelocity) {
          scroll2 = scroll1;
          scroll1 = containerAnimation ? scrollFunc() : scroll;

          if (snap) {
            snap2 = snap1;
            snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
          }
        } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).


        if (anticipatePin && pin && !_refreshing && !_startup && _lastScrollTime) {
          if (!clipped && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {
            clipped = 0.0001;
          } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {
            clipped = 0.9999;
          }
        }

        if (clipped !== prevProgress && self.enabled) {
          isActive = self.isActive = !!clipped && clipped < 1;
          wasActive = !!prevProgress && prevProgress < 1;
          toggled = isActive !== wasActive;
          stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)

          self.direction = clipped > prevProgress ? 1 : -1;
          self.progress = clipped;

          if (stateChanged && !_refreshing) {
            toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.

            if (isToggle) {
              action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)

              isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
            }
          }

          preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction$1(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {
            return t.endAnimation();
          }));

          if (!isToggle) {
            if (scrubTween && !_refreshing && !_startup) {
              scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.

              if (scrubTween.resetTo) {
                scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
              } else {
                // legacy support (courtesy), before 3.10.0
                scrubTween.vars.totalProgress = clipped;
                scrubTween.invalidate().restart();
              }
            } else if (animation) {
              animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));
            }
          }

          if (pin) {
            reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);

            if (!useFixedPosition) {
              pinSetter(_round$1(pinStart + pinChange * clipped));
            } else if (stateChanged) {
              isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)

              if (pinReparent) {
                if (!reset && (isActive || isAtMax)) {
                  var bounds = _getBounds(pin, true),
                      _offset = scroll - start;

                  _reparent(pin, _body$1, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                } else {
                  _reparent(pin, spacer);
                }
              }

              _setState(isActive || isAtMax ? pinActiveState : pinState);

              pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
            }
          }

          snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);
          toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray$2(toggleClass.targets).forEach(function (el) {
            return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
          }); // classes could affect positioning, so do it even if reset or refreshing is true.

          onUpdate && !isToggle && !reset && onUpdate(self);

          if (stateChanged && !_refreshing) {
            if (isToggle) {
              if (isTakingAction) {
                if (action === "complete") {
                  animation.pause().totalProgress(1);
                } else if (action === "reset") {
                  animation.restart(true).pause();
                } else if (action === "restart") {
                  animation.restart(true);
                } else {
                  animation[action]();
                }
              }

              onUpdate && onUpdate(self);
            }

            if (toggled || !_limitCallbacks) {
              // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
              onToggle && toggled && _callback(self, onToggle);
              callbacks[toggleState] && _callback(self, callbacks[toggleState]);
              once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.

              if (!toggled) {
                // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
                toggleState = clipped === 1 ? 1 : 3;
                callbacks[toggleState] && _callback(self, callbacks[toggleState]);
              }
            }

            if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
              _endAnimation(self.callbackAnimation);

              scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
            }
          } else if (isToggle && onUpdate && !_refreshing) {
            onUpdate(self);
          }
        } // update absolutely-positioned markers (only if the scroller isn't the viewport)


        if (markerEndSetter) {
          var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
          markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
          markerEndSetter(n);
        }

        caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
      };

      self.enable = function (reset, refresh) {
        if (!self.enabled) {
          self.enabled = true;

          _addListener(scroller, "resize", _onResize);

          isViewport || _addListener(scroller, "scroll", _onScroll);
          onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);

          if (reset !== false) {
            self.progress = prevProgress = 0;
            scroll1 = scroll2 = lastSnap = scrollFunc();
          }

          refresh !== false && self.refresh();
        }
      };

      self.getTween = function (snap) {
        return snap && tweenTo ? tweenTo.tween : scrubTween;
      };

      self.setPositions = function (newStart, newEnd, keepClamp, pinOffset) {
        // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()
        if (containerAnimation) {
          // convert ratios into scroll positions. Remember, start/end values on ScrollTriggers that have a containerAnimation refer to the time (in seconds), NOT scroll positions.
          var st = containerAnimation.scrollTrigger,
              duration = containerAnimation.duration(),
              _change = st.end - st.start;

          newStart = st.start + _change * newStart / duration;
          newEnd = st.start + _change * newEnd / duration;
        }

        self.refresh(false, false, {
          start: _keepClamp(newStart, keepClamp && !!self._startClamp),
          end: _keepClamp(newEnd, keepClamp && !!self._endClamp)
        }, pinOffset);
        self.update();
      };

      self.adjustPinSpacing = function (amount) {
        if (spacerState && amount) {
          var i = spacerState.indexOf(direction.d) + 1;
          spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
          spacerState[1] = parseFloat(spacerState[1]) + amount + _px;

          _setState(spacerState);
        }
      };

      self.disable = function (reset, allowAnimation) {
        if (self.enabled) {
          reset !== false && self.revert(true, true);
          self.enabled = self.isActive = false;
          allowAnimation || scrubTween && scrubTween.pause();
          prevScroll = 0;
          pinCache && (pinCache.uncache = 1);
          onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);

          if (snapDelayedCall) {
            snapDelayedCall.pause();
            tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
          }

          if (!isViewport) {
            var i = _triggers.length;

            while (i--) {
              if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
                return; //don't remove the listeners if there are still other triggers referencing it.
              }
            }

            _removeListener(scroller, "resize", _onResize);

            isViewport || _removeListener(scroller, "scroll", _onScroll);
          }
        }
      };

      self.kill = function (revert, allowAnimation) {
        self.disable(revert, allowAnimation);
        scrubTween && !allowAnimation && scrubTween.kill();
        id && delete _ids[id];

        var i = _triggers.indexOf(self);

        i >= 0 && _triggers.splice(i, 1);
        i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
        // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.

        i = 0;

        _triggers.forEach(function (t) {
          return t.scroller === self.scroller && (i = 1);
        });

        i || _refreshingAll || (self.scroll.rec = 0);

        if (animation) {
          animation.scrollTrigger = null;
          revert && animation.revert({
            kill: false
          });
          allowAnimation || animation.kill();
        }

        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
          return m.parentNode && m.parentNode.removeChild(m);
        });
        _primary === self && (_primary = 0);

        if (pin) {
          pinCache && (pinCache.uncache = 1);
          i = 0;

          _triggers.forEach(function (t) {
            return t.pin === pin && i++;
          });

          i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.
        }

        vars.onKill && vars.onKill(self);
      };

      _triggers.push(self);

      self.enable(false, false);
      customRevertReturn && customRevertReturn(self);

      if (animation && animation.add && !change) {
        // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.
        var updateFunc = self.update; // some browsers may fire a scroll event BEFORE a tick elapses and/or the DOMContentLoaded fires. So there's a chance update() will be called BEFORE a refresh() has happened on a Timeline-attached ScrollTrigger which means the start/end won't be calculated yet. We don't want to add conditional logic inside the update() method (like check to see if end is defined and if not, force a refresh()) because that's a function that gets hit a LOT (performance). So we swap out the real update() method for this one that'll re-attach it the first time it gets called and of course forces a refresh().

        self.update = function () {
          self.update = updateFunc;
          _scrollers.cache++; // otherwise a cached scroll position may get used in the refresh() in a very rare scenario, like if ScrollTriggers are created inside a DOMContentLoaded event and the queued requestAnimationFrame() fires beforehand. See https://gsap.com/community/forums/topic/41267-scrolltrigger-breaks-on-refresh-when-using-domcontentloaded/

          start || end || self.refresh();
        };

        gsap$2.delayedCall(0.01, self.update);
        change = 0.01;
        start = end = 0;
      } else {
        self.refresh();
      }

      pin && _queueRefreshAll(); // pinning could affect the positions of other things, so make sure we queue a full refresh()
    };

    ScrollTrigger.register = function register(core) {
      if (!_coreInitted$2) {
        gsap$2 = core || _getGSAP$2();
        _windowExists$2() && window.document && ScrollTrigger.enable();
        _coreInitted$2 = _enabled;
      }

      return _coreInitted$2;
    };

    ScrollTrigger.defaults = function defaults(config) {
      if (config) {
        for (var p in config) {
          _defaults[p] = config[p];
        }
      }

      return _defaults;
    };

    ScrollTrigger.disable = function disable(reset, kill) {
      _enabled = 0;

      _triggers.forEach(function (trigger) {
        return trigger[kill ? "kill" : "disable"](reset);
      });

      _removeListener(_win$1, "wheel", _onScroll);

      _removeListener(_doc, "scroll", _onScroll);

      clearInterval(_syncInterval);

      _removeListener(_doc, "touchcancel", _passThrough);

      _removeListener(_body$1, "touchstart", _passThrough);

      _multiListener(_removeListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

      _multiListener(_removeListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);

      _resizeDelay.kill();

      _iterateAutoRefresh(_removeListener);

      for (var i = 0; i < _scrollers.length; i += 3) {
        _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 1]);

        _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 2]);
      }
    };

    ScrollTrigger.enable = function enable() {
      _win$1 = window;
      _doc = document;
      _docEl$1 = _doc.documentElement;
      _body$1 = _doc.body;

      if (gsap$2) {
        _toArray$2 = gsap$2.utils.toArray;
        _clamp = gsap$2.utils.clamp;
        _context = gsap$2.core.context || _passThrough;
        _suppressOverwrites = gsap$2.core.suppressOverwrites || _passThrough;
        _scrollRestoration = _win$1.history.scrollRestoration || "auto";
        _lastScroll = _win$1.pageYOffset || 0;
        gsap$2.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.

        if (_body$1) {
          _enabled = 1;
          _div100vh = document.createElement("div"); // to solve mobile browser address bar show/hide resizing, we shouldn't rely on window.innerHeight. Instead, use a <div> with its height set to 100vh and measure that since that's what the scrolling is based on anyway and it's not affected by address bar showing/hiding.

          _div100vh.style.height = "100vh";
          _div100vh.style.position = "absolute";

          _refresh100vh();

          _rafBugFix();

          Observer$1.register(gsap$2); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

          ScrollTrigger.isTouch = Observer$1.isTouch;
          _fixIOSBug = Observer$1.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503

          _ignoreMobileResize = Observer$1.isTouch === 1;

          _addListener(_win$1, "wheel", _onScroll); // mostly for 3rd party smooth scrolling libraries.


          _root = [_win$1, _doc, _docEl$1, _body$1];

          if (gsap$2.matchMedia) {
            ScrollTrigger.matchMedia = function (vars) {
              var mm = gsap$2.matchMedia(),
                  p;

              for (p in vars) {
                mm.add(p, vars[p]);
              }

              return mm;
            };

            gsap$2.addEventListener("matchMediaInit", function () {
              return _revertAll();
            });
            gsap$2.addEventListener("matchMediaRevert", function () {
              return _revertRecorded();
            });
            gsap$2.addEventListener("matchMedia", function () {
              _refreshAll(0, 1);

              _dispatch("matchMedia");
            });
            gsap$2.matchMedia().add("(orientation: portrait)", function () {
              // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.
              _setBaseDimensions();

              return _setBaseDimensions;
            });
          } else {
            console.warn("Requires GSAP 3.11.0 or later");
          }

          _setBaseDimensions();

          _addListener(_doc, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!


          var bodyHasStyle = _body$1.hasAttribute("style"),
              bodyStyle = _body$1.style,
              border = bodyStyle.borderTopStyle,
              AnimationProto = gsap$2.core.Animation.prototype,
              bounds,
              i;

          AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
            value: function value() {
              return this.time(-0.01, true);
            }
          }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)

          bodyStyle.borderTopStyle = "solid"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.

          bounds = _getBounds(_body$1);
          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding

          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
          border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");

          if (!bodyHasStyle) {
            // SSR frameworks like Next.js complain if this attribute gets added.
            _body$1.setAttribute("style", ""); // it's not enough to just removeAttribute() - we must first set it to empty, otherwise Next.js complains.


            _body$1.removeAttribute("style");
          } // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.


          _syncInterval = setInterval(_sync, 250);
          gsap$2.delayedCall(0.5, function () {
            return _startup = 0;
          });

          _addListener(_doc, "touchcancel", _passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.


          _addListener(_body$1, "touchstart", _passThrough); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/


          _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

          _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);

          _transformProp = gsap$2.utils.checkPrefix("transform");

          _stateProps.push(_transformProp);

          _coreInitted$2 = _getTime();
          _resizeDelay = gsap$2.delayedCall(0.2, _refreshAll).pause();
          _autoRefresh = [_doc, "visibilitychange", function () {
            var w = _win$1.innerWidth,
                h = _win$1.innerHeight;

            if (_doc.hidden) {
              _prevWidth = w;
              _prevHeight = h;
            } else if (_prevWidth !== w || _prevHeight !== h) {
              _onResize();
            }
          }, _doc, "DOMContentLoaded", _refreshAll, _win$1, "load", _refreshAll, _win$1, "resize", _onResize];

          _iterateAutoRefresh(_addListener);

          _triggers.forEach(function (trigger) {
            return trigger.enable(0, 1);
          });

          for (i = 0; i < _scrollers.length; i += 3) {
            _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 1]);

            _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 2]);
          }
        }
      }
    };

    ScrollTrigger.config = function config(vars) {
      "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
      var ms = vars.syncInterval;
      ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
      "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);

      if ("autoRefreshEvents" in vars) {
        _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");
        _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
      }
    };

    ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
      var t = _getTarget(target),
          i = _scrollers.indexOf(t),
          isViewport = _isViewport(t);

      if (~i) {
        _scrollers.splice(i, isViewport ? 6 : 2);
      }

      if (vars) {
        isViewport ? _proxies.unshift(_win$1, vars, _body$1, vars, _docEl$1, vars) : _proxies.unshift(t, vars);
      }
    };

    ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
      _triggers.forEach(function (t) {
        return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
      });
    };

    ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
      var bounds = (_isString$1(element) ? _getTarget(element) : element).getBoundingClientRect(),
          offset = bounds[horizontal ? _width : _height] * ratio || 0;
      return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win$1.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win$1.innerHeight;
    };

    ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
      _isString$1(element) && (element = _getTarget(element));
      var bounds = element.getBoundingClientRect(),
          size = bounds[horizontal ? _width : _height],
          offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
      return horizontal ? (bounds.left + offset) / _win$1.innerWidth : (bounds.top + offset) / _win$1.innerHeight;
    };

    ScrollTrigger.killAll = function killAll(allowListeners) {
      _triggers.slice(0).forEach(function (t) {
        return t.vars.id !== "ScrollSmoother" && t.kill();
      });

      if (allowListeners !== true) {
        var listeners = _listeners.killAll || [];
        _listeners = {};
        listeners.forEach(function (f) {
          return f();
        });
      }
    };

    return ScrollTrigger;
  }();
  ScrollTrigger$1.version = "3.13.0";

  ScrollTrigger$1.saveStyles = function (targets) {
    return targets ? _toArray$2(targets).forEach(function (target) {
      // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
      if (target && target.style) {
        var i = _savedStyles.indexOf(target);

        i >= 0 && _savedStyles.splice(i, 5);

        _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap$2.core.getCache(target), _context());
      }
    }) : _savedStyles;
  };

  ScrollTrigger$1.revert = function (soft, media) {
    return _revertAll(!soft, media);
  };

  ScrollTrigger$1.create = function (vars, animation) {
    return new ScrollTrigger$1(vars, animation);
  };

  ScrollTrigger$1.refresh = function (safe) {
    return safe ? _onResize(true) : (_coreInitted$2 || ScrollTrigger$1.register()) && _refreshAll(true);
  };

  ScrollTrigger$1.update = function (force) {
    return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);
  };

  ScrollTrigger$1.clearScrollMemory = _clearScrollMemory;

  ScrollTrigger$1.maxScroll = function (element, horizontal) {
    return _maxScroll(element, horizontal ? _horizontal : _vertical);
  };

  ScrollTrigger$1.getScrollFunc = function (element, horizontal) {
    return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
  };

  ScrollTrigger$1.getById = function (id) {
    return _ids[id];
  };

  ScrollTrigger$1.getAll = function () {
    return _triggers.filter(function (t) {
      return t.vars.id !== "ScrollSmoother";
    });
  }; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.


  ScrollTrigger$1.isScrolling = function () {
    return !!_lastScrollTime;
  };

  ScrollTrigger$1.snapDirectional = _snapDirectional;

  ScrollTrigger$1.addEventListener = function (type, callback) {
    var a = _listeners[type] || (_listeners[type] = []);
    ~a.indexOf(callback) || a.push(callback);
  };

  ScrollTrigger$1.removeEventListener = function (type, callback) {
    var a = _listeners[type],
        i = a && a.indexOf(callback);
    i >= 0 && a.splice(i, 1);
  };

  ScrollTrigger$1.batch = function (targets, vars) {
    var result = [],
        varsCopy = {},
        interval = vars.interval || 0.016,
        batchMax = vars.batchMax || 1e9,
        proxyCallback = function proxyCallback(type, callback) {
      var elements = [],
          triggers = [],
          delay = gsap$2.delayedCall(interval, function () {
        callback(elements, triggers);
        elements = [];
        triggers = [];
      }).pause();
      return function (self) {
        elements.length || delay.restart(true);
        elements.push(self.trigger);
        triggers.push(self);
        batchMax <= elements.length && delay.progress(1);
      };
    },
        p;

    for (p in vars) {
      varsCopy[p] = p.substr(0, 2) === "on" && _isFunction$1(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
    }

    if (_isFunction$1(batchMax)) {
      batchMax = batchMax();

      _addListener(ScrollTrigger$1, "refresh", function () {
        return batchMax = vars.batchMax();
      });
    }

    _toArray$2(targets).forEach(function (target) {
      var config = {};

      for (p in varsCopy) {
        config[p] = varsCopy[p];
      }

      config.trigger = target;
      result.push(ScrollTrigger$1.create(config));
    });

    return result;
  }; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).


  var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
    current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
    return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
  },
      _allowNativePanning = function _allowNativePanning(target, direction) {
    if (direction === true) {
      target.style.removeProperty("touch-action");
    } else {
      target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer$1.isTouch ? " pinch-zoom" : "") : "none"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.
    }

    target === _docEl$1 && _allowNativePanning(_body$1, direction);
  },
      _overflow = {
    auto: 1,
    scroll: 1
  },
      _nestedScroll = function _nestedScroll(_ref5) {
    var event = _ref5.event,
        target = _ref5.target,
        axis = _ref5.axis;

    var node = (event.changedTouches ? event.changedTouches[0] : event).target,
        cache = node._gsap || gsap$2.core.getCache(node),
        time = _getTime(),
        cs;

    if (!cache._isScrollT || time - cache._isScrollT > 2000) {
      // cache for 2 seconds to improve performance.
      while (node && node !== _body$1 && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {
        node = node.parentNode;
      }

      cache._isScroll = node && node !== target && !_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
      cache._isScrollT = time;
    }

    if (cache._isScroll || axis === "x") {
      event.stopPropagation();
      event._gsapAllow = true;
    }
  },
      // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor
  _inputObserver = function _inputObserver(target, type, inputs, nested) {
    return Observer$1.create({
      target: target,
      capture: true,
      debounce: false,
      lockAxis: true,
      type: type,
      onWheel: nested = nested && _nestedScroll,
      onPress: nested,
      onDrag: nested,
      onScroll: nested,
      onEnable: function onEnable() {
        return inputs && _addListener(_doc, Observer$1.eventTypes[0], _captureInputs, false, true);
      },
      onDisable: function onDisable() {
        return _removeListener(_doc, Observer$1.eventTypes[0], _captureInputs, true);
      }
    });
  },
      _inputExp = /(input|label|select|textarea)/i,
      _inputIsFocused,
      _captureInputs = function _captureInputs(e) {
    var isInput = _inputExp.test(e.target.tagName);

    if (isInput || _inputIsFocused) {
      e._gsapAllow = true;
      _inputIsFocused = isInput;
    }
  },
      _getScrollNormalizer = function _getScrollNormalizer(vars) {
    _isObject(vars) || (vars = {});
    vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
    vars.type || (vars.type = "wheel,touch");
    vars.debounce = !!vars.debounce;
    vars.id = vars.id || "normalizer";

    var _vars2 = vars,
        normalizeScrollX = _vars2.normalizeScrollX,
        momentum = _vars2.momentum,
        allowNestedScroll = _vars2.allowNestedScroll,
        onRelease = _vars2.onRelease,
        self,
        maxY,
        target = _getTarget(vars.target) || _docEl$1,
        smoother = gsap$2.core.globals().ScrollSmoother,
        smootherInstance = smoother && smoother.get(),
        content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()),
        scrollFuncY = _getScrollFunc(target, _vertical),
        scrollFuncX = _getScrollFunc(target, _horizontal),
        scale = 1,
        initialScale = (Observer$1.isTouch && _win$1.visualViewport ? _win$1.visualViewport.scale * _win$1.visualViewport.width : _win$1.outerWidth) / _win$1.innerWidth,
        wheelRefresh = 0,
        resolveMomentumDuration = _isFunction$1(momentum) ? function () {
      return momentum(self);
    } : function () {
      return momentum || 2.8;
    },
        lastRefreshID,
        skipTouchMove,
        inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),
        resumeTouchMove = function resumeTouchMove() {
      return skipTouchMove = false;
    },
        scrollClampX = _passThrough,
        scrollClampY = _passThrough,
        updateClamps = function updateClamps() {
      maxY = _maxScroll(target, _vertical);
      scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);
      normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _horizontal)));
      lastRefreshID = _refreshID;
    },
        removeContentOffset = function removeContentOffset() {
      content._gsap.y = _round$1(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
      content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
      scrollFuncY.offset = scrollFuncY.cacheID = 0;
    },
        ignoreDrag = function ignoreDrag() {
      if (skipTouchMove) {
        requestAnimationFrame(resumeTouchMove);

        var offset = _round$1(self.deltaY / 2),
            scroll = scrollClampY(scrollFuncY.v - offset);

        if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
          scrollFuncY.offset = scroll - scrollFuncY.v;

          var y = _round$1((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);

          content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
          content._gsap.y = y + "px";
          scrollFuncY.cacheID = _scrollers.cache;

          _updateAll();
        }

        return true;
      }

      scrollFuncY.offset && removeContentOffset();
      skipTouchMove = true;
    },
        tween,
        startScrollX,
        startScrollY,
        onStopDelayedCall,
        onResize = function onResize() {
      // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.
      updateClamps();

      if (tween.isActive() && tween.vars.scrollY > maxY) {
        scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
      }
    };

    content && gsap$2.set(content, {
      y: "+=0"
    }); // to ensure there's a cache (element._gsap)

    vars.ignoreCheck = function (e) {
      return _fixIOSBug && e.type === "touchmove" && ignoreDrag() || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
    };

    vars.onPress = function () {
      skipTouchMove = false;
      var prevScale = scale;
      scale = _round$1((_win$1.visualViewport && _win$1.visualViewport.scale || 1) / initialScale);
      tween.pause();
      prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
      startScrollX = scrollFuncX();
      startScrollY = scrollFuncY();
      updateClamps();
      lastRefreshID = _refreshID;
    };

    vars.onRelease = vars.onGestureStart = function (self, wasDragging) {
      scrollFuncY.offset && removeContentOffset();

      if (!wasDragging) {
        onStopDelayedCall.restart(true);
      } else {
        _scrollers.cache++; // make sure we're pulling the non-cached value
        // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),	dur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)

        var dur = resolveMomentumDuration(),
            currentScroll,
            endScroll;

        if (normalizeScrollX) {
          currentScroll = scrollFuncX();
          endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.

          dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
          tween.vars.scrollX = scrollClampX(endScroll);
        }

        currentScroll = scrollFuncY();
        endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)

        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
        tween.vars.scrollY = scrollClampY(endScroll);
        tween.invalidate().duration(dur).play(0.01);

        if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
          // iOS bug: it'll show the address bar but NOT fire the window "resize" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.
          gsap$2.to({}, {
            onUpdate: onResize,
            duration: dur
          });
        }
      }

      onRelease && onRelease(self);
    };

    vars.onWheel = function () {
      tween._ts && tween.pause();

      if (_getTime() - wheelRefresh > 1000) {
        // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.
        lastRefreshID = 0;
        wheelRefresh = _getTime();
      }
    };

    vars.onChange = function (self, dx, dy, xArray, yArray) {
      _refreshID !== lastRefreshID && updateClamps();
      dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.

      if (dy) {
        scrollFuncY.offset && removeContentOffset();
        var isTouch = yArray[2] === dy,
            y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],
            yClamped = scrollClampY(y);
        isTouch && y !== yClamped && (startScrollY += yClamped - y);
        scrollFuncY(yClamped);
      }

      (dy || dx) && _updateAll();
    };

    vars.onEnable = function () {
      _allowNativePanning(target, normalizeScrollX ? false : "x");

      ScrollTrigger$1.addEventListener("refresh", onResize);

      _addListener(_win$1, "resize", onResize);

      if (scrollFuncY.smooth) {
        scrollFuncY.target.style.scrollBehavior = "auto";
        scrollFuncY.smooth = scrollFuncX.smooth = false;
      }

      inputObserver.enable();
    };

    vars.onDisable = function () {
      _allowNativePanning(target, true);

      _removeListener(_win$1, "resize", onResize);

      ScrollTrigger$1.removeEventListener("refresh", onResize);
      inputObserver.kill();
    };

    vars.lockAxis = vars.lockAxis !== false;
    self = new Observer$1(vars);
    self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.

    _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.

    _fixIOSBug && gsap$2.ticker.add(_passThrough); // prevent the ticker from sleeping

    onStopDelayedCall = self._dc;
    tween = gsap$2.to(self, {
      ease: "power4",
      paused: true,
      inherit: false,
      scrollX: normalizeScrollX ? "+=0.1" : "+=0",
      scrollY: "+=0.1",
      modifiers: {
        scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function () {
          return tween.pause();
        })
      },
      onUpdate: _updateAll,
      onComplete: onStopDelayedCall.vars.onComplete
    }); // we need the modifier to sense if the scroll position is altered outside of the momentum tween (like with a scrollTo tween) so we can pause() it to prevent conflicts.

    return self;
  };

  ScrollTrigger$1.sort = function (func) {
    if (_isFunction$1(func)) {
      return _triggers.sort(func);
    }

    var scroll = _win$1.pageYOffset || 0;
    ScrollTrigger$1.getAll().forEach(function (t) {
      return t._sortY = t.trigger ? scroll + t.trigger.getBoundingClientRect().top : t.start + _win$1.innerHeight;
    });
    return _triggers.sort(func || function (a, b) {
      return (a.vars.refreshPriority || 0) * -1e6 + (a.vars.containerAnimation ? 1e6 : a._sortY) - ((b.vars.containerAnimation ? 1e6 : b._sortY) + (b.vars.refreshPriority || 0) * -1e6);
    }); // anything with a containerAnimation should refresh last.
  };

  ScrollTrigger$1.observe = function (vars) {
    return new Observer$1(vars);
  };

  ScrollTrigger$1.normalizeScroll = function (vars) {
    if (typeof vars === "undefined") {
      return _normalizer;
    }

    if (vars === true && _normalizer) {
      return _normalizer.enable();
    }

    if (vars === false) {
      _normalizer && _normalizer.kill();
      _normalizer = vars;
      return;
    }

    var normalizer = vars instanceof Observer$1 ? vars : _getScrollNormalizer(vars);
    _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();
    _isViewport(normalizer.target) && (_normalizer = normalizer);
    return normalizer;
  };

  ScrollTrigger$1.core = {
    // smaller file size way to leverage in ScrollSmoother and Observer
    _getVelocityProp: _getVelocityProp,
    _inputObserver: _inputObserver,
    _scrollers: _scrollers,
    _proxies: _proxies,
    bridge: {
      // when normalizeScroll sets the scroll position (ss = setScroll)
      ss: function ss() {
        _lastScrollTime || _dispatch("scrollStart");
        _lastScrollTime = _getTime();
      },
      // a way to get the _refreshing value in Observer
      ref: function ref() {
        return _refreshing;
      }
    }
  };
  _getGSAP$2() && gsap$2.registerPlugin(ScrollTrigger$1);

  document.head.appendChild(document.createElement("style")).textContent="/*! \n * OverlayScrollbars\n * Version: 2.12.0\n * \n * Copyright (c) Rene Haas | KingSora.\n * https://github.com/KingSora\n * \n * Released under the MIT license.\n */\n.os-size-observer,\n.os-size-observer-listener {\n  scroll-behavior: auto !important;\n  direction: inherit;\n  pointer-events: none;\n  overflow: hidden;\n  visibility: hidden;\n  box-sizing: border-box;\n}\n\n.os-size-observer,\n.os-size-observer-listener,\n.os-size-observer-listener-item,\n.os-size-observer-listener-item-final {\n  writing-mode: horizontal-tb;\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n\n.os-size-observer {\n  z-index: -1;\n  contain: strict;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  padding: inherit;\n  border: inherit;\n  box-sizing: inherit;\n  margin: -133px;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  transform: scale(0.1);\n}\n.os-size-observer::before {\n  content: \"\";\n  flex: none;\n  box-sizing: inherit;\n  padding: 10px;\n  width: 10px;\n  height: 10px;\n}\n\n.os-size-observer-appear {\n  animation: os-size-observer-appear-animation 1ms forwards;\n}\n\n.os-size-observer-listener {\n  box-sizing: border-box;\n  position: relative;\n  flex: auto;\n  padding: inherit;\n  border: inherit;\n  margin: -133px;\n  transform: scale(calc(1 / 0.1));\n}\n.os-size-observer-listener.ltr {\n  margin-right: -266px;\n  margin-left: 0;\n}\n.os-size-observer-listener.rtl {\n  margin-left: -266px;\n  margin-right: 0;\n}\n.os-size-observer-listener:empty::before {\n  content: \"\";\n  width: 100%;\n  height: 100%;\n}\n.os-size-observer-listener:empty::before, .os-size-observer-listener > .os-size-observer-listener-item {\n  display: block;\n  position: relative;\n  padding: inherit;\n  border: inherit;\n  box-sizing: content-box;\n  flex: auto;\n}\n\n.os-size-observer-listener-scroll {\n  box-sizing: border-box;\n  display: flex;\n}\n\n.os-size-observer-listener-item {\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  direction: ltr;\n  flex: none;\n}\n\n.os-size-observer-listener-item-final {\n  transition: none;\n}\n\n@keyframes os-size-observer-appear-animation {\n  from {\n    cursor: auto;\n  }\n  to {\n    cursor: none;\n  }\n}\n.os-trinsic-observer {\n  flex: none;\n  box-sizing: border-box;\n  position: relative;\n  max-width: 0px;\n  max-height: 1px;\n  padding: 0;\n  margin: 0;\n  border: none;\n  overflow: hidden;\n  z-index: -1;\n  height: 0;\n  top: calc(100% + 1px);\n  contain: strict;\n}\n.os-trinsic-observer:not(:empty) {\n  height: calc(100% + 1px);\n  top: -1px;\n}\n.os-trinsic-observer:not(:empty) > .os-size-observer {\n  width: 1000%;\n  height: 1000%;\n  min-height: 1px;\n  min-width: 1px;\n}\n\n/**\n * hide native scrollbars\n * changes to this styles need to be reflected in the environment styles to correctly detect scrollbar hiding\n */\n[data-overlayscrollbars-initialize]:not([data-overlayscrollbars-viewport]),\n[data-overlayscrollbars-viewport~=scrollbarHidden],\nhtml[data-overlayscrollbars-viewport~=scrollbarHidden] > body {\n  scrollbar-width: none !important;\n}\n\n[data-overlayscrollbars-initialize]:not([data-overlayscrollbars-viewport])::-webkit-scrollbar,\n[data-overlayscrollbars-initialize]:not([data-overlayscrollbars-viewport])::-webkit-scrollbar-corner,\n[data-overlayscrollbars-viewport~=scrollbarHidden]::-webkit-scrollbar,\n[data-overlayscrollbars-viewport~=scrollbarHidden]::-webkit-scrollbar-corner,\nhtml[data-overlayscrollbars-viewport~=scrollbarHidden] > body::-webkit-scrollbar,\nhtml[data-overlayscrollbars-viewport~=scrollbarHidden] > body::-webkit-scrollbar-corner {\n  -webkit-appearance: none !important;\n          appearance: none !important;\n  display: none !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n[data-overlayscrollbars-initialize]:not([data-overlayscrollbars]):not(html):not(body) {\n  overflow: auto;\n}\n\n/**\n * body element\n */\nhtml[data-overlayscrollbars-body] {\n  overflow: hidden;\n}\n\nhtml[data-overlayscrollbars-body],\nhtml[data-overlayscrollbars-body] > body {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n}\n\nhtml[data-overlayscrollbars-body] > body {\n  overflow: visible;\n  margin: 0;\n}\n\n/**\n * structure setup \n */\n[data-overlayscrollbars] {\n  position: relative;\n}\n\n[data-overlayscrollbars~=host],\n[data-overlayscrollbars-padding] {\n  display: flex;\n  align-items: stretch !important;\n  flex-direction: row !important;\n  flex-wrap: nowrap !important;\n  scroll-behavior: auto !important;\n}\n\n[data-overlayscrollbars-padding],\n[data-overlayscrollbars-viewport]:not([data-overlayscrollbars]) {\n  box-sizing: inherit;\n  position: relative;\n  flex: auto;\n  height: auto;\n  width: 100%;\n  min-width: 0;\n  padding: 0;\n  margin: 0;\n  border: none;\n  z-index: 0;\n}\n\n[data-overlayscrollbars-viewport]:not([data-overlayscrollbars]) {\n  --os-vaw: 0;\n  --os-vah: 0;\n  outline: none;\n}\n[data-overlayscrollbars-viewport]:not([data-overlayscrollbars]):focus {\n  outline: none;\n}\n[data-overlayscrollbars-viewport][data-overlayscrollbars-viewport~=arrange]::before {\n  content: \"\";\n  position: absolute;\n  pointer-events: none;\n  z-index: -1;\n  min-width: 1px;\n  min-height: 1px;\n  width: var(--os-vaw);\n  height: var(--os-vah);\n}\n\n/**\n * wrapper elements overflow:\n */\n[data-overlayscrollbars~=host],\n[data-overlayscrollbars-padding] {\n  overflow: hidden !important;\n}\n\n[data-overlayscrollbars~=host][data-overlayscrollbars~=noClipping],\n[data-overlayscrollbars-padding~=noClipping] {\n  overflow: visible !important;\n}\n\n/**\n * viewport overflow:\n */\n[data-overlayscrollbars-viewport] {\n  --os-viewport-overflow-x: hidden;\n  --os-viewport-overflow-y: hidden;\n  overflow-x: var(--os-viewport-overflow-x);\n  overflow-y: var(--os-viewport-overflow-y);\n}\n\n[data-overlayscrollbars-viewport~=overflowXVisible] {\n  --os-viewport-overflow-x: visible;\n}\n\n[data-overlayscrollbars-viewport~=overflowXHidden] {\n  --os-viewport-overflow-x: hidden;\n}\n\n[data-overlayscrollbars-viewport~=overflowXScroll] {\n  --os-viewport-overflow-x: scroll;\n}\n\n[data-overlayscrollbars-viewport~=overflowYVisible] {\n  --os-viewport-overflow-y: visible;\n}\n\n[data-overlayscrollbars-viewport~=overflowYHidden] {\n  --os-viewport-overflow-y: hidden;\n}\n\n[data-overlayscrollbars-viewport~=overflowYScroll] {\n  --os-viewport-overflow-y: scroll;\n}\n\n[data-overlayscrollbars-viewport~=overflowImportant] {\n  overflow-x: var(--os-viewport-overflow-x) !important;\n  overflow-y: var(--os-viewport-overflow-y) !important;\n}\n\n/**\n * viewport state modifiers:\n */\n[data-overlayscrollbars-viewport~=noContent]:not(#osFakeId) {\n  font-size: 0 !important;\n  line-height: 0 !important;\n}\n\n[data-overlayscrollbars-viewport~=noContent]:not(#osFakeId)::before,\n[data-overlayscrollbars-viewport~=noContent]:not(#osFakeId)::after,\n[data-overlayscrollbars-viewport~=noContent]:not(#osFakeId) > * {\n  display: none !important;\n  position: absolute !important;\n  width: 1px !important;\n  height: 1px !important;\n  padding: 0 !important;\n  margin: -1px !important;\n  overflow: hidden !important;\n  clip: rect(0, 0, 0, 0) !important;\n  white-space: nowrap !important;\n  border-width: 0 !important;\n}\n\n[data-overlayscrollbars-viewport~=measuring],\n[data-overlayscrollbars-viewport~=scrolling] {\n  scroll-behavior: auto !important;\n  scroll-snap-type: none !important;\n}\n\n[data-overlayscrollbars-viewport~=measuring][data-overlayscrollbars-viewport~=overflowXVisible] {\n  overflow-x: hidden !important;\n}\n\n[data-overlayscrollbars-viewport~=measuring][data-overlayscrollbars-viewport~=overflowYVisible] {\n  overflow-y: hidden !important;\n}\n\n/**\n * content element:\n */\n[data-overlayscrollbars-content] {\n  box-sizing: inherit;\n}\n\n/**\n * Display contents to bridge any flickering during deferred initialization.\n */\n[data-overlayscrollbars-contents]:not(#osFakeId):not([data-overlayscrollbars-padding]):not([data-overlayscrollbars-viewport]):not([data-overlayscrollbars-content]) {\n  display: contents;\n}\n\n/**\n * optional & experimental grid mode\n */\n[data-overlayscrollbars-grid],\n[data-overlayscrollbars-grid] [data-overlayscrollbars-padding] {\n  display: grid;\n  grid-template: 1fr/1fr;\n}\n\n[data-overlayscrollbars-grid] > [data-overlayscrollbars-padding],\n[data-overlayscrollbars-grid] > [data-overlayscrollbars-viewport],\n[data-overlayscrollbars-grid] > [data-overlayscrollbars-padding] > [data-overlayscrollbars-viewport] {\n  height: auto !important;\n  width: auto !important;\n}\n\n@property --os-scroll-percent {\n  syntax: \"<number>\";\n  inherits: true;\n  initial-value: 0;\n}\n@property --os-viewport-percent {\n  syntax: \"<number>\";\n  inherits: true;\n  initial-value: 0;\n}\n.os-scrollbar {\n  --os-viewport-percent: 0;\n  --os-scroll-percent: 0;\n  --os-scroll-direction: 0;\n  --os-scroll-percent-directional: calc(\n    var(--os-scroll-percent) - (var(--os-scroll-percent) + (1 - var(--os-scroll-percent)) * -1) *\n      var(--os-scroll-direction)\n  );\n}\n\n.os-scrollbar {\n  contain: size layout;\n  contain: size layout style;\n  transition: opacity 0.15s, visibility 0.15s, top 0.15s, right 0.15s, bottom 0.15s, left 0.15s;\n  pointer-events: none;\n  position: absolute;\n  opacity: 0;\n  visibility: hidden;\n}\n\nbody > .os-scrollbar {\n  position: fixed;\n  z-index: 99999;\n}\n\n.os-scrollbar-transitionless {\n  transition: none !important;\n}\n\n.os-scrollbar-track {\n  position: relative;\n  padding: 0 !important;\n  border: none !important;\n}\n\n.os-scrollbar-handle {\n  position: absolute;\n}\n\n.os-scrollbar-track,\n.os-scrollbar-handle {\n  pointer-events: none;\n  width: 100%;\n  height: 100%;\n}\n\n.os-scrollbar.os-scrollbar-track-interactive .os-scrollbar-track,\n.os-scrollbar.os-scrollbar-handle-interactive .os-scrollbar-handle {\n  pointer-events: auto;\n  touch-action: none;\n}\n\n.os-scrollbar-horizontal {\n  bottom: 0;\n  left: 0;\n}\n\n.os-scrollbar-vertical {\n  top: 0;\n  right: 0;\n}\n\n.os-scrollbar-rtl.os-scrollbar-horizontal {\n  right: 0;\n}\n\n.os-scrollbar-rtl.os-scrollbar-vertical {\n  right: auto;\n  left: 0;\n}\n\n.os-scrollbar-visible {\n  opacity: 1;\n  visibility: visible;\n}\n\n.os-scrollbar-auto-hide.os-scrollbar-auto-hide-hidden {\n  opacity: 0;\n  visibility: hidden;\n}\n\n.os-scrollbar-interaction.os-scrollbar-visible {\n  opacity: 1;\n  visibility: visible;\n}\n\n.os-scrollbar-unusable,\n.os-scrollbar-unusable *,\n.os-scrollbar-wheel,\n.os-scrollbar-wheel * {\n  pointer-events: none !important;\n}\n\n.os-scrollbar-unusable .os-scrollbar-handle {\n  opacity: 0 !important;\n  transition: none !important;\n}\n\n.os-scrollbar-horizontal .os-scrollbar-handle {\n  bottom: 0;\n  left: calc(var(--os-scroll-percent-directional) * 100%);\n  transform: translateX(calc(var(--os-scroll-percent-directional) * -100%));\n  width: calc(var(--os-viewport-percent) * 100%);\n}\n\n.os-scrollbar-vertical .os-scrollbar-handle {\n  right: 0;\n  top: calc(var(--os-scroll-percent-directional) * 100%);\n  transform: translateY(calc(var(--os-scroll-percent-directional) * -100%));\n  height: calc(var(--os-viewport-percent) * 100%);\n}\n\n@supports (container-type: size) {\n  .os-scrollbar-track {\n    container-type: size;\n  }\n  .os-scrollbar-horizontal .os-scrollbar-handle {\n    left: auto;\n    transform: translateX(calc(var(--os-scroll-percent-directional) * 100cqw + var(--os-scroll-percent-directional) * -100%));\n  }\n  .os-scrollbar-vertical .os-scrollbar-handle {\n    top: auto;\n    transform: translateY(calc(var(--os-scroll-percent-directional) * 100cqh + var(--os-scroll-percent-directional) * -100%));\n  }\n  .os-scrollbar-rtl.os-scrollbar-horizontal .os-scrollbar-handle {\n    right: auto;\n    left: 0;\n  }\n}\n.os-scrollbar-rtl.os-scrollbar-vertical .os-scrollbar-handle {\n  right: auto;\n  left: 0;\n}\n\n.os-scrollbar.os-scrollbar-horizontal.os-scrollbar-cornerless,\n.os-scrollbar.os-scrollbar-horizontal.os-scrollbar-cornerless.os-scrollbar-rtl {\n  left: 0;\n  right: 0;\n}\n\n.os-scrollbar.os-scrollbar-vertical.os-scrollbar-cornerless,\n.os-scrollbar.os-scrollbar-vertical.os-scrollbar-cornerless.os-scrollbar-rtl {\n  top: 0;\n  bottom: 0;\n}\n\n@media print {\n  .os-scrollbar {\n    display: none;\n  }\n}\n.os-scrollbar {\n  --os-size: 0;\n  --os-padding-perpendicular: 0;\n  --os-padding-axis: 0;\n  --os-track-border-radius: 0;\n  --os-track-bg: none;\n  --os-track-bg-hover: none;\n  --os-track-bg-active: none;\n  --os-track-border: none;\n  --os-track-border-hover: none;\n  --os-track-border-active: none;\n  --os-handle-border-radius: 0;\n  --os-handle-bg: none;\n  --os-handle-bg-hover: none;\n  --os-handle-bg-active: none;\n  --os-handle-border: none;\n  --os-handle-border-hover: none;\n  --os-handle-border-active: none;\n  --os-handle-min-size: 33px;\n  --os-handle-max-size: none;\n  --os-handle-perpendicular-size: 100%;\n  --os-handle-perpendicular-size-hover: 100%;\n  --os-handle-perpendicular-size-active: 100%;\n  --os-handle-interactive-area-offset: 0;\n}\n\n.os-scrollbar-track {\n  border: var(--os-track-border);\n  border-radius: var(--os-track-border-radius);\n  background: var(--os-track-bg);\n  transition: opacity 0.15s, background-color 0.15s, border-color 0.15s;\n}\n.os-scrollbar-track:hover {\n  border: var(--os-track-border-hover);\n  background: var(--os-track-bg-hover);\n}\n.os-scrollbar-track:active {\n  border: var(--os-track-border-active);\n  background: var(--os-track-bg-active);\n}\n\n.os-scrollbar-handle {\n  border: var(--os-handle-border);\n  border-radius: var(--os-handle-border-radius);\n  background: var(--os-handle-bg);\n}\n.os-scrollbar-handle:hover {\n  border: var(--os-handle-border-hover);\n  background: var(--os-handle-bg-hover);\n}\n.os-scrollbar-handle:active {\n  border: var(--os-handle-border-active);\n  background: var(--os-handle-bg-active);\n}\n\n.os-scrollbar-track:before,\n.os-scrollbar-handle:before {\n  content: \"\";\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  display: block;\n}\n\n.os-scrollbar-horizontal {\n  padding: var(--os-padding-perpendicular) var(--os-padding-axis);\n  right: var(--os-size);\n  height: var(--os-size);\n}\n.os-scrollbar-horizontal.os-scrollbar-rtl {\n  left: var(--os-size);\n  right: 0;\n}\n.os-scrollbar-horizontal .os-scrollbar-track:before {\n  top: calc(var(--os-padding-perpendicular) * -1);\n  bottom: calc(var(--os-padding-perpendicular) * -1);\n}\n.os-scrollbar-horizontal .os-scrollbar-handle {\n  min-width: var(--os-handle-min-size);\n  max-width: var(--os-handle-max-size);\n  height: var(--os-handle-perpendicular-size);\n  transition: opacity 0.15s, background-color 0.15s, border-color 0.15s, height 0.15s;\n}\n.os-scrollbar-horizontal .os-scrollbar-handle:before {\n  top: calc((var(--os-padding-perpendicular) + var(--os-handle-interactive-area-offset)) * -1);\n  bottom: calc(var(--os-padding-perpendicular) * -1);\n}\n.os-scrollbar-horizontal:hover .os-scrollbar-handle {\n  height: var(--os-handle-perpendicular-size-hover);\n}\n.os-scrollbar-horizontal:active .os-scrollbar-handle {\n  height: var(--os-handle-perpendicular-size-active);\n}\n\n.os-scrollbar-vertical {\n  padding: var(--os-padding-axis) var(--os-padding-perpendicular);\n  bottom: var(--os-size);\n  width: var(--os-size);\n}\n.os-scrollbar-vertical .os-scrollbar-track:before {\n  left: calc(var(--os-padding-perpendicular) * -1);\n  right: calc(var(--os-padding-perpendicular) * -1);\n}\n.os-scrollbar-vertical .os-scrollbar-handle {\n  min-height: var(--os-handle-min-size);\n  max-height: var(--os-handle-max-size);\n  width: var(--os-handle-perpendicular-size);\n  transition: opacity 0.15s, background-color 0.15s, border-color 0.15s, width 0.15s;\n}\n.os-scrollbar-vertical .os-scrollbar-handle:before {\n  left: calc((var(--os-padding-perpendicular) + var(--os-handle-interactive-area-offset)) * -1);\n  right: calc(var(--os-padding-perpendicular) * -1);\n}\n.os-scrollbar-vertical.os-scrollbar-rtl .os-scrollbar-handle:before {\n  right: calc((var(--os-padding-perpendicular) + var(--os-handle-interactive-area-offset)) * -1);\n  left: calc(var(--os-padding-perpendicular) * -1);\n}\n.os-scrollbar-vertical:hover .os-scrollbar-handle {\n  width: var(--os-handle-perpendicular-size-hover);\n}\n.os-scrollbar-vertical:active .os-scrollbar-handle {\n  width: var(--os-handle-perpendicular-size-active);\n}\n\n/* NONE THEME: */\n[data-overlayscrollbars-viewport~=measuring] > .os-scrollbar,\n.os-theme-none.os-scrollbar {\n  display: none !important;\n}\n\n/* DARK & LIGHT THEME: */\n.os-theme-dark,\n.os-theme-light {\n  box-sizing: border-box;\n  --os-size: 10px;\n  --os-padding-perpendicular: 2px;\n  --os-padding-axis: 2px;\n  --os-track-border-radius: 10px;\n  --os-handle-interactive-area-offset: 4px;\n  --os-handle-border-radius: 10px;\n}\n\n.os-theme-dark {\n  --os-handle-bg: rgba(0, 0, 0, 0.44);\n  --os-handle-bg-hover: rgba(0, 0, 0, 0.55);\n  --os-handle-bg-active: rgba(0, 0, 0, 0.66);\n}\n\n.os-theme-light {\n  --os-handle-bg: rgba(255, 255, 255, 0.44);\n  --os-handle-bg-hover: rgba(255, 255, 255, 0.55);\n  --os-handle-bg-active: rgba(255, 255, 255, 0.66);\n}";

  /*!
   * OverlayScrollbars
   * Version: 2.12.0
   *
   * Copyright (c) Rene Haas | KingSora.
   * https://github.com/KingSora
   *
   * Released under the MIT license.
   */
  const createCache = (t, n) => {
    const {o: o, i: s, u: e} = t;
    let c = o;
    let r;
    const cacheUpdateContextual = (t, n) => {
      const o = c;
      const i = t;
      const l = n || (s ? !s(o, i) : o !== i);
      if (l || e) {
        c = i;
        r = o;
      }
      return [ c, l, r ];
    };
    const cacheUpdateIsolated = t => cacheUpdateContextual(n(c, r), t);
    const getCurrentCache = t => [ c, !!t, r ];
    return [ n ? cacheUpdateIsolated : cacheUpdateContextual, getCurrentCache ];
  };

  const t$1 = typeof window !== "undefined" && typeof HTMLElement !== "undefined" && !!window.document;

  const n$1 = t$1 ? window : {};

  const o$1 = Math.max;

  const s$1 = Math.min;

  const e$1 = Math.round;

  const c = Math.abs;

  const r$1 = Math.sign;

  const i$1 = n$1.cancelAnimationFrame;

  const l$1 = n$1.requestAnimationFrame;

  const a$1 = n$1.setTimeout;

  const u = n$1.clearTimeout;

  const getApi = t => typeof n$1[t] !== "undefined" ? n$1[t] : void 0;

  const f = getApi("MutationObserver");

  const _ = getApi("IntersectionObserver");

  const d = getApi("ResizeObserver");

  const p = getApi("ScrollTimeline");

  const isUndefined = t => t === void 0;

  const isNull = t => t === null;

  const isNumber$1 = t => typeof t === "number";

  const isString = t => typeof t === "string";

  const isBoolean = t => typeof t === "boolean";

  const isFunction = t => typeof t === "function";

  const isArray$1 = t => Array.isArray(t);

  const isObject$2 = t => typeof t === "object" && !isArray$1(t) && !isNull(t);

  const isArrayLike = t => {
    const n = !!t && t.length;
    const o = isNumber$1(n) && n > -1 && n % 1 == 0;
    return isArray$1(t) || !isFunction(t) && o ? n > 0 && isObject$2(t) ? n - 1 in t : true : false;
  };

  const isPlainObject = t => !!t && t.constructor === Object;

  const isHTMLElement = t => t instanceof HTMLElement;

  const isElement = t => t instanceof Element;

  function each(t, n) {
    if (isArrayLike(t)) {
      for (let o = 0; o < t.length; o++) {
        if (n(t[o], o, t) === false) {
          break;
        }
      }
    } else if (t) {
      each(Object.keys(t), (o => n(t[o], o, t)));
    }
    return t;
  }

  const inArray = (t, n) => t.indexOf(n) >= 0;

  const concat = (t, n) => t.concat(n);

  const push$1 = (t, n, o) => {
    if (!isString(n) && isArrayLike(n)) {
      Array.prototype.push.apply(t, n);
    } else {
      t.push(n);
    }
    return t;
  };

  const from = t => Array.from(t || []);

  const createOrKeepArray = t => {
    if (isArray$1(t)) {
      return t;
    }
    return !isString(t) && isArrayLike(t) ? from(t) : [ t ];
  };

  const isEmptyArray = t => !!t && !t.length;

  const deduplicateArray = t => from(new Set(t));

  const runEachAndClear = (t, n, o) => {
    const runFn = t => t ? t.apply(void 0, n || []) : true;
    each(t, runFn);
    if (!o) {
      t.length = 0;
    }
  };

  const v = "paddingTop";

  const g = "paddingRight";

  const h = "paddingLeft";

  const b = "paddingBottom";

  const w = "marginLeft";

  const y = "marginRight";

  const S = "marginBottom";

  const m = "overflowX";

  const O = "overflowY";

  const C = "width";

  const $ = "height";

  const x = "visible";

  const H = "hidden";

  const E = "scroll";

  const capitalizeFirstLetter = t => {
    const n = String(t || "");
    return n ? n[0].toUpperCase() + n.slice(1) : "";
  };

  const equal = (t, n, o, s) => {
    if (t && n) {
      let s = true;
      each(o, (o => {
        const e = t[o];
        const c = n[o];
        if (e !== c) {
          s = false;
        }
      }));
      return s;
    }
    return false;
  };

  const equalWH = (t, n) => equal(t, n, [ "w", "h" ]);

  const equalXY = (t, n) => equal(t, n, [ "x", "y" ]);

  const equalTRBL = (t, n) => equal(t, n, [ "t", "r", "b", "l" ]);

  const bind = (t, ...n) => t.bind(0, ...n);

  const selfClearTimeout = t => {
    let n;
    const o = t ? a$1 : l$1;
    const s = t ? u : i$1;
    return [ e => {
      s(n);
      n = o((() => e()), isFunction(t) ? t() : t);
    }, () => s(n) ];
  };

  const getDebouncer = t => {
    const n = isFunction(t) ? t() : t;
    if (isNumber$1(n)) {
      const t = n ? a$1 : l$1;
      const o = n ? u : i$1;
      return s => {
        const e = t((() => s()), n);
        return () => {
          o(e);
        };
      };
    }
    return n && n._;
  };

  const debounce = (t, n) => {
    const {p: o, v: s, S: e, m: c} = n || {};
    let r;
    let i;
    let l;
    let a;
    const u = function invokeFunctionToDebounce(n) {
      if (i) {
        i();
      }
      if (r) {
        r();
      }
      a = i = r = l = void 0;
      t.apply(this, n);
    };
    const mergeParms = t => c && l ? c(l, t) : t;
    const flush = () => {
      if (i && l) {
        u(mergeParms(l) || l);
      }
    };
    const f = function debouncedFn() {
      const t = from(arguments);
      const n = getDebouncer(o);
      if (n) {
        const o = getDebouncer(s);
        const c = mergeParms(t);
        const f = c || t;
        const _ = u.bind(0, f);
        if (i) {
          i();
        }
        if (e && !a) {
          _();
          a = true;
          i = n((() => a = void 0));
        } else {
          i = n(_);
          if (o && !r) {
            r = o(flush);
          }
        }
        l = f;
      } else {
        u(t);
      }
    };
    f.O = flush;
    return f;
  };

  const hasOwnProperty = (t, n) => Object.prototype.hasOwnProperty.call(t, n);

  const keys$1 = t => t ? Object.keys(t) : [];

  const assignDeep = (t, n, o, s, e, c, r) => {
    const i = [ n, o, s, e, c, r ];
    if ((typeof t !== "object" || isNull(t)) && !isFunction(t)) {
      t = {};
    }
    each(i, (n => {
      each(n, ((o, s) => {
        const e = n[s];
        if (t === e) {
          return true;
        }
        const c = isArray$1(e);
        if (e && isPlainObject(e)) {
          const n = t[s];
          let o = n;
          if (c && !isArray$1(n)) {
            o = [];
          } else if (!c && !isPlainObject(n)) {
            o = {};
          }
          t[s] = assignDeep(o, e);
        } else {
          t[s] = c ? e.slice() : e;
        }
      }));
    }));
    return t;
  };

  const removeUndefinedProperties = (t, n) => each(assignDeep({}, t), ((t, n, o) => {
    if (t === void 0) {
      delete o[n];
    } else if (t && isPlainObject(t)) {
      o[n] = removeUndefinedProperties(t);
    }
  }));

  const isEmptyObject = t => !keys$1(t).length;

  const noop = () => {};

  const capNumber = (t, n, e) => o$1(t, s$1(n, e));

  const getDomTokensArray = t => deduplicateArray((isArray$1(t) ? t : (t || "").split(" ")).filter((t => t)));

  const getAttr = (t, n) => t && t.getAttribute(n);

  const hasAttr = (t, n) => t && t.hasAttribute(n);

  const setAttrs = (t, n, o) => {
    each(getDomTokensArray(n), (n => {
      if (t) {
        t.setAttribute(n, String(o || ""));
      }
    }));
  };

  const removeAttrs = (t, n) => {
    each(getDomTokensArray(n), (n => t && t.removeAttribute(n)));
  };

  const domTokenListAttr = (t, n) => {
    const o = getDomTokensArray(getAttr(t, n));
    const s = bind(setAttrs, t, n);
    const domTokenListOperation = (t, n) => {
      const s = new Set(o);
      each(getDomTokensArray(t), (t => {
        s[n](t);
      }));
      return from(s).join(" ");
    };
    return {
      C: t => s(domTokenListOperation(t, "delete")),
      $: t => s(domTokenListOperation(t, "add")),
      H: t => {
        const n = getDomTokensArray(t);
        return n.reduce(((t, n) => t && o.includes(n)), n.length > 0);
      }
    };
  };

  const removeAttrClass = (t, n, o) => {
    domTokenListAttr(t, n).C(o);
    return bind(addAttrClass, t, n, o);
  };

  const addAttrClass = (t, n, o) => {
    domTokenListAttr(t, n).$(o);
    return bind(removeAttrClass, t, n, o);
  };

  const addRemoveAttrClass = (t, n, o, s) => (s ? addAttrClass : removeAttrClass)(t, n, o);

  const hasAttrClass = (t, n, o) => domTokenListAttr(t, n).H(o);

  const createDomTokenListClass = t => domTokenListAttr(t, "class");

  const removeClass = (t, n) => {
    createDomTokenListClass(t).C(n);
  };

  const addClass = (t, n) => {
    createDomTokenListClass(t).$(n);
    return bind(removeClass, t, n);
  };

  const find$1 = (t, n) => {
    const o = n ? isElement(n) && n : document;
    return o ? from(o.querySelectorAll(t)) : [];
  };

  const findFirst = (t, n) => {
    const o = n ? isElement(n) && n : document;
    return o && o.querySelector(t);
  };

  const is$2 = (t, n) => isElement(t) && t.matches(n);

  const isBodyElement = t => is$2(t, "body");

  const contents = t => t ? from(t.childNodes) : [];

  const parent = t => t && t.parentElement;

  const closest = (t, n) => isElement(t) && t.closest(n);

  const getFocusedElement = t => document.activeElement;

  const liesBetween = (t, n, o) => {
    const s = closest(t, n);
    const e = t && findFirst(o, s);
    const c = closest(e, n) === s;
    return s && e ? s === t || e === t || c && closest(closest(t, o), n) !== s : false;
  };

  const removeElements = t => {
    each(createOrKeepArray(t), (t => {
      const n = parent(t);
      if (t && n) {
        n.removeChild(t);
      }
    }));
  };

  const appendChildren = (t, n) => bind(removeElements, t && n && each(createOrKeepArray(n), (n => {
    if (n) {
      t.appendChild(n);
    }
  })));

  let z;

  const getTrustedTypePolicy = () => z;

  const setTrustedTypePolicy = t => {
    z = t;
  };

  const createDiv = t => {
    const n = document.createElement("div");
    setAttrs(n, "class", t);
    return n;
  };

  const createDOM = t => {
    const n = createDiv();
    const o = getTrustedTypePolicy();
    const s = t.trim();
    n.innerHTML = o ? o.createHTML(s) : s;
    return each(contents(n), (t => removeElements(t)));
  };

  const getCSSVal = (t, n) => t.getPropertyValue(n) || t[n] || "";

  const validFiniteNumber = t => {
    const n = t || 0;
    return isFinite(n) ? n : 0;
  };

  const parseToZeroOrNumber = t => validFiniteNumber(parseFloat(t || ""));

  const roundCssNumber = t => Math.round(t * 1e4) / 1e4;

  const numberToCssPx = t => `${roundCssNumber(validFiniteNumber(t))}px`;

  function setStyles(t, n) {
    t && n && each(n, ((n, o) => {
      try {
        const s = t.style;
        const e = isNull(n) || isBoolean(n) ? "" : isNumber$1(n) ? numberToCssPx(n) : n;
        if (o.indexOf("--") === 0) {
          s.setProperty(o, e);
        } else {
          s[o] = e;
        }
      } catch (s) {}
    }));
  }

  function getStyles(t, o, s) {
    const e = isString(o);
    let c = e ? "" : {};
    if (t) {
      const r = n$1.getComputedStyle(t, s) || t.style;
      c = e ? getCSSVal(r, o) : from(o).reduce(((t, n) => {
        t[n] = getCSSVal(r, n);
        return t;
      }), c);
    }
    return c;
  }

  const topRightBottomLeft = (t, n, o) => {
    const s = n ? `${n}-` : "";
    const e = o ? `-${o}` : "";
    const c = `${s}top${e}`;
    const r = `${s}right${e}`;
    const i = `${s}bottom${e}`;
    const l = `${s}left${e}`;
    const a = getStyles(t, [ c, r, i, l ]);
    return {
      t: parseToZeroOrNumber(a[c]),
      r: parseToZeroOrNumber(a[r]),
      b: parseToZeroOrNumber(a[i]),
      l: parseToZeroOrNumber(a[l])
    };
  };

  const getTrasformTranslateValue = (t, n) => `translate${isObject$2(t) ? `(${t.x},${t.y})` : `${n ? "X" : "Y"}(${t})`}`;

  const elementHasDimensions = t => !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length);

  const T = {
    w: 0,
    h: 0
  };

  const getElmWidthHeightProperty = (t, n) => n ? {
    w: n[`${t}Width`],
    h: n[`${t}Height`]
  } : T;

  const getWindowSize = t => getElmWidthHeightProperty("inner", t || n$1);

  const I = bind(getElmWidthHeightProperty, "offset");

  const A = bind(getElmWidthHeightProperty, "client");

  const D = bind(getElmWidthHeightProperty, "scroll");

  const getFractionalSize = t => {
    const n = parseFloat(getStyles(t, C)) || 0;
    const o = parseFloat(getStyles(t, $)) || 0;
    return {
      w: n - e$1(n),
      h: o - e$1(o)
    };
  };

  const getBoundingClientRect = t => t.getBoundingClientRect();

  const hasDimensions = t => !!t && elementHasDimensions(t);

  const domRectHasDimensions = t => !!(t && (t[$] || t[C]));

  const domRectAppeared = (t, n) => {
    const o = domRectHasDimensions(t);
    const s = domRectHasDimensions(n);
    return !s && o;
  };

  const removeEventListener = (t, n, o, s) => {
    each(getDomTokensArray(n), (n => {
      if (t) {
        t.removeEventListener(n, o, s);
      }
    }));
  };

  const addEventListener = (t, n, o, s) => {
    var e;
    const c = (e = s && s.T) != null ? e : true;
    const r = s && s.I || false;
    const i = s && s.A || false;
    const l = {
      passive: c,
      capture: r
    };
    return bind(runEachAndClear, getDomTokensArray(n).map((n => {
      const s = i ? e => {
        removeEventListener(t, n, s, r);
        if (o) {
          o(e);
        }
      } : o;
      if (t) {
        t.addEventListener(n, s, l);
      }
      return bind(removeEventListener, t, n, s, r);
    })));
  };

  const stopPropagation = t => t.stopPropagation();

  const preventDefault = t => t.preventDefault();

  const stopAndPrevent = t => stopPropagation(t) || preventDefault(t);

  const scrollElementTo = (t, n) => {
    const {x: o, y: s} = isNumber$1(n) ? {
      x: n,
      y: n
    } : n || {};
    isNumber$1(o) && (t.scrollLeft = o);
    isNumber$1(s) && (t.scrollTop = s);
  };

  const getElementScroll = t => ({
    x: t.scrollLeft,
    y: t.scrollTop
  });

  const getZeroScrollCoordinates = () => ({
    D: {
      x: 0,
      y: 0
    },
    M: {
      x: 0,
      y: 0
    }
  });

  const sanitizeScrollCoordinates = (t, n) => {
    const {D: o, M: s} = t;
    const {w: e, h: i} = n;
    const sanitizeAxis = (t, n, o) => {
      let s = r$1(t) * o;
      let e = r$1(n) * o;
      if (s === e) {
        const o = c(t);
        const r = c(n);
        e = o > r ? 0 : e;
        s = o < r ? 0 : s;
      }
      s = s === e ? 0 : s;
      return [ s + 0, e + 0 ];
    };
    const [l, a] = sanitizeAxis(o.x, s.x, e);
    const [u, f] = sanitizeAxis(o.y, s.y, i);
    return {
      D: {
        x: l,
        y: u
      },
      M: {
        x: a,
        y: f
      }
    };
  };

  const isDefaultDirectionScrollCoordinates = ({D: t, M: n}) => {
    const getAxis = (t, n) => t === 0 && t <= n;
    return {
      x: getAxis(t.x, n.x),
      y: getAxis(t.y, n.y)
    };
  };

  const getScrollCoordinatesPercent = ({D: t, M: n}, o) => {
    const getAxis = (t, n, o) => capNumber(0, 1, (t - o) / (t - n) || 0);
    return {
      x: getAxis(t.x, n.x, o.x),
      y: getAxis(t.y, n.y, o.y)
    };
  };

  const focusElement = t => {
    if (t && t.focus) {
      t.focus({
        preventScroll: true
      });
    }
  };

  const manageListener = (t, n) => {
    each(createOrKeepArray(n), t);
  };

  const createEventListenerHub = t => {
    const n = new Map;
    const removeEvent = (t, o) => {
      if (t) {
        const s = n.get(t);
        manageListener((t => {
          if (s) {
            s[t ? "delete" : "clear"](t);
          }
        }), o);
      } else {
        n.forEach((t => {
          t.clear();
        }));
        n.clear();
      }
    };
    const addEvent = (t, o) => {
      if (isString(t)) {
        const s = n.get(t) || new Set;
        n.set(t, s);
        manageListener((t => {
          if (isFunction(t)) {
            s.add(t);
          }
        }), o);
        return bind(removeEvent, t, o);
      }
      if (isBoolean(o) && o) {
        removeEvent();
      }
      const s = keys$1(t);
      const e = [];
      each(s, (n => {
        const o = t[n];
        if (o) {
          push$1(e, addEvent(n, o));
        }
      }));
      return bind(runEachAndClear, e);
    };
    const triggerEvent = (t, o) => {
      each(from(n.get(t)), (t => {
        if (o && !isEmptyArray(o)) {
          t.apply(0, o);
        } else {
          t();
        }
      }));
    };
    addEvent(t || {});
    return [ addEvent, removeEvent, triggerEvent ];
  };

  const M = {};

  const k = {};

  const addPlugins = t => {
    each(t, (t => each(t, ((n, o) => {
      M[o] = t[o];
    }))));
  };

  const registerPluginModuleInstances = (t, n, o) => keys$1(t).map((s => {
    const {static: e, instance: c} = t[s];
    const [r, i, l] = o || [];
    const a = o ? c : e;
    if (a) {
      const t = o ? a(r, i, n) : a(n);
      return (l || k)[s] = t;
    }
  }));

  const getStaticPluginModuleInstance = t => k[t];

  const R = "__osOptionsValidationPlugin";

  const V = `data-overlayscrollbars`;

  const L = "os-environment";

  const U = `${L}-scrollbar-hidden`;

  const P = `${V}-initialize`;

  const N = "noClipping";

  const q = `${V}-body`;

  const B = V;

  const F = "host";

  const j = `${V}-viewport`;

  const X = m;

  const Y = O;

  const W = "arrange";

  const J = "measuring";

  const G = "scrolling";

  const K = "scrollbarHidden";

  const Q = "noContent";

  const Z = `${V}-padding`;

  const tt = `${V}-content`;

  const nt = "os-size-observer";

  const ot = `${nt}-appear`;

  const st = `${nt}-listener`;

  const it = "os-trinsic-observer";

  const lt = "os-theme-none";

  const at = "os-scrollbar";

  const ut = `${at}-rtl`;

  const ft = `${at}-horizontal`;

  const _t = `${at}-vertical`;

  const dt = `${at}-track`;

  const pt = `${at}-handle`;

  const vt = `${at}-visible`;

  const gt = `${at}-cornerless`;

  const ht = `${at}-interaction`;

  const bt = `${at}-unusable`;

  const wt = `${at}-auto-hide`;

  const yt = `${wt}-hidden`;

  const St = `${at}-wheel`;

  const mt = `${dt}-interactive`;

  const Ot = `${pt}-interactive`;

  const Ct = "__osSizeObserverPlugin";

  const getShowNativeOverlaidScrollbars = (t, n) => {
    const {k: o} = n;
    const [s, e] = t("showNativeOverlaidScrollbars");
    return [ s && o.x && o.y, e ];
  };

  const overflowIsVisible = t => t.indexOf(x) === 0;

  const overflowBehaviorToOverflowStyle = t => t.replace(`${x}-`, "");

  const overflowCssValueToOverflowStyle = (t, n) => {
    if (t === "auto") {
      return n ? E : H;
    }
    const o = t || H;
    return [ H, E, x ].includes(o) ? o : H;
  };

  const getElementOverflowStyle = (t, n) => {
    const {overflowX: o, overflowY: s} = getStyles(t, [ m, O ]);
    return {
      x: overflowCssValueToOverflowStyle(o, n.x),
      y: overflowCssValueToOverflowStyle(s, n.y)
    };
  };

  const xt = "__osScrollbarsHidingPlugin";

  const Et = "__osClickScrollPlugin";

  const opsStringify = t => JSON.stringify(t, ((t, n) => {
    if (isFunction(n)) {
      throw 0;
    }
    return n;
  }));

  const getPropByPath = (t, n) => t ? `${n}`.split(".").reduce(((t, n) => t && hasOwnProperty(t, n) ? t[n] : void 0), t) : void 0;

  const Tt = {
    paddingAbsolute: false,
    showNativeOverlaidScrollbars: false,
    update: {
      elementEvents: [ [ "img", "load" ] ],
      debounce: [ 0, 33 ],
      attributes: null,
      ignoreMutation: null
    },
    overflow: {
      x: "scroll",
      y: "scroll"
    },
    scrollbars: {
      theme: "os-theme-dark",
      visibility: "auto",
      autoHide: "never",
      autoHideDelay: 1300,
      autoHideSuspend: false,
      dragScroll: true,
      clickScroll: false,
      pointers: [ "mouse", "touch", "pen" ]
    }
  };

  const getOptionsDiff = (t, n) => {
    const o = {};
    const s = concat(keys$1(n), keys$1(t));
    each(s, (s => {
      const e = t[s];
      const c = n[s];
      if (isObject$2(e) && isObject$2(c)) {
        assignDeep(o[s] = {}, getOptionsDiff(e, c));
        if (isEmptyObject(o[s])) {
          delete o[s];
        }
      } else if (hasOwnProperty(n, s) && c !== e) {
        let t = true;
        if (isArray$1(e) || isArray$1(c)) {
          try {
            if (opsStringify(e) === opsStringify(c)) {
              t = false;
            }
          } catch (r) {}
        }
        if (t) {
          o[s] = c;
        }
      }
    }));
    return o;
  };

  const createOptionCheck = (t, n, o) => s => [ getPropByPath(t, s), o || getPropByPath(n, s) !== void 0 ];

  let It;

  const getNonce = () => It;

  const setNonce = t => {
    It = t;
  };

  let At;

  const createEnvironment = () => {
    const getNativeScrollbarSize = (t, n, o) => {
      appendChildren(document.body, t);
      appendChildren(document.body, t);
      const s = A(t);
      const e = I(t);
      const c = getFractionalSize(n);
      if (o) {
        removeElements(t);
      }
      return {
        x: e.h - s.h + c.h,
        y: e.w - s.w + c.w
      };
    };
    const getNativeScrollbarsHiding = t => {
      let n = false;
      const o = addClass(t, U);
      try {
        n = getStyles(t, "scrollbar-width") === "none" || getStyles(t, "display", "::-webkit-scrollbar") === "none";
      } catch (s) {}
      o();
      return n;
    };
    const t = `.${L}{scroll-behavior:auto!important;position:fixed;opacity:0;visibility:hidden;overflow:scroll;height:200px;width:200px;z-index:-1}.${L} div{width:200%;height:200%;margin:10px 0}.${U}{scrollbar-width:none!important}.${U}::-webkit-scrollbar,.${U}::-webkit-scrollbar-corner{appearance:none!important;display:none!important;width:0!important;height:0!important}`;
    const o = createDOM(`<div class="${L}"><div></div><style>${t}</style></div>`);
    const s = o[0];
    const e = s.firstChild;
    const c = s.lastChild;
    const r = getNonce();
    if (r) {
      c.nonce = r;
    }
    const [i, , l] = createEventListenerHub();
    const [a, u] = createCache({
      o: getNativeScrollbarSize(s, e),
      i: equalXY
    }, bind(getNativeScrollbarSize, s, e, true));
    const [f] = u();
    const _ = getNativeScrollbarsHiding(s);
    const d = {
      x: f.x === 0,
      y: f.y === 0
    };
    const v = {
      elements: {
        host: null,
        padding: !_,
        viewport: t => _ && isBodyElement(t) && t,
        content: false
      },
      scrollbars: {
        slot: true
      },
      cancel: {
        nativeScrollbarsOverlaid: false,
        body: null
      }
    };
    const g = assignDeep({}, Tt);
    const h = bind(assignDeep, {}, g);
    const b = bind(assignDeep, {}, v);
    const w = {
      P: f,
      k: d,
      U: _,
      J: !!p,
      G: bind(i, "r"),
      K: b,
      Z: t => assignDeep(v, t) && b(),
      tt: h,
      nt: t => assignDeep(g, t) && h(),
      ot: assignDeep({}, v),
      st: assignDeep({}, g)
    };
    removeAttrs(s, "style");
    removeElements(s);
    addEventListener(n$1, "resize", (() => {
      l("r", []);
    }));
    if (isFunction(n$1.matchMedia) && !_ && (!d.x || !d.y)) {
      const addZoomListener = t => {
        const o = n$1.matchMedia(`(resolution: ${n$1.devicePixelRatio}dppx)`);
        addEventListener(o, "change", (() => {
          t();
          addZoomListener(t);
        }), {
          A: true
        });
      };
      addZoomListener((() => {
        const [t, n] = a();
        assignDeep(w.P, t);
        l("r", [ n ]);
      }));
    }
    return w;
  };

  const getEnvironment = () => {
    if (!At) {
      At = createEnvironment();
    }
    return At;
  };

  const createEventContentChange = (t, n, o) => {
    let s = false;
    const e = o ? new WeakMap : false;
    const destroy = () => {
      s = true;
    };
    const updateElements = c => {
      if (e && o) {
        const r = o.map((n => {
          const [o, s] = n || [];
          const e = s && o ? (c || find$1)(o, t) : [];
          return [ e, s ];
        }));
        each(r, (o => each(o[0], (c => {
          const r = o[1];
          const i = e.get(c) || [];
          const l = t.contains(c);
          if (l && r) {
            const t = addEventListener(c, r, (o => {
              if (s) {
                t();
                e.delete(c);
              } else {
                n(o);
              }
            }));
            e.set(c, push$1(i, t));
          } else {
            runEachAndClear(i);
            e.delete(c);
          }
        }))));
      }
    };
    updateElements();
    return [ destroy, updateElements ];
  };

  const createDOMObserver = (t, n, o, s) => {
    let e = false;
    const {et: c, ct: r, rt: i, it: l, lt: a, ut: u} = s || {};
    const _ = debounce((() => e && o(true)), {
      p: 33,
      v: 99
    });
    const [d, p] = createEventContentChange(t, _, i);
    const v = c || [];
    const g = r || [];
    const h = concat(v, g);
    const observerCallback = (e, c) => {
      if (!isEmptyArray(c)) {
        const r = a || noop;
        const i = u || noop;
        const f = [];
        const _ = [];
        let d = false;
        let v = false;
        each(c, (o => {
          const {attributeName: e, target: c, type: a, oldValue: u, addedNodes: p, removedNodes: h} = o;
          const b = a === "attributes";
          const w = a === "childList";
          const y = t === c;
          const S = b && e;
          const m = S && getAttr(c, e || "");
          const O = isString(m) ? m : null;
          const C = S && u !== O;
          const $ = inArray(g, e) && C;
          if (n && (w || !y)) {
            const n = b && C;
            const a = n && l && is$2(c, l);
            const _ = a ? !r(c, e, u, O) : !b || n;
            const d = _ && !i(o, !!a, t, s);
            each(p, (t => push$1(f, t)));
            each(h, (t => push$1(f, t)));
            v = v || d;
          }
          if (!n && y && C && !r(c, e, u, O)) {
            push$1(_, e);
            d = d || $;
          }
        }));
        p((t => deduplicateArray(f).reduce(((n, o) => {
          push$1(n, find$1(t, o));
          return is$2(o, t) ? push$1(n, o) : n;
        }), [])));
        if (n) {
          if (!e && v) {
            o(false);
          }
          return [ false ];
        }
        if (!isEmptyArray(_) || d) {
          const t = [ deduplicateArray(_), d ];
          if (!e) {
            o.apply(0, t);
          }
          return t;
        }
      }
    };
    const b = new f(bind(observerCallback, false));
    return [ () => {
      b.observe(t, {
        attributes: true,
        attributeOldValue: true,
        attributeFilter: h,
        subtree: n,
        childList: n,
        characterData: n
      });
      e = true;
      return () => {
        if (e) {
          d();
          b.disconnect();
          e = false;
        }
      };
    }, () => {
      if (e) {
        _.O();
        return observerCallback(true, b.takeRecords());
      }
    } ];
  };

  let Dt = null;

  const createSizeObserver = (t, n, o) => {
    const {ft: s} = o || {};
    const e = getStaticPluginModuleInstance(Ct);
    const [c] = createCache({
      o: false,
      u: true
    });
    return () => {
      const o = [];
      const r = createDOM(`<div class="${nt}"><div class="${st}"></div></div>`);
      const i = r[0];
      const l = i.firstChild;
      const onSizeChangedCallbackProxy = t => {
        const o = isArray$1(t) && !isEmptyArray(t);
        let s = false;
        let e = false;
        if (o) {
          const n = t[0];
          const [o, , r] = c(n.contentRect);
          const i = domRectHasDimensions(o);
          e = domRectAppeared(o, r);
          s = !e && !i;
        } else {
          e = t === true;
        }
        if (!s) {
          n({
            _t: true,
            ft: e
          });
        }
      };
      if (d) {
        if (!isBoolean(Dt)) {
          const n = new d(noop);
          n.observe(t, {
            get box() {
              Dt = true;
            }
          });
          Dt = Dt || false;
          n.disconnect();
        }
        const n = debounce(onSizeChangedCallbackProxy, {
          p: 0,
          v: 0
        });
        const resizeObserverCallback = t => n(t);
        const s = new d(resizeObserverCallback);
        s.observe(Dt ? t : l);
        push$1(o, [ () => {
          s.disconnect();
        }, !Dt && appendChildren(t, i) ]);
        if (Dt) {
          const n = new d(resizeObserverCallback);
          n.observe(t, {
            box: "border-box"
          });
          push$1(o, (() => n.disconnect()));
        }
      } else if (e) {
        const [n, c] = e(l, onSizeChangedCallbackProxy, s);
        push$1(o, concat([ addClass(i, ot), addEventListener(i, "animationstart", n), appendChildren(t, i) ], c));
      } else {
        return noop;
      }
      return bind(runEachAndClear, o);
    };
  };

  const createTrinsicObserver = (t, n) => {
    let o;
    const isHeightIntrinsic = t => t.h === 0 || t.isIntersecting || t.intersectionRatio > 0;
    const s = createDiv(it);
    const [e] = createCache({
      o: false
    });
    const triggerOnTrinsicChangedCallback = (t, o) => {
      if (t) {
        const s = e(isHeightIntrinsic(t));
        const [, c] = s;
        return c && !o && n(s) && [ s ];
      }
    };
    const intersectionObserverCallback = (t, n) => triggerOnTrinsicChangedCallback(n.pop(), t);
    return [ () => {
      const n = [];
      if (_) {
        o = new _(bind(intersectionObserverCallback, false), {
          root: t
        });
        o.observe(s);
        push$1(n, (() => {
          o.disconnect();
        }));
      } else {
        const onSizeChanged = () => {
          const t = I(s);
          triggerOnTrinsicChangedCallback(t);
        };
        push$1(n, createSizeObserver(s, onSizeChanged)());
        onSizeChanged();
      }
      return bind(runEachAndClear, push$1(n, appendChildren(t, s)));
    }, () => o && intersectionObserverCallback(true, o.takeRecords()) ];
  };

  const createObserversSetup = (t, n, o, s) => {
    let e;
    let c;
    let r;
    let i;
    let l;
    let a;
    const u = `[${B}]`;
    const f = `[${j}]`;
    const _ = [ "id", "class", "style", "open", "wrap", "cols", "rows" ];
    const {dt: p, vt: v, L: g, gt: h, ht: b, V: w, bt: y, wt: S, yt: m, St: O} = t;
    const getDirectionIsRTL = t => getStyles(t, "direction") === "rtl";
    const C = {
      Ot: false,
      B: getDirectionIsRTL(p)
    };
    const $ = getEnvironment();
    const x = getStaticPluginModuleInstance(xt);
    const [H] = createCache({
      i: equalWH,
      o: {
        w: 0,
        h: 0
      }
    }, (() => {
      const s = x && x.R(t, n, C, $, o).Y;
      const e = y && w;
      const c = !e && hasAttrClass(v, B, N);
      const r = !w && S(W);
      const i = r && getElementScroll(h);
      const l = i && O();
      const a = m(J, c);
      const u = r && s && s();
      const f = D(g);
      const _ = getFractionalSize(g);
      if (u) {
        u();
      }
      scrollElementTo(h, i);
      if (l) {
        l();
      }
      if (c) {
        a();
      }
      return {
        w: f.w + _.w,
        h: f.h + _.h
      };
    }));
    const E = debounce(s, {
      p: () => e,
      v: () => c,
      m(t, n) {
        const [o] = t;
        const [s] = n;
        return [ concat(keys$1(o), keys$1(s)).reduce(((t, n) => {
          t[n] = o[n] || s[n];
          return t;
        }), {}) ];
      }
    });
    const setDirection = t => {
      const n = getDirectionIsRTL(p);
      assignDeep(t, {
        Ct: a !== n
      });
      assignDeep(C, {
        B: n
      });
      a = n;
    };
    const onTrinsicChanged = (t, n) => {
      const [o, e] = t;
      const c = {
        $t: e
      };
      assignDeep(C, {
        Ot: o
      });
      if (!n) {
        s(c);
      }
      return c;
    };
    const onSizeChanged = ({_t: t, ft: n}) => {
      const o = t && !n;
      const e = !o && $.U ? E : s;
      const c = {
        _t: t || n,
        ft: n
      };
      setDirection(c);
      e(c);
    };
    const onContentMutation = (t, n) => {
      const [, o] = H();
      const e = {
        xt: o
      };
      setDirection(e);
      const c = t ? s : E;
      if (o && !n) {
        c(e);
      }
      return e;
    };
    const onHostMutation = (t, n, o) => {
      const s = {
        Ht: n
      };
      setDirection(s);
      if (n && !o) {
        E(s);
      }
      return s;
    };
    const [z, T] = b ? createTrinsicObserver(v, onTrinsicChanged) : [];
    const I = !w && createSizeObserver(v, onSizeChanged, {
      ft: true
    });
    const [A, M] = createDOMObserver(v, false, onHostMutation, {
      ct: _,
      et: _
    });
    const k = w && d && new d((t => {
      const n = t[t.length - 1].contentRect;
      onSizeChanged({
        _t: true,
        ft: domRectAppeared(n, l)
      });
      l = n;
    }));
    const R = debounce((() => {
      const [, t] = H();
      s({
        xt: t,
        _t: y
      });
    }), {
      p: 222,
      S: true
    });
    return [ () => {
      if (k) {
        k.observe(v);
      }
      const t = I && I();
      const n = z && z();
      const o = A();
      const s = $.G((t => {
        if (t) {
          E({
            Et: t
          });
        } else {
          R();
        }
      }));
      return () => {
        if (k) {
          k.disconnect();
        }
        if (t) {
          t();
        }
        if (n) {
          n();
        }
        if (i) {
          i();
        }
        o();
        s();
      };
    }, ({zt: t, Tt: n, It: o}) => {
      const s = {};
      const [l] = t("update.ignoreMutation");
      const [a, d] = t("update.attributes");
      const [p, v] = t("update.elementEvents");
      const [h, y] = t("update.debounce");
      const S = v || d;
      const m = n || o;
      const ignoreMutationFromOptions = t => isFunction(l) && l(t);
      if (S) {
        if (r) {
          r();
        }
        if (i) {
          i();
        }
        const [t, n] = createDOMObserver(b || g, true, onContentMutation, {
          et: concat(_, a || []),
          rt: p,
          it: u,
          ut: (t, n) => {
            const {target: o, attributeName: s} = t;
            const e = !n && s && !w ? liesBetween(o, u, f) : false;
            return e || !!closest(o, `.${at}`) || !!ignoreMutationFromOptions(t);
          }
        });
        i = t();
        r = n;
      }
      if (y) {
        E.O();
        if (isArray$1(h)) {
          const t = h[0];
          const n = h[1];
          e = isNumber$1(t) && t;
          c = isNumber$1(n) && n;
        } else if (isNumber$1(h)) {
          e = h;
          c = false;
        } else {
          e = false;
          c = false;
        }
      }
      if (m) {
        const t = M();
        const n = T && T();
        const o = r && r();
        if (t) {
          assignDeep(s, onHostMutation(t[0], t[1], m));
        }
        if (n) {
          assignDeep(s, onTrinsicChanged(n[0], m));
        }
        if (o) {
          assignDeep(s, onContentMutation(o[0], m));
        }
      }
      setDirection(s);
      return s;
    }, C ];
  };

  const resolveInitialization = (t, n) => isFunction(n) ? n.apply(0, t) : n;

  const staticInitializationElement = (t, n, o, s) => {
    const e = isUndefined(s) ? o : s;
    const c = resolveInitialization(t, e);
    return c || n.apply(0, t);
  };

  const dynamicInitializationElement = (t, n, o, s) => {
    const e = isUndefined(s) ? o : s;
    const c = resolveInitialization(t, e);
    return !!c && (isHTMLElement(c) ? c : n.apply(0, t));
  };

  const cancelInitialization = (t, n) => {
    const {nativeScrollbarsOverlaid: o, body: s} = n || {};
    const {k: e, U: c, K: r} = getEnvironment();
    const {nativeScrollbarsOverlaid: i, body: l} = r().cancel;
    const a = o != null ? o : i;
    const u = isUndefined(s) ? l : s;
    const f = (e.x || e.y) && a;
    const _ = t && (isNull(u) ? !c : u);
    return !!f || !!_;
  };

  const createScrollbarsSetupElements = (t, n, o, s) => {
    const e = "--os-viewport-percent";
    const c = "--os-scroll-percent";
    const r = "--os-scroll-direction";
    const {K: i} = getEnvironment();
    const {scrollbars: l} = i();
    const {slot: a} = l;
    const {dt: u, vt: f, L: _, At: d, gt: v, bt: g, V: h} = n;
    const {scrollbars: b} = d ? {} : t;
    const {slot: w} = b || {};
    const y = [];
    const S = [];
    const m = [];
    const O = dynamicInitializationElement([ u, f, _ ], (() => h && g ? u : f), a, w);
    const initScrollTimeline = t => {
      if (p) {
        let n = null;
        let s = [];
        const e = new p({
          source: v,
          axis: t
        });
        const cancelAnimation = () => {
          if (n) {
            n.cancel();
          }
          n = null;
        };
        const _setScrollPercentAnimation = c => {
          const {Dt: r} = o;
          const i = isDefaultDirectionScrollCoordinates(r)[t];
          const l = t === "x";
          const a = [ getTrasformTranslateValue(0, l), getTrasformTranslateValue(`calc(100cq${l ? "w" : "h"} + -100%)`, l) ];
          const u = i ? a : a.reverse();
          if (s[0] === u[0] && s[1] === u[1]) {
            return cancelAnimation;
          }
          cancelAnimation();
          s = u;
          n = c.Mt.animate({
            clear: [ "left" ],
            transform: u
          }, {
            timeline: e
          });
          return cancelAnimation;
        };
        return {
          kt: _setScrollPercentAnimation
        };
      }
    };
    const C = {
      x: initScrollTimeline("x"),
      y: initScrollTimeline("y")
    };
    const getViewportPercent = () => {
      const {Rt: t, Vt: n} = o;
      const getAxisValue = (t, n) => capNumber(0, 1, t / (t + n) || 0);
      return {
        x: getAxisValue(n.x, t.x),
        y: getAxisValue(n.y, t.y)
      };
    };
    const scrollbarStructureAddRemoveClass = (t, n, o) => {
      const s = o ? addClass : removeClass;
      each(t, (t => {
        s(t.Lt, n);
      }));
    };
    const scrollbarStyle = (t, n) => {
      each(t, (t => {
        const [o, s] = n(t);
        setStyles(o, s);
      }));
    };
    const scrollbarsAddRemoveClass = (t, n, o) => {
      const s = isBoolean(o);
      const e = s ? o : true;
      const c = s ? !o : true;
      if (e) {
        scrollbarStructureAddRemoveClass(S, t, n);
      }
      if (c) {
        scrollbarStructureAddRemoveClass(m, t, n);
      }
    };
    const refreshScrollbarsHandleLength = () => {
      const t = getViewportPercent();
      const createScrollbarStyleFn = t => n => [ n.Lt, {
        [e]: roundCssNumber(t) + ""
      } ];
      scrollbarStyle(S, createScrollbarStyleFn(t.x));
      scrollbarStyle(m, createScrollbarStyleFn(t.y));
    };
    const refreshScrollbarsHandleOffset = () => {
      if (!p) {
        const {Dt: t} = o;
        const n = getScrollCoordinatesPercent(t, getElementScroll(v));
        const createScrollbarStyleFn = t => n => [ n.Lt, {
          [c]: roundCssNumber(t) + ""
        } ];
        scrollbarStyle(S, createScrollbarStyleFn(n.x));
        scrollbarStyle(m, createScrollbarStyleFn(n.y));
      }
    };
    const refreshScrollbarsScrollCoordinates = () => {
      const {Dt: t} = o;
      const n = isDefaultDirectionScrollCoordinates(t);
      const createScrollbarStyleFn = t => n => [ n.Lt, {
        [r]: t ? "0" : "1"
      } ];
      scrollbarStyle(S, createScrollbarStyleFn(n.x));
      scrollbarStyle(m, createScrollbarStyleFn(n.y));
      if (p) {
        S.forEach(C.x.kt);
        m.forEach(C.y.kt);
      }
    };
    const refreshScrollbarsScrollbarOffset = () => {
      if (h && !g) {
        const {Rt: t, Dt: n} = o;
        const s = isDefaultDirectionScrollCoordinates(n);
        const e = getScrollCoordinatesPercent(n, getElementScroll(v));
        const styleScrollbarPosition = n => {
          const {Lt: o} = n;
          const c = parent(o) === _ && o;
          const getTranslateValue = (t, n, o) => {
            const s = n * t;
            return numberToCssPx(o ? s : -s);
          };
          return [ c, c && {
            transform: getTrasformTranslateValue({
              x: getTranslateValue(e.x, t.x, s.x),
              y: getTranslateValue(e.y, t.y, s.y)
            })
          } ];
        };
        scrollbarStyle(S, styleScrollbarPosition);
        scrollbarStyle(m, styleScrollbarPosition);
      }
    };
    const generateScrollbarDOM = t => {
      const n = t ? "x" : "y";
      const o = t ? ft : _t;
      const e = createDiv(`${at} ${o}`);
      const c = createDiv(dt);
      const r = createDiv(pt);
      const i = {
        Lt: e,
        Ut: c,
        Mt: r
      };
      const l = C[n];
      push$1(t ? S : m, i);
      push$1(y, [ appendChildren(e, c), appendChildren(c, r), bind(removeElements, e), l && l.kt(i), s(i, scrollbarsAddRemoveClass, t) ]);
      return i;
    };
    const $ = bind(generateScrollbarDOM, true);
    const x = bind(generateScrollbarDOM, false);
    const appendElements = () => {
      appendChildren(O, S[0].Lt);
      appendChildren(O, m[0].Lt);
      return bind(runEachAndClear, y);
    };
    $();
    x();
    return [ {
      Pt: refreshScrollbarsHandleLength,
      Nt: refreshScrollbarsHandleOffset,
      qt: refreshScrollbarsScrollCoordinates,
      Bt: refreshScrollbarsScrollbarOffset,
      Ft: scrollbarsAddRemoveClass,
      jt: {
        Xt: S,
        Yt: $,
        Wt: bind(scrollbarStyle, S)
      },
      Jt: {
        Xt: m,
        Yt: x,
        Wt: bind(scrollbarStyle, m)
      }
    }, appendElements ];
  };

  const createScrollbarsSetupEvents = (t, n, o, s) => (r, i, l) => {
    const {vt: u, L: f, V: _, gt: d, Gt: p, St: v} = n;
    const {Lt: g, Ut: h, Mt: b} = r;
    const [w, y] = selfClearTimeout(333);
    const [S, m] = selfClearTimeout(444);
    const scrollOffsetElementScrollBy = t => {
      if (isFunction(d.scrollBy)) {
        d.scrollBy({
          behavior: "smooth",
          left: t.x,
          top: t.y
        });
      }
    };
    const createInteractiveScrollEvents = () => {
      const n = "pointerup pointercancel lostpointercapture";
      const s = `client${l ? "X" : "Y"}`;
      const r = l ? C : $;
      const i = l ? "left" : "top";
      const a = l ? "w" : "h";
      const u = l ? "x" : "y";
      const createRelativeHandleMove = (t, n) => s => {
        const {Rt: e} = o;
        const c = I(h)[a] - I(b)[a];
        const r = n * s / c;
        const i = r * e[u];
        scrollElementTo(d, {
          [u]: t + i
        });
      };
      const f = [];
      return addEventListener(h, "pointerdown", (o => {
        const l = closest(o.target, `.${pt}`) === b;
        const _ = l ? b : h;
        const g = t.scrollbars;
        const w = g[l ? "dragScroll" : "clickScroll"];
        const {button: y, isPrimary: O, pointerType: C} = o;
        const {pointers: $} = g;
        const x = y === 0 && O && w && ($ || []).includes(C);
        if (x) {
          runEachAndClear(f);
          m();
          const t = !l && (o.shiftKey || w === "instant");
          const g = bind(getBoundingClientRect, b);
          const y = bind(getBoundingClientRect, h);
          const getHandleOffset = (t, n) => (t || g())[i] - (n || y())[i];
          const O = e$1(getBoundingClientRect(d)[r]) / I(d)[a] || 1;
          const C = createRelativeHandleMove(getElementScroll(d)[u], 1 / O);
          const $ = o[s];
          const x = g();
          const H = y();
          const E = x[r];
          const z = getHandleOffset(x, H) + E / 2;
          const T = $ - H[i];
          const A = l ? 0 : T - z;
          const releasePointerCapture = t => {
            runEachAndClear(k);
            _.releasePointerCapture(t.pointerId);
          };
          const D = l || t;
          const M = v();
          const k = [ addEventListener(p, n, releasePointerCapture), addEventListener(p, "selectstart", (t => preventDefault(t)), {
            T: false
          }), addEventListener(h, n, releasePointerCapture), D && addEventListener(h, "pointermove", (t => C(A + (t[s] - $)))), D && (() => {
            const t = getElementScroll(d);
            M();
            const n = getElementScroll(d);
            const o = {
              x: n.x - t.x,
              y: n.y - t.y
            };
            if (c(o.x) > 3 || c(o.y) > 3) {
              v();
              scrollElementTo(d, t);
              scrollOffsetElementScrollBy(o);
              S(M);
            }
          }) ];
          _.setPointerCapture(o.pointerId);
          if (t) {
            C(A);
          } else if (!l) {
            const t = getStaticPluginModuleInstance(Et);
            if (t) {
              const n = t(C, A, E, (t => {
                if (t) {
                  M();
                } else {
                  push$1(k, M);
                }
              }));
              push$1(k, n);
              push$1(f, bind(n, true));
            }
          }
        }
      }));
    };
    let O = true;
    return bind(runEachAndClear, [ addEventListener(b, "pointermove pointerleave", s), addEventListener(g, "pointerenter", (() => {
      i(ht, true);
    })), addEventListener(g, "pointerleave pointercancel", (() => {
      i(ht, false);
    })), !_ && addEventListener(g, "mousedown", (() => {
      const t = getFocusedElement();
      if (hasAttr(t, j) || hasAttr(t, B) || t === document.body) {
        a$1(bind(focusElement, f), 25);
      }
    })), addEventListener(g, "wheel", (t => {
      const {deltaX: n, deltaY: o, deltaMode: s} = t;
      if (O && s === 0 && parent(g) === u) {
        scrollOffsetElementScrollBy({
          x: n,
          y: o
        });
      }
      O = false;
      i(St, true);
      w((() => {
        O = true;
        i(St);
      }));
      preventDefault(t);
    }), {
      T: false,
      I: true
    }), addEventListener(g, "pointerdown", (() => {
      const t = addEventListener(p, "click", (t => {
        n();
        stopAndPrevent(t);
      }), {
        A: true,
        I: true,
        T: false
      });
      const n = addEventListener(p, "pointerup pointercancel", (() => {
        n();
        setTimeout(t, 150);
      }), {
        I: true,
        T: true
      });
    }), {
      I: true,
      T: true
    }), createInteractiveScrollEvents(), y, m ]);
  };

  const createScrollbarsSetup = (t, n, o, s, e, c) => {
    let r;
    let i;
    let l;
    let a;
    let u;
    let f = noop;
    let _ = 0;
    const d = [ "mouse", "pen" ];
    const isHoverablePointerType = t => d.includes(t.pointerType);
    const [p, v] = selfClearTimeout();
    const [g, h] = selfClearTimeout(100);
    const [b, w] = selfClearTimeout(100);
    const [y, S] = selfClearTimeout((() => _));
    const [m, O] = createScrollbarsSetupElements(t, e, s, createScrollbarsSetupEvents(n, e, s, (t => isHoverablePointerType(t) && manageScrollbarsAutoHideInstantInteraction())));
    const {vt: C, Kt: $, bt: H} = e;
    const {Ft: z, Pt: T, Nt: I, qt: A, Bt: D} = m;
    const manageScrollbarsAutoHide = (t, n) => {
      S();
      if (t) {
        z(yt);
      } else {
        const t = bind(z, yt, true);
        if (_ > 0 && !n) {
          y(t);
        } else {
          t();
        }
      }
    };
    const manageScrollbarsAutoHideInstantInteraction = () => {
      if (l ? !r : !a) {
        manageScrollbarsAutoHide(true);
        g((() => {
          manageScrollbarsAutoHide(false);
        }));
      }
    };
    const manageAutoHideSuspension = t => {
      z(wt, t, true);
      z(wt, t, false);
    };
    const onHostMouseEnter = t => {
      if (isHoverablePointerType(t)) {
        r = l;
        if (l) {
          manageScrollbarsAutoHide(true);
        }
      }
    };
    const M = [ S, h, w, v, () => f(), addEventListener(C, "pointerover", onHostMouseEnter, {
      A: true
    }), addEventListener(C, "pointerenter", onHostMouseEnter), addEventListener(C, "pointerleave", (t => {
      if (isHoverablePointerType(t)) {
        r = false;
        if (l) {
          manageScrollbarsAutoHide(false);
        }
      }
    })), addEventListener(C, "pointermove", (t => {
      if (isHoverablePointerType(t) && i) {
        manageScrollbarsAutoHideInstantInteraction();
      }
    })), addEventListener($, "scroll", (t => {
      p((() => {
        I();
        manageScrollbarsAutoHideInstantInteraction();
      }));
      c(t);
      D();
    })) ];
    const k = getStaticPluginModuleInstance(xt);
    return [ () => bind(runEachAndClear, push$1(M, O())), ({zt: t, It: n, Qt: e, Zt: c}) => {
      const {tn: r, nn: d, sn: p, en: v} = c || {};
      const {Ct: g, ft: h} = e || {};
      const {B: w} = o;
      const {k: y, U: S} = getEnvironment();
      const {cn: m, j: O} = s;
      const [C, M] = t("showNativeOverlaidScrollbars");
      const [R, V] = t("scrollbars.theme");
      const [L, U] = t("scrollbars.visibility");
      const [P, N] = t("scrollbars.autoHide");
      const [q, B] = t("scrollbars.autoHideSuspend");
      const [F] = t("scrollbars.autoHideDelay");
      const [j, X] = t("scrollbars.dragScroll");
      const [Y, W] = t("scrollbars.clickScroll");
      const [J, G] = t("overflow");
      const K = h && !n;
      const Q = O.x || O.y;
      const Z = r || d || v || g || n;
      const tt = p || U || G;
      const nt = C && y.x && y.y;
      const ot = !S && !k;
      const st = nt || ot;
      const setScrollbarVisibility = (t, n, o) => {
        const s = t.includes(E) && (L === x || L === "auto" && n === E);
        z(vt, s, o);
        return s;
      };
      _ = F;
      if (K) {
        if (q && Q) {
          manageAutoHideSuspension(false);
          f();
          b((() => {
            f = addEventListener($, "scroll", bind(manageAutoHideSuspension, true), {
              A: true
            });
          }));
        } else {
          manageAutoHideSuspension(true);
        }
      }
      if (M || ot) {
        z(lt, st);
      }
      if (V) {
        z(u);
        z(R, true);
        u = R;
      }
      if (B && !q) {
        manageAutoHideSuspension(true);
      }
      if (N) {
        i = P === "move";
        l = P === "leave";
        a = P === "never";
        manageScrollbarsAutoHide(a, true);
      }
      if (X) {
        z(Ot, j);
      }
      if (W) {
        z(mt, !!Y);
      }
      if (tt) {
        const t = setScrollbarVisibility(J.x, m.x, true);
        const n = setScrollbarVisibility(J.y, m.y, false);
        const o = t && n;
        z(gt, !o);
      }
      if (Z) {
        I();
        T();
        D();
        if (v) {
          A();
        }
        z(bt, !O.x, true);
        z(bt, !O.y, false);
        z(ut, w && !H);
      }
    }, {}, m ];
  };

  const createStructureSetupElements = t => {
    const o = getEnvironment();
    const {K: s, U: e} = o;
    const {elements: c} = s();
    const {padding: r, viewport: i, content: l} = c;
    const a = isHTMLElement(t);
    const u = a ? {} : t;
    const {elements: f} = u;
    const {padding: _, viewport: d, content: p} = f || {};
    const v = a ? t : u.target;
    const g = isBodyElement(v);
    const h = v.ownerDocument;
    const b = h.documentElement;
    const getDocumentWindow = () => h.defaultView || n$1;
    const w = bind(staticInitializationElement, [ v ]);
    const y = bind(dynamicInitializationElement, [ v ]);
    const S = bind(createDiv, "");
    const C = bind(w, S, i);
    const $ = bind(y, S, l);
    const elementHasOverflow = t => {
      const n = I(t);
      const o = D(t);
      const s = getStyles(t, m);
      const e = getStyles(t, O);
      return o.w - n.w > 0 && !overflowIsVisible(s) || o.h - n.h > 0 && !overflowIsVisible(e);
    };
    const x = C(d);
    const H = x === v;
    const E = H && g;
    const z = !H && $(p);
    const T = !H && x === z;
    const A = E ? b : x;
    const M = E ? A : v;
    const k = !H && y(S, r, _);
    const R = !T && z;
    const V = [ R, A, k, M ].map((t => isHTMLElement(t) && !parent(t) && t));
    const elementIsGenerated = t => t && inArray(V, t);
    const L = !elementIsGenerated(A) && elementHasOverflow(A) ? A : v;
    const U = E ? b : A;
    const N = E ? h : A;
    const X = {
      dt: v,
      vt: M,
      L: A,
      rn: k,
      ht: R,
      gt: U,
      Kt: N,
      ln: g ? b : L,
      Gt: h,
      bt: g,
      At: a,
      V: H,
      an: getDocumentWindow,
      wt: t => hasAttrClass(A, j, t),
      yt: (t, n) => addRemoveAttrClass(A, j, t, n),
      St: () => addRemoveAttrClass(U, j, G, true)
    };
    const {dt: Y, vt: W, rn: J, L: Q, ht: nt} = X;
    const ot = [ () => {
      removeAttrs(W, [ B, P ]);
      removeAttrs(Y, P);
      if (g) {
        removeAttrs(b, [ P, B ]);
      }
    } ];
    let st = contents([ nt, Q, J, W, Y ].find((t => t && !elementIsGenerated(t))));
    const et = E ? Y : nt || Q;
    const ct = bind(runEachAndClear, ot);
    const appendElements = () => {
      const t = getDocumentWindow();
      const n = getFocusedElement();
      const unwrap = t => {
        appendChildren(parent(t), contents(t));
        removeElements(t);
      };
      const prepareWrapUnwrapFocus = t => addEventListener(t, "focusin focusout focus blur", stopAndPrevent, {
        I: true,
        T: false
      });
      const o = "tabindex";
      const s = getAttr(Q, o);
      const c = prepareWrapUnwrapFocus(n);
      setAttrs(W, B, H ? "" : F);
      setAttrs(J, Z, "");
      setAttrs(Q, j, "");
      setAttrs(nt, tt, "");
      if (!H) {
        setAttrs(Q, o, s || "-1");
        if (g) {
          setAttrs(b, q, "");
        }
      }
      appendChildren(et, st);
      appendChildren(W, J);
      appendChildren(J || W, !H && Q);
      appendChildren(Q, nt);
      push$1(ot, [ c, () => {
        const t = getFocusedElement();
        const n = elementIsGenerated(Q);
        const e = n && t === Q ? Y : t;
        const c = prepareWrapUnwrapFocus(e);
        removeAttrs(J, Z);
        removeAttrs(nt, tt);
        removeAttrs(Q, j);
        if (g) {
          removeAttrs(b, q);
        }
        if (s) {
          setAttrs(Q, o, s);
        } else {
          removeAttrs(Q, o);
        }
        if (elementIsGenerated(nt)) {
          unwrap(nt);
        }
        if (n) {
          unwrap(Q);
        }
        if (elementIsGenerated(J)) {
          unwrap(J);
        }
        focusElement(e);
        c();
      } ]);
      if (e && !H) {
        addAttrClass(Q, j, K);
        push$1(ot, bind(removeAttrs, Q, j));
      }
      focusElement(!H && g && n === Y && t.top === t ? Q : n);
      c();
      st = 0;
      return ct;
    };
    return [ X, appendElements, ct ];
  };

  const createTrinsicUpdateSegment = ({ht: t}) => ({Qt: n, un: o, It: s}) => {
    const {$t: e} = n || {};
    const {Ot: c} = o;
    const r = t && (e || s);
    if (r) {
      setStyles(t, {
        [$]: c && "100%"
      });
    }
  };

  const createPaddingUpdateSegment = ({vt: t, rn: n, L: o, V: s}, e) => {
    const [c, r] = createCache({
      i: equalTRBL,
      o: topRightBottomLeft()
    }, bind(topRightBottomLeft, t, "padding", ""));
    return ({zt: t, Qt: i, un: l, It: a}) => {
      let [u, f] = r(a);
      const {U: _} = getEnvironment();
      const {_t: d, xt: p, Ct: m} = i || {};
      const {B: O} = l;
      const [$, x] = t("paddingAbsolute");
      const H = a || p;
      if (d || f || H) {
        [u, f] = c(a);
      }
      const E = !s && (x || m || f);
      if (E) {
        const t = !$ || !n && !_;
        const s = u.r + u.l;
        const c = u.t + u.b;
        const r = {
          [y]: t && !O ? -s : 0,
          [S]: t ? -c : 0,
          [w]: t && O ? -s : 0,
          top: t ? -u.t : 0,
          right: t ? O ? -u.r : "auto" : 0,
          left: t ? O ? "auto" : -u.l : 0,
          [C]: t && `calc(100% + ${s}px)`
        };
        const i = {
          [v]: t ? u.t : 0,
          [g]: t ? u.r : 0,
          [b]: t ? u.b : 0,
          [h]: t ? u.l : 0
        };
        setStyles(n || o, r);
        setStyles(o, i);
        assignDeep(e, {
          rn: u,
          fn: !t,
          F: n ? i : assignDeep({}, r, i)
        });
      }
      return {
        _n: E
      };
    };
  };

  const createOverflowUpdateSegment = (t, s) => {
    const e = getEnvironment();
    const {vt: c, rn: r, L: i, V: a, Kt: u, gt: f, bt: _, yt: d, an: p} = t;
    const {U: v} = e;
    const g = _ && a;
    const h = bind(o$1, 0);
    const b = {
      display: () => false,
      direction: t => t !== "ltr",
      flexDirection: t => t.endsWith("-reverse"),
      writingMode: t => t !== "horizontal-tb"
    };
    const w = keys$1(b);
    const y = {
      i: equalWH,
      o: {
        w: 0,
        h: 0
      }
    };
    const S = {
      i: equalXY,
      o: {}
    };
    const setMeasuringMode = t => {
      d(J, !g && t);
    };
    const getMeasuredScrollCoordinates = t => {
      const n = w.some((n => {
        const o = t[n];
        return o && b[n](o);
      }));
      if (!n) {
        return {
          D: {
            x: 0,
            y: 0
          },
          M: {
            x: 1,
            y: 1
          }
        };
      }
      setMeasuringMode(true);
      const o = getElementScroll(f);
      const s = d(Q, true);
      const e = addEventListener(u, E, (t => {
        const n = getElementScroll(f);
        if (t.isTrusted && n.x === o.x && n.y === o.y) {
          stopPropagation(t);
        }
      }), {
        I: true,
        A: true
      });
      scrollElementTo(f, {
        x: 0,
        y: 0
      });
      s();
      const c = getElementScroll(f);
      const r = D(f);
      scrollElementTo(f, {
        x: r.w,
        y: r.h
      });
      const i = getElementScroll(f);
      scrollElementTo(f, {
        x: i.x - c.x < 1 && -r.w,
        y: i.y - c.y < 1 && -r.h
      });
      const a = getElementScroll(f);
      scrollElementTo(f, o);
      l$1((() => e()));
      return {
        D: c,
        M: a
      };
    };
    const getOverflowAmount = (t, o) => {
      const s = n$1.devicePixelRatio % 1 !== 0 ? 1 : 0;
      const e = {
        w: h(t.w - o.w),
        h: h(t.h - o.h)
      };
      return {
        w: e.w > s ? e.w : 0,
        h: e.h > s ? e.h : 0
      };
    };
    const getViewportOverflowStyle = (t, n) => {
      const getAxisOverflowStyle = (t, n, o, s) => {
        const e = t === x ? H : overflowBehaviorToOverflowStyle(t);
        const c = overflowIsVisible(t);
        const r = overflowIsVisible(o);
        if (!n && !s) {
          return H;
        }
        if (c && r) {
          return x;
        }
        if (c) {
          const t = n ? x : H;
          return n && s ? e : t;
        }
        const i = r && s ? x : H;
        return n ? e : i;
      };
      return {
        x: getAxisOverflowStyle(n.x, t.x, n.y, t.y),
        y: getAxisOverflowStyle(n.y, t.y, n.x, t.x)
      };
    };
    const setViewportOverflowStyle = t => {
      const createAllOverflowStyleClassNames = t => [ x, H, E ].map((n => createViewportOverflowStyleClassName(overflowCssValueToOverflowStyle(n), t)));
      const n = createAllOverflowStyleClassNames(true).concat(createAllOverflowStyleClassNames()).join(" ");
      d(n);
      d(keys$1(t).map((n => createViewportOverflowStyleClassName(t[n], n === "x"))).join(" "), true);
    };
    const [m, O] = createCache(y, bind(getFractionalSize, i));
    const [C, $] = createCache(y, bind(D, i));
    const [z, T] = createCache(y);
    const [I] = createCache(S);
    const [M, k] = createCache(y);
    const [R] = createCache(S);
    const [V] = createCache({
      i: (t, n) => equal(t, n, w),
      o: {}
    }, (() => hasDimensions(i) ? getStyles(i, w) : {}));
    const [L, U] = createCache({
      i: (t, n) => equalXY(t.D, n.D) && equalXY(t.M, n.M),
      o: getZeroScrollCoordinates()
    });
    const P = getStaticPluginModuleInstance(xt);
    const createViewportOverflowStyleClassName = (t, n) => {
      const o = n ? X : Y;
      return `${o}${capitalizeFirstLetter(t)}`;
    };
    return ({zt: n, Qt: o, un: l, It: a}, {_n: u}) => {
      const {_t: f, Ht: _, xt: b, Ct: w, ft: y, Et: S} = o || {};
      const x = P && P.R(t, s, l, e, n);
      const {X: H, Y: E, W: D} = x || {};
      const [q, F] = getShowNativeOverlaidScrollbars(n, e);
      const [j, X] = n("overflow");
      const Y = overflowIsVisible(j.x);
      const W = overflowIsVisible(j.y);
      const J = f || u || b || w || S || F;
      let G = O(a);
      let Q = $(a);
      let tt = T(a);
      let nt = k(a);
      if (F && v) {
        d(K, !q);
      }
      if (J) {
        if (hasAttrClass(c, B, N)) {
          setMeasuringMode(true);
        }
        const t = E && E();
        const [n] = G = m(a);
        const [o] = Q = C(a);
        const s = A(i);
        const e = g && getWindowSize(p());
        const r = {
          w: h(o.w + n.w),
          h: h(o.h + n.h)
        };
        const l = {
          w: h((e ? e.w : s.w + h(s.w - o.w)) + n.w),
          h: h((e ? e.h : s.h + h(s.h - o.h)) + n.h)
        };
        if (t) {
          t();
        }
        nt = M(l);
        tt = z(getOverflowAmount(r, l), a);
      }
      const [ot, st] = nt;
      const [et, ct] = tt;
      const [rt, it] = Q;
      const [lt, at] = G;
      const [ut, ft] = I({
        x: et.w > 0,
        y: et.h > 0
      });
      const _t = Y && W && (ut.x || ut.y) || Y && ut.x && !ut.y || W && ut.y && !ut.x;
      const dt = u || w || S || at || it || st || ct || X || F || J || _ && g;
      const [pt, vt] = V(a);
      const gt = w || y || vt || ft || a;
      const [ht, bt] = gt ? L(getMeasuredScrollCoordinates(pt), a) : U();
      let wt = getViewportOverflowStyle(ut, j);
      setMeasuringMode(false);
      if (dt) {
        setViewportOverflowStyle(wt);
        wt = getElementOverflowStyle(i, ut);
        if (D && H) {
          H(wt, rt, lt);
          setStyles(i, D(wt));
        }
      }
      const [yt, St] = R(wt);
      addRemoveAttrClass(c, B, N, _t);
      addRemoveAttrClass(r, Z, N, _t);
      assignDeep(s, {
        cn: yt,
        Vt: {
          x: ot.w,
          y: ot.h
        },
        Rt: {
          x: et.w,
          y: et.h
        },
        j: ut,
        Dt: sanitizeScrollCoordinates(ht, et)
      });
      return {
        sn: St,
        tn: st,
        nn: ct,
        en: bt || ct
      };
    };
  };

  const createStructureSetup = t => {
    const [n, o, s] = createStructureSetupElements(t);
    const e = {
      rn: {
        t: 0,
        r: 0,
        b: 0,
        l: 0
      },
      fn: false,
      F: {
        [y]: 0,
        [S]: 0,
        [w]: 0,
        [v]: 0,
        [g]: 0,
        [b]: 0,
        [h]: 0
      },
      Vt: {
        x: 0,
        y: 0
      },
      Rt: {
        x: 0,
        y: 0
      },
      cn: {
        x: H,
        y: H
      },
      j: {
        x: false,
        y: false
      },
      Dt: getZeroScrollCoordinates()
    };
    const {dt: c, gt: r, V: i, St: l} = n;
    const {U: a, k: u} = getEnvironment();
    const f = !a && (u.x || u.y);
    const _ = [ createTrinsicUpdateSegment(n), createPaddingUpdateSegment(n, e), createOverflowUpdateSegment(n, e) ];
    return [ o, t => {
      const n = {};
      const o = f;
      const s = o && getElementScroll(r);
      const e = s && l();
      each(_, (o => {
        assignDeep(n, o(t, n) || {});
      }));
      scrollElementTo(r, s);
      if (e) {
        e();
      }
      if (!i) {
        scrollElementTo(c, 0);
      }
      return n;
    }, e, n, s ];
  };

  const createSetups = (t, n, o, s, e) => {
    let c = false;
    const r = createOptionCheck(n, {});
    const [i, l, a, u, f] = createStructureSetup(t);
    const [_, d, p] = createObserversSetup(u, a, r, (t => {
      update({}, t);
    }));
    const [v, g, , h] = createScrollbarsSetup(t, n, p, a, u, e);
    const updateHintsAreTruthy = t => keys$1(t).some((n => !!t[n]));
    const update = (t, e) => {
      if (o()) {
        return false;
      }
      const {dn: r, It: i, Tt: a, pn: u} = t;
      const f = r || {};
      const _ = !!i || !c;
      const v = {
        zt: createOptionCheck(n, f, _),
        dn: f,
        It: _
      };
      if (u) {
        g(v);
        return false;
      }
      const h = e || d(assignDeep({}, v, {
        Tt: a
      }));
      const b = l(assignDeep({}, v, {
        un: p,
        Qt: h
      }));
      g(assignDeep({}, v, {
        Qt: h,
        Zt: b
      }));
      const w = updateHintsAreTruthy(h);
      const y = updateHintsAreTruthy(b);
      const S = w || y || !isEmptyObject(f) || _;
      c = true;
      if (S) {
        s(t, {
          Qt: h,
          Zt: b
        });
      }
      return S;
    };
    return [ () => {
      const {ln: t, gt: n, St: o} = u;
      const s = getElementScroll(t);
      const e = [ _(), i(), v() ];
      const c = o();
      scrollElementTo(n, s);
      c();
      return bind(runEachAndClear, e);
    }, update, () => ({
      vn: p,
      gn: a
    }), {
      hn: u,
      bn: h
    }, f ];
  };

  const Mt = new WeakMap;

  const addInstance = (t, n) => {
    Mt.set(t, n);
  };

  const removeInstance = t => {
    Mt.delete(t);
  };

  const getInstance = t => Mt.get(t);

  const OverlayScrollbars = (t, n, o) => {
    const {tt: s} = getEnvironment();
    const e = isHTMLElement(t);
    const c = e ? t : t.target;
    const r = getInstance(c);
    if (n && !r) {
      let r = false;
      const i = [];
      const l = {};
      const validateOptions = t => {
        const n = removeUndefinedProperties(t);
        const o = getStaticPluginModuleInstance(R);
        return o ? o(n, true) : n;
      };
      const a = assignDeep({}, s(), validateOptions(n));
      const [u, f, _] = createEventListenerHub();
      const [d, p, v] = createEventListenerHub(o);
      const triggerEvent = (t, n) => {
        v(t, n);
        _(t, n);
      };
      const [g, h, b, w, y] = createSetups(t, a, (() => r), (({dn: t, It: n}, {Qt: o, Zt: s}) => {
        const {_t: e, Ct: c, $t: r, xt: i, Ht: l, ft: a} = o;
        const {tn: u, nn: f, sn: _, en: d} = s;
        triggerEvent("updated", [ S, {
          updateHints: {
            sizeChanged: !!e,
            directionChanged: !!c,
            heightIntrinsicChanged: !!r,
            overflowEdgeChanged: !!u,
            overflowAmountChanged: !!f,
            overflowStyleChanged: !!_,
            scrollCoordinatesChanged: !!d,
            contentMutation: !!i,
            hostMutation: !!l,
            appear: !!a
          },
          changedOptions: t || {},
          force: !!n
        } ]);
      }), (t => triggerEvent("scroll", [ S, t ])));
      const destroy = t => {
        removeInstance(c);
        runEachAndClear(i);
        r = true;
        triggerEvent("destroyed", [ S, t ]);
        f();
        p();
      };
      const S = {
        options(t, n) {
          if (t) {
            const o = n ? s() : {};
            const e = getOptionsDiff(a, assignDeep(o, validateOptions(t)));
            if (!isEmptyObject(e)) {
              assignDeep(a, e);
              h({
                dn: e
              });
            }
          }
          return assignDeep({}, a);
        },
        on: d,
        off: (t, n) => {
          if (t && n) {
            p(t, n);
          }
        },
        state() {
          const {vn: t, gn: n} = b();
          const {B: o} = t;
          const {Vt: s, Rt: e, cn: c, j: i, rn: l, fn: a, Dt: u} = n;
          return assignDeep({}, {
            overflowEdge: s,
            overflowAmount: e,
            overflowStyle: c,
            hasOverflow: i,
            scrollCoordinates: {
              start: u.D,
              end: u.M
            },
            padding: l,
            paddingAbsolute: a,
            directionRTL: o,
            destroyed: r
          });
        },
        elements() {
          const {dt: t, vt: n, rn: o, L: s, ht: e, gt: c, Kt: r} = w.hn;
          const {jt: i, Jt: l} = w.bn;
          const translateScrollbarStructure = t => {
            const {Mt: n, Ut: o, Lt: s} = t;
            return {
              scrollbar: s,
              track: o,
              handle: n
            };
          };
          const translateScrollbarsSetupElement = t => {
            const {Xt: n, Yt: o} = t;
            const s = translateScrollbarStructure(n[0]);
            return assignDeep({}, s, {
              clone: () => {
                const t = translateScrollbarStructure(o());
                h({
                  pn: true
                });
                return t;
              }
            });
          };
          return assignDeep({}, {
            target: t,
            host: n,
            padding: o || s,
            viewport: s,
            content: e || s,
            scrollOffsetElement: c,
            scrollEventElement: r,
            scrollbarHorizontal: translateScrollbarsSetupElement(i),
            scrollbarVertical: translateScrollbarsSetupElement(l)
          });
        },
        update: t => h({
          It: t,
          Tt: true
        }),
        destroy: bind(destroy, false),
        plugin: t => l[keys$1(t)[0]]
      };
      push$1(i, [ y ]);
      addInstance(c, S);
      registerPluginModuleInstances(M, OverlayScrollbars, [ S, u, l ]);
      if (cancelInitialization(w.hn.bt, !e && t.cancel)) {
        destroy(true);
        return S;
      }
      push$1(i, g());
      triggerEvent("initialized", [ S ]);
      S.update();
      return S;
    }
    return r;
  };

  OverlayScrollbars.plugin = t => {
    const n = isArray$1(t);
    const o = n ? t : [ t ];
    const s = o.map((t => registerPluginModuleInstances(t, OverlayScrollbars)[0]));
    addPlugins(o);
    return n ? s : s[0];
  };

  OverlayScrollbars.valid = t => {
    const n = t && t.elements;
    const o = isFunction(n) && n();
    return isPlainObject(o) && !!getInstance(o.target);
  };

  OverlayScrollbars.env = () => {
    const {P: t, k: n, U: o, J: s, ot: e, st: c, K: r, Z: i, tt: l, nt: a} = getEnvironment();
    return assignDeep({}, {
      scrollbarsSize: t,
      scrollbarsOverlaid: n,
      scrollbarsHiding: o,
      scrollTimeline: s,
      staticDefaultInitialization: e,
      staticDefaultOptions: c,
      getDefaultInitialization: r,
      setDefaultInitialization: i,
      getDefaultOptions: l,
      setDefaultOptions: a
    });
  };

  OverlayScrollbars.nonce = setNonce;

  OverlayScrollbars.trustedTypePolicy = setTrustedTypePolicy;

  /*
   * common
   * 
   */
  var common$1 = /*#__PURE__*/function () {
    function common() {
      _classCallCheck(this, common);
      gsapWithCSS.registerPlugin(ScrollTrigger$1);
      // barba.hooks.beforeOnce((data) => {
      //     console.log('once')
      //     this.load();
      // })
      // barba.hooks.after((data) => {
      //     console.log('after')
      //     this.load();
      // });
    }
    return _createClass$1(common, [{
      key: "load",
      value: function load() {
        console.log('load');
        OverlayScrollbars(document.querySelector('body'), {
          showNativeOverlaidScrollbars: true
        });
        this.loader();
        this.scrollEvent();
        this.setDeviceClassToBody();
        this.globalMenu();
        this.smoothScroll();
        this.cMouseStalker();
        this.jsSplitText();
        this.jsClone();
        this.jsStickySection();
        this.jsAccordion();
        this.isSectionDark();
        this.isVisible();
        this.isVisibleSpan();
        this.isVisibleType();
      }
    }, {
      key: "reload",
      value: function reload() {}

      /*
       * loader()
       * 
       */
    }, {
      key: "loader",
      value: function loader() {
        var loadedClass = 'loadedLower';
        var classNameScroll = 'is-scrolled';
        var marginScrolled = 300;
        setTimeout(function () {
          document.body.classList.add(loadedClass);
        }, 500);
        var handleScroll = function handleScroll() {
          if (window.scrollY > marginScrolled) {
            document.body.classList.add(classNameScroll);
          } else {
            document.body.classList.remove(classNameScroll);
          }
        };
        window.addEventListener('scroll', handleScroll);
        window.addEventListener('resize', handleScroll);
        window.addEventListener('orientationchange', handleScroll);
      }

      /*
       * scrollEvent
       * 
       */
    }, {
      key: "scrollEvent",
      value: function scrollEvent() {
        var defPos = 0;
        var ticking = false;
        window.addEventListener('scroll', function () {
          if (!ticking) {
            ticking = true;
            requestAnimationFrame(function () {
              addBodyScrollClass();
              ticking = false;
            });
          }
        });
        function addBodyScrollClass() {
          var currentPos = window.scrollY;
          if (currentPos > defPos) {
            if (currentPos >= 200) {
              document.body.classList.add('scrollDown');
              document.body.classList.remove('scrollUp');
            }
          } else {
            document.body.classList.remove('scrollDown');
            document.body.classList.add('scrollUp');
          }
          defPos = currentPos;
        }

        // footerScrollTrigger
        var footer = document.querySelector('.l-footer');
        if (footer) {
          ScrollTrigger$1.create({
            trigger: footer,
            start: 'top bottom',
            onEnter: function onEnter() {
              return document.body.classList.add('is-footer-show');
            },
            onLeaveBack: function onLeaveBack() {
              return document.body.classList.remove('is-footer-show');
            }
          });
        }
      }

      /*
       * globalMenu
       * 
       */
    }, {
      key: "globalMenu",
      value: function globalMenu() {
        var classNameNavOpen = 'is-nav-open';
        var classNameNavClose = 'is-nav-closing';
        var header = document.querySelector('.l-header');
        var headerMenu = document.querySelector('.l-header-menu');
        if (!header || !headerMenu) return;
        headerMenu.addEventListener('click', function () {
          headerMenu.classList.toggle(classNameNavOpen);
          if (headerMenu.classList.contains(classNameNavOpen)) {
            document.body.classList.add(classNameNavOpen);
          } else {
            navClose();
          }
        });
        var headerLinks = header.querySelectorAll('a');
        headerLinks.forEach(function (link) {
          link.addEventListener('click', function () {
            headerMenu.classList.remove(classNameNavOpen);
            navClose();
          });
        });

        // 
        function navClose() {
          document.body.classList.remove(classNameNavOpen);
          document.body.classList.add(classNameNavClose);
          setTimeout(function () {
            document.body.classList.remove(classNameNavClose);
          }, 600);
        }

        // Esc
        window.addEventListener('keydown', function (event) {
          if (event.key === 'Escape' || event.keyCode === 27) {
            headerMenu.classList.remove(classNameNavOpen);
            navClose();
          }
        });

        // 
        var formSearch = document.querySelector('.l-header-drawer__search .c-form-search');
        var button = document.querySelector('.l-header-drawer__search .c-form-search__btn');
        if (!Utility.isPC()) {
          button.addEventListener('click', function (e) {
            if (!formSearch.classList.contains('is-show')) {
              e.preventDefault();
              formSearch.classList.add('is-show');
            }
          });
        }
      }

      /*
       * smoothScroll
       * 
       */
    }, {
      key: "smoothScroll",
      value: function smoothScroll() {
        var anchors = document.querySelectorAll('a[data-scroll-anchor]:not(.noscroll)');
        anchors.forEach(function (anchor) {
          anchor.addEventListener('click', function (e) {
            e.preventDefault();
            var href = anchor.getAttribute('href');
            var index = href.indexOf('#');
            if (index === -1) return;
            var targetSelector = href.slice(index);
            var target = document.querySelector(targetSelector);
            if (!target) return;
            var targetPos = target.getBoundingClientRect().top + window.pageYOffset;
            var currentScroll = window.pageYOffset;
            var scroll = Math.abs(currentScroll - targetPos);
            var duration = 0.7 * scroll;
            if (duration > 300) {
              duration = 300;
            }

            // 
            window.scrollTo({
              top: targetPos,
              behavior: 'smooth'
            });

            // URL
            setTimeout(function () {
              history.pushState(null, '', href);
            }, duration);
          });
        });
      }
    }, {
      key: "cMouseStalker",
      value: function cMouseStalker() {
        var btn = document.querySelector('.l-aside-stalker .c-btn-stalker');
        var stalkerTriggers = document.querySelectorAll('.js-stalker-show, a[class^="c-card"]');
        if (btn && ScrollTrigger$1.isTouch !== 1) {
          var xTo = gsapWithCSS.quickTo(btn, "x", {
            duration: 0.3,
            ease: "power2.out"
          });
          var yTo = gsapWithCSS.quickTo(btn, "y", {
            duration: 0.3,
            ease: "power2.out"
          });
          document.addEventListener('mousemove', function (e) {
            var shift = btn.offsetWidth / 2;
            xTo(e.clientX - shift);
            yTo(e.clientY - shift);
          });

          // document.addEventListener('mousemove', (e) => {
          //     const shift = btn.offsetWidth / 2;
          //
          //     gsap.to(btn, {
          //         x: e.clientX - shift,
          //         y: e.clientY - shift,
          //         ease: 'power1.out',
          //         delay: 0.005,
          //     });
          // });

          stalkerTriggers.forEach(function (trigger) {
            trigger.addEventListener('mouseover', function () {
              btn.classList.add('on-stalker-show');
            });
            trigger.addEventListener('mouseout', function () {
              btn.classList.remove('on-stalker-show');
            });
          });
        }
      }
    }, {
      key: "jsClone",
      value: function jsClone() {
        var elements = document.querySelectorAll('.js-clone');
        elements.forEach(function (el) {
          // data-clone-num 
          var cloneNum = parseInt(el.dataset.cloneNum, 10) || 1;
          for (var i = 0; i < cloneNum; i++) {
            var clone = el.cloneNode(true);
            clone.setAttribute('aria-hidden', 'true');
            el.parentNode.insertBefore(clone, el.nextSibling);
          }
        });
      }
    }, {
      key: "jsSplitText",
      value: function jsSplitText() {
        var domList = document.querySelectorAll('.js-split-text');
        if (domList.length) {
          domList.forEach(function (el) {
            Utility.convertSpiltSpan(el);
          });
        }
      }
    }, {
      key: "jsStickySection",
      value: function jsStickySection() {
        var container = document.querySelector('.js-sticky-section');
        var pin = document.querySelector('.js-sticky-section__aside');
        var asideLis = document.querySelectorAll('.js-sticky-section__aside li');
        var sections = document.querySelectorAll('.js-sticky-section__content section');
        if (container && pin && Utility.isPC()) {
          window.addEventListener('load', function () {
            // sticky
            var pinUl = pin.querySelector('ul');
            var pinHeight = pinUl ? pinUl.offsetHeight : 0;
            ScrollTrigger$1.create({
              trigger: container,
              start: 'top top+=160px',
              end: "bottom top+=".concat(pinHeight),
              pin: pin,
              pinSpacing: false,
              markers: false
            });

            // 
            sections.forEach(function (section, index) {
              ScrollTrigger$1.create({
                trigger: section,
                start: 'top top+=160px',
                end: 'bottom top+=160px',
                markers: false,
                onEnter: function onEnter() {
                  asideLis.forEach(function (li) {
                    return li.classList.remove('is-current');
                  });
                  if (asideLis[index]) {
                    asideLis[index].classList.add('is-current');
                  }
                },
                onEnterBack: function onEnterBack() {
                  asideLis.forEach(function (li) {
                    return li.classList.remove('is-current');
                  });
                  if (asideLis[index]) {
                    asideLis[index].classList.add('is-current');
                  }
                }
              });
            });
          });
        }
      }
    }, {
      key: "jsAccordion",
      value: function jsAccordion() {
        // vars
        var btn = '.js-accordion';

        // functions
        if ($$1(btn).length) {
          $$1(btn).on('click', function (e) {
            e.preventDefault();
            var isFlex = $$1(this).attr('data-accordion-flex') ? true : false;
            $$1(this).toggleClass('is-open');
            if ($$1(this).hasClass('is-open')) {
              if (isFlex) {
                $$1(this).next().stop(0, 0).slideDown({
                  start: function start() {
                    $$1(this).css({
                      display: "flex"
                    });
                  }
                });
              } else {
                $$1(this).next().stop(0, 0).slideDown();
              }
            } else {
              $$1(this).next().stop(0, 0).slideUp();
            }
          });
        }
      }
    }, {
      key: "isSectionDark",
      value: function isSectionDark() {
        var shift = Utility.isPC() ? 100 / 1440 * window.innerWidth / 2 : 75 / 390 * window.innerWidth / 2;
        document.querySelectorAll('.is-section-dark:not(.l-header-drawer)').forEach(function (section) {
          ScrollTrigger$1.create({
            trigger: section,
            start: "top-=".concat(shift, " top"),
            end: "bottom-=".concat(shift, " top"),
            markers: false,
            onEnter: function onEnter() {
              return document.body.classList.add('is-header-dark');
            },
            onLeave: function onLeave() {
              return document.body.classList.remove('is-header-dark');
            },
            onEnterBack: function onEnterBack() {
              return document.body.classList.add('is-header-dark');
            },
            onLeaveBack: function onLeaveBack() {
              return document.body.classList.remove('is-header-dark');
            }
          });
        });
      }
    }, {
      key: "isVisible",
      value: function isVisible() {
        var elements = document.querySelectorAll('.js-visible');
        elements.forEach(function (el) {
          ScrollTrigger$1.create({
            trigger: el,
            toggleClass: 'is-visible',
            start: 'top bottom-=20%',
            once: true
          });
        });
      }
    }, {
      key: "isVisibleSpan",
      value: function isVisibleSpan() {
        var domList = document.querySelectorAll('.js-visible-span');
        if (domList.length) {
          domList.forEach(function (el) {
            var spans = el.querySelectorAll('span');
            gsapWithCSS.set(spans, {
              opacity: 0,
              y: 10
            });
            gsapWithCSS.set(el, {
              opacity: 1
            });
            gsapWithCSS.to(spans, {
              scrollTrigger: {
                trigger: el,
                start: 'top bottom-=20%'
              },
              delay: 0.5,
              opacity: 1,
              stagger: {
                each: 0.01,
                from: "random"
              },
              ease: 'power3.out'
            });
          });
        }
      }
    }, {
      key: "isVisibleType",
      value: function isVisibleType() {
        var domList = document.querySelectorAll('.js-visible-type');
        if (domList.length) {
          domList.forEach(function (el) {
            Utility.convertSpiltSpan(el);
          });
          domList.forEach(function (el) {
            var spans = el.querySelectorAll('span');
            gsapWithCSS.set(spans, {
              opacity: 0,
              y: '20%'
            });
            gsapWithCSS.to(spans, {
              scrollTrigger: {
                trigger: el,
                start: 'top bottom-=20%'
              },
              delay: 0.5,
              opacity: 1,
              y: '0%',
              stagger: 0.03,
              ease: 'power3.out' // typo 'poser3.out'  'power3.out'
            });
          });
        }
      }

      /*globalMenu
       * setDeviceClassToBody
       * 
       */
    }, {
      key: "setDeviceClassToBody",
      value: function setDeviceClassToBody() {
        var updateBodyClass = function updateBodyClass() {
          var body = document.body;
          body.classList.toggle('isSP', Utility.isSP());
          body.classList.toggle('isTAB', Utility.isTAB());
          body.classList.toggle('isPC', Utility.isPC());
        };

        // 
        window.addEventListener('load', updateBodyClass);
        window.addEventListener('resize', updateBodyClass);
        window.addEventListener('orientationchange', updateBodyClass);
      }
    }]);
  }();

  /*!
   * ScrollToPlugin 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */

  /* eslint-disable */
  var gsap$1,
      _coreInitted$1,
      _window,
      _docEl,
      _body,
      _toArray$1,
      _config,
      ScrollTrigger,
      _windowExists$1 = function _windowExists() {
    return typeof window !== "undefined";
  },
      _getGSAP$1 = function _getGSAP() {
    return gsap$1 || _windowExists$1() && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1;
  },
      _isString = function _isString(value) {
    return typeof value === "string";
  },
      _isFunction = function _isFunction(value) {
    return typeof value === "function";
  },
      _max = function _max(element, axis) {
    var dim = axis === "x" ? "Width" : "Height",
        scroll = "scroll" + dim,
        client = "client" + dim;
    return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];
  },
      _buildGetter = function _buildGetter(e, axis) {
    //pass in an element and an axis ("x" or "y") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.
    var p = "scroll" + (axis === "x" ? "Left" : "Top");

    if (e === _window) {
      if (e.pageXOffset != null) {
        p = "page" + axis.toUpperCase() + "Offset";
      } else {
        e = _docEl[p] != null ? _docEl : _body;
      }
    }

    return function () {
      return e[p];
    };
  },
      _clean = function _clean(value, index, target, targets) {
    _isFunction(value) && (value = value(index, target, targets));

    if (typeof value !== "object") {
      return _isString(value) && value !== "max" && value.charAt(1) !== "=" ? {
        x: value,
        y: value
      } : {
        y: value
      }; //if we don't receive an object as the parameter, assume the user intends "y".
    } else if (value.nodeType) {
      return {
        y: value,
        x: value
      };
    } else {
      var result = {},
          p;

      for (p in value) {
        result[p] = p !== "onAutoKill" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];
      }

      return result;
    }
  },
      _getOffset = function _getOffset(element, container) {
    element = _toArray$1(element)[0];

    if (!element || !element.getBoundingClientRect) {
      return console.warn("scrollTo target doesn't exist. Using 0") || {
        x: 0,
        y: 0
      };
    }

    var rect = element.getBoundingClientRect(),
        isRoot = !container || container === _window || container === _body,
        cRect = isRoot ? {
      top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),
      left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)
    } : container.getBoundingClientRect(),
        offsets = {
      x: rect.left - cRect.left,
      y: rect.top - cRect.top
    };

    if (!isRoot && container) {
      //only add the current scroll position if it's not the window/body.
      offsets.x += _buildGetter(container, "x")();
      offsets.y += _buildGetter(container, "y")();
    }

    return offsets;
  },
      _parseVal = function _parseVal(value, target, axis, currentVal, offset) {
    return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);
  },
      _initCore$1 = function _initCore() {
    gsap$1 = _getGSAP$1();

    if (_windowExists$1() && gsap$1 && typeof document !== "undefined" && document.body) {
      _window = window;
      _body = document.body;
      _docEl = document.documentElement;
      _toArray$1 = gsap$1.utils.toArray;
      gsap$1.config({
        autoKillThreshold: 7
      });
      _config = gsap$1.config();
      _coreInitted$1 = 1;
    }
  };

  var ScrollToPlugin = {
    version: "3.13.0",
    name: "scrollTo",
    rawVars: 1,
    register: function register(core) {
      gsap$1 = core;

      _initCore$1();
    },
    init: function init(target, value, tween, index, targets) {
      _coreInitted$1 || _initCore$1();
      var data = this,
          snapType = gsap$1.getProperty(target, "scrollSnapType");
      data.isWin = target === _window;
      data.target = target;
      data.tween = tween;
      value = _clean(value, index, target, targets);
      data.vars = value;
      data.autoKill = !!("autoKill" in value ? value : _config).autoKill;
      data.getX = _buildGetter(target, "x");
      data.getY = _buildGetter(target, "y");
      data.x = data.xPrev = data.getX();
      data.y = data.yPrev = data.getY();
      ScrollTrigger || (ScrollTrigger = gsap$1.core.globals().ScrollTrigger);
      gsap$1.getProperty(target, "scrollBehavior") === "smooth" && gsap$1.set(target, {
        scrollBehavior: "auto"
      });

      if (snapType && snapType !== "none") {
        // disable scroll snapping to avoid strange behavior
        data.snap = 1;
        data.snapInline = target.style.scrollSnapType;
        target.style.scrollSnapType = "none";
      }

      if (value.x != null) {
        data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);

        data._props.push("scrollTo_x");
      } else {
        data.skipX = 1;
      }

      if (value.y != null) {
        data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);

        data._props.push("scrollTo_y");
      } else {
        data.skipY = 1;
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt,
          target = data.target,
          tween = data.tween,
          autoKill = data.autoKill,
          xPrev = data.xPrev,
          yPrev = data.yPrev,
          isWin = data.isWin,
          snap = data.snap,
          snapInline = data.snapInline,
          x,
          y,
          yDif,
          xDif,
          threshold;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      x = isWin || !data.skipX ? data.getX() : xPrev;
      y = isWin || !data.skipY ? data.getY() : yPrev;
      yDif = y - yPrev;
      xDif = x - xPrev;
      threshold = _config.autoKillThreshold;

      if (data.x < 0) {
        //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)
        data.x = 0;
      }

      if (data.y < 0) {
        data.y = 0;
      }

      if (autoKill) {
        //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.
        if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
          data.skipX = 1; //if the user scrolls separately, we should stop tweening!
        }

        if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
          data.skipY = 1; //if the user scrolls separately, we should stop tweening!
        }

        if (data.skipX && data.skipY) {
          tween.kill();
          data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
        }
      }

      if (isWin) {
        _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);
      } else {
        data.skipY || (target.scrollTop = data.y);
        data.skipX || (target.scrollLeft = data.x);
      }

      if (snap && (ratio === 1 || ratio === 0)) {
        y = target.scrollTop;
        x = target.scrollLeft;
        snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
        target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.

        target.scrollLeft = x + 1;
        target.scrollTop = y;
        target.scrollLeft = x;
      }

      data.xPrev = data.x;
      data.yPrev = data.y;
      ScrollTrigger && ScrollTrigger.update();
    },
    kill: function kill(property) {
      var both = property === "scrollTo",
          i = this._props.indexOf(property);

      if (both || property === "scrollTo_x") {
        this.skipX = 1;
      }

      if (both || property === "scrollTo_y") {
        this.skipY = 1;
      }

      i > -1 && this._props.splice(i, 1);
      return !this._props.length;
    }
  };
  ScrollToPlugin.max = _max;
  ScrollToPlugin.getOffset = _getOffset;
  ScrollToPlugin.buildGetter = _buildGetter;

  ScrollToPlugin.config = function (vars) {
    _config || _initCore$1() || (_config = gsap$1.config()); // in case the window hasn't been defined yet.

    for (var p in vars) {
      _config[p] = vars[p];
    }
  };

  _getGSAP$1() && gsap$1.registerPlugin(ScrollToPlugin);

  /*!
   * DrawSVGPlugin 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  */

  /* eslint-disable */
  var gsap,
      _toArray,
      _win,
      _isEdge,
      _coreInitted,
      _warned,
      _getStyleSaver,
      _reverting,
      _windowExists = function _windowExists() {
    return typeof window !== "undefined";
  },
      _getGSAP = function _getGSAP() {
    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
  },
      _numExp = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
      //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
  _types = {
    rect: ["width", "height"],
    circle: ["r", "r"],
    ellipse: ["rx", "ry"],
    line: ["x2", "y2"]
  },
      _round = function _round(value) {
    return Math.round(value * 10000) / 10000;
  },
      _parseNum = function _parseNum(value) {
    return parseFloat(value) || 0;
  },
      _parseSingleVal = function _parseSingleVal(value, length) {
    var num = _parseNum(value);

    return ~value.indexOf("%") ? num / 100 * length : num;
  },
      _getAttributeAsNumber = function _getAttributeAsNumber(target, attr) {
    return _parseNum(target.getAttribute(attr));
  },
      _sqrt = Math.sqrt,
      _getDistance = function _getDistance(x1, y1, x2, y2, scaleX, scaleY) {
    return _sqrt(Math.pow((_parseNum(x2) - _parseNum(x1)) * scaleX, 2) + Math.pow((_parseNum(y2) - _parseNum(y1)) * scaleY, 2));
  },
      _warn = function _warn(message) {
    return console.warn(message);
  },
      _hasNonScalingStroke = function _hasNonScalingStroke(target) {
    return target.getAttribute("vector-effect") === "non-scaling-stroke";
  },
      _bonusValidated = 1,
      //<name>DrawSVGPlugin</name>
  //accepts values like "100%" or "20% 80%" or "20 50" and parses it into an absolute start and end position on the line/stroke based on its length. Returns an an array with the start and end values, like [0, 243]
  _parse = function _parse(value, length, defaultStart) {
    var i = value.indexOf(" "),
        s,
        e;

    if (i < 0) {
      s = defaultStart !== undefined ? defaultStart + "" : value;
      e = value;
    } else {
      s = value.substr(0, i);
      e = value.substr(i + 1);
    }

    s = _parseSingleVal(s, length);
    e = _parseSingleVal(e, length);
    return s > e ? [e, s] : [s, e];
  },
      _getLength = function _getLength(target) {
    target = _toArray(target)[0];

    if (!target) {
      return 0;
    }

    var type = target.tagName.toLowerCase(),
        style = target.style,
        scaleX = 1,
        scaleY = 1,
        length,
        bbox,
        points,
        prevPoint,
        i,
        rx,
        ry;

    if (_hasNonScalingStroke(target)) {
      //non-scaling-stroke basically scales the shape and then strokes it at the screen-level (after transforms), thus we need to adjust the length accordingly.
      scaleY = target.getScreenCTM();
      scaleX = _sqrt(scaleY.a * scaleY.a + scaleY.b * scaleY.b);
      scaleY = _sqrt(scaleY.d * scaleY.d + scaleY.c * scaleY.c);
    }

    try {
      //IE bug: calling <path>.getTotalLength() locks the repaint area of the stroke to whatever its current dimensions are on that frame/tick. To work around that, we must call getBBox() to force IE to recalculate things.
      bbox = target.getBBox(); //solely for fixing bug in IE - we don't actually use the bbox.
    } catch (e) {
      //firefox has a bug that throws an error if the element isn't visible.
      _warn("Some browsers won't measure invisible elements (like display:none or masks inside defs).");
    }

    var _ref = bbox || {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
        x = _ref.x,
        y = _ref.y,
        width = _ref.width,
        height = _ref.height;

    if ((!bbox || !width && !height) && _types[type]) {
      //if the element isn't visible, try to discern width/height using its attributes.
      width = _getAttributeAsNumber(target, _types[type][0]);
      height = _getAttributeAsNumber(target, _types[type][1]);

      if (type !== "rect" && type !== "line") {
        //double the radius for circles and ellipses
        width *= 2;
        height *= 2;
      }

      if (type === "line") {
        x = _getAttributeAsNumber(target, "x1");
        y = _getAttributeAsNumber(target, "y1");
        width = Math.abs(width - x);
        height = Math.abs(height - y);
      }
    }

    if (type === "path") {
      prevPoint = style.strokeDasharray;
      style.strokeDasharray = "none";
      length = target.getTotalLength() || 0;
      _round(scaleX) !== _round(scaleY) && !_warned && (_warned = 1) && _warn("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled.");
      length *= (scaleX + scaleY) / 2;
      style.strokeDasharray = prevPoint;
    } else if (type === "rect") {
      length = width * 2 * scaleX + height * 2 * scaleY;
    } else if (type === "line") {
      length = _getDistance(x, y, x + width, y + height, scaleX, scaleY);
    } else if (type === "polyline" || type === "polygon") {
      points = target.getAttribute("points").match(_numExp) || [];
      type === "polygon" && points.push(points[0], points[1]);
      length = 0;

      for (i = 2; i < points.length; i += 2) {
        length += _getDistance(points[i - 2], points[i - 1], points[i], points[i + 1], scaleX, scaleY) || 0;
      }
    } else if (type === "circle" || type === "ellipse") {
      rx = width / 2 * scaleX;
      ry = height / 2 * scaleY;
      length = Math.PI * (3 * (rx + ry) - _sqrt((3 * rx + ry) * (rx + 3 * ry)));
    }

    return length || 0;
  },
      _getPosition = function _getPosition(target, length) {
    target = _toArray(target)[0];

    if (!target) {
      return [0, 0];
    }

    length || (length = _getLength(target) + 1);

    var cs = _win.getComputedStyle(target),
        dash = cs.strokeDasharray || "",
        offset = _parseNum(cs.strokeDashoffset),
        i = dash.indexOf(",");

    i < 0 && (i = dash.indexOf(" "));
    dash = i < 0 ? length : _parseNum(dash.substr(0, i));
    dash > length && (dash = length);
    return [-offset || 0, dash - offset || 0];
  },
      _initCore = function _initCore() {
    if (_windowExists()) {
      _win = window;
      _coreInitted = gsap = _getGSAP();
      _toArray = gsap.utils.toArray;
      _getStyleSaver = gsap.core.getStyleSaver;

      _reverting = gsap.core.reverting || function () {};

      _isEdge = ((_win.navigator || {}).userAgent || "").indexOf("Edge") !== -1; //Microsoft Edge has a bug that causes it not to redraw the path correctly if the stroke-linecap is anything other than "butt" (like "round") and it doesn't match the stroke-linejoin. A way to trigger it is to change the stroke-miterlimit, so we'll only do that if/when we have to (to maximize performance)
    }
  };

  var DrawSVGPlugin = {
    version: "3.13.0",
    name: "drawSVG",
    register: function register(core) {
      gsap = core;

      _initCore();
    },
    init: function init(target, value, tween, index, targets) {
      if (!target.getBBox) {
        return false;
      }

      _coreInitted || _initCore();

      var length = _getLength(target),
          start,
          end,
          cs;

      this.styles = _getStyleSaver && _getStyleSaver(target, "strokeDashoffset,strokeDasharray,strokeMiterlimit");
      this.tween = tween;
      this._style = target.style;
      this._target = target;

      if (value + "" === "true") {
        value = "0 100%";
      } else if (!value) {
        value = "0 0";
      } else if ((value + "").indexOf(" ") === -1) {
        value = "0 " + value;
      }

      start = _getPosition(target, length);
      end = _parse(value, length, start[0]);
      this._length = _round(length);
      this._dash = _round(start[1] - start[0]); //some browsers render artifacts if dash is 0, so we use a very small number in that case.

      this._offset = _round(-start[0]);
      this._dashPT = this.add(this, "_dash", this._dash, _round(end[1] - end[0]), 0, 0, 0, 0, 0, 1);
      this._offsetPT = this.add(this, "_offset", this._offset, _round(-end[0]), 0, 0, 0, 0, 0, 1);

      if (_isEdge) {
        //to work around a bug in Microsoft Edge, animate the stroke-miterlimit by 0.0001 just to trigger the repaint (unnecessary if it's "round" and stroke-linejoin is also "round"). Imperceptible, relatively high-performance, and effective. Another option was to set the "d" <path> attribute to its current value on every tick, but that seems like it'd be much less performant.
        cs = _win.getComputedStyle(target);

        if (cs.strokeLinecap !== cs.strokeLinejoin) {
          end = _parseNum(cs.strokeMiterlimit);
          this.add(target.style, "strokeMiterlimit", end, end + 0.01);
        }
      }

      this._live = _hasNonScalingStroke(target) || ~(value + "").indexOf("live");
      this._nowrap = ~(value + "").indexOf("nowrap");

      this._props.push("drawSVG");

      return _bonusValidated;
    },
    render: function render(ratio, data) {
      if (data.tween._time || !_reverting()) {
        var pt = data._pt,
            style = data._style,
            length,
            lengthRatio,
            dash,
            offset;

        if (pt) {
          //when the element has vector-effect="non-scaling-stroke" and the SVG is resized (like on a window resize), it actually changes the length of the stroke! So we must sense that and make the proper adjustments.
          if (data._live) {
            length = _getLength(data._target);

            if (length !== data._length) {
              lengthRatio = length / data._length;
              data._length = length;

              if (data._offsetPT) {
                data._offsetPT.s *= lengthRatio;
                data._offsetPT.c *= lengthRatio;
              }

              if (data._dashPT) {
                data._dashPT.s *= lengthRatio;
                data._dashPT.c *= lengthRatio;
              } else {
                data._dash *= lengthRatio;
              }
            }
          }

          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }

          dash = data._dash || ratio && ratio !== 1 && 0.0001 || 0; // only let it be zero if it's at the start or end of the tween.

          length = data._length - dash + 0.1;
          offset = data._offset;
          dash && offset && dash + Math.abs(offset % data._length) > data._length - 0.05 && (offset += offset < 0 ? 0.005 : -0.005) && (length += 0.005);
          style.strokeDashoffset = dash ? offset : offset + 0.001;
          style.strokeDasharray = length < 0.1 ? "none" : dash ? dash + "px," + (data._nowrap ? 999999 : length) + "px" : "0px, 999999px";
        }
      } else {
        data.styles.revert();
      }
    },
    getLength: _getLength,
    getPosition: _getPosition
  };
  _getGSAP() && gsap.registerPlugin(DrawSVGPlugin);

  /**
   * SSR Window 4.0.2
   * Better handling for window object in SSR environment
   * https://github.com/nolimits4web/ssr-window
   *
   * Copyright 2021, Vladimir Kharlampidi
   *
   * Licensed under MIT
   *
   * Released on: December 13, 2021
   */
  /* eslint-disable no-param-reassign */
  function isObject$1(obj) {
      return (obj !== null &&
          typeof obj === 'object' &&
          'constructor' in obj &&
          obj.constructor === Object);
  }
  function extend$1(target = {}, src = {}) {
      Object.keys(src).forEach((key) => {
          if (typeof target[key] === 'undefined')
              target[key] = src[key];
          else if (isObject$1(src[key]) &&
              isObject$1(target[key]) &&
              Object.keys(src[key]).length > 0) {
              extend$1(target[key], src[key]);
          }
      });
  }

  const ssrDocument = {
      body: {},
      addEventListener() { },
      removeEventListener() { },
      activeElement: {
          blur() { },
          nodeName: '',
      },
      querySelector() {
          return null;
      },
      querySelectorAll() {
          return [];
      },
      getElementById() {
          return null;
      },
      createEvent() {
          return {
              initEvent() { },
          };
      },
      createElement() {
          return {
              children: [],
              childNodes: [],
              style: {},
              setAttribute() { },
              getElementsByTagName() {
                  return [];
              },
          };
      },
      createElementNS() {
          return {};
      },
      importNode() {
          return null;
      },
      location: {
          hash: '',
          host: '',
          hostname: '',
          href: '',
          origin: '',
          pathname: '',
          protocol: '',
          search: '',
      },
  };
  function getDocument() {
      const doc = typeof document !== 'undefined' ? document : {};
      extend$1(doc, ssrDocument);
      return doc;
  }

  const ssrWindow = {
      document: ssrDocument,
      navigator: {
          userAgent: '',
      },
      location: {
          hash: '',
          host: '',
          hostname: '',
          href: '',
          origin: '',
          pathname: '',
          protocol: '',
          search: '',
      },
      history: {
          replaceState() { },
          pushState() { },
          go() { },
          back() { },
      },
      CustomEvent: function CustomEvent() {
          return this;
      },
      addEventListener() { },
      removeEventListener() { },
      getComputedStyle() {
          return {
              getPropertyValue() {
                  return '';
              },
          };
      },
      Image() { },
      Date() { },
      screen: {},
      setTimeout() { },
      clearTimeout() { },
      matchMedia() {
          return {};
      },
      requestAnimationFrame(callback) {
          if (typeof setTimeout === 'undefined') {
              callback();
              return null;
          }
          return setTimeout(callback, 0);
      },
      cancelAnimationFrame(id) {
          if (typeof setTimeout === 'undefined') {
              return;
          }
          clearTimeout(id);
      },
  };
  function getWindow() {
      const win = typeof window !== 'undefined' ? window : {};
      extend$1(win, ssrWindow);
      return win;
  }

  function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach(key => {
      try {
        object[key] = null;
      } catch (e) {
        // no getter for object
      }
      try {
        delete object[key];
      } catch (e) {
        // something got wrong
      }
    });
  }
  function nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  }
  function now() {
    return Date.now();
  }
  function getComputedStyle$1(el) {
    const window = getWindow();
    let style;
    if (window.getComputedStyle) {
      style = window.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
      style = el.currentStyle;
    }
    if (!style) {
      style = el.style;
    }
    return style;
  }
  function getTranslate(el, axis = 'x') {
    const window = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle$1(el);
    if (window.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(',').length > 6) {
        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
      }
      // Some old versions of Webkit choke when 'none' is passed; pass
      // empty string instead in this case
      transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
      matrix = transformMatrix.toString().split(',');
    }
    if (axis === 'x') {
      // Latest Chrome and webkits Fix
      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
    }
    if (axis === 'y') {
      // Latest Chrome and webkits Fix
      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  }
  function isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
  }
  function isNode$1(node) {
    // eslint-disable-next-line
    if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
      return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
  }
  function extend(...args) {
    const to = Object(args[0]);
    const noExtend = ['__proto__', 'constructor', 'prototype'];
    for (let i = 1; i < args.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null && !isNode$1(nextSource)) {
        const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend(to[nextKey], nextSource[nextKey]);
              }
            } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
              to[nextKey] = {};
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend(to[nextKey], nextSource[nextKey]);
              }
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  }
  function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
  }
  function animateCSSModeScroll({
    swiper,
    targetPosition,
    side
  }) {
    const window = getWindow();
    const startPosition = -swiper.translate;
    let startTime = null;
    let time;
    const duration = swiper.params.speed;
    swiper.wrapperEl.style.scrollSnapType = 'none';
    window.cancelAnimationFrame(swiper.cssModeFrameID);
    const dir = targetPosition > startPosition ? 'next' : 'prev';
    const isOutOfBound = (current, target) => {
      return dir === 'next' && current >= target || dir === 'prev' && current <= target;
    };
    const animate = () => {
      time = new Date().getTime();
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
      if (isOutOfBound(currentPosition, targetPosition)) {
        currentPosition = targetPosition;
      }
      swiper.wrapperEl.scrollTo({
        [side]: currentPosition
      });
      if (isOutOfBound(currentPosition, targetPosition)) {
        swiper.wrapperEl.style.overflow = 'hidden';
        swiper.wrapperEl.style.scrollSnapType = '';
        setTimeout(() => {
          swiper.wrapperEl.style.overflow = '';
          swiper.wrapperEl.scrollTo({
            [side]: currentPosition
          });
        });
        window.cancelAnimationFrame(swiper.cssModeFrameID);
        return;
      }
      swiper.cssModeFrameID = window.requestAnimationFrame(animate);
    };
    animate();
  }
  function getSlideTransformEl(slideEl) {
    return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowEl && slideEl.shadowEl.querySelector('.swiper-slide-transform') || slideEl;
  }
  function elementChildren(element, selector = '') {
    return [...element.children].filter(el => el.matches(selector));
  }
  function createElement(tag, classes = []) {
    const el = document.createElement(tag);
    el.classList.add(...(Array.isArray(classes) ? classes : [classes]));
    return el;
  }
  function elementOffset(el) {
    const window = getWindow();
    const document = getDocument();
    const box = el.getBoundingClientRect();
    const body = document.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === window ? window.scrollY : el.scrollTop;
    const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  }
  function elementPrevAll(el, selector) {
    const prevEls = [];
    while (el.previousElementSibling) {
      const prev = el.previousElementSibling; // eslint-disable-line
      if (selector) {
        if (prev.matches(selector)) prevEls.push(prev);
      } else prevEls.push(prev);
      el = prev;
    }
    return prevEls;
  }
  function elementNextAll(el, selector) {
    const nextEls = [];
    while (el.nextElementSibling) {
      const next = el.nextElementSibling; // eslint-disable-line
      if (selector) {
        if (next.matches(selector)) nextEls.push(next);
      } else nextEls.push(next);
      el = next;
    }
    return nextEls;
  }
  function elementStyle(el, prop) {
    const window = getWindow();
    return window.getComputedStyle(el, null).getPropertyValue(prop);
  }
  function elementIndex(el) {
    let child = el;
    let i;
    if (child) {
      i = 0;
      // eslint-disable-next-line
      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1) i += 1;
      }
      return i;
    }
    return undefined;
  }
  function elementParents(el, selector) {
    const parents = []; // eslint-disable-line
    let parent = el.parentElement; // eslint-disable-line
    while (parent) {
      if (selector) {
        if (parent.matches(selector)) parents.push(parent);
      } else {
        parents.push(parent);
      }
      parent = parent.parentElement;
    }
    return parents;
  }
  function elementTransitionEnd(el, callback) {
    function fireCallBack(e) {
      if (e.target !== el) return;
      callback.call(el, e);
      el.removeEventListener('transitionend', fireCallBack);
    }
    if (callback) {
      el.addEventListener('transitionend', fireCallBack);
    }
  }
  function elementOuterSize(el, size, includeMargins) {
    const window = getWindow();
    if (includeMargins) {
      return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
    }
    return el.offsetWidth;
  }

  let support;
  function calcSupport() {
    const window = getWindow();
    const document = getDocument();
    return {
      smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,
      touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)
    };
  }
  function getSupport() {
    if (!support) {
      support = calcSupport();
    }
    return support;
  }

  let deviceCached;
  function calcDevice({
    userAgent
  } = {}) {
    const support = getSupport();
    const window = getWindow();
    const platform = window.navigator.platform;
    const ua = userAgent || window.navigator.userAgent;
    const device = {
      ios: false,
      android: false
    };
    const screenWidth = window.screen.width;
    const screenHeight = window.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform === 'Win32';
    let macos = platform === 'MacIntel';

    // iPadOs 13 fix
    const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
    if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      if (!ipad) ipad = [0, 1, '13_0_0'];
      macos = false;
    }

    // Android
    if (android && !windows) {
      device.os = 'android';
      device.android = true;
    }
    if (ipad || iphone || ipod) {
      device.os = 'ios';
      device.ios = true;
    }

    // Export object
    return device;
  }
  function getDevice(overrides = {}) {
    if (!deviceCached) {
      deviceCached = calcDevice(overrides);
    }
    return deviceCached;
  }

  let browser;
  function calcBrowser() {
    const window = getWindow();
    let needPerspectiveFix = false;
    function isSafari() {
      const ua = window.navigator.userAgent.toLowerCase();
      return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
    }
    if (isSafari()) {
      const ua = String(window.navigator.userAgent);
      if (ua.includes('Version/')) {
        const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));
        needPerspectiveFix = major < 16 || major === 16 && minor < 2;
      }
    }
    return {
      isSafari: needPerspectiveFix || isSafari(),
      needPerspectiveFix,
      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
    };
  }
  function getBrowser() {
    if (!browser) {
      browser = calcBrowser();
    }
    return browser;
  }

  function Resize({
    swiper,
    on,
    emit
  }) {
    const window = getWindow();
    let observer = null;
    let animationFrame = null;
    const resizeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      emit('beforeResize');
      emit('resize');
    };
    const createObserver = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      observer = new ResizeObserver(entries => {
        animationFrame = window.requestAnimationFrame(() => {
          const {
            width,
            height
          } = swiper;
          let newWidth = width;
          let newHeight = height;
          entries.forEach(({
            contentBoxSize,
            contentRect,
            target
          }) => {
            if (target && target !== swiper.el) return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });
          if (newWidth !== width || newHeight !== height) {
            resizeHandler();
          }
        });
      });
      observer.observe(swiper.el);
    };
    const removeObserver = () => {
      if (animationFrame) {
        window.cancelAnimationFrame(animationFrame);
      }
      if (observer && observer.unobserve && swiper.el) {
        observer.unobserve(swiper.el);
        observer = null;
      }
    };
    const orientationChangeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      emit('orientationchange');
    };
    on('init', () => {
      if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
        createObserver();
        return;
      }
      window.addEventListener('resize', resizeHandler);
      window.addEventListener('orientationchange', orientationChangeHandler);
    });
    on('destroy', () => {
      removeObserver();
      window.removeEventListener('resize', resizeHandler);
      window.removeEventListener('orientationchange', orientationChangeHandler);
    });
  }

  function Observer({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const observers = [];
    const window = getWindow();
    const attach = (target, options = {}) => {
      const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
      const observer = new ObserverFunc(mutations => {
        // The observerUpdate event should only be triggered
        // once despite the number of mutations.  Additional
        // triggers are redundant and are very costly
        if (swiper.__preventObserver__) return;
        if (mutations.length === 1) {
          emit('observerUpdate', mutations[0]);
          return;
        }
        const observerUpdate = function observerUpdate() {
          emit('observerUpdate', mutations[0]);
        };
        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(observerUpdate);
        } else {
          window.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
        childList: typeof options.childList === 'undefined' ? true : options.childList,
        characterData: typeof options.characterData === 'undefined' ? true : options.characterData
      });
      observers.push(observer);
    };
    const init = () => {
      if (!swiper.params.observer) return;
      if (swiper.params.observeParents) {
        const containerParents = elementParents(swiper.el);
        for (let i = 0; i < containerParents.length; i += 1) {
          attach(containerParents[i]);
        }
      }
      // Observe container
      attach(swiper.el, {
        childList: swiper.params.observeSlideChildren
      });

      // Observe wrapper
      attach(swiper.wrapperEl, {
        attributes: false
      });
    };
    const destroy = () => {
      observers.forEach(observer => {
        observer.disconnect();
      });
      observers.splice(0, observers.length);
    };
    extendParams({
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    });
    on('init', init);
    on('destroy', destroy);
  }

  /* eslint-disable no-underscore-dangle */

  var eventsEmitter = {
    on(events, handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (typeof handler !== 'function') return self;
      const method = priority ? 'unshift' : 'push';
      events.split(' ').forEach(event => {
        if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
        self.eventsListeners[event][method](handler);
      });
      return self;
    },
    once(events, handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (typeof handler !== 'function') return self;
      function onceHandler(...args) {
        self.off(events, onceHandler);
        if (onceHandler.__emitterProxy) {
          delete onceHandler.__emitterProxy;
        }
        handler.apply(self, args);
      }
      onceHandler.__emitterProxy = handler;
      return self.on(events, onceHandler, priority);
    },
    onAny(handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (typeof handler !== 'function') return self;
      const method = priority ? 'unshift' : 'push';
      if (self.eventsAnyListeners.indexOf(handler) < 0) {
        self.eventsAnyListeners[method](handler);
      }
      return self;
    },
    offAny(handler) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (!self.eventsAnyListeners) return self;
      const index = self.eventsAnyListeners.indexOf(handler);
      if (index >= 0) {
        self.eventsAnyListeners.splice(index, 1);
      }
      return self;
    },
    off(events, handler) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (!self.eventsListeners) return self;
      events.split(' ').forEach(event => {
        if (typeof handler === 'undefined') {
          self.eventsListeners[event] = [];
        } else if (self.eventsListeners[event]) {
          self.eventsListeners[event].forEach((eventHandler, index) => {
            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
              self.eventsListeners[event].splice(index, 1);
            }
          });
        }
      });
      return self;
    },
    emit(...args) {
      const self = this;
      if (!self.eventsListeners || self.destroyed) return self;
      if (!self.eventsListeners) return self;
      let events;
      let data;
      let context;
      if (typeof args[0] === 'string' || Array.isArray(args[0])) {
        events = args[0];
        data = args.slice(1, args.length);
        context = self;
      } else {
        events = args[0].events;
        data = args[0].data;
        context = args[0].context || self;
      }
      data.unshift(context);
      const eventsArray = Array.isArray(events) ? events : events.split(' ');
      eventsArray.forEach(event => {
        if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
          self.eventsAnyListeners.forEach(eventHandler => {
            eventHandler.apply(context, [event, ...data]);
          });
        }
        if (self.eventsListeners && self.eventsListeners[event]) {
          self.eventsListeners[event].forEach(eventHandler => {
            eventHandler.apply(context, data);
          });
        }
      });
      return self;
    }
  };

  function updateSize() {
    const swiper = this;
    let width;
    let height;
    const el = swiper.el;
    if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
      width = swiper.params.width;
    } else {
      width = el.clientWidth;
    }
    if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
      height = swiper.params.height;
    } else {
      height = el.clientHeight;
    }
    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
      return;
    }

    // Subtract paddings
    width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);
    height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);
    if (Number.isNaN(width)) width = 0;
    if (Number.isNaN(height)) height = 0;
    Object.assign(swiper, {
      width,
      height,
      size: swiper.isHorizontal() ? width : height
    });
  }

  function updateSlides() {
    const swiper = this;
    function getDirectionLabel(property) {
      if (swiper.isHorizontal()) {
        return property;
      }
      // prettier-ignore
      return {
        'width': 'height',
        'margin-top': 'margin-left',
        'margin-bottom ': 'margin-right',
        'margin-left': 'margin-top',
        'margin-right': 'margin-bottom',
        'padding-left': 'padding-top',
        'padding-right': 'padding-bottom',
        'marginRight': 'marginBottom'
      }[property];
    }
    function getDirectionPropertyValue(node, label) {
      return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
    }
    const params = swiper.params;
    const {
      wrapperEl,
      slidesEl,
      size: swiperSize,
      rtlTranslate: rtl,
      wrongRTL
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === 'function') {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }
    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === 'function') {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }
    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index = 0;
    if (typeof swiperSize === 'undefined') {
      return;
    }
    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
    } else if (typeof spaceBetween === 'string') {
      spaceBetween = parseFloat(spaceBetween);
    }
    swiper.virtualSize = -spaceBetween;

    // reset margins
    slides.forEach(slideEl => {
      if (rtl) {
        slideEl.style.marginLeft = '';
      } else {
        slideEl.style.marginRight = '';
      }
      slideEl.style.marginBottom = '';
      slideEl.style.marginTop = '';
    });

    // reset cssMode offsets
    if (params.centeredSlides && params.cssMode) {
      setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');
      setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');
    }
    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
    if (gridEnabled) {
      swiper.grid.initSlides(slidesLength);
    }

    // Calc slides
    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
      return typeof params.breakpoints[key].slidesPerView !== 'undefined';
    }).length > 0;
    for (let i = 0; i < slidesLength; i += 1) {
      slideSize = 0;
      let slide;
      if (slides[i]) slide = slides[i];
      if (gridEnabled) {
        swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
      }
      if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line

      if (params.slidesPerView === 'auto') {
        if (shouldResetSlideSize) {
          slides[i].style[getDirectionLabel('width')] = ``;
        }
        const slideStyles = getComputedStyle(slide);
        const currentTransform = slide.style.transform;
        const currentWebKitTransform = slide.style.webkitTransform;
        if (currentTransform) {
          slide.style.transform = 'none';
        }
        if (currentWebKitTransform) {
          slide.style.webkitTransform = 'none';
        }
        if (params.roundLengths) {
          slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);
        } else {
          // eslint-disable-next-line
          const width = getDirectionPropertyValue(slideStyles, 'width');
          const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
          const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
          const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
          const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
          const boxSizing = slideStyles.getPropertyValue('box-sizing');
          if (boxSizing && boxSizing === 'border-box') {
            slideSize = width + marginLeft + marginRight;
          } else {
            const {
              clientWidth,
              offsetWidth
            } = slide;
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
          }
        }
        if (currentTransform) {
          slide.style.transform = currentTransform;
        }
        if (currentWebKitTransform) {
          slide.style.webkitTransform = currentWebKitTransform;
        }
        if (params.roundLengths) slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
        if (params.roundLengths) slideSize = Math.floor(slideSize);
        if (slides[i]) {
          slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
        }
      }
      if (slides[i]) {
        slides[i].swiperSlideSize = slideSize;
      }
      slidesSizesGrid.push(slideSize);
      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
        if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }
      swiper.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
      wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (params.setWrapperSize) {
      wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (gridEnabled) {
      swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
    }

    // Remove last grid elements depending on width
    if (!params.centeredSlides) {
      const newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem);
        }
      }
      snapGrid = newSlidesGrid;
      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }
    if (isVirtual && params.loop) {
      const size = slidesSizesGrid[0] + spaceBetween;
      if (params.slidesPerGroup > 1) {
        const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
        const groupSize = size * params.slidesPerGroup;
        for (let i = 0; i < groups; i += 1) {
          snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
        }
      }
      for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
        if (params.slidesPerGroup === 1) {
          snapGrid.push(snapGrid[snapGrid.length - 1] + size);
        }
        slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
        swiper.virtualSize += size;
      }
    }
    if (snapGrid.length === 0) snapGrid = [0];
    if (spaceBetween !== 0) {
      const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
      slides.filter((_, slideIndex) => {
        if (!params.cssMode || params.loop) return true;
        if (slideIndex === slides.length - 1) {
          return false;
        }
        return true;
      }).forEach(slideEl => {
        slideEl.style[key] = `${spaceBetween}px`;
      });
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach(slideSizeValue => {
        allSlidesSize += slideSizeValue + (spaceBetween || 0);
      });
      allSlidesSize -= spaceBetween;
      const maxSnap = allSlidesSize - swiperSize;
      snapGrid = snapGrid.map(snap => {
        if (snap <= 0) return -offsetBefore;
        if (snap > maxSnap) return maxSnap + offsetAfter;
        return snap;
      });
    }
    if (params.centerInsufficientSlides) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach(slideSizeValue => {
        allSlidesSize += slideSizeValue + (spaceBetween || 0);
      });
      allSlidesSize -= spaceBetween;
      if (allSlidesSize < swiperSize) {
        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
        snapGrid.forEach((snap, snapIndex) => {
          snapGrid[snapIndex] = snap - allSlidesOffset;
        });
        slidesGrid.forEach((snap, snapIndex) => {
          slidesGrid[snapIndex] = snap + allSlidesOffset;
        });
      }
    }
    Object.assign(swiper, {
      slides,
      snapGrid,
      slidesGrid,
      slidesSizesGrid
    });
    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
      setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
      setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
      const addToSnapGrid = -swiper.snapGrid[0];
      const addToSlidesGrid = -swiper.slidesGrid[0];
      swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
      swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
    }
    if (slidesLength !== previousSlidesLength) {
      swiper.emit('slidesLengthChange');
    }
    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow) swiper.checkOverflow();
      swiper.emit('snapGridLengthChange');
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit('slidesGridLengthChange');
    }
    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
    if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
      const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
      if (slidesLength <= params.maxBackfaceHiddenSlides) {
        if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
      } else if (hasClassBackfaceClassAdded) {
        swiper.el.classList.remove(backFaceHiddenClass);
      }
    }
  }

  function updateAutoHeight(speed) {
    const swiper = this;
    const activeSlides = [];
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let newHeight = 0;
    let i;
    if (typeof speed === 'number') {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    }
    const getSlideByIndex = index => {
      if (isVirtual) {
        return swiper.slides[swiper.getSlideIndexByData(index)];
      }
      return swiper.slides[index];
    };
    // Find slides currently in view
    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
      if (swiper.params.centeredSlides) {
        (swiper.visibleSlides || []).forEach(slide => {
          activeSlides.push(slide);
        });
      } else {
        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
          const index = swiper.activeIndex + i;
          if (index > swiper.slides.length && !isVirtual) break;
          activeSlides.push(getSlideByIndex(index));
        }
      }
    } else {
      activeSlides.push(getSlideByIndex(swiper.activeIndex));
    }

    // Find new height from highest slide in view
    for (i = 0; i < activeSlides.length; i += 1) {
      if (typeof activeSlides[i] !== 'undefined') {
        const height = activeSlides[i].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    }

    // Update Height
    if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
  }

  function updateSlidesOffset() {
    const swiper = this;
    const slides = swiper.slides;
    // eslint-disable-next-line
    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
    for (let i = 0; i < slides.length; i += 1) {
      slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
    }
  }

  function updateSlidesProgress(translate = this && this.translate || 0) {
    const swiper = this;
    const params = swiper.params;
    const {
      slides,
      rtlTranslate: rtl,
      snapGrid
    } = swiper;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
    let offsetCenter = -translate;
    if (rtl) offsetCenter = translate;

    // Visible Slides
    slides.forEach(slideEl => {
      slideEl.classList.remove(params.slideVisibleClass);
    });
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];
    let spaceBetween = params.spaceBetween;
    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
    } else if (typeof spaceBetween === 'string') {
      spaceBetween = parseFloat(spaceBetween);
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slide = slides[i];
      let slideOffset = slide.swiperSlideOffset;
      if (params.cssMode && params.centeredSlides) {
        slideOffset -= slides[0].swiperSlideOffset;
      }
      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
      const slideBefore = -(offsetCenter - slideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides[i].classList.add(params.slideVisibleClass);
      }
      slide.progress = rtl ? -slideProgress : slideProgress;
      slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }
  }

  function updateProgress(translate) {
    const swiper = this;
    if (typeof translate === 'undefined') {
      const multiplier = swiper.rtlTranslate ? -1 : 1;
      // eslint-disable-next-line
      translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }
    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let {
      progress,
      isBeginning,
      isEnd,
      progressLoop
    } = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate - swiper.minTranslate()) / translatesDiff;
      const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
      const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
      isBeginning = isBeginningRounded || progress <= 0;
      isEnd = isEndRounded || progress >= 1;
      if (isBeginningRounded) progress = 0;
      if (isEndRounded) progress = 1;
    }
    if (params.loop) {
      const firstSlideIndex = swiper.getSlideIndexByData(0);
      const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
      const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
      const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
      const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
      const translateAbs = Math.abs(translate);
      if (translateAbs >= firstSlideTranslate) {
        progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
      } else {
        progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
      }
      if (progressLoop > 1) progressLoop -= 1;
    }
    Object.assign(swiper, {
      progress,
      progressLoop,
      isBeginning,
      isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
    if (isBeginning && !wasBeginning) {
      swiper.emit('reachBeginning toEdge');
    }
    if (isEnd && !wasEnd) {
      swiper.emit('reachEnd toEdge');
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper.emit('fromEdge');
    }
    swiper.emit('progress', progress);
  }

  function updateSlidesClasses() {
    const swiper = this;
    const {
      slides,
      params,
      slidesEl,
      activeIndex
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const getFilteredSlide = selector => {
      return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
    };
    slides.forEach(slideEl => {
      slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
    });
    let activeSlide;
    if (isVirtual) {
      if (params.loop) {
        let slideIndex = activeIndex - swiper.virtual.slidesBefore;
        if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
        if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
        activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
      } else {
        activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
      }
    } else {
      activeSlide = slides[activeIndex];
    }
    if (activeSlide) {
      // Active classes
      activeSlide.classList.add(params.slideActiveClass);

      // Next Slide
      let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !nextSlide) {
        nextSlide = slides[0];
      }
      if (nextSlide) {
        nextSlide.classList.add(params.slideNextClass);
      }
      // Prev Slide
      let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !prevSlide === 0) {
        prevSlide = slides[slides.length - 1];
      }
      if (prevSlide) {
        prevSlide.classList.add(params.slidePrevClass);
      }
    }
    swiper.emitSlidesClasses();
  }

  const processLazyPreloader = (swiper, imageEl) => {
    if (!swiper || swiper.destroyed || !swiper.params) return;
    const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
    const slideEl = imageEl.closest(slideSelector());
    if (slideEl) {
      const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      if (lazyEl) lazyEl.remove();
    }
  };
  const unlazy = (swiper, index) => {
    if (!swiper.slides[index]) return;
    const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
    if (imageEl) imageEl.removeAttribute('loading');
  };
  const preload = swiper => {
    if (!swiper || swiper.destroyed || !swiper.params) return;
    let amount = swiper.params.lazyPreloadPrevNext;
    const len = swiper.slides.length;
    if (!len || !amount || amount < 0) return;
    amount = Math.min(amount, len);
    const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
    const activeIndex = swiper.activeIndex;
    if (swiper.params.grid && swiper.params.grid.rows > 1) {
      const activeColumn = activeIndex;
      const preloadColumns = [activeColumn - amount];
      preloadColumns.push(...Array.from({
        length: amount
      }).map((_, i) => {
        return activeColumn + slidesPerView + i;
      }));
      swiper.slides.forEach((slideEl, i) => {
        if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
      });
      return;
    }
    const slideIndexLastInView = activeIndex + slidesPerView - 1;
    if (swiper.params.rewind || swiper.params.loop) {
      for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
        const realIndex = (i % len + len) % len;
        if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
      }
    } else {
      for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
        if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
          unlazy(swiper, i);
        }
      }
    }
  };

  function getActiveIndexByTranslate(swiper) {
    const {
      slidesGrid,
      params
    } = swiper;
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    let activeIndex;
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
    return activeIndex;
  }
  function updateActiveIndex(newActiveIndex) {
    const swiper = this;
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const {
      snapGrid,
      params,
      activeIndex: previousIndex,
      realIndex: previousRealIndex,
      snapIndex: previousSnapIndex
    } = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;
    const getVirtualRealIndex = aIndex => {
      let realIndex = aIndex - swiper.virtual.slidesBefore;
      if (realIndex < 0) {
        realIndex = swiper.virtual.slides.length + realIndex;
      }
      if (realIndex >= swiper.virtual.slides.length) {
        realIndex -= swiper.virtual.slides.length;
      }
      return realIndex;
    };
    if (typeof activeIndex === 'undefined') {
      activeIndex = getActiveIndexByTranslate(swiper);
    }
    if (snapGrid.indexOf(translate) >= 0) {
      snapIndex = snapGrid.indexOf(translate);
    } else {
      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit('snapIndexChange');
      }
      if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
        swiper.realIndex = getVirtualRealIndex(activeIndex);
      }
      return;
    }
    // Get real index
    let realIndex;
    if (swiper.virtual && params.virtual.enabled && params.loop) {
      realIndex = getVirtualRealIndex(activeIndex);
    } else if (swiper.slides[activeIndex]) {
      realIndex = parseInt(swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex, 10);
    } else {
      realIndex = activeIndex;
    }
    Object.assign(swiper, {
      previousSnapIndex,
      snapIndex,
      previousRealIndex,
      realIndex,
      previousIndex,
      activeIndex
    });
    if (swiper.initialized) {
      preload(swiper);
    }
    swiper.emit('activeIndexChange');
    swiper.emit('snapIndexChange');
    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
      swiper.emit('slideChange');
    }
  }

  function updateClickedSlide(e) {
    const swiper = this;
    const params = swiper.params;
    const slide = e.closest(`.${params.slideClass}, swiper-slide`);
    let slideFound = false;
    let slideIndex;
    if (slide) {
      for (let i = 0; i < swiper.slides.length; i += 1) {
        if (swiper.slides[i] === slide) {
          slideFound = true;
          slideIndex = i;
          break;
        }
      }
    }
    if (slide && slideFound) {
      swiper.clickedSlide = slide;
      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);
      } else {
        swiper.clickedIndex = slideIndex;
      }
    } else {
      swiper.clickedSlide = undefined;
      swiper.clickedIndex = undefined;
      return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }

  var update$1 = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
  };

  function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
    const swiper = this;
    const {
      params,
      rtlTranslate: rtl,
      translate,
      wrapperEl
    } = swiper;
    if (params.virtualTranslate) {
      return rtl ? -translate : translate;
    }
    if (params.cssMode) {
      return translate;
    }
    let currentTranslate = getTranslate(wrapperEl, axis);
    currentTranslate += swiper.cssOverflowAdjustment();
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
  }

  function setTranslate(translate, byController) {
    const swiper = this;
    const {
      rtlTranslate: rtl,
      params,
      wrapperEl,
      progress
    } = swiper;
    let x = 0;
    let y = 0;
    const z = 0;
    if (swiper.isHorizontal()) {
      x = rtl ? -translate : translate;
    } else {
      y = translate;
    }
    if (params.roundLengths) {
      x = Math.floor(x);
      y = Math.floor(y);
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y;
    if (params.cssMode) {
      wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
      if (swiper.isHorizontal()) {
        x -= swiper.cssOverflowAdjustment();
      } else {
        y -= swiper.cssOverflowAdjustment();
      }
      wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
    }

    // Check if we need to update progress
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
      swiper.updateProgress(translate);
    }
    swiper.emit('setTranslate', swiper.translate, byController);
  }

  function minTranslate() {
    return -this.snapGrid[0];
  }

  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }

  function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
    const swiper = this;
    const {
      params,
      wrapperEl
    } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }
    const minTranslate = swiper.minTranslate();
    const maxTranslate = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;

    // Update progress
    swiper.updateProgress(newTranslate);
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      if (speed === 0) {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: -newTranslate,
            side: isH ? 'left' : 'top'
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: -newTranslate,
          behavior: 'smooth'
        });
      }
      return true;
    }
    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionEnd');
      }
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionStart');
      }
      if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onTranslateToWrapperTransitionEnd) {
          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
            swiper.onTranslateToWrapperTransitionEnd = null;
            delete swiper.onTranslateToWrapperTransitionEnd;
            if (runCallbacks) {
              swiper.emit('transitionEnd');
            }
          };
        }
        swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      }
    }
    return true;
  }

  var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
  };

  function setTransition(duration, byController) {
    const swiper = this;
    if (!swiper.params.cssMode) {
      swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
    }
    swiper.emit('setTransition', duration, byController);
  }

  function transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step
  }) {
    const {
      activeIndex,
      previousIndex
    } = swiper;
    let dir = direction;
    if (!dir) {
      if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
    }
    swiper.emit(`transition${step}`);
    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === 'reset') {
        swiper.emit(`slideResetTransition${step}`);
        return;
      }
      swiper.emit(`slideChangeTransition${step}`);
      if (dir === 'next') {
        swiper.emit(`slideNextTransition${step}`);
      } else {
        swiper.emit(`slidePrevTransition${step}`);
      }
    }
  }

  function transitionStart(runCallbacks = true, direction) {
    const swiper = this;
    const {
      params
    } = swiper;
    if (params.cssMode) return;
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: 'Start'
    });
  }

  function transitionEnd(runCallbacks = true, direction) {
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: 'End'
    });
  }

  var transition = {
    setTransition,
    transitionStart,
    transitionEnd
  };

  function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
    if (typeof index === 'string') {
      index = parseInt(index, 10);
    }
    const swiper = this;
    let slideIndex = index;
    if (slideIndex < 0) slideIndex = 0;
    const {
      params,
      snapGrid,
      slidesGrid,
      previousIndex,
      activeIndex,
      rtlTranslate: rtl,
      wrapperEl,
      enabled
    } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
      return false;
    }
    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    const translate = -snapGrid[snapIndex];
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        const normalizedTranslate = -Math.floor(translate * 100);
        const normalizedGrid = Math.floor(slidesGrid[i] * 100);
        const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
        if (typeof slidesGrid[i + 1] !== 'undefined') {
          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
            slideIndex = i;
          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
            slideIndex = i + 1;
          }
        } else if (normalizedTranslate >= normalizedGrid) {
          slideIndex = i;
        }
      }
    }
    // Directions locks
    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
        return false;
      }
      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) {
          return false;
        }
      }
    }
    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
      swiper.emit('beforeSlideChangeStart');
    }

    // Update progress
    swiper.updateProgress(translate);
    let direction;
    if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';

    // Update Index
    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
      swiper.updateActiveIndex(slideIndex);
      // Update Height
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
      swiper.updateSlidesClasses();
      if (params.effect !== 'slide') {
        swiper.setTranslate(translate);
      }
      if (direction !== 'reset') {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }
      return false;
    }
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      const t = rtl ? translate : -translate;
      if (speed === 0) {
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        if (isVirtual) {
          swiper.wrapperEl.style.scrollSnapType = 'none';
          swiper._immediateVirtual = true;
        }
        if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
          swiper._cssModeVirtualInitialSet = true;
          requestAnimationFrame(() => {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
          });
        } else {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        }
        if (isVirtual) {
          requestAnimationFrame(() => {
            swiper.wrapperEl.style.scrollSnapType = '';
            swiper._immediateVirtual = false;
          });
        }
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: t,
            side: isH ? 'left' : 'top'
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: t,
          behavior: 'smooth'
        });
      }
      return true;
    }
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (speed === 0) {
      swiper.transitionEnd(runCallbacks, direction);
    } else if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
    }
    return true;
  }

  function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
    if (typeof index === 'string') {
      const indexAsNumber = parseInt(index, 10);
      index = indexAsNumber;
    }
    const swiper = this;
    let newIndex = index;
    if (swiper.params.loop) {
      if (swiper.virtual && swiper.params.virtual.enabled) {
        // eslint-disable-next-line
        newIndex = newIndex + swiper.virtual.slidesBefore;
      } else {
        newIndex = swiper.getSlideIndexByData(newIndex);
      }
    }
    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    const {
      enabled,
      params,
      animating
    } = swiper;
    if (!enabled) return swiper;
    let perGroup = params.slidesPerGroup;
    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
    }
    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
      if (animating && !isVirtual && params.loopPreventsSliding) return false;
      swiper.loopFix({
        direction: 'next'
      });
      // eslint-disable-next-line
      swiper._clientLeft = swiper.wrapperEl.clientLeft;
    }
    if (params.rewind && swiper.isEnd) {
      return swiper.slideTo(0, speed, runCallbacks, internal);
    }
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    const {
      params,
      snapGrid,
      slidesGrid,
      rtlTranslate,
      enabled,
      animating
    } = swiper;
    if (!enabled) return swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
      if (animating && !isVirtual && params.loopPreventsSliding) return false;
      swiper.loopFix({
        direction: 'prev'
      });
      // eslint-disable-next-line
      swiper._clientLeft = swiper.wrapperEl.clientLeft;
    }
    const translate = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize(val) {
      if (val < 0) return -Math.floor(Math.abs(val));
      return Math.floor(val);
    }
    const normalizedTranslate = normalize(translate);
    const normalizedSnapGrid = snapGrid.map(val => normalize(val));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === 'undefined' && params.cssMode) {
      let prevSnapIndex;
      snapGrid.forEach((snap, snapIndex) => {
        if (normalizedTranslate >= snap) {
          // prevSnap = snap;
          prevSnapIndex = snapIndex;
        }
      });
      if (typeof prevSnapIndex !== 'undefined') {
        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
      }
    }
    let prevIndex = 0;
    if (typeof prevSnap !== 'undefined') {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
        prevIndex = Math.max(prevIndex, 0);
      }
    }
    if (params.rewind && swiper.isBeginning) {
      const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
    const swiper = this;
    let index = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    if (translate >= swiper.snapGrid[snapIndex]) {
      // The current translate is on or after the current snap index, so the choice
      // is between the current index and the one after it.
      const currentSnap = swiper.snapGrid[snapIndex];
      const nextSnap = swiper.snapGrid[snapIndex + 1];
      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
        index += swiper.params.slidesPerGroup;
      }
    } else {
      // The current translate is before the current snap index, so the choice
      // is between the current index and the one before it.
      const prevSnap = swiper.snapGrid[snapIndex - 1];
      const currentSnap = swiper.snapGrid[snapIndex];
      if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
        index -= swiper.params.slidesPerGroup;
      }
    }
    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index, speed, runCallbacks, internal);
  }

  function slideToClickedSlide() {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;
    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
    if (params.loop) {
      if (swiper.animating) return;
      realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
      if (params.centeredSlides) {
        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
          swiper.loopFix();
          slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }

  var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
  };

  function loopCreate(slideRealIndex) {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    slides.forEach((el, index) => {
      el.setAttribute('data-swiper-slide-index', index);
    });
    swiper.loopFix({
      slideRealIndex,
      direction: params.centeredSlides ? undefined : 'next'
    });
  }

  function loopFix({
    slideRealIndex,
    slideTo = true,
    direction,
    setTranslate,
    activeSlideIndex,
    byController,
    byMousewheel
  } = {}) {
    const swiper = this;
    if (!swiper.params.loop) return;
    swiper.emit('beforeLoopFix');
    const {
      slides,
      allowSlidePrev,
      allowSlideNext,
      slidesEl,
      params
    } = swiper;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    if (swiper.virtual && params.virtual.enabled) {
      if (slideTo) {
        if (!params.centeredSlides && swiper.snapIndex === 0) {
          swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
        } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
          swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
        } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
          swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
        }
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit('loopFix');
      return;
    }
    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));
    let loopedSlides = params.loopedSlides || slidesPerView;
    if (loopedSlides % params.slidesPerGroup !== 0) {
      loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;
    }
    swiper.loopedSlides = loopedSlides;
    const prependSlidesIndexes = [];
    const appendSlidesIndexes = [];
    let activeIndex = swiper.activeIndex;
    if (typeof activeSlideIndex === 'undefined') {
      activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);
    } else {
      activeIndex = activeSlideIndex;
    }
    const isNext = direction === 'next' || !direction;
    const isPrev = direction === 'prev' || !direction;
    let slidesPrepended = 0;
    let slidesAppended = 0;
    // prepend last slides before start
    if (activeSlideIndex < loopedSlides) {
      slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);
      for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {
        const index = i - Math.floor(i / slides.length) * slides.length;
        prependSlidesIndexes.push(slides.length - index - 1);
      }
    } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {
      slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);
      for (let i = 0; i < slidesAppended; i += 1) {
        const index = i - Math.floor(i / slides.length) * slides.length;
        appendSlidesIndexes.push(index);
      }
    }
    if (isPrev) {
      prependSlidesIndexes.forEach(index => {
        swiper.slides[index].swiperLoopMoveDOM = true;
        slidesEl.prepend(swiper.slides[index]);
        swiper.slides[index].swiperLoopMoveDOM = false;
      });
    }
    if (isNext) {
      appendSlidesIndexes.forEach(index => {
        swiper.slides[index].swiperLoopMoveDOM = true;
        slidesEl.append(swiper.slides[index]);
        swiper.slides[index].swiperLoopMoveDOM = false;
      });
    }
    swiper.recalcSlides();
    if (params.slidesPerView === 'auto') {
      swiper.updateSlides();
    }
    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
    if (slideTo) {
      if (prependSlidesIndexes.length > 0 && isPrev) {
        if (typeof slideRealIndex === 'undefined') {
          const currentSlideTranslate = swiper.slidesGrid[activeIndex];
          const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
          const diff = newSlideTranslate - currentSlideTranslate;
          if (byMousewheel) {
            swiper.setTranslate(swiper.translate - diff);
          } else {
            swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
            if (setTranslate) {
              swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;
            }
          }
        } else {
          if (setTranslate) {
            swiper.slideToLoop(slideRealIndex, 0, false, true);
          }
        }
      } else if (appendSlidesIndexes.length > 0 && isNext) {
        if (typeof slideRealIndex === 'undefined') {
          const currentSlideTranslate = swiper.slidesGrid[activeIndex];
          const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
          const diff = newSlideTranslate - currentSlideTranslate;
          if (byMousewheel) {
            swiper.setTranslate(swiper.translate - diff);
          } else {
            swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
            if (setTranslate) {
              swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;
            }
          }
        } else {
          swiper.slideToLoop(slideRealIndex, 0, false, true);
        }
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.controller && swiper.controller.control && !byController) {
      const loopParams = {
        slideRealIndex,
        slideTo: false,
        direction,
        setTranslate,
        activeSlideIndex,
        byController: true
      };
      if (Array.isArray(swiper.controller.control)) {
        swiper.controller.control.forEach(c => {
          if (!c.destroyed && c.params.loop) c.loopFix(loopParams);
        });
      } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
        swiper.controller.control.loopFix(loopParams);
      }
    }
    swiper.emit('loopFix');
  }

  function loopDestroy() {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
    swiper.recalcSlides();
    const newSlidesOrder = [];
    swiper.slides.forEach(slideEl => {
      const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
      newSlidesOrder[index] = slideEl;
    });
    swiper.slides.forEach(slideEl => {
      slideEl.removeAttribute('data-swiper-slide-index');
    });
    newSlidesOrder.forEach(slideEl => {
      slidesEl.append(slideEl);
    });
    swiper.recalcSlides();
    swiper.slideTo(swiper.realIndex, 0);
  }

  var loop = {
    loopCreate,
    loopFix,
    loopDestroy
  };

  function setGrabCursor(moving) {
    const swiper = this;
    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
    if (swiper.isElement) {
      swiper.__preventObserver__ = true;
    }
    el.style.cursor = 'move';
    el.style.cursor = moving ? 'grabbing' : 'grab';
    if (swiper.isElement) {
      requestAnimationFrame(() => {
        swiper.__preventObserver__ = false;
      });
    }
  }

  function unsetGrabCursor() {
    const swiper = this;
    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
      return;
    }
    if (swiper.isElement) {
      swiper.__preventObserver__ = true;
    }
    swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
    if (swiper.isElement) {
      requestAnimationFrame(() => {
        swiper.__preventObserver__ = false;
      });
    }
  }

  var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
  };

  // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
  function closestElement(selector, base = this) {
    function __closestFrom(el) {
      if (!el || el === getDocument() || el === getWindow()) return null;
      if (el.assignedSlot) el = el.assignedSlot;
      const found = el.closest(selector);
      if (!found && !el.getRootNode) {
        return null;
      }
      return found || __closestFrom(el.getRootNode().host);
    }
    return __closestFrom(base);
  }
  function onTouchStart$1(event) {
    const swiper = this;
    const document = getDocument();
    const window = getWindow();
    const data = swiper.touchEventsData;
    data.evCache.push(event);
    const {
      params,
      touches,
      enabled
    } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && event.pointerType === 'mouse') return;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }
    if (!swiper.animating && params.cssMode && params.loop) {
      swiper.loopFix();
    }
    let e = event;
    if (e.originalEvent) e = e.originalEvent;
    let targetEl = e.target;
    if (params.touchEventsTarget === 'wrapper') {
      if (!swiper.wrapperEl.contains(targetEl)) return;
    }
    if ('which' in e && e.which === 3) return;
    if ('button' in e && e.button > 0) return;
    if (data.isTouched && data.isMoved) return;

    // change target el for shadow root component
    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
    // eslint-disable-next-line
    const eventPath = event.composedPath ? event.composedPath() : event.path;
    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
      targetEl = eventPath[0];
    }
    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e.target && e.target.shadowRoot);

    // use closestElement for shadow root element to get the actual closest for nested shadow root element
    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
      swiper.allowClick = true;
      return;
    }
    if (params.swipeHandler) {
      if (!targetEl.closest(params.swipeHandler)) return;
    }
    touches.currentX = e.pageX;
    touches.currentY = e.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;

    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

    const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
      if (edgeSwipeDetection === 'prevent') {
        event.preventDefault();
      } else {
        return;
      }
    }
    Object.assign(data, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: undefined,
      startMoving: undefined
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = undefined;
    if (params.threshold > 0) data.allowThresholdMove = false;
    let preventDefault = true;
    if (targetEl.matches(data.focusableElements)) {
      preventDefault = false;
      if (targetEl.nodeName === 'SELECT') {
        data.isTouched = false;
      }
    }
    if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {
      document.activeElement.blur();
    }
    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
      e.preventDefault();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
      swiper.freeMode.onTouchStart();
    }
    swiper.emit('touchStart', e);
  }

  function onTouchMove$1(event) {
    const document = getDocument();
    const swiper = this;
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      enabled
    } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && event.pointerType === 'mouse') return;
    let e = event;
    if (e.originalEvent) e = e.originalEvent;
    if (!data.isTouched) {
      if (data.startMoving && data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }
      return;
    }
    const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
    if (pointerIndex >= 0) data.evCache[pointerIndex] = e;
    const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;
    const pageX = targetTouch.pageX;
    const pageY = targetTouch.pageY;
    if (e.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }
    if (!swiper.allowTouchMove) {
      if (!e.target.matches(data.focusableElements)) {
        swiper.allowClick = false;
      }
      if (data.isTouched) {
        Object.assign(touches, {
          startX: pageX,
          startY: pageY,
          prevX: swiper.touches.currentX,
          prevY: swiper.touches.currentY,
          currentX: pageX,
          currentY: pageY
        });
        data.touchStartTime = now();
      }
      return;
    }
    if (params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        // Vertical
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
          data.isTouched = false;
          data.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
        return;
      }
    }
    if (document.activeElement) {
      if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
        data.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }
    if (data.allowTouchCallbacks) {
      swiper.emit('touchMove', e);
    }
    if (e.targetTouches && e.targetTouches.length > 1) return;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
    if (typeof data.isScrolling === 'undefined') {
      let touchAngle;
      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
        data.isScrolling = false;
      } else {
        // eslint-disable-next-line
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }
    if (data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    if (typeof data.startMoving === 'undefined') {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data.startMoving = true;
      }
    }
    if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {
      data.isTouched = false;
      return;
    }
    if (!data.startMoving) {
      return;
    }
    swiper.allowClick = false;
    if (!params.cssMode && e.cancelable) {
      e.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
      e.stopPropagation();
    }
    let diff = swiper.isHorizontal() ? diffX : diffY;
    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
    if (params.oneWayMovement) {
      diff = Math.abs(diff) * (rtl ? 1 : -1);
      touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
    }
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) {
      diff = -diff;
      touchesDiff = -touchesDiff;
    }
    const prevTouchesDirection = swiper.touchesDirection;
    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
    swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
    const isLoop = swiper.params.loop && !params.cssMode;
    if (!data.isMoved) {
      if (isLoop) {
        swiper.loopFix({
          direction: swiper.swipeDirection
        });
      }
      data.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);
      if (swiper.animating) {
        const evt = new window.CustomEvent('transitionend', {
          bubbles: true,
          cancelable: true
        });
        swiper.wrapperEl.dispatchEvent(evt);
      }
      data.allowMomentumBounce = false;
      // Grab Cursor
      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }
      swiper.emit('sliderFirstMove', e);
    }
    let loopFixed;
    if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {
      // need another loop fix
      swiper.loopFix({
        direction: swiper.swipeDirection,
        setTranslate: true
      });
      loopFixed = true;
    }
    swiper.emit('sliderMove', e);
    data.isMoved = true;
    data.currentTranslate = diff + data.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }
    if (diff > 0) {
      if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {
        swiper.loopFix({
          direction: 'prev',
          setTranslate: true,
          activeSlideIndex: 0
        });
      }
      if (data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) {
          data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
        }
      }
    } else if (diff < 0) {
      if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {
        swiper.loopFix({
          direction: 'next',
          setTranslate: true,
          activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
        });
      }
      if (data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) {
          data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
        }
      }
    }
    if (disableParentSwiper) {
      e.preventedByNestedSwiper = true;
    }

    // Directions locks
    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
      data.currentTranslate = data.startTranslate;
    }

    // Threshold
    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
          data.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data.currentTranslate = data.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data.currentTranslate = data.startTranslate;
        return;
      }
    }
    if (!params.followFinger || params.cssMode) return;

    // Update active index in free mode
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
      swiper.freeMode.onTouchMove();
    }
    // Update progress
    swiper.updateProgress(data.currentTranslate);
    // Update translate
    swiper.setTranslate(data.currentTranslate);
  }

  function onTouchEnd(event) {
    const swiper = this;
    const data = swiper.touchEventsData;
    const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);
    if (pointerIndex >= 0) {
      data.evCache.splice(pointerIndex, 1);
    }
    if (['pointercancel', 'pointerout', 'pointerleave'].includes(event.type)) {
      const proceed = event.type === 'pointercancel' && (swiper.browser.isSafari || swiper.browser.isWebView);
      if (!proceed) {
        return;
      }
    }
    const {
      params,
      touches,
      rtlTranslate: rtl,
      slidesGrid,
      enabled
    } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && event.pointerType === 'mouse') return;
    let e = event;
    if (e.originalEvent) e = e.originalEvent;
    if (data.allowTouchCallbacks) {
      swiper.emit('touchEnd', e);
    }
    data.allowTouchCallbacks = false;
    if (!data.isTouched) {
      if (data.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    // Return Grab Cursor
    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    }

    // Time diff
    const touchEndTime = now();
    const timeDiff = touchEndTime - data.touchStartTime;

    // Tap, doubleTap, Click
    if (swiper.allowClick) {
      const pathTree = e.path || e.composedPath && e.composedPath();
      swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
      swiper.emit('tap click', e);
      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
        swiper.emit('doubleTap doubleClick', e);
      }
    }
    data.lastClickTime = now();
    nextTick(() => {
      if (!swiper.destroyed) swiper.allowClick = true;
    });
    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    let currentPos;
    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data.currentTranslate;
    }
    if (params.cssMode) {
      return;
    }
    if (params.freeMode && params.freeMode.enabled) {
      swiper.freeMode.onTouchEnd({
        currentPos
      });
      return;
    }

    // Find current slide
    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];
    for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (typeof slidesGrid[i + increment] !== 'undefined') {
        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
          stopIndex = i;
          groupSize = slidesGrid[i + increment] - slidesGrid[i];
        }
      } else if (currentPos >= slidesGrid[i]) {
        stopIndex = i;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    }
    let rewindFirstIndex = null;
    let rewindLastIndex = null;
    if (params.rewind) {
      if (swiper.isBeginning) {
        rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      } else if (swiper.isEnd) {
        rewindFirstIndex = 0;
      }
    }
    // Find current slide size
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
      // Long touches
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      if (swiper.swipeDirection === 'next') {
        if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
      }
      if (swiper.swipeDirection === 'prev') {
        if (ratio > 1 - params.longSwipesRatio) {
          swiper.slideTo(stopIndex + increment);
        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
          swiper.slideTo(rewindLastIndex);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    } else {
      // Short swipes
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
      if (!isNavButtonTarget) {
        if (swiper.swipeDirection === 'next') {
          swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
        }
        if (swiper.swipeDirection === 'prev') {
          swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
        }
      } else if (e.target === swiper.navigation.nextEl) {
        swiper.slideTo(stopIndex + increment);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  }

  function onResize() {
    const swiper = this;
    const {
      params,
      el
    } = swiper;
    if (el && el.offsetWidth === 0) return;

    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Save locks
    const {
      allowSlideNext,
      allowSlidePrev,
      snapGrid
    } = swiper;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

    // Disable locks on resize
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();
    const isVirtualLoop = isVirtual && params.loop;
    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      if (swiper.params.loop && !isVirtual) {
        swiper.slideToLoop(swiper.realIndex, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
    }
    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
      clearTimeout(swiper.autoplay.resizeTimeout);
      swiper.autoplay.resizeTimeout = setTimeout(() => {
        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
          swiper.autoplay.resume();
        }
      }, 500);
    }
    // Return locks after resize
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }

  function onClick(e) {
    const swiper = this;
    if (!swiper.enabled) return;
    if (!swiper.allowClick) {
      if (swiper.params.preventClicks) e.preventDefault();
      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
  }

  function onScroll() {
    const swiper = this;
    const {
      wrapperEl,
      rtlTranslate,
      enabled
    } = swiper;
    if (!enabled) return;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) {
      swiper.translate = -wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollTop;
    }
    // eslint-disable-next-line
    if (swiper.translate === 0) swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper.progress) {
      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }
    swiper.emit('setTranslate', swiper.translate, false);
  }

  function onLoad(e) {
    const swiper = this;
    processLazyPreloader(swiper, e.target);
    if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
      return;
    }
    swiper.update();
  }

  let dummyEventAttached = false;
  function dummyEventListener() {}
  const events = (swiper, method) => {
    const document = getDocument();
    const {
      params,
      el,
      wrapperEl,
      device
    } = swiper;
    const capture = !!params.nested;
    const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
    const swiperMethod = method;

    // Touch Events
    el[domMethod]('pointerdown', swiper.onTouchStart, {
      passive: false
    });
    document[domMethod]('pointermove', swiper.onTouchMove, {
      passive: false,
      capture
    });
    document[domMethod]('pointerup', swiper.onTouchEnd, {
      passive: true
    });
    document[domMethod]('pointercancel', swiper.onTouchEnd, {
      passive: true
    });
    document[domMethod]('pointerout', swiper.onTouchEnd, {
      passive: true
    });
    document[domMethod]('pointerleave', swiper.onTouchEnd, {
      passive: true
    });

    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
      el[domMethod]('click', swiper.onClick, true);
    }
    if (params.cssMode) {
      wrapperEl[domMethod]('scroll', swiper.onScroll);
    }

    // Resize handler
    if (params.updateOnWindowResize) {
      swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
    } else {
      swiper[swiperMethod]('observerUpdate', onResize, true);
    }

    // Images loader
    el[domMethod]('load', swiper.onLoad, {
      capture: true
    });
  };
  function attachEvents() {
    const swiper = this;
    const document = getDocument();
    const {
      params
    } = swiper;
    swiper.onTouchStart = onTouchStart$1.bind(swiper);
    swiper.onTouchMove = onTouchMove$1.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    if (params.cssMode) {
      swiper.onScroll = onScroll.bind(swiper);
    }
    swiper.onClick = onClick.bind(swiper);
    swiper.onLoad = onLoad.bind(swiper);
    if (!dummyEventAttached) {
      document.addEventListener('touchstart', dummyEventListener);
      dummyEventAttached = true;
    }
    events(swiper, 'on');
  }
  function detachEvents() {
    const swiper = this;
    events(swiper, 'off');
  }
  var events$1 = {
    attachEvents,
    detachEvents
  };

  const isGridEnabled = (swiper, params) => {
    return swiper.grid && params.grid && params.grid.rows > 1;
  };
  function setBreakpoint() {
    const swiper = this;
    const {
      realIndex,
      initialized,
      params,
      el
    } = swiper;
    const breakpoints = params.breakpoints;
    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;

    // Get breakpoint for window width and update parameters
    const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = isGridEnabled(swiper, params);
    const isMultiRow = isGridEnabled(swiper, breakpointParams);
    const wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      el.classList.add(`${params.containerModifierClass}grid`);
      if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
        el.classList.add(`${params.containerModifierClass}grid-column`);
      }
      swiper.emitContainerClasses();
    }

    // Toggle navigation, pagination, scrollbar
    ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
      if (typeof breakpointParams[prop] === 'undefined') return;
      const wasModuleEnabled = params[prop] && params[prop].enabled;
      const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
      if (wasModuleEnabled && !isModuleEnabled) {
        swiper[prop].disable();
      }
      if (!wasModuleEnabled && isModuleEnabled) {
        swiper[prop].enable();
      }
    });
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    if (directionChanged && initialized) {
      swiper.changeDirection();
    }
    extend(swiper.params, breakpointParams);
    const isEnabled = swiper.params.enabled;
    Object.assign(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
      swiper.disable();
    } else if (!wasEnabled && isEnabled) {
      swiper.enable();
    }
    swiper.currentBreakpoint = breakpoint;
    swiper.emit('_beforeBreakpoint', breakpointParams);
    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    }
    swiper.emit('breakpoint', breakpointParams);
  }

  function getBreakpoint(breakpoints, base = 'window', containerEl) {
    if (!breakpoints || base === 'container' && !containerEl) return undefined;
    let breakpoint = false;
    const window = getWindow();
    const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints).map(point => {
      if (typeof point === 'string' && point.indexOf('@') === 0) {
        const minRatio = parseFloat(point.substr(1));
        const value = currentHeight * minRatio;
        return {
          value,
          point
        };
      }
      return {
        value: point,
        point
      };
    });
    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
    for (let i = 0; i < points.length; i += 1) {
      const {
        point,
        value
      } = points[i];
      if (base === 'window') {
        if (window.matchMedia(`(min-width: ${value}px)`).matches) {
          breakpoint = point;
        }
      } else if (value <= containerEl.clientWidth) {
        breakpoint = point;
      }
    }
    return breakpoint || 'max';
  }

  var breakpoints = {
    setBreakpoint,
    getBreakpoint
  };

  function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach(item => {
      if (typeof item === 'object') {
        Object.keys(item).forEach(classNames => {
          if (item[classNames]) {
            resultClasses.push(prefix + classNames);
          }
        });
      } else if (typeof item === 'string') {
        resultClasses.push(prefix + item);
      }
    });
    return resultClasses;
  }
  function addClasses() {
    const swiper = this;
    const {
      classNames,
      params,
      rtl,
      el,
      device
    } = swiper;
    // prettier-ignore
    const suffixes = prepareClasses(['initialized', params.direction, {
      'free-mode': swiper.params.freeMode && params.freeMode.enabled
    }, {
      'autoheight': params.autoHeight
    }, {
      'rtl': rtl
    }, {
      'grid': params.grid && params.grid.rows > 1
    }, {
      'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
    }, {
      'android': device.android
    }, {
      'ios': device.ios
    }, {
      'css-mode': params.cssMode
    }, {
      'centered': params.cssMode && params.centeredSlides
    }, {
      'watch-progress': params.watchSlidesProgress
    }], params.containerModifierClass);
    classNames.push(...suffixes);
    el.classList.add(...classNames);
    swiper.emitContainerClasses();
  }

  function removeClasses() {
    const swiper = this;
    const {
      el,
      classNames
    } = swiper;
    el.classList.remove(...classNames);
    swiper.emitContainerClasses();
  }

  var classes = {
    addClasses,
    removeClasses
  };

  function checkOverflow() {
    const swiper = this;
    const {
      isLocked: wasLocked,
      params
    } = swiper;
    const {
      slidesOffsetBefore
    } = params;
    if (slidesOffsetBefore) {
      const lastSlideIndex = swiper.slides.length - 1;
      const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
      swiper.isLocked = swiper.size > lastSlideRightEdge;
    } else {
      swiper.isLocked = swiper.snapGrid.length === 1;
    }
    if (params.allowSlideNext === true) {
      swiper.allowSlideNext = !swiper.isLocked;
    }
    if (params.allowSlidePrev === true) {
      swiper.allowSlidePrev = !swiper.isLocked;
    }
    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
    }
    if (wasLocked !== swiper.isLocked) {
      swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
    }
  }
  var checkOverflow$1 = {
    checkOverflow
  };

  var defaults = {
    init: true,
    direction: 'horizontal',
    oneWayMovement: false,
    touchEventsTarget: 'wrapper',
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    enabled: true,
    focusableElements: 'input, select, option, textarea, button, video, label',
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: 'slide',
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

    // Breakpoints
    breakpoints: undefined,
    breakpointsBase: 'window',
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 5,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // loop
    loop: false,
    loopedSlides: null,
    loopPreventsSliding: true,
    // rewind
    rewind: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: 'swiper-no-swiping',
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: 'swiper-',
    // NEW
    slideClass: 'swiper-slide',
    slideActiveClass: 'swiper-slide-active',
    slideVisibleClass: 'swiper-slide-visible',
    slideNextClass: 'swiper-slide-next',
    slidePrevClass: 'swiper-slide-prev',
    wrapperClass: 'swiper-wrapper',
    lazyPreloaderClass: 'swiper-lazy-preloader',
    lazyPreloadPrevNext: 0,
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
  };

  function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj = {}) {
      const moduleParamName = Object.keys(obj)[0];
      const moduleParams = obj[moduleParamName];
      if (typeof moduleParams !== 'object' || moduleParams === null) {
        extend(allModulesParams, obj);
        return;
      }
      if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
        params[moduleParamName] = {
          auto: true
        };
      }
      if (!(moduleParamName in params && 'enabled' in moduleParams)) {
        extend(allModulesParams, obj);
        return;
      }
      if (params[moduleParamName] === true) {
        params[moduleParamName] = {
          enabled: true
        };
      }
      if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
        params[moduleParamName].enabled = true;
      }
      if (!params[moduleParamName]) params[moduleParamName] = {
        enabled: false
      };
      extend(allModulesParams, obj);
    };
  }

  /* eslint no-param-reassign: "off" */
  const prototypes = {
    eventsEmitter,
    update: update$1,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes
  };
  const extendedDefaults = {};
  class Swiper {
    constructor(...args) {
      let el;
      let params;
      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
        params = args[0];
      } else {
        [el, params] = args;
      }
      if (!params) params = {};
      params = extend({}, params);
      if (el && !params.el) params.el = el;
      const document = getDocument();
      if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {
        const swipers = [];
        document.querySelectorAll(params.el).forEach(containerEl => {
          const newParams = extend({}, params, {
            el: containerEl
          });
          swipers.push(new Swiper(newParams));
        });
        // eslint-disable-next-line no-constructor-return
        return swipers;
      }

      // Swiper Instance
      const swiper = this;
      swiper.__swiper__ = true;
      swiper.support = getSupport();
      swiper.device = getDevice({
        userAgent: params.userAgent
      });
      swiper.browser = getBrowser();
      swiper.eventsListeners = {};
      swiper.eventsAnyListeners = [];
      swiper.modules = [...swiper.__modules__];
      if (params.modules && Array.isArray(params.modules)) {
        swiper.modules.push(...params.modules);
      }
      const allModulesParams = {};
      swiper.modules.forEach(mod => {
        mod({
          params,
          swiper,
          extendParams: moduleExtendParams(params, allModulesParams),
          on: swiper.on.bind(swiper),
          once: swiper.once.bind(swiper),
          off: swiper.off.bind(swiper),
          emit: swiper.emit.bind(swiper)
        });
      });

      // Extend defaults with modules params
      const swiperParams = extend({}, defaults, allModulesParams);

      // Extend defaults with passed params
      swiper.params = extend({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = extend({}, swiper.params);
      swiper.passedParams = extend({}, params);

      // add event listeners
      if (swiper.params && swiper.params.on) {
        Object.keys(swiper.params.on).forEach(eventName => {
          swiper.on(eventName, swiper.params.on[eventName]);
        });
      }
      if (swiper.params && swiper.params.onAny) {
        swiper.onAny(swiper.params.onAny);
      }

      // Extend Swiper
      Object.assign(swiper, {
        enabled: swiper.params.enabled,
        el,
        // Classes
        classNames: [],
        // Slides
        slides: [],
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal() {
          return swiper.params.direction === 'horizontal';
        },
        isVertical() {
          return swiper.params.direction === 'vertical';
        },
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        cssOverflowAdjustment() {
          // Returns 0 unless `translate` is > 2**23
          // Should be subtracted from css values to prevent overflow
          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
        },
        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
        // Touch Events
        touchEventsData: {
          isTouched: undefined,
          isMoved: undefined,
          allowTouchCallbacks: undefined,
          touchStartTime: undefined,
          isScrolling: undefined,
          currentTranslate: undefined,
          startTranslate: undefined,
          allowThresholdMove: undefined,
          // Form elements to match
          focusableElements: swiper.params.focusableElements,
          // Last click time
          lastClickTime: 0,
          clickTimeout: undefined,
          // Velocities
          velocities: [],
          allowMomentumBounce: undefined,
          startMoving: undefined,
          evCache: []
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      });
      swiper.emit('_swiper');

      // Init
      if (swiper.params.init) {
        swiper.init();
      }

      // Return app instance
      // eslint-disable-next-line no-constructor-return
      return swiper;
    }
    getSlideIndex(slideEl) {
      const {
        slidesEl,
        params
      } = this;
      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
      const firstSlideIndex = elementIndex(slides[0]);
      return elementIndex(slideEl) - firstSlideIndex;
    }
    getSlideIndexByData(index) {
      return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);
    }
    recalcSlides() {
      const swiper = this;
      const {
        slidesEl,
        params
      } = swiper;
      swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    }
    enable() {
      const swiper = this;
      if (swiper.enabled) return;
      swiper.enabled = true;
      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }
      swiper.emit('enable');
    }
    disable() {
      const swiper = this;
      if (!swiper.enabled) return;
      swiper.enabled = false;
      if (swiper.params.grabCursor) {
        swiper.unsetGrabCursor();
      }
      swiper.emit('disable');
    }
    setProgress(progress, speed) {
      const swiper = this;
      progress = Math.min(Math.max(progress, 0), 1);
      const min = swiper.minTranslate();
      const max = swiper.maxTranslate();
      const current = (max - min) * progress + min;
      swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    emitContainerClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      const cls = swiper.el.className.split(' ').filter(className => {
        return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
      });
      swiper.emit('_containerClasses', cls.join(' '));
    }
    getSlideClasses(slideEl) {
      const swiper = this;
      if (swiper.destroyed) return '';
      return slideEl.className.split(' ').filter(className => {
        return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
      }).join(' ');
    }
    emitSlidesClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      const updates = [];
      swiper.slides.forEach(slideEl => {
        const classNames = swiper.getSlideClasses(slideEl);
        updates.push({
          slideEl,
          classNames
        });
        swiper.emit('_slideClass', slideEl, classNames);
      });
      swiper.emit('_slideClasses', updates);
    }
    slidesPerViewDynamic(view = 'current', exact = false) {
      const swiper = this;
      const {
        params,
        slides,
        slidesGrid,
        slidesSizesGrid,
        size: swiperSize,
        activeIndex
      } = swiper;
      let spv = 1;
      if (params.centeredSlides) {
        let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;
        let breakLoop;
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
      } else {
        // eslint-disable-next-line
        if (view === 'current') {
          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        } else {
          // previous
          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        }
      }
      return spv;
    }
    update() {
      const swiper = this;
      if (!swiper || swiper.destroyed) return;
      const {
        snapGrid,
        params
      } = swiper;
      // Breakpoints
      if (params.breakpoints) {
        swiper.setBreakpoint();
      }
      [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
        if (imageEl.complete) {
          processLazyPreloader(swiper, imageEl);
        }
      });
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      function setTranslate() {
        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      let translated;
      if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
        setTranslate();
        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
          const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
          translated = swiper.slideTo(slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
        if (!translated) {
          setTranslate();
        }
      }
      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
      swiper.emit('update');
    }
    changeDirection(newDirection, needUpdate = true) {
      const swiper = this;
      const currentDirection = swiper.params.direction;
      if (!newDirection) {
        // eslint-disable-next-line
        newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
      }
      if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
        return swiper;
      }
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
      swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
      swiper.emitContainerClasses();
      swiper.params.direction = newDirection;
      swiper.slides.forEach(slideEl => {
        if (newDirection === 'vertical') {
          slideEl.style.width = '';
        } else {
          slideEl.style.height = '';
        }
      });
      swiper.emit('changeDirection');
      if (needUpdate) swiper.update();
      return swiper;
    }
    changeLanguageDirection(direction) {
      const swiper = this;
      if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
      swiper.rtl = direction === 'rtl';
      swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
      if (swiper.rtl) {
        swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = 'rtl';
      } else {
        swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = 'ltr';
      }
      swiper.update();
    }
    mount(element) {
      const swiper = this;
      if (swiper.mounted) return true;

      // Find el
      let el = element || swiper.params.el;
      if (typeof el === 'string') {
        el = document.querySelector(el);
      }
      if (!el) {
        return false;
      }
      el.swiper = swiper;
      if (el.shadowEl) {
        swiper.isElement = true;
      }
      const getWrapperSelector = () => {
        return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
      };
      const getWrapper = () => {
        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
          const res = el.shadowRoot.querySelector(getWrapperSelector());
          // Children needs to return slot items
          return res;
        }
        return elementChildren(el, getWrapperSelector())[0];
      };
      // Find Wrapper
      let wrapperEl = getWrapper();
      if (!wrapperEl && swiper.params.createElements) {
        wrapperEl = createElement('div', swiper.params.wrapperClass);
        el.append(wrapperEl);
        elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
          wrapperEl.append(slideEl);
        });
      }
      Object.assign(swiper, {
        el,
        wrapperEl,
        slidesEl: swiper.isElement ? el : wrapperEl,
        mounted: true,
        // RTL
        rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',
        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),
        wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'
      });
      return true;
    }
    init(el) {
      const swiper = this;
      if (swiper.initialized) return swiper;
      const mounted = swiper.mount(el);
      if (mounted === false) return swiper;
      swiper.emit('beforeInit');

      // Set breakpoint
      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      }

      // Add Classes
      swiper.addClasses();

      // Update size
      swiper.updateSize();

      // Update slides
      swiper.updateSlides();
      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      }

      // Set Grab Cursor
      if (swiper.params.grabCursor && swiper.enabled) {
        swiper.setGrabCursor();
      }

      // Slide To Initial Slide
      if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
        swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
      }

      // Create loop
      if (swiper.params.loop) {
        swiper.loopCreate();
      }

      // Attach events
      swiper.attachEvents();
      [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
        if (imageEl.complete) {
          processLazyPreloader(swiper, imageEl);
        } else {
          imageEl.addEventListener('load', e => {
            processLazyPreloader(swiper, e.target);
          });
        }
      });
      preload(swiper);

      // Init Flag
      swiper.initialized = true;
      preload(swiper);

      // Emit
      swiper.emit('init');
      swiper.emit('afterInit');
      return swiper;
    }
    destroy(deleteInstance = true, cleanStyles = true) {
      const swiper = this;
      const {
        params,
        el,
        wrapperEl,
        slides
      } = swiper;
      if (typeof swiper.params === 'undefined' || swiper.destroyed) {
        return null;
      }
      swiper.emit('beforeDestroy');

      // Init Flag
      swiper.initialized = false;

      // Detach events
      swiper.detachEvents();

      // Destroy loop
      if (params.loop) {
        swiper.loopDestroy();
      }

      // Cleanup styles
      if (cleanStyles) {
        swiper.removeClasses();
        el.removeAttribute('style');
        wrapperEl.removeAttribute('style');
        if (slides && slides.length) {
          slides.forEach(slideEl => {
            slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
            slideEl.removeAttribute('style');
            slideEl.removeAttribute('data-swiper-slide-index');
          });
        }
      }
      swiper.emit('destroy');

      // Detach emitter events
      Object.keys(swiper.eventsListeners).forEach(eventName => {
        swiper.off(eventName);
      });
      if (deleteInstance !== false) {
        swiper.el.swiper = null;
        deleteProps(swiper);
      }
      swiper.destroyed = true;
      return null;
    }
    static extendDefaults(newDefaults) {
      extend(extendedDefaults, newDefaults);
    }
    static get extendedDefaults() {
      return extendedDefaults;
    }
    static get defaults() {
      return defaults;
    }
    static installModule(mod) {
      if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
      const modules = Swiper.prototype.__modules__;
      if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
        modules.push(mod);
      }
    }
    static use(module) {
      if (Array.isArray(module)) {
        module.forEach(m => Swiper.installModule(m));
        return Swiper;
      }
      Swiper.installModule(module);
      return Swiper;
    }
  }
  Object.keys(prototypes).forEach(prototypeGroup => {
    Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
  });
  Swiper.use([Resize, Observer]);

  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
    if (swiper.params.createElements) {
      Object.keys(checkProps).forEach(key => {
        if (!params[key] && params.auto === true) {
          let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];
          if (!element) {
            element = createElement('div', checkProps[key]);
            element.className = checkProps[key];
            swiper.el.append(element);
          }
          params[key] = element;
          originalParams[key] = element;
        }
      });
    }
    return params;
  }

  function Navigation({
    swiper,
    extendParams,
    on,
    emit
  }) {
    extendParams({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: 'swiper-button-disabled',
        hiddenClass: 'swiper-button-hidden',
        lockClass: 'swiper-button-lock',
        navigationDisabledClass: 'swiper-navigation-disabled'
      }
    });
    swiper.navigation = {
      nextEl: null,
      prevEl: null
    };
    const makeElementsArray = el => {
      if (!Array.isArray(el)) el = [el].filter(e => !!e);
      return el;
    };
    function getEl(el) {
      let res;
      if (el && typeof el === 'string' && swiper.isElement) {
        res = swiper.el.shadowRoot.querySelector(el);
        if (res) return res;
      }
      if (el) {
        if (typeof el === 'string') res = [...document.querySelectorAll(el)];
        if (swiper.params.uniqueNavElements && typeof el === 'string' && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
          res = swiper.el.querySelector(el);
        }
      }
      if (el && !res) return el;
      // if (Array.isArray(res) && res.length === 1) res = res[0];
      return res;
    }
    function toggleEl(el, disabled) {
      const params = swiper.params.navigation;
      el = makeElementsArray(el);
      el.forEach(subEl => {
        if (subEl) {
          subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));
          if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;
          if (swiper.params.watchOverflow && swiper.enabled) {
            subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
          }
        }
      });
    }
    function update() {
      // Update Navigation Buttons
      const {
        nextEl,
        prevEl
      } = swiper.navigation;
      if (swiper.params.loop) {
        toggleEl(prevEl, false);
        toggleEl(nextEl, false);
        return;
      }
      toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
      toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
    }
    function onPrevClick(e) {
      e.preventDefault();
      if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
      swiper.slidePrev();
      emit('navigationPrev');
    }
    function onNextClick(e) {
      e.preventDefault();
      if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
      swiper.slideNext();
      emit('navigationNext');
    }
    function init() {
      const params = swiper.params.navigation;
      swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
        nextEl: 'swiper-button-next',
        prevEl: 'swiper-button-prev'
      });
      if (!(params.nextEl || params.prevEl)) return;
      let nextEl = getEl(params.nextEl);
      let prevEl = getEl(params.prevEl);
      Object.assign(swiper.navigation, {
        nextEl,
        prevEl
      });
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const initButton = (el, dir) => {
        if (el) {
          el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
        }
        if (!swiper.enabled && el) {
          el.classList.add(...params.lockClass.split(' '));
        }
      };
      nextEl.forEach(el => initButton(el, 'next'));
      prevEl.forEach(el => initButton(el, 'prev'));
    }
    function destroy() {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const destroyButton = (el, dir) => {
        el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
        el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));
      };
      nextEl.forEach(el => destroyButton(el, 'next'));
      prevEl.forEach(el => destroyButton(el, 'prev'));
    }
    on('init', () => {
      if (swiper.params.navigation.enabled === false) {
        // eslint-disable-next-line
        disable();
      } else {
        init();
        update();
      }
    });
    on('toEdge fromEdge lock unlock', () => {
      update();
    });
    on('destroy', () => {
      destroy();
    });
    on('enable disable', () => {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.navigation.lockClass));
    });
    on('click', (_s, e) => {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const targetEl = e.target;
      if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {
        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
        let isHidden;
        if (nextEl.length) {
          isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
        } else if (prevEl.length) {
          isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
        }
        if (isHidden === true) {
          emit('navigationShow');
        } else {
          emit('navigationHide');
        }
        [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));
      }
    });
    const enable = () => {
      swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));
      init();
      update();
    };
    const disable = () => {
      swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));
      destroy();
    };
    Object.assign(swiper.navigation, {
      enable,
      disable,
      update,
      init,
      destroy
    });
  }

  function classesToSelector(classes = '') {
    return `.${classes.trim().replace(/([\.:!+\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
  }

  function Pagination({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const pfx = 'swiper-pagination';
    extendParams({
      pagination: {
        el: null,
        bulletElement: 'span',
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: 'bullets',
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: number => number,
        formatFractionTotal: number => number,
        bulletClass: `${pfx}-bullet`,
        bulletActiveClass: `${pfx}-bullet-active`,
        modifierClass: `${pfx}-`,
        currentClass: `${pfx}-current`,
        totalClass: `${pfx}-total`,
        hiddenClass: `${pfx}-hidden`,
        progressbarFillClass: `${pfx}-progressbar-fill`,
        progressbarOppositeClass: `${pfx}-progressbar-opposite`,
        clickableClass: `${pfx}-clickable`,
        lockClass: `${pfx}-lock`,
        horizontalClass: `${pfx}-horizontal`,
        verticalClass: `${pfx}-vertical`,
        paginationDisabledClass: `${pfx}-disabled`
      }
    });
    swiper.pagination = {
      el: null,
      bullets: []
    };
    let bulletSize;
    let dynamicBulletIndex = 0;
    const makeElementsArray = el => {
      if (!Array.isArray(el)) el = [el].filter(e => !!e);
      return el;
    };
    function isPaginationDisabled() {
      return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
    }
    function setSideBullets(bulletEl, position) {
      const {
        bulletActiveClass
      } = swiper.params.pagination;
      if (!bulletEl) return;
      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
      if (bulletEl) {
        bulletEl.classList.add(`${bulletActiveClass}-${position}`);
        bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
        if (bulletEl) {
          bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
        }
      }
    }
    function onBulletClick(e) {
      const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
      if (!bulletEl) {
        return;
      }
      e.preventDefault();
      const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
      if (swiper.params.loop) {
        if (swiper.realIndex === index) return;
        const newSlideIndex = swiper.getSlideIndexByData(index);
        const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);
        if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {
          swiper.loopFix({
            direction: newSlideIndex > currentSlideIndex ? 'next' : 'prev',
            activeSlideIndex: newSlideIndex,
            slideTo: false
          });
        }
        swiper.slideToLoop(index);
      } else {
        swiper.slideTo(index);
      }
    }
    function update() {
      // Render || Update Pagination bullets/items
      const rtl = swiper.rtl;
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      let el = swiper.pagination.el;
      el = makeElementsArray(el);
      // Current/Total
      let current;
      let previousIndex;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.loop) {
        previousIndex = swiper.previousRealIndex || 0;
        current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
      } else if (typeof swiper.snapIndex !== 'undefined') {
        current = swiper.snapIndex;
        previousIndex = swiper.previousSnapIndex;
      } else {
        previousIndex = swiper.previousIndex || 0;
        current = swiper.activeIndex || 0;
      }
      // Types
      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
        const bullets = swiper.pagination.bullets;
        let firstIndex;
        let lastIndex;
        let midIndex;
        if (params.dynamicBullets) {
          bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);
          el.forEach(subEl => {
            subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
          });
          if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {
            dynamicBulletIndex += current - (previousIndex || 0);
            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
              dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (dynamicBulletIndex < 0) {
              dynamicBulletIndex = 0;
            }
          }
          firstIndex = Math.max(current - dynamicBulletIndex, 0);
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }
        bullets.forEach(bulletEl => {
          const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();
          bulletEl.classList.remove(...classesToRemove);
        });
        if (el.length > 1) {
          bullets.forEach(bullet => {
            const bulletIndex = elementIndex(bullet);
            if (bulletIndex === current) {
              bullet.classList.add(...params.bulletActiveClass.split(' '));
            } else if (swiper.isElement) {
              bullet.setAttribute('part', 'bullet');
            }
            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));
              }
              if (bulletIndex === firstIndex) {
                setSideBullets(bullet, 'prev');
              }
              if (bulletIndex === lastIndex) {
                setSideBullets(bullet, 'next');
              }
            }
          });
        } else {
          const bullet = bullets[current];
          if (bullet) {
            bullet.classList.add(...params.bulletActiveClass.split(' '));
          }
          if (swiper.isElement) {
            bullets.forEach((bulletEl, bulletIndex) => {
              bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');
            });
          }
          if (params.dynamicBullets) {
            const firstDisplayedBullet = bullets[firstIndex];
            const lastDisplayedBullet = bullets[lastIndex];
            for (let i = firstIndex; i <= lastIndex; i += 1) {
              if (bullets[i]) {
                bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));
              }
            }
            setSideBullets(firstDisplayedBullet, 'prev');
            setSideBullets(lastDisplayedBullet, 'next');
          }
        }
        if (params.dynamicBullets) {
          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
          const offsetProp = rtl ? 'right' : 'left';
          bullets.forEach(bullet => {
            bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;
          });
        }
      }
      el.forEach((subEl, subElIndex) => {
        if (params.type === 'fraction') {
          subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {
            fractionEl.textContent = params.formatFractionCurrent(current + 1);
          });
          subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {
            totalEl.textContent = params.formatFractionTotal(total);
          });
        }
        if (params.type === 'progressbar') {
          let progressbarDirection;
          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
          } else {
            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
          }
          const scale = (current + 1) / total;
          let scaleX = 1;
          let scaleY = 1;
          if (progressbarDirection === 'horizontal') {
            scaleX = scale;
          } else {
            scaleY = scale;
          }
          subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {
            progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
            progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
          });
        }
        if (params.type === 'custom' && params.renderCustom) {
          subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
          if (subElIndex === 0) emit('paginationRender', subEl);
        } else {
          if (subElIndex === 0) emit('paginationRender', subEl);
          emit('paginationUpdate', subEl);
        }
        if (swiper.params.watchOverflow && swiper.enabled) {
          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
        }
      });
    }
    function render() {
      // Render Container
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      let el = swiper.pagination.el;
      el = makeElementsArray(el);
      let paginationHTML = '';
      if (params.type === 'bullets') {
        let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
        if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
          numberOfBullets = slidesLength;
        }
        for (let i = 0; i < numberOfBullets; i += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
          } else {
            // prettier-ignore
            paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ''} class="${params.bulletClass}"></${params.bulletElement}>`;
          }
        }
      }
      if (params.type === 'fraction') {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
        } else {
          paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
        }
      }
      if (params.type === 'progressbar') {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
        } else {
          paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
        }
      }
      swiper.pagination.bullets = [];
      el.forEach(subEl => {
        if (params.type !== 'custom') {
          subEl.innerHTML = paginationHTML || '';
        }
        if (params.type === 'bullets') {
          swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
        }
      });
      if (params.type !== 'custom') {
        emit('paginationRender', el[0]);
      }
    }
    function init() {
      swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
        el: 'swiper-pagination'
      });
      const params = swiper.params.pagination;
      if (!params.el) return;
      let el;
      if (typeof params.el === 'string' && swiper.isElement) {
        el = swiper.el.shadowRoot.querySelector(params.el);
      }
      if (!el && typeof params.el === 'string') {
        el = [...document.querySelectorAll(params.el)];
      }
      if (!el) {
        el = params.el;
      }
      if (!el || el.length === 0) return;
      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {
        el = [...swiper.el.querySelectorAll(params.el)];
        // check if it belongs to another nested Swiper
        if (el.length > 1) {
          el = el.filter(subEl => {
            if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;
            return true;
          })[0];
        }
      }
      if (Array.isArray(el) && el.length === 1) el = el[0];
      Object.assign(swiper.pagination, {
        el
      });
      el = makeElementsArray(el);
      el.forEach(subEl => {
        if (params.type === 'bullets' && params.clickable) {
          subEl.classList.add(params.clickableClass);
        }
        subEl.classList.add(params.modifierClass + params.type);
        subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (params.type === 'bullets' && params.dynamicBullets) {
          subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
          dynamicBulletIndex = 0;
          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }
        if (params.type === 'progressbar' && params.progressbarOpposite) {
          subEl.classList.add(params.progressbarOppositeClass);
        }
        if (params.clickable) {
          subEl.addEventListener('click', onBulletClick);
        }
        if (!swiper.enabled) {
          subEl.classList.add(params.lockClass);
        }
      });
    }
    function destroy() {
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      let el = swiper.pagination.el;
      if (el) {
        el = makeElementsArray(el);
        el.forEach(subEl => {
          subEl.classList.remove(params.hiddenClass);
          subEl.classList.remove(params.modifierClass + params.type);
          subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
          if (params.clickable) {
            subEl.removeEventListener('click', onBulletClick);
          }
        });
      }
      if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));
    }
    on('changeDirection', () => {
      if (!swiper.pagination || !swiper.pagination.el) return;
      const params = swiper.params.pagination;
      let {
        el
      } = swiper.pagination;
      el = makeElementsArray(el);
      el.forEach(subEl => {
        subEl.classList.remove(params.horizontalClass, params.verticalClass);
        subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      });
    });
    on('init', () => {
      if (swiper.params.pagination.enabled === false) {
        // eslint-disable-next-line
        disable();
      } else {
        init();
        render();
        update();
      }
    });
    on('activeIndexChange', () => {
      if (typeof swiper.snapIndex === 'undefined') {
        update();
      }
    });
    on('snapIndexChange', () => {
      update();
    });
    on('snapGridLengthChange', () => {
      render();
      update();
    });
    on('destroy', () => {
      destroy();
    });
    on('enable disable', () => {
      let {
        el
      } = swiper.pagination;
      if (el) {
        el = makeElementsArray(el);
        el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));
      }
    });
    on('lock unlock', () => {
      update();
    });
    on('click', (_s, e) => {
      const targetEl = e.target;
      let {
        el
      } = swiper.pagination;
      if (!Array.isArray(el)) el = [el].filter(element => !!element);
      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
        const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
        if (isHidden === true) {
          emit('paginationShow');
        } else {
          emit('paginationHide');
        }
        el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
      }
    });
    const enable = () => {
      swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
      let {
        el
      } = swiper.pagination;
      if (el) {
        el = makeElementsArray(el);
        el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
      }
      init();
      render();
      update();
    };
    const disable = () => {
      swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
      let {
        el
      } = swiper.pagination;
      if (el) {
        el = makeElementsArray(el);
        el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
      }
      destroy();
    };
    Object.assign(swiper.pagination, {
      enable,
      disable,
      render,
      update,
      init,
      destroy
    });
  }

  function Scrollbar({
    swiper,
    extendParams,
    on,
    emit
  }) {
    const document = getDocument();
    let isTouched = false;
    let timeout = null;
    let dragTimeout = null;
    let dragStartPos;
    let dragSize;
    let trackSize;
    let divider;
    extendParams({
      scrollbar: {
        el: null,
        dragSize: 'auto',
        hide: false,
        draggable: false,
        snapOnRelease: true,
        lockClass: 'swiper-scrollbar-lock',
        dragClass: 'swiper-scrollbar-drag',
        scrollbarDisabledClass: 'swiper-scrollbar-disabled',
        horizontalClass: `swiper-scrollbar-horizontal`,
        verticalClass: `swiper-scrollbar-vertical`
      }
    });
    swiper.scrollbar = {
      el: null,
      dragEl: null
    };
    function setTranslate() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      const {
        scrollbar,
        rtlTranslate: rtl
      } = swiper;
      const {
        dragEl,
        el
      } = scrollbar;
      const params = swiper.params.scrollbar;
      const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
      let newSize = dragSize;
      let newPos = (trackSize - dragSize) * progress;
      if (rtl) {
        newPos = -newPos;
        if (newPos > 0) {
          newSize = dragSize - newPos;
          newPos = 0;
        } else if (-newPos + dragSize > trackSize) {
          newSize = trackSize + newPos;
        }
      } else if (newPos < 0) {
        newSize = dragSize + newPos;
        newPos = 0;
      } else if (newPos + dragSize > trackSize) {
        newSize = trackSize - newPos;
      }
      if (swiper.isHorizontal()) {
        dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
        dragEl.style.width = `${newSize}px`;
      } else {
        dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
        dragEl.style.height = `${newSize}px`;
      }
      if (params.hide) {
        clearTimeout(timeout);
        el.style.opacity = 1;
        timeout = setTimeout(() => {
          el.style.opacity = 0;
          el.style.transitionDuration = '400ms';
        }, 1000);
      }
    }
    function setTransition(duration) {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
    }
    function updateSize() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      const {
        scrollbar
      } = swiper;
      const {
        dragEl,
        el
      } = scrollbar;
      dragEl.style.width = '';
      dragEl.style.height = '';
      trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
      divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
      if (swiper.params.scrollbar.dragSize === 'auto') {
        dragSize = trackSize * divider;
      } else {
        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
      }
      if (swiper.isHorizontal()) {
        dragEl.style.width = `${dragSize}px`;
      } else {
        dragEl.style.height = `${dragSize}px`;
      }
      if (divider >= 1) {
        el.style.display = 'none';
      } else {
        el.style.display = '';
      }
      if (swiper.params.scrollbar.hide) {
        el.style.opacity = 0;
      }
      if (swiper.params.watchOverflow && swiper.enabled) {
        scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);
      }
    }
    function getPointerPosition(e) {
      return swiper.isHorizontal() ? e.clientX : e.clientY;
    }
    function setDragPosition(e) {
      const {
        scrollbar,
        rtlTranslate: rtl
      } = swiper;
      const {
        el
      } = scrollbar;
      let positionRatio;
      positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
      positionRatio = Math.max(Math.min(positionRatio, 1), 0);
      if (rtl) {
        positionRatio = 1 - positionRatio;
      }
      const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
      swiper.updateProgress(position);
      swiper.setTranslate(position);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    function onDragStart(e) {
      const params = swiper.params.scrollbar;
      const {
        scrollbar,
        wrapperEl
      } = swiper;
      const {
        el,
        dragEl
      } = scrollbar;
      isTouched = true;
      dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
      e.preventDefault();
      e.stopPropagation();
      wrapperEl.style.transitionDuration = '100ms';
      dragEl.style.transitionDuration = '100ms';
      setDragPosition(e);
      clearTimeout(dragTimeout);
      el.style.transitionDuration = '0ms';
      if (params.hide) {
        el.style.opacity = 1;
      }
      if (swiper.params.cssMode) {
        swiper.wrapperEl.style['scroll-snap-type'] = 'none';
      }
      emit('scrollbarDragStart', e);
    }
    function onDragMove(e) {
      const {
        scrollbar,
        wrapperEl
      } = swiper;
      const {
        el,
        dragEl
      } = scrollbar;
      if (!isTouched) return;
      if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      setDragPosition(e);
      wrapperEl.style.transitionDuration = '0ms';
      el.style.transitionDuration = '0ms';
      dragEl.style.transitionDuration = '0ms';
      emit('scrollbarDragMove', e);
    }
    function onDragEnd(e) {
      const params = swiper.params.scrollbar;
      const {
        scrollbar,
        wrapperEl
      } = swiper;
      const {
        el
      } = scrollbar;
      if (!isTouched) return;
      isTouched = false;
      if (swiper.params.cssMode) {
        swiper.wrapperEl.style['scroll-snap-type'] = '';
        wrapperEl.style.transitionDuration = '';
      }
      if (params.hide) {
        clearTimeout(dragTimeout);
        dragTimeout = nextTick(() => {
          el.style.opacity = 0;
          el.style.transitionDuration = '400ms';
        }, 1000);
      }
      emit('scrollbarDragEnd', e);
      if (params.snapOnRelease) {
        swiper.slideToClosest();
      }
    }
    function events(method) {
      const {
        scrollbar,
        params
      } = swiper;
      const el = scrollbar.el;
      if (!el) return;
      const target = el;
      const activeListener = params.passiveListeners ? {
        passive: false,
        capture: false
      } : false;
      const passiveListener = params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      if (!target) return;
      const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
      target[eventMethod]('pointerdown', onDragStart, activeListener);
      document[eventMethod]('pointermove', onDragMove, activeListener);
      document[eventMethod]('pointerup', onDragEnd, passiveListener);
    }
    function enableDraggable() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      events('on');
    }
    function disableDraggable() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      events('off');
    }
    function init() {
      const {
        scrollbar,
        el: swiperEl
      } = swiper;
      swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
        el: 'swiper-scrollbar'
      });
      const params = swiper.params.scrollbar;
      if (!params.el) return;
      let el;
      if (typeof params.el === 'string' && swiper.isElement) {
        el = swiper.el.shadowRoot.querySelector(params.el);
      }
      if (!el && typeof params.el === 'string') {
        el = document.querySelectorAll(params.el);
      } else if (!el) {
        el = params.el;
      }
      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
        el = swiperEl.querySelector(params.el);
      }
      if (el.length > 0) el = el[0];
      el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      let dragEl;
      if (el) {
        dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);
        if (!dragEl) {
          dragEl = createElement('div', swiper.params.scrollbar.dragClass);
          el.append(dragEl);
        }
      }
      Object.assign(scrollbar, {
        el,
        dragEl
      });
      if (params.draggable) {
        enableDraggable();
      }
      if (el) {
        el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);
      }
    }
    function destroy() {
      const params = swiper.params.scrollbar;
      const el = swiper.scrollbar.el;
      if (el) {
        el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      }
      disableDraggable();
    }
    on('init', () => {
      if (swiper.params.scrollbar.enabled === false) {
        // eslint-disable-next-line
        disable();
      } else {
        init();
        updateSize();
        setTranslate();
      }
    });
    on('update resize observerUpdate lock unlock', () => {
      updateSize();
    });
    on('setTranslate', () => {
      setTranslate();
    });
    on('setTransition', (_s, duration) => {
      setTransition(duration);
    });
    on('enable disable', () => {
      const {
        el
      } = swiper.scrollbar;
      if (el) {
        el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);
      }
    });
    on('destroy', () => {
      destroy();
    });
    const enable = () => {
      swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);
      if (swiper.scrollbar.el) {
        swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);
      }
      init();
      updateSize();
      setTranslate();
    };
    const disable = () => {
      swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);
      if (swiper.scrollbar.el) {
        swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);
      }
      destroy();
    };
    Object.assign(swiper.scrollbar, {
      enable,
      disable,
      updateSize,
      setTranslate,
      init,
      destroy
    });
  }

  /* eslint no-underscore-dangle: "off" */
  /* eslint no-use-before-define: "off" */
  function Autoplay({
    swiper,
    extendParams,
    on,
    emit,
    params
  }) {
    swiper.autoplay = {
      running: false,
      paused: false,
      timeLeft: 0
    };
    extendParams({
      autoplay: {
        enabled: false,
        delay: 3000,
        waitForTransition: true,
        disableOnInteraction: true,
        stopOnLastSlide: false,
        reverseDirection: false,
        pauseOnMouseEnter: false
      }
    });
    let timeout;
    let raf;
    let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;
    let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;
    let autoplayTimeLeft;
    let autoplayStartTime = new Date().getTime;
    let wasPaused;
    let isTouched;
    let pausedByTouch;
    let touchStartTimeout;
    let slideChanged;
    let pausedByInteraction;
    function onTransitionEnd(e) {
      if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
      if (e.target !== swiper.wrapperEl) return;
      swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);
      resume();
    }
    const calcTimeLeft = () => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      if (swiper.autoplay.paused) {
        wasPaused = true;
      } else if (wasPaused) {
        autoplayDelayCurrent = autoplayTimeLeft;
        wasPaused = false;
      }
      const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();
      swiper.autoplay.timeLeft = timeLeft;
      emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);
      raf = requestAnimationFrame(() => {
        calcTimeLeft();
      });
    };
    const getSlideDelay = () => {
      let activeSlideEl;
      if (swiper.virtual && swiper.params.virtual.enabled) {
        activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];
      } else {
        activeSlideEl = swiper.slides[swiper.activeIndex];
      }
      if (!activeSlideEl) return undefined;
      const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);
      return currentSlideDelay;
    };
    const run = delayForce => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      cancelAnimationFrame(raf);
      calcTimeLeft();
      let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;
      autoplayDelayTotal = swiper.params.autoplay.delay;
      autoplayDelayCurrent = swiper.params.autoplay.delay;
      const currentSlideDelay = getSlideDelay();
      if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {
        delay = currentSlideDelay;
        autoplayDelayTotal = currentSlideDelay;
        autoplayDelayCurrent = currentSlideDelay;
      }
      autoplayTimeLeft = delay;
      const speed = swiper.params.speed;
      const proceed = () => {
        if (!swiper || swiper.destroyed) return;
        if (swiper.params.autoplay.reverseDirection) {
          if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
            swiper.slidePrev(speed, true, true);
            emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            swiper.slideTo(swiper.slides.length - 1, speed, true, true);
            emit('autoplay');
          }
        } else {
          if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
            swiper.slideNext(speed, true, true);
            emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            swiper.slideTo(0, speed, true, true);
            emit('autoplay');
          }
        }
        if (swiper.params.cssMode) {
          autoplayStartTime = new Date().getTime();
          requestAnimationFrame(() => {
            run();
          });
        }
      };
      if (delay > 0) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          proceed();
        }, delay);
      } else {
        requestAnimationFrame(() => {
          proceed();
        });
      }

      // eslint-disable-next-line
      return delay;
    };
    const start = () => {
      swiper.autoplay.running = true;
      run();
      emit('autoplayStart');
    };
    const stop = () => {
      swiper.autoplay.running = false;
      clearTimeout(timeout);
      cancelAnimationFrame(raf);
      emit('autoplayStop');
    };
    const pause = (internal, reset) => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      clearTimeout(timeout);
      if (!internal) {
        pausedByInteraction = true;
      }
      const proceed = () => {
        emit('autoplayPause');
        if (swiper.params.autoplay.waitForTransition) {
          swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);
        } else {
          resume();
        }
      };
      swiper.autoplay.paused = true;
      if (reset) {
        if (slideChanged) {
          autoplayTimeLeft = swiper.params.autoplay.delay;
        }
        slideChanged = false;
        proceed();
        return;
      }
      const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
      autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);
      if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
      if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
      proceed();
    };
    const resume = () => {
      if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
      autoplayStartTime = new Date().getTime();
      if (pausedByInteraction) {
        pausedByInteraction = false;
        run(autoplayTimeLeft);
      } else {
        run();
      }
      swiper.autoplay.paused = false;
      emit('autoplayResume');
    };
    const onVisibilityChange = () => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      const document = getDocument();
      if (document.visibilityState === 'hidden') {
        pausedByInteraction = true;
        pause(true);
      }
      if (document.visibilityState === 'visible') {
        resume();
      }
    };
    const onPointerEnter = e => {
      if (e.pointerType !== 'mouse') return;
      pausedByInteraction = true;
      pause(true);
    };
    const onPointerLeave = e => {
      if (e.pointerType !== 'mouse') return;
      if (swiper.autoplay.paused) {
        resume();
      }
    };
    const attachMouseEvents = () => {
      if (swiper.params.autoplay.pauseOnMouseEnter) {
        swiper.el.addEventListener('pointerenter', onPointerEnter);
        swiper.el.addEventListener('pointerleave', onPointerLeave);
      }
    };
    const detachMouseEvents = () => {
      swiper.el.removeEventListener('pointerenter', onPointerEnter);
      swiper.el.removeEventListener('pointerleave', onPointerLeave);
    };
    const attachDocumentEvents = () => {
      const document = getDocument();
      document.addEventListener('visibilitychange', onVisibilityChange);
    };
    const detachDocumentEvents = () => {
      const document = getDocument();
      document.removeEventListener('visibilitychange', onVisibilityChange);
    };
    on('init', () => {
      if (swiper.params.autoplay.enabled) {
        attachMouseEvents();
        attachDocumentEvents();
        autoplayStartTime = new Date().getTime();
        start();
      }
    });
    on('destroy', () => {
      detachMouseEvents();
      detachDocumentEvents();
      if (swiper.autoplay.running) {
        stop();
      }
    });
    on('beforeTransitionStart', (_s, speed, internal) => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      if (internal || !swiper.params.autoplay.disableOnInteraction) {
        pause(true, true);
      } else {
        stop();
      }
    });
    on('sliderFirstMove', () => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      if (swiper.params.autoplay.disableOnInteraction) {
        stop();
        return;
      }
      isTouched = true;
      pausedByTouch = false;
      pausedByInteraction = false;
      touchStartTimeout = setTimeout(() => {
        pausedByInteraction = true;
        pausedByTouch = true;
        pause(true);
      }, 200);
    });
    on('touchEnd', () => {
      if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
      clearTimeout(touchStartTimeout);
      clearTimeout(timeout);
      if (swiper.params.autoplay.disableOnInteraction) {
        pausedByTouch = false;
        isTouched = false;
        return;
      }
      if (pausedByTouch && swiper.params.cssMode) resume();
      pausedByTouch = false;
      isTouched = false;
    });
    on('slideChange', () => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      slideChanged = true;
    });
    Object.assign(swiper.autoplay, {
      start,
      stop,
      pause,
      resume
    });
  }

  function effectInit(params) {
    const {
      effect,
      swiper,
      on,
      setTranslate,
      setTransition,
      overwriteParams,
      perspective,
      recreateShadows,
      getEffectParams
    } = params;
    on('beforeInit', () => {
      if (swiper.params.effect !== effect) return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
      if (perspective && perspective()) {
        swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      }
      const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
      Object.assign(swiper.params, overwriteParamsResult);
      Object.assign(swiper.originalParams, overwriteParamsResult);
    });
    on('setTranslate', () => {
      if (swiper.params.effect !== effect) return;
      setTranslate();
    });
    on('setTransition', (_s, duration) => {
      if (swiper.params.effect !== effect) return;
      setTransition(duration);
    });
    on('transitionEnd', () => {
      if (swiper.params.effect !== effect) return;
      if (recreateShadows) {
        if (!getEffectParams || !getEffectParams().slideShadows) return;
        // remove shadows
        swiper.slides.forEach(slideEl => {
          slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());
        });
        // create new one
        recreateShadows();
      }
    });
    let requireUpdateOnVirtual;
    on('virtualUpdate', () => {
      if (swiper.params.effect !== effect) return;
      if (!swiper.slides.length) {
        requireUpdateOnVirtual = true;
      }
      requestAnimationFrame(() => {
        if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
          setTranslate();
          requireUpdateOnVirtual = false;
        }
      });
    });
  }

  function effectTarget(effectParams, slideEl) {
    const transformEl = getSlideTransformEl(slideEl);
    if (transformEl !== slideEl) {
      transformEl.style.backfaceVisibility = 'hidden';
      transformEl.style['-webkit-backface-visibility'] = 'hidden';
    }
    return transformEl;
  }

  function effectVirtualTransitionEnd({
    swiper,
    duration,
    transformElements,
    allSlides
  }) {
    const {
      activeIndex
    } = swiper;
    const getSlide = el => {
      if (!el.parentElement) {
        // assume shadow root
        const slide = swiper.slides.filter(slideEl => slideEl.shadowEl && slideEl.shadowEl === el.parentNode)[0];
        return slide;
      }
      return el.parentElement;
    };
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      let transitionEndTarget;
      if (allSlides) {
        transitionEndTarget = transformElements;
      } else {
        transitionEndTarget = transformElements.filter(transformEl => {
          const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;
          return swiper.getSlideIndex(el) === activeIndex;
        });
      }
      transitionEndTarget.forEach(el => {
        elementTransitionEnd(el, () => {
          if (eventTriggered) return;
          if (!swiper || swiper.destroyed) return;
          eventTriggered = true;
          swiper.animating = false;
          const evt = new window.CustomEvent('transitionend', {
            bubbles: true,
            cancelable: true
          });
          swiper.wrapperEl.dispatchEvent(evt);
        });
      });
    }
  }

  function EffectFade({
    swiper,
    extendParams,
    on
  }) {
    extendParams({
      fadeEffect: {
        crossFade: false
      }
    });
    const setTranslate = () => {
      const {
        slides
      } = swiper;
      const params = swiper.params.fadeEffect;
      for (let i = 0; i < slides.length; i += 1) {
        const slideEl = swiper.slides[i];
        const offset = slideEl.swiperSlideOffset;
        let tx = -offset;
        if (!swiper.params.virtualTranslate) tx -= swiper.translate;
        let ty = 0;
        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
        }
        const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
        const targetEl = effectTarget(params, slideEl);
        targetEl.style.opacity = slideOpacity;
        targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
      }
    };
    const setTransition = duration => {
      const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
      transformElements.forEach(el => {
        el.style.transitionDuration = `${duration}ms`;
      });
      effectVirtualTransitionEnd({
        swiper,
        duration,
        transformElements,
        allSlides: true
      });
    };
    effectInit({
      effect: 'fade',
      swiper,
      on,
      setTranslate,
      setTransition,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: !swiper.params.cssMode
      })
    });
  }

  document.head.appendChild(document.createElement("style")).textContent="/**\n * Swiper 9.4.1\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: June 13, 2023\n */\n\n@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper,swiper-container{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);box-sizing:content-box}.swiper-android .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}.swiper-slide,swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-horizontal.swiper-css-mode>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-vertical.swiper-css-mode>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}.swiper-css-mode.swiper-free-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:none}.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader,.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader,swiper-container:not(.swiper-watch-progress) .swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear}.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}.swiper-lazy-preloader-black{--swiper-preloader-color:#000}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.swiper-virtual .swiper-slide{-webkit-backface-visibility:hidden;transform:translateZ(0)}.swiper-virtual.swiper-css-mode .swiper-wrapper::after{content:'';position:absolute;left:0;top:0;pointer-events:none}.swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after{height:1px;width:var(--swiper-virtual-size)}.swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after{width:1px;height:var(--swiper-virtual-size)}:root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:var(--swiper-navigation-top-offset,50%);width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next:after,.swiper-button-prev:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;font-variant:initial;line-height:1}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:var(--swiper-navigation-sides-offset,10px);right:auto}.swiper-button-prev:after,.swiper-rtl .swiper-button-next:after{content:'prev'}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:var(--swiper-navigation-sides-offset,10px);left:auto}.swiper-button-next:after,.swiper-rtl .swiper-button-prev:after{content:'next'}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:var(--swiper-pagination-bottom,8px);top:var(--swiper-pagination-top,auto);left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:var(--swiper-pagination-bullet-border-radius,50%);background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:var(--swiper-pagination-right,8px);left:var(--swiper-pagination-left,auto);top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,:host(.swiper-horizontal.swiper-rtl) .swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-fraction{color:var(--swiper-pagination-fraction-color,inherit)}.swiper-pagination-progressbar{background:var(--swiper-pagination-progressbar-bg-color,rgba(0,0,0,.25));position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:var(--swiper-pagination-progressbar-size,4px);left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:var(--swiper-pagination-progressbar-size,4px);height:100%;left:0;top:0}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:var(--swiper-scrollbar-border-radius,10px);position:relative;-ms-touch-action:none;background:var(--swiper-scrollbar-bg-color,rgba(0,0,0,.1))}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:var(--swiper-scrollbar-sides-offset,1%);bottom:var(--swiper-scrollbar-bottom,4px);top:var(--swiper-scrollbar-top,auto);z-index:50;height:var(--swiper-scrollbar-size,4px);width:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;left:var(--swiper-scrollbar-left,auto);right:var(--swiper-scrollbar-right,4px);top:var(--swiper-scrollbar-sides-offset,1%);z-index:50;width:var(--swiper-scrollbar-size,4px);height:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:var(--swiper-scrollbar-drag-bg-color,rgba(0,0,0,.5));border-radius:var(--swiper-scrollbar-border-radius,10px);left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:flex;justify-content:center;align-items:center;text-align:center}.swiper-zoom-container>canvas,.swiper-zoom-container>img,.swiper-zoom-container>svg{max-width:100%;max-height:100%;object-fit:contain}.swiper-slide-zoomed{cursor:move;touch-action:none}.swiper .swiper-notification,swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-free-mode>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}.swiper-grid>.swiper-wrapper{flex-wrap:wrap}.swiper-grid-column>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}.swiper-fade.swiper-free-mode .swiper-slide{transition-timing-function:ease-out}.swiper-fade .swiper-slide{pointer-events:none;transition-property:opacity}.swiper-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-fade .swiper-slide-active,.swiper-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-cube{overflow:visible}.swiper-cube .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-cube .swiper-slide .swiper-slide{pointer-events:none}.swiper-cube.swiper-rtl .swiper-slide{transform-origin:100% 0}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-next,.swiper-cube .swiper-slide-next+.swiper-slide,.swiper-cube .swiper-slide-prev{pointer-events:auto;visibility:visible}.swiper-cube .swiper-slide-shadow-bottom,.swiper-cube .swiper-slide-shadow-left,.swiper-cube .swiper-slide-shadow-right,.swiper-cube .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;filter:blur(50px)}.swiper-flip{overflow:visible}.swiper-flip .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-flip .swiper-slide .swiper-slide{pointer-events:none}.swiper-flip .swiper-slide-active,.swiper-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-flip .swiper-slide-shadow-bottom,.swiper-flip .swiper-slide-shadow-left,.swiper-flip .swiper-slide-shadow-right,.swiper-flip .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-creative .swiper-slide{-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper-cards{overflow:visible}.swiper-cards .swiper-slide{transform-origin:center bottom;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden}";

  function e(e,t){for(var o=0;o<t.length;o++){var n=t[o];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}function t(e){return function(e){if(Array.isArray(e))return o(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return o(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return o(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(e,t){(null==t||t>e.length)&&(t=e.length);for(var o=0,n=new Array(t);o<t;o++)n[o]=e[o];return n}var n,i,a,r,s,l=(n=["a[href]","area[href]",'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',"select:not([disabled]):not([aria-hidden])","textarea:not([disabled]):not([aria-hidden])","button:not([disabled]):not([aria-hidden])","iframe","object","embed","[contenteditable]",'[tabindex]:not([tabindex^="-"])'],i=function(){function o(e){var n=e.targetModal,i=e.triggers,a=void 0===i?[]:i,r=e.onShow,s=void 0===r?function(){}:r,l=e.onClose,c=void 0===l?function(){}:l,d=e.openTrigger,u=void 0===d?"data-micromodal-trigger":d,f=e.closeTrigger,h=void 0===f?"data-micromodal-close":f,v=e.openClass,g=void 0===v?"is-open":v,m=e.disableScroll,b=void 0!==m&&m,y=e.disableFocus,p=void 0!==y&&y,w=e.awaitCloseAnimation,E=void 0!==w&&w,k=e.awaitOpenAnimation,M=void 0!==k&&k,A=e.debugMode,C=void 0!==A&&A;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,o),this.modal=document.getElementById(n),this.config={debugMode:C,disableScroll:b,openTrigger:u,closeTrigger:h,openClass:g,onShow:s,onClose:c,awaitCloseAnimation:E,awaitOpenAnimation:M,disableFocus:p},a.length>0&&this.registerTriggers.apply(this,t(a)),this.onClick=this.onClick.bind(this),this.onKeydown=this.onKeydown.bind(this);}var i,a;return i=o,(a=[{key:"registerTriggers",value:function(){for(var e=this,t=arguments.length,o=new Array(t),n=0;n<t;n++)o[n]=arguments[n];o.filter(Boolean).forEach((function(t){t.addEventListener("click",(function(t){return e.showModal(t)}));}));}},{key:"showModal",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(this.activeElement=document.activeElement,this.modal.setAttribute("aria-hidden","false"),this.modal.classList.add(this.config.openClass),this.scrollBehaviour("disable"),this.addEventListeners(),this.config.awaitOpenAnimation){var o=function t(){e.modal.removeEventListener("animationend",t,!1),e.setFocusToFirstNode();};this.modal.addEventListener("animationend",o,!1);}else this.setFocusToFirstNode();this.config.onShow(this.modal,this.activeElement,t);}},{key:"closeModal",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=this.modal;if(this.modal.setAttribute("aria-hidden","true"),this.removeEventListeners(),this.scrollBehaviour("enable"),this.activeElement&&this.activeElement.focus&&this.activeElement.focus(),this.config.onClose(this.modal,this.activeElement,e),this.config.awaitCloseAnimation){var o=this.config.openClass;this.modal.addEventListener("animationend",(function e(){t.classList.remove(o),t.removeEventListener("animationend",e,!1);}),!1);}else t.classList.remove(this.config.openClass);}},{key:"closeModalById",value:function(e){this.modal=document.getElementById(e),this.modal&&this.closeModal();}},{key:"scrollBehaviour",value:function(e){if(this.config.disableScroll){var t=document.querySelector("body");switch(e){case"enable":Object.assign(t.style,{overflow:""});break;case"disable":Object.assign(t.style,{overflow:"hidden"});}}}},{key:"addEventListeners",value:function(){this.modal.addEventListener("touchstart",this.onClick),this.modal.addEventListener("click",this.onClick),document.addEventListener("keydown",this.onKeydown);}},{key:"removeEventListeners",value:function(){this.modal.removeEventListener("touchstart",this.onClick),this.modal.removeEventListener("click",this.onClick),document.removeEventListener("keydown",this.onKeydown);}},{key:"onClick",value:function(e){(e.target.hasAttribute(this.config.closeTrigger)||e.target.parentNode.hasAttribute(this.config.closeTrigger))&&(e.preventDefault(),e.stopPropagation(),this.closeModal(e));}},{key:"onKeydown",value:function(e){27===e.keyCode&&this.closeModal(e),9===e.keyCode&&this.retainFocus(e);}},{key:"getFocusableNodes",value:function(){var e=this.modal.querySelectorAll(n);return Array.apply(void 0,t(e))}},{key:"setFocusToFirstNode",value:function(){var e=this;if(!this.config.disableFocus){var t=this.getFocusableNodes();if(0!==t.length){var o=t.filter((function(t){return !t.hasAttribute(e.config.closeTrigger)}));o.length>0&&o[0].focus(),0===o.length&&t[0].focus();}}}},{key:"retainFocus",value:function(e){var t=this.getFocusableNodes();if(0!==t.length)if(t=t.filter((function(e){return null!==e.offsetParent})),this.modal.contains(document.activeElement)){var o=t.indexOf(document.activeElement);e.shiftKey&&0===o&&(t[t.length-1].focus(),e.preventDefault()),!e.shiftKey&&t.length>0&&o===t.length-1&&(t[0].focus(),e.preventDefault());}else t[0].focus();}}])&&e(i.prototype,a),o}(),a=null,r=function(e){if(!document.getElementById(e))return console.warn("MicroModal: Seems like you have missed %c'".concat(e,"'"),"background-color: #f8f9fa;color: #50596c;font-weight: bold;","ID somewhere in your code. Refer example below to resolve it."),console.warn("%cExample:","background-color: #f8f9fa;color: #50596c;font-weight: bold;",'<div class="modal" id="'.concat(e,'"></div>')),!1},s=function(e,t){if(function(e){e.length<=0&&(console.warn("MicroModal: Please specify at least one %c'micromodal-trigger'","background-color: #f8f9fa;color: #50596c;font-weight: bold;","data attribute."),console.warn("%cExample:","background-color: #f8f9fa;color: #50596c;font-weight: bold;",'<a href="#" data-micromodal-trigger="my-modal"></a>'));}(e),!t)return !0;for(var o in t)r(o);return !0},{init:function(e){var o=Object.assign({},{openTrigger:"data-micromodal-trigger"},e),n=t(document.querySelectorAll("[".concat(o.openTrigger,"]"))),r=function(e,t){var o=[];return e.forEach((function(e){var n=e.attributes[t].value;void 0===o[n]&&(o[n]=[]),o[n].push(e);})),o}(n,o.openTrigger);if(!0!==o.debugMode||!1!==s(n,r))for(var l in r){var c=r[l];o.targetModal=l,o.triggers=t(c),a=new i(o);}},show:function(e,t){var o=t||{};o.targetModal=e,!0===o.debugMode&&!1===r(e)||(a&&a.removeEventListeners(),(a=new i(o)).showModal());},close:function(e){e?a.closeModalById(e):a.closeModal();}});"undefined"!=typeof window&&(window.MicroModal=l);

  Swiper.use([Navigation, Pagination, Autoplay, Scrollbar, EffectFade]);
  var Page = /*#__PURE__*/function () {
    function Page() {
      _classCallCheck(this, Page);
      gsapWithCSS.registerPlugin(ScrollTrigger$1, ScrollToPlugin, DrawSVGPlugin);
      this.settings = {
        swipers: [],
        eventListeners: [],
        scrollY: 0
      };
      // this.cHeadingSection()
      if (document.querySelector('.cm-post')) {
        this.cmPost();
        if (document.querySelector('.cm-post--creative')) {
          this.cmPostCreative();
        }
      }
      if (document.querySelector('.cm-block-media-youtube')) {
        this.cmBlockMediaYoutube();
      }
      if (document.querySelector('.p-top-service')) {
        this.pTopService();
      }
      if (document.querySelector('.p-top-creative__list') && Utility.isPC()) {
        this.pTopCreative();
      }
      if (document.querySelector('.p-company-member__list')) {
        this.pCompanyModal();
      }
      if (document.querySelector('.p-media-pickup')) {
        this.pMediaPickup();
      }
      if (document.querySelector('.cm-modal-blog')) {
        this.cmModalBlog();
      }
    }
    // cHeadingSection() {
    //
    // }
    return _createClass$1(Page, [{
      key: "cmPost",
      value: function cmPost() {
        // 
        document.querySelectorAll('.single-media__card-more').forEach(function (button) {
          button.addEventListener('click', function () {
            var card = button.closest('.single-media__card');
            if (!card) return;
            var text = card.querySelector('.single-media__card-text--hidden');
            if (text) {
              text.classList.remove('single-media__card-text--hidden');
            }
            button.remove();
          });
        });
        // 
        document.querySelectorAll('a.wp-block-button__link').forEach(function (el) {
          // ->
          if (el.textContent.includes('->')) {
            el.textContent = el.textContent.replace(/->/g, '').trim();
          }
          // 
          var icon = document.createElement('i');
          icon.className = 'c-btn-more__arrow';
          icon.innerHTML = "\n    <svg width=\"40\" height=\"40\">\n      <use href=\"#ico-arrow\"></use>\n    </svg>\n    ";
          el.appendChild(icon);
        });
      }
    }, {
      key: "cmPostCreative",
      value: function cmPostCreative() {
        // H2
        document.querySelectorAll('.cm-post h2').forEach(function (h2) {
          if (h2.textContent.trim().startsWith("(")) return;
          h2.innerHTML = "(".concat(h2.innerHTML.trim(), ")");
          h2.classList.add("is-bracketed");
        });
        // 
        document.querySelectorAll('.cm-post a[rel="noopener"]:not(.c-link-arrow)').forEach(function (link) {
          var text = link.textContent.trim();
          link.innerHTML = '';
          link.classList.add('c-link-arrow');

          // 
          var span = document.createElement('span');
          span.className = 'c-link-arrow__txt';
          span.textContent = text;
          link.appendChild(span);

          // 
          var icon = document.createElement('i');
          icon.className = 'c-link-arrow__arrow';
          icon.innerHTML = '<svg width="40" height="40"><use href="#ico-arrow"></use></svg>';
          link.appendChild(icon);
        });
      }
    }, {
      key: "cmBlockMediaYoutube",
      value: function cmBlockMediaYoutube() {
        new Swiper('.cm-block-media-youtube .swiper', {
          loop: true,
          loopAdditionalSlides: 1,
          slidesPerView: 1,
          spaceBetween: 16,
          pagination: {
            el: '.cm-block-media-youtube__paginate'
          },
          breakpoints: {
            1024: {
              slidesPerView: 3,
              spaceBetween: 24
            }
          }
        });
      }
    }, {
      key: "pTopService",
      value: function pTopService() {
        gsapWithCSS.fromTo(gsapWithCSS.utils.toArray('.p-top-service__bg svg path'), {
          drawSVG: "0 0"
        }, {
          scrollTrigger: {
            trigger: '.p-top-service',
            start: 'top top',
            markers: false
          },
          duration: 20,
          stagger: 0.5,
          drawSVG: "100% 0",
          ease: 'power3.out'
        });
        ScrollTrigger$1.create({
          trigger: '.p-top-service',
          start: 'top top',
          //end: `bottom-=${200/1440*window.innerWidth} bottom`,
          end: "bottom bottom",
          pin: '.p-top-service__bg',
          pinSpacing: false,
          markers: false
        });
        if (Utility.isPC()) {
          ScrollTrigger$1.create({
            trigger: '.p-top-service',
            start: 'top top',
            end: 'bottom bottom',
            pin: '.p-top-service__head',
            pinSpacing: false,
            markers: false
          });
        }
      }
    }, {
      key: "pTopCreative",
      value: function pTopCreative() {
        var xTo = gsapWithCSS.quickTo('.p-top-creative__figure figure', "x", {
          duration: 0.4,
          ease: "power3"
        });
        var yTo = gsapWithCSS.quickTo('.p-top-creative__figure figure', "y", {
          duration: 0.4,
          ease: "power3"
        });
        document.addEventListener("mousemove", moveElement);
        function moveElement(e) {
          var shift = document.querySelector('.p-top-creative__figure figure').offsetHeight / 2;
          xTo(e.clientX + 40 / 1600 * window.innerWidth);
          yTo(e.clientY - shift);
        }
        $$1('.p-top-creative__list li').on('mouseenter', function () {
          var index = $$1(this).index();
          $$1('.p-top-creative__figure figure').css('opacity', 0);
          $$1('.p-top-creative__figure figure').eq(index).css('opacity', 1);
        });
        $$1('.p-top-creative__list').on('mouseleave', function () {
          $$1('.p-top-creative__figure figure').css('opacity', 0);
        });
        this.settings.eventListeners.push({
          element: document,
          event: "mousemove",
          handler: moveElement
        });
      }
    }, {
      key: "pCompanyModal",
      value: function pCompanyModal() {
        l.init({
          onClose: function onClose(modal) {
            // 
            var img = modal.querySelector('.cm-modal-member__pic img');
            if (img) {
              img.src = '';
            }
          }
        });
        var jsonDataElement = document.getElementById('memberData');
        var modal = document.getElementById('modal-member');
        if ($$1('.c-btn-member').length && jsonDataElement && modal) {
          var updateModal = function updateModal(order) {
            var member = memberData.find(function (item) {
              return item.order === order;
            });
            if (!member) return;
            gsapWithCSS.timeline({
              defaults: {
                ease: 'none'
              }
            }).to('.cm-modal-member', {
              opacity: 0,
              duration: 0.3,
              ease: 'power3.out'
            }).add(function () {
              // DOM
              document.querySelector(".cm-modal-member__pic img").src = member['pic'];
              document.querySelector(".cm-modal-member #job").textContent = member.job;
              document.querySelector(".cm-modal-member #name").textContent = member.name;
              document.querySelector(".cm-modal-member #message p").innerHTML = member.message;
            }).to('.cm-modal-member', {
              opacity: 1,
              delay: 0.1,
              duration: 0.3,
              ease: 'power3.out'
            });
          };
          var memberData = JSON.parse(jsonDataElement.textContent);
          var preloadedImages = {};
          if (memberData) {
            memberData.forEach(function (member) {
              if (member['pic']) {
                var img = new Image();
                img.src = member['pic'];
                preloadedImages[member.order] = img;
              }
            });
          }
          document.querySelectorAll(".c-btn-member").forEach(function (button) {
            button.addEventListener("click", function () {
              var order = parseInt(button.getAttribute("data-order"));
              updateModal(order);
            });
          });
        }
      }
    }, {
      key: "pMediaPickup",
      value: function pMediaPickup() {
        new Swiper('.p-media-pickup .swiper', {
          loop: true,
          loopAdditionalSlides: 1,
          slidesPerView: 1,
          spaceBetween: 12,
          initialSlide: 1,
          pagination: {
            el: '.p-media-pickup__paginate'
          },
          breakpoints: {
            1024: {
              spaceBetween: 36
            }
          }
        });
      }
    }, {
      key: "cmModalBlog",
      value: function cmModalBlog() {
        document.addEventListener('DOMContentLoaded', function () {
          l.init();
          var isOpened = false;
          window.addEventListener('scroll', function () {
            if (isOpened) return;
            if (window.scrollY > window.innerHeight) {
              l.show('modal-blog');
              isOpened = true;
            }
          });
        });
      }
    }]);
  }();

  /**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  const REVISION = '180';

  /**
   * Represents mouse buttons and interaction types in context of controls.
   *
   * @type {ConstantsMouse}
   * @constant
   */
  const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };

  /**
   * Represents touch interaction types in context of controls.
   *
   * @type {ConstantsTouch}
   * @constant
   */
  const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };

  /**
   * Disables face culling.
   *
   * @type {number}
   * @constant
   */
  const CullFaceNone = 0;

  /**
   * Culls back faces.
   *
   * @type {number}
   * @constant
   */
  const CullFaceBack = 1;

  /**
   * Culls front faces.
   *
   * @type {number}
   * @constant
   */
  const CullFaceFront = 2;

  /**
   * Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm.
   *
   * @type {number}
   * @constant
   */
  const PCFShadowMap = 1;

  /**
   * Filters shadow maps using the Percentage-Closer Filtering (PCF) algorithm with
   * better soft shadows especially when using low-resolution shadow maps.
   *
   * @type {number}
   * @constant
   */
  const PCFSoftShadowMap = 2;

  /**
   * Filters shadow maps using the Variance Shadow Map (VSM) algorithm.
   * When using VSMShadowMap all shadow receivers will also cast shadows.
   *
   * @type {number}
   * @constant
   */
  const VSMShadowMap = 3;

  /**
   * Only front faces are rendered.
   *
   * @type {number}
   * @constant
   */
  const FrontSide = 0;

  /**
   * Only back faces are rendered.
   *
   * @type {number}
   * @constant
   */
  const BackSide = 1;

  /**
   * Both front and back faces are rendered.
   *
   * @type {number}
   * @constant
   */
  const DoubleSide = 2;

  /**
   * No blending is performed which effectively disables
   * alpha transparency.
   *
   * @type {number}
   * @constant
   */
  const NoBlending = 0;

  /**
   * The default blending.
   *
   * @type {number}
   * @constant
   */
  const NormalBlending = 1;

  /**
   * Represents additive blending.
   *
   * @type {number}
   * @constant
   */
  const AdditiveBlending = 2;

  /**
   * Represents subtractive blending.
   *
   * @type {number}
   * @constant
   */
  const SubtractiveBlending = 3;

  /**
   * Represents multiply blending.
   *
   * @type {number}
   * @constant
   */
  const MultiplyBlending = 4;

  /**
   * Represents custom blending.
   *
   * @type {number}
   * @constant
   */
  const CustomBlending = 5;

  /**
   * A `source + destination` blending equation.
   *
   * @type {number}
   * @constant
   */
  const AddEquation = 100;

  /**
   * A `source - destination` blending equation.
   *
   * @type {number}
   * @constant
   */
  const SubtractEquation = 101;

  /**
   * A `destination - source` blending equation.
   *
   * @type {number}
   * @constant
   */
  const ReverseSubtractEquation = 102;

  /**
   * A blend equation that uses the minimum of source and destination.
   *
   * @type {number}
   * @constant
   */
  const MinEquation = 103;

  /**
   * A blend equation that uses the maximum of source and destination.
   *
   * @type {number}
   * @constant
   */
  const MaxEquation = 104;

  /**
   * Multiplies all colors by `0`.
   *
   * @type {number}
   * @constant
   */
  const ZeroFactor = 200;

  /**
   * Multiplies all colors by `1`.
   *
   * @type {number}
   * @constant
   */
  const OneFactor = 201;

  /**
   * Multiplies all colors by the source colors.
   *
   * @type {number}
   * @constant
   */
  const SrcColorFactor = 202;

  /**
   * Multiplies all colors by `1` minus each source color.
   *
   * @type {number}
   * @constant
   */
  const OneMinusSrcColorFactor = 203;

  /**
   * Multiplies all colors by the source alpha value.
   *
   * @type {number}
   * @constant
   */
  const SrcAlphaFactor = 204;

  /**
   * Multiplies all colors by 1 minus the source alpha value.
   *
   * @type {number}
   * @constant
   */
  const OneMinusSrcAlphaFactor = 205;

  /**
   * Multiplies all colors by the destination alpha value.
   *
   * @type {number}
   * @constant
   */
  const DstAlphaFactor = 206;

  /**
   * Multiplies all colors by `1` minus the destination alpha value.
   *
   * @type {number}
   * @constant
   */
  const OneMinusDstAlphaFactor = 207;

  /**
   * Multiplies all colors by the destination color.
   *
   * @type {number}
   * @constant
   */
  const DstColorFactor = 208;

  /**
   * Multiplies all colors by `1` minus each destination color.
   *
   * @type {number}
   * @constant
   */
  const OneMinusDstColorFactor = 209;

  /**
   * Multiplies the RGB colors by the smaller of either the source alpha
   * value or the value of `1` minus the destination alpha value. The alpha
   * value is multiplied by `1`.
   *
   * @type {number}
   * @constant
   */
  const SrcAlphaSaturateFactor = 210;

  /**
   * Multiplies all colors by a constant color.
   *
   * @type {number}
   * @constant
   */
  const ConstantColorFactor = 211;

  /**
   * Multiplies all colors by `1` minus a constant color.
   *
   * @type {number}
   * @constant
   */
  const OneMinusConstantColorFactor = 212;

  /**
   * Multiplies all colors by a constant alpha value.
   *
   * @type {number}
   * @constant
   */
  const ConstantAlphaFactor = 213;

  /**
   * Multiplies all colors by 1 minus a constant alpha value.
   *
   * @type {number}
   * @constant
   */
  const OneMinusConstantAlphaFactor = 214;

  /**
   * Never pass.
   *
   * @type {number}
   * @constant
   */
  const NeverDepth = 0;

  /**
   * Always pass.
   *
   * @type {number}
   * @constant
   */
  const AlwaysDepth = 1;

  /**
   * Pass if the incoming value is less than the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const LessDepth = 2;

  /**
   * Pass if the incoming value is less than or equal to the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const LessEqualDepth = 3;

  /**
   * Pass if the incoming value equals the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const EqualDepth = 4;

  /**
   * Pass if the incoming value is greater than or equal to the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const GreaterEqualDepth = 5;

  /**
   * Pass if the incoming value is greater than the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const GreaterDepth = 6;

  /**
   * Pass if the incoming value is not equal to the depth buffer value.
   *
   * @type {number}
   * @constant
   */
  const NotEqualDepth = 7;

  /**
   * Multiplies the environment map color with the surface color.
   *
   * @type {number}
   * @constant
   */
  const MultiplyOperation = 0;

  /**
   * Uses reflectivity to blend between the two colors.
   *
   * @type {number}
   * @constant
   */
  const MixOperation = 1;

  /**
   * Adds the two colors.
   *
   * @type {number}
   * @constant
   */
  const AddOperation = 2;

  /**
   * No tone mapping is applied.
   *
   * @type {number}
   * @constant
   */
  const NoToneMapping = 0;

  /**
   * Linear tone mapping.
   *
   * @type {number}
   * @constant
   */
  const LinearToneMapping = 1;

  /**
   * Reinhard tone mapping.
   *
   * @type {number}
   * @constant
   */
  const ReinhardToneMapping = 2;

  /**
   * Cineon tone mapping.
   *
   * @type {number}
   * @constant
   */
  const CineonToneMapping = 3;

  /**
   * ACES Filmic tone mapping.
   *
   * @type {number}
   * @constant
   */
  const ACESFilmicToneMapping = 4;

  /**
   * Custom tone mapping.
   *
   * Expects a custom implementation by modifying shader code of the material's fragment shader.
   *
   * @type {number}
   * @constant
   */
  const CustomToneMapping = 5;

  /**
   * AgX tone mapping.
   *
   * @type {number}
   * @constant
   */
  const AgXToneMapping = 6;

  /**
   * Neutral tone mapping.
   *
   * Implementation based on the Khronos 3D Commerce Group standard tone mapping.
   *
   * @type {number}
   * @constant
   */
  const NeutralToneMapping = 7;

  /**
   * The skinned mesh shares the same world space as the skeleton.
   *
   * @type {string}
   * @constant
   */
  const AttachedBindMode = 'attached';

  /**
   * The skinned mesh does not share the same world space as the skeleton.
   * This is useful when a skeleton is shared across multiple skinned meshes.
   *
   * @type {string}
   * @constant
   */
  const DetachedBindMode = 'detached';

  /**
   * Maps textures using the geometry's UV coordinates.
   *
   * @type {number}
   * @constant
   */
  const UVMapping = 300;

  /**
   * Reflection mapping for cube textures.
   *
   * @type {number}
   * @constant
   */
  const CubeReflectionMapping = 301;

  /**
   * Refraction mapping for cube textures.
   *
   * @type {number}
   * @constant
   */
  const CubeRefractionMapping = 302;

  /**
   * Reflection mapping for equirectangular textures.
   *
   * @type {number}
   * @constant
   */
  const EquirectangularReflectionMapping = 303;

  /**
   * Refraction mapping for equirectangular textures.
   *
   * @type {number}
   * @constant
   */
  const EquirectangularRefractionMapping = 304;

  /**
   * Reflection mapping for PMREM textures.
   *
   * @type {number}
   * @constant
   */
  const CubeUVReflectionMapping = 306;

  /**
   * The texture will simply repeat to infinity.
   *
   * @type {number}
   * @constant
   */
  const RepeatWrapping = 1000;

  /**
   * The last pixel of the texture stretches to the edge of the mesh.
   *
   * @type {number}
   * @constant
   */
  const ClampToEdgeWrapping = 1001;

  /**
   * The texture will repeats to infinity, mirroring on each repeat.
   *
   * @type {number}
   * @constant
   */
  const MirroredRepeatWrapping = 1002;

  /**
   * Returns the value of the texture element that is nearest (in Manhattan distance)
   * to the specified texture coordinates.
   *
   * @type {number}
   * @constant
   */
  const NearestFilter = 1003;

  /**
   * Chooses the mipmap that most closely matches the size of the pixel being textured
   * and uses the `NearestFilter` criterion (the texel nearest to the center of the pixel)
   * to produce a texture value.
   *
   * @type {number}
   * @constant
   */
  const NearestMipmapNearestFilter = 1004;

  /**
   * Chooses the two mipmaps that most closely match the size of the pixel being textured and
   * uses the `NearestFilter` criterion to produce a texture value from each mipmap.
   * The final texture value is a weighted average of those two values.
   *
   * @type {number}
   * @constant
   */
  const NearestMipmapLinearFilter = 1005;

  /**
   * Returns the weighted average of the four texture elements that are closest to the specified
   * texture coordinates, and can include items wrapped or repeated from other parts of a texture,
   * depending on the values of `wrapS` and `wrapT`, and on the exact mapping.
   *
   * @type {number}
   * @constant
   */
  const LinearFilter = 1006;

  /**
   * Chooses the mipmap that most closely matches the size of the pixel being textured and uses
   * the `LinearFilter` criterion (a weighted average of the four texels that are closest to the
   * center of the pixel) to produce a texture value.
   *
   * @type {number}
   * @constant
   */
  const LinearMipmapNearestFilter = 1007;

  /**
   * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses
   * the `LinearFilter` criterion to produce a texture value from each mipmap. The final texture value
   * is a weighted average of those two values.
   *
   * @type {number}
   * @constant
   */
  const LinearMipmapLinearFilter = 1008;

  /**
   * An unsigned byte data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedByteType = 1009;

  /**
   * A byte data type for textures.
   *
   * @type {number}
   * @constant
   */
  const ByteType = 1010;

  /**
   * A short data type for textures.
   *
   * @type {number}
   * @constant
   */
  const ShortType = 1011;

  /**
   * An unsigned short data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedShortType = 1012;

  /**
   * An int data type for textures.
   *
   * @type {number}
   * @constant
   */
  const IntType = 1013;

  /**
   * An unsigned int data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedIntType = 1014;

  /**
   * A float data type for textures.
   *
   * @type {number}
   * @constant
   */
  const FloatType = 1015;

  /**
   * A half float data type for textures.
   *
   * @type {number}
   * @constant
   */
  const HalfFloatType = 1016;

  /**
   * An unsigned short 4_4_4_4 (packed) data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedShort4444Type = 1017;

  /**
   * An unsigned short 5_5_5_1 (packed) data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedShort5551Type = 1018;

  /**
   * An unsigned int 24_8 data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedInt248Type = 1020;

  /**
   * An unsigned int 5_9_9_9 (packed) data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedInt5999Type = 35902;

  /**
   * An unsigned int 10_11_11 (packed) data type for textures.
   *
   * @type {number}
   * @constant
   */
  const UnsignedInt101111Type = 35899;

  /**
   * Discards the red, green and blue components and reads just the alpha component.
   *
   * @type {number}
   * @constant
   */
  const AlphaFormat = 1021;

  /**
   * Discards the alpha component and reads the red, green and blue component.
   *
   * @type {number}
   * @constant
   */
  const RGBFormat = 1022;

  /**
   * Reads the red, green, blue and alpha components.
   *
   * @type {number}
   * @constant
   */
  const RGBAFormat = 1023;

  /**
   * Reads each element as a single depth value, converts it to floating point, and clamps to the range `[0,1]`.
   *
   * @type {number}
   * @constant
   */
  const DepthFormat = 1026;

  /**
   * Reads each element is a pair of depth and stencil values. The depth component of the pair is interpreted as
   * in `DepthFormat`. The stencil component is interpreted based on the depth + stencil internal format.
   *
   * @type {number}
   * @constant
   */
  const DepthStencilFormat = 1027;

  /**
   * Discards the green, blue and alpha components and reads just the red component.
   *
   * @type {number}
   * @constant
   */
  const RedFormat = 1028;

  /**
   * Discards the green, blue and alpha components and reads just the red component. The texels are read as integers instead of floating point.
   *
   * @type {number}
   * @constant
   */
  const RedIntegerFormat = 1029;

  /**
   * Discards the alpha, and blue components and reads the red, and green components.
   *
   * @type {number}
   * @constant
   */
  const RGFormat = 1030;

  /**
   * Discards the alpha, and blue components and reads the red, and green components. The texels are read as integers instead of floating point.
   *
   * @type {number}
   * @constant
   */
  const RGIntegerFormat = 1031;

  /**
   * Reads the red, green, blue and alpha components. The texels are read as integers instead of floating point.
   *
   * @type {number}
   * @constant
   */
  const RGBAIntegerFormat = 1033;

  /**
   * A DXT1-compressed image in an RGB image format.
   *
   * @type {number}
   * @constant
   */
  const RGB_S3TC_DXT1_Format = 33776;

  /**
   * A DXT1-compressed image in an RGB image format with a simple on/off alpha value.
   *
   * @type {number}
   * @constant
   */
  const RGBA_S3TC_DXT1_Format = 33777;

  /**
   * A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.
   *
   * @type {number}
   * @constant
   */
  const RGBA_S3TC_DXT3_Format = 33778;

  /**
   * A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3
   * compression in how the alpha compression is done.
   *
   * @type {number}
   * @constant
   */
  const RGBA_S3TC_DXT5_Format = 33779;

  /**
   * PVRTC RGB compression in 4-bit mode. One block for each 44 pixels.
   *
   * @type {number}
   * @constant
   */
  const RGB_PVRTC_4BPPV1_Format = 35840;

  /**
   * PVRTC RGB compression in 2-bit mode. One block for each 84 pixels.
   *
   * @type {number}
   * @constant
   */
  const RGB_PVRTC_2BPPV1_Format = 35841;

  /**
   * PVRTC RGBA compression in 4-bit mode. One block for each 44 pixels.
   *
   * @type {number}
   * @constant
   */
  const RGBA_PVRTC_4BPPV1_Format = 35842;

  /**
   * PVRTC RGBA compression in 2-bit mode. One block for each 84 pixels.
   *
   * @type {number}
   * @constant
   */
  const RGBA_PVRTC_2BPPV1_Format = 35843;

  /**
   * ETC1 RGB format.
   *
   * @type {number}
   * @constant
   */
  const RGB_ETC1_Format = 36196;

  /**
   * ETC2 RGB format.
   *
   * @type {number}
   * @constant
   */
  const RGB_ETC2_Format = 37492;

  /**
   * ETC2 RGBA format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ETC2_EAC_Format = 37496;

  /**
   * ASTC RGBA 4x4 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_4x4_Format = 37808;

  /**
   * ASTC RGBA 5x4 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_5x4_Format = 37809;

  /**
   * ASTC RGBA 5x5 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_5x5_Format = 37810;

  /**
   * ASTC RGBA 6x5 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_6x5_Format = 37811;

  /**
   * ASTC RGBA 6x6 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_6x6_Format = 37812;

  /**
   * ASTC RGBA 8x5 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_8x5_Format = 37813;

  /**
   * ASTC RGBA 8x6 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_8x6_Format = 37814;

  /**
   * ASTC RGBA 8x8 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_8x8_Format = 37815;

  /**
   * ASTC RGBA 10x5 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_10x5_Format = 37816;

  /**
   * ASTC RGBA 10x6 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_10x6_Format = 37817;

  /**
   * ASTC RGBA 10x8 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_10x8_Format = 37818;

  /**
   * ASTC RGBA 10x10 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_10x10_Format = 37819;

  /**
   * ASTC RGBA 12x10 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_12x10_Format = 37820;

  /**
   * ASTC RGBA 12x12 format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_ASTC_12x12_Format = 37821;

  /**
   * BPTC RGBA format.
   *
   * @type {number}
   * @constant
   */
  const RGBA_BPTC_Format = 36492;

  /**
   * BPTC Signed RGB format.
   *
   * @type {number}
   * @constant
   */
  const RGB_BPTC_SIGNED_Format = 36494;

  /**
   * BPTC Unsigned RGB format.
   *
   * @type {number}
   * @constant
   */
  const RGB_BPTC_UNSIGNED_Format = 36495;

  /**
   * RGTC1 Red format.
   *
   * @type {number}
   * @constant
   */
  const RED_RGTC1_Format = 36283;

  /**
   * RGTC1 Signed Red format.
   *
   * @type {number}
   * @constant
   */
  const SIGNED_RED_RGTC1_Format = 36284;

  /**
   * RGTC2 Red Green format.
   *
   * @type {number}
   * @constant
   */
  const RED_GREEN_RGTC2_Format = 36285;

  /**
   * RGTC2 Signed Red Green format.
   *
   * @type {number}
   * @constant
   */
  const SIGNED_RED_GREEN_RGTC2_Format = 36286;

  /**
   * Discrete interpolation mode for keyframe tracks.
   *
   * @type {number}
   * @constant
   */
  const InterpolateDiscrete = 2300;

  /**
   * Linear interpolation mode for keyframe tracks.
   *
   * @type {number}
   * @constant
   */
  const InterpolateLinear = 2301;

  /**
   * Smooth interpolation mode for keyframe tracks.
   *
   * @type {number}
   * @constant
   */
  const InterpolateSmooth = 2302;

  /**
   * Zero curvature ending for animations.
   *
   * @type {number}
   * @constant
   */
  const ZeroCurvatureEnding = 2400;

  /**
   * Zero slope ending for animations.
   *
   * @type {number}
   * @constant
   */
  const ZeroSlopeEnding = 2401;

  /**
   * Wrap around ending for animations.
   *
   * @type {number}
   * @constant
   */
  const WrapAroundEnding = 2402;

  /**
   * Default animation blend mode.
   *
   * @type {number}
   * @constant
   */
  const NormalAnimationBlendMode = 2500;

  /**
   * For every three vertices draw a single triangle.
   *
   * @type {number}
   * @constant
   */
  const TrianglesDrawMode = 0;

  /**
   * For each vertex draw a triangle from the last three vertices.
   *
   * @type {number}
   * @constant
   */
  const TriangleStripDrawMode = 1;

  /**
   * For each vertex draw a triangle from the first vertex and the last two vertices.
   *
   * @type {number}
   * @constant
   */
  const TriangleFanDrawMode = 2;

  /**
   * Basic depth packing.
   *
   * @type {number}
   * @constant
   */
  const BasicDepthPacking = 3200;

  /**
   * A depth value is packed into 32 bit RGBA.
   *
   * @type {number}
   * @constant
   */
  const RGBADepthPacking = 3201;

  /**
   * Normal information is relative to the underlying surface.
   *
   * @type {number}
   * @constant
   */
  const TangentSpaceNormalMap = 0;

  /**
   * Normal information is relative to the object orientation.
   *
   * @type {number}
   * @constant
   */
  const ObjectSpaceNormalMap = 1;

  // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.

  /**
   * No color space.
   *
   * @type {string}
   * @constant
   */
  const NoColorSpace = '';

  /**
   * sRGB color space.
   *
   * @type {string}
   * @constant
   */
  const SRGBColorSpace = 'srgb';

  /**
   * sRGB-linear color space.
   *
   * @type {string}
   * @constant
   */
  const LinearSRGBColorSpace = 'srgb-linear';

  /**
   * Linear transfer function.
   *
   * @type {string}
   * @constant
   */
  const LinearTransfer = 'linear';

  /**
   * sRGB transfer function.
   *
   * @type {string}
   * @constant
   */
  const SRGBTransfer = 'srgb';

  /**
   * Keeps the current value.
   *
   * @type {number}
   * @constant
   */
  const KeepStencilOp = 7680;

  /**
   * Will always return true.
   *
   * @type {number}
   * @constant
   */
  const AlwaysStencilFunc = 519;

  /**
   * Never pass.
   *
   * @type {number}
   * @constant
   */
  const NeverCompare = 512;

  /**
   * Pass if the incoming value is less than the texture value.
   *
   * @type {number}
   * @constant
   */
  const LessCompare = 513;

  /**
   * Pass if the incoming value equals the texture value.
   *
   * @type {number}
   * @constant
   */
  const EqualCompare = 514;

  /**
   * Pass if the incoming value is less than or equal to the texture value.
   *
   * @type {number}
   * @constant
   */
  const LessEqualCompare = 515;

  /**
   * Pass if the incoming value is greater than the texture value.
   *
   * @type {number}
   * @constant
   */
  const GreaterCompare = 516;

  /**
   * Pass if the incoming value is not equal to the texture value.
   *
   * @type {number}
   * @constant
   */
  const NotEqualCompare = 517;

  /**
   * Pass if the incoming value is greater than or equal to the texture value.
   *
   * @type {number}
   * @constant
   */
  const GreaterEqualCompare = 518;

  /**
   * Always pass.
   *
   * @type {number}
   * @constant
   */
  const AlwaysCompare = 519;

  /**
   * The contents are intended to be specified once by the application, and used many
   * times as the source for drawing and image specification commands.
   *
   * @type {number}
   * @constant
   */
  const StaticDrawUsage = 35044;

  /**
   * GLSL 3 shader code.
   *
   * @type {string}
   * @constant
   */
  const GLSL3 = '300 es';

  /**
   * WebGL coordinate system.
   *
   * @type {number}
   * @constant
   */
  const WebGLCoordinateSystem = 2000;

  /**
   * WebGPU coordinate system.
   *
   * @type {number}
   * @constant
   */
  const WebGPUCoordinateSystem = 2001;

  /**
   * This type represents mouse buttons and interaction types in context of controls.
   *
   * @typedef {Object} ConstantsMouse
   * @property {number} MIDDLE - The left mouse button.
   * @property {number} LEFT - The middle mouse button.
   * @property {number} RIGHT - The right mouse button.
   * @property {number} ROTATE - A rotate interaction.
   * @property {number} DOLLY - A dolly interaction.
   * @property {number} PAN - A pan interaction.
   **/

  /**
   * This type represents touch interaction types in context of controls.
   *
   * @typedef {Object} ConstantsTouch
   * @property {number} ROTATE - A rotate interaction.
   * @property {number} PAN - A pan interaction.
   * @property {number} DOLLY_PAN - The dolly-pan interaction.
   * @property {number} DOLLY_ROTATE - A dolly-rotate interaction.
   **/

  /**
   * This type represents the different timestamp query types.
   *
   * @typedef {Object} ConstantsTimestampQuery
   * @property {string} COMPUTE - A `compute` timestamp query.
   * @property {string} RENDER - A `render` timestamp query.
   **/

  /**
   * Represents the different interpolation sampling types.
   *
   * @typedef {Object} ConstantsInterpolationSamplingType
   * @property {string} PERSPECTIVE - Perspective-correct interpolation.
   * @property {string} LINEAR - Linear interpolation.
   * @property {string} FLAT - Flat interpolation.
   */

  /**
   * Represents the different interpolation sampling modes.
   *
   * @typedef {Object} ConstantsInterpolationSamplingMode
   * @property {string} NORMAL - Normal sampling mode.
   * @property {string} CENTROID - Centroid sampling mode.
   * @property {string} SAMPLE - Sample-specific sampling mode.
   * @property {string} FIRST - Flat interpolation using the first vertex.
   * @property {string} EITHER - Flat interpolation using either vertex.
   */

  /**
   * This modules allows to dispatch event objects on custom JavaScript objects.
   *
   * Main repository: [eventdispatcher.js]{@link https://github.com/mrdoob/eventdispatcher.js/}
   *
   * Code Example:
   * ```js
   * class Car extends EventDispatcher {
   * 	start() {
   *		this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );
   *	}
   *};
   *
   * // Using events with the custom object
   * const car = new Car();
   * car.addEventListener( 'start', function ( event ) {
   * 	alert( event.message );
   * } );
   *
   * car.start();
   * ```
   */
  class EventDispatcher {

  	/**
  	 * Adds the given event listener to the given event type.
  	 *
  	 * @param {string} type - The type of event to listen to.
  	 * @param {Function} listener - The function that gets called when the event is fired.
  	 */
  	addEventListener( type, listener ) {

  		if ( this._listeners === undefined ) this._listeners = {};

  		const listeners = this._listeners;

  		if ( listeners[ type ] === undefined ) {

  			listeners[ type ] = [];

  		}

  		if ( listeners[ type ].indexOf( listener ) === -1 ) {

  			listeners[ type ].push( listener );

  		}

  	}

  	/**
  	 * Returns `true` if the given event listener has been added to the given event type.
  	 *
  	 * @param {string} type - The type of event.
  	 * @param {Function} listener - The listener to check.
  	 * @return {boolean} Whether the given event listener has been added to the given event type.
  	 */
  	hasEventListener( type, listener ) {

  		const listeners = this._listeners;

  		if ( listeners === undefined ) return false;

  		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== -1;

  	}

  	/**
  	 * Removes the given event listener from the given event type.
  	 *
  	 * @param {string} type - The type of event.
  	 * @param {Function} listener - The listener to remove.
  	 */
  	removeEventListener( type, listener ) {

  		const listeners = this._listeners;

  		if ( listeners === undefined ) return;

  		const listenerArray = listeners[ type ];

  		if ( listenerArray !== undefined ) {

  			const index = listenerArray.indexOf( listener );

  			if ( index !== -1 ) {

  				listenerArray.splice( index, 1 );

  			}

  		}

  	}

  	/**
  	 * Dispatches an event object.
  	 *
  	 * @param {Object} event - The event that gets fired.
  	 */
  	dispatchEvent( event ) {

  		const listeners = this._listeners;

  		if ( listeners === undefined ) return;

  		const listenerArray = listeners[ event.type ];

  		if ( listenerArray !== undefined ) {

  			event.target = this;

  			// Make a copy, in case listeners are removed while iterating.
  			const array = listenerArray.slice( 0 );

  			for ( let i = 0, l = array.length; i < l; i ++ ) {

  				array[ i ].call( this, event );

  			}

  			event.target = null;

  		}

  	}

  }

  const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

  let _seed = 1234567;


  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 180 / Math.PI;

  /**
   * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
   * (universally unique identifier).
   *
   * @return {string} The UUID.
   */
  function generateUUID() {

  	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

  	const d0 = Math.random() * 0xffffffff | 0;
  	const d1 = Math.random() * 0xffffffff | 0;
  	const d2 = Math.random() * 0xffffffff | 0;
  	const d3 = Math.random() * 0xffffffff | 0;
  	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
  			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
  			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
  			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

  	// .toLowerCase() here flattens concatenated strings to save heap memory space.
  	return uuid.toLowerCase();

  }

  /**
   * Clamps the given value between min and max.
   *
   * @param {number} value - The value to clamp.
   * @param {number} min - The min value.
   * @param {number} max - The max value.
   * @return {number} The clamped value.
   */
  function clamp( value, min, max ) {

  	return Math.max( min, Math.min( max, value ) );

  }

  /**
   * Computes the Euclidean modulo of the given parameters that
   * is `( ( n % m ) + m ) % m`.
   *
   * @param {number} n - The first parameter.
   * @param {number} m - The second parameter.
   * @return {number} The Euclidean modulo.
   */
  function euclideanModulo( n, m ) {

  	// https://en.wikipedia.org/wiki/Modulo_operation

  	return ( ( n % m ) + m ) % m;

  }

  /**
   * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
   * for the given value.
   *
   * @param {number} x - The value to be mapped.
   * @param {number} a1 - Minimum value for range A.
   * @param {number} a2 - Maximum value for range A.
   * @param {number} b1 - Minimum value for range B.
   * @param {number} b2 - Maximum value for range B.
   * @return {number} The mapped value.
   */
  function mapLinear( x, a1, a2, b1, b2 ) {

  	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  }

  /**
   * Returns the percentage in the closed interval `[0, 1]` of the given value
   * between the start and end point.
   *
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} value - A value between start and end.
   * @return {number} The interpolation factor.
   */
  function inverseLerp( x, y, value ) {

  	// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/

  	if ( x !== y ) {

  		return ( value - x ) / ( y - x );

  	} else {

  		return 0;

  	}

  }

  /**
   * Returns a value linearly interpolated from two known points based on the given interval -
   * `t = 0` will return `x` and `t = 1` will return `y`.
   *
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {number} The interpolated value.
   */
  function lerp( x, y, t ) {

  	return ( 1 - t ) * x + t * y;

  }

  /**
   * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
   * time to maintain frame rate independent movement. For details, see
   * [Frame rate independent damping using lerp]{@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}.
   *
   * @param {number} x - The current point.
   * @param {number} y - The target point.
   * @param {number} lambda - A higher lambda value will make the movement more sudden,
   * and a lower value will make the movement more gradual.
   * @param {number} dt - Delta time in seconds.
   * @return {number} The interpolated value.
   */
  function damp( x, y, lambda, dt ) {

  	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

  }

  /**
   * Returns a value that alternates between `0` and the given `length` parameter.
   *
   * @param {number} x - The value to pingpong.
   * @param {number} [length=1] - The positive value the function will pingpong to.
   * @return {number} The alternated value.
   */
  function pingpong( x, length = 1 ) {

  	// https://www.desmos.com/calculator/vcsjnyz7x4

  	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

  }

  /**
   * Returns a value in the range `[0,1]` that represents the percentage that `x` has
   * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
   * the `min` and `max`.
   *
   * See [Smoothstep]{@link http://en.wikipedia.org/wiki/Smoothstep} for more details.
   *
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  function smoothstep( x, min, max ) {

  	if ( x <= min ) return 0;
  	if ( x >= max ) return 1;

  	x = ( x - min ) / ( max - min );

  	return x * x * ( 3 - 2 * x );

  }

  /**
   * A [variation on smoothstep]{@link https://en.wikipedia.org/wiki/Smoothstep#Variations}
   * that has zero 1st and 2nd order derivatives at x=0 and x=1.
   *
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  function smootherstep( x, min, max ) {

  	if ( x <= min ) return 0;
  	if ( x >= max ) return 1;

  	x = ( x - min ) / ( max - min );

  	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  }

  /**
   * Returns a random integer from `<low, high>` interval.
   *
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random integer.
   */
  function randInt( low, high ) {

  	return low + Math.floor( Math.random() * ( high - low + 1 ) );

  }

  /**
   * Returns a random float from `<low, high>` interval.
   *
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random float.
   */
  function randFloat( low, high ) {

  	return low + Math.random() * ( high - low );

  }

  /**
   * Returns a random integer from `<-range/2, range/2>` interval.
   *
   * @param {number} range - Defines the value range.
   * @return {number} A random float.
   */
  function randFloatSpread( range ) {

  	return range * ( 0.5 - Math.random() );

  }

  /**
   * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
   *
   * @param {number} [s] - The integer seed.
   * @return {number} A random float.
   */
  function seededRandom( s ) {

  	if ( s !== undefined ) _seed = s;

  	// Mulberry32 generator

  	let t = _seed += 0x6D2B79F5;

  	t = Math.imul( t ^ t >>> 15, t | 1 );

  	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

  	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

  }

  /**
   * Converts degrees to radians.
   *
   * @param {number} degrees - A value in degrees.
   * @return {number} The converted value in radians.
   */
  function degToRad( degrees ) {

  	return degrees * DEG2RAD;

  }

  /**
   * Converts radians to degrees.
   *
   * @param {number} radians - A value in radians.
   * @return {number} The converted value in degrees.
   */
  function radToDeg( radians ) {

  	return radians * RAD2DEG;

  }

  /**
   * Returns `true` if the given number is a power of two.
   *
   * @param {number} value - The value to check.
   * @return {boolean} Whether the given number is a power of two or not.
   */
  function isPowerOfTwo( value ) {

  	return ( value & ( value - 1 ) ) === 0 && value !== 0;

  }

  /**
   * Returns the smallest power of two that is greater than or equal to the given number.
   *
   * @param {number} value - The value to find a POT for.
   * @return {number} The smallest power of two that is greater than or equal to the given number.
   */
  function ceilPowerOfTwo( value ) {

  	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

  }

  /**
   * Returns the largest power of two that is less than or equal to the given number.
   *
   * @param {number} value - The value to find a POT for.
   * @return {number} The largest power of two that is less than or equal to the given number.
   */
  function floorPowerOfTwo( value ) {

  	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

  }

  /**
   * Sets the given quaternion from the [Intrinsic Proper Euler Angles]{@link https://en.wikipedia.org/wiki/Euler_angles}
   * defined by the given angles and order.
   *
   * Rotations are applied to the axes in the order specified by order:
   * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
   *
   * @param {Quaternion} q - The quaternion to set.
   * @param {number} a - The rotation applied to the first axis, in radians.
   * @param {number} b - The rotation applied to the second axis, in radians.
   * @param {number} c - The rotation applied to the third axis, in radians.
   * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
   */
  function setQuaternionFromProperEuler( q, a, b, c, order ) {

  	const cos = Math.cos;
  	const sin = Math.sin;

  	const c2 = cos( b / 2 );
  	const s2 = sin( b / 2 );

  	const c13 = cos( ( a + c ) / 2 );
  	const s13 = sin( ( a + c ) / 2 );

  	const c1_3 = cos( ( a - c ) / 2 );
  	const s1_3 = sin( ( a - c ) / 2 );

  	const c3_1 = cos( ( c - a ) / 2 );
  	const s3_1 = sin( ( c - a ) / 2 );

  	switch ( order ) {

  		case 'XYX':
  			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
  			break;

  		case 'YZY':
  			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
  			break;

  		case 'ZXZ':
  			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
  			break;

  		case 'XZX':
  			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
  			break;

  		case 'YXY':
  			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
  			break;

  		case 'ZYZ':
  			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
  			break;

  		default:
  			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

  	}

  }

  /**
   * Denormalizes the given value according to the given typed array.
   *
   * @param {number} value - The value to denormalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The denormalize (float) value in the range `[0,1]`.
   */
  function denormalize( value, array ) {

  	switch ( array.constructor ) {

  		case Float32Array:

  			return value;

  		case Uint32Array:

  			return value / 4294967295.0;

  		case Uint16Array:

  			return value / 65535.0;

  		case Uint8Array:

  			return value / 255.0;

  		case Int32Array:

  			return Math.max( value / 2147483647.0, -1 );

  		case Int16Array:

  			return Math.max( value / 32767.0, -1 );

  		case Int8Array:

  			return Math.max( value / 127.0, -1 );

  		default:

  			throw new Error( 'Invalid component type.' );

  	}

  }

  /**
   * Normalizes the given value according to the given typed array.
   *
   * @param {number} value - The float value in the range `[0,1]` to normalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The normalize value.
   */
  function normalize( value, array ) {

  	switch ( array.constructor ) {

  		case Float32Array:

  			return value;

  		case Uint32Array:

  			return Math.round( value * 4294967295.0 );

  		case Uint16Array:

  			return Math.round( value * 65535.0 );

  		case Uint8Array:

  			return Math.round( value * 255.0 );

  		case Int32Array:

  			return Math.round( value * 2147483647.0 );

  		case Int16Array:

  			return Math.round( value * 32767.0 );

  		case Int8Array:

  			return Math.round( value * 127.0 );

  		default:

  			throw new Error( 'Invalid component type.' );

  	}

  }

  /**
   * @class
   * @classdesc A collection of math utility functions.
   * @hideconstructor
   */
  const MathUtils = {
  	DEG2RAD: DEG2RAD,
  	RAD2DEG: RAD2DEG,
  	/**
  	 * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
  	 * (universally unique identifier).
  	 *
  	 * @static
  	 * @method
  	 * @return {string} The UUID.
  	 */
  	generateUUID: generateUUID,
  	/**
  	 * Clamps the given value between min and max.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The value to clamp.
  	 * @param {number} min - The min value.
  	 * @param {number} max - The max value.
  	 * @return {number} The clamped value.
  	 */
  	clamp: clamp,
  	/**
  	 * Computes the Euclidean modulo of the given parameters that
  	 * is `( ( n % m ) + m ) % m`.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} n - The first parameter.
  	 * @param {number} m - The second parameter.
  	 * @return {number} The Euclidean modulo.
  	 */
  	euclideanModulo: euclideanModulo,
  	/**
  	 * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
  	 * for the given value.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The value to be mapped.
  	 * @param {number} a1 - Minimum value for range A.
  	 * @param {number} a2 - Maximum value for range A.
  	 * @param {number} b1 - Minimum value for range B.
  	 * @param {number} b2 - Maximum value for range B.
  	 * @return {number} The mapped value.
  	 */
  	mapLinear: mapLinear,
  	/**
  	 * Returns the percentage in the closed interval `[0, 1]` of the given value
  	 * between the start and end point.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The start point
  	 * @param {number} y - The end point.
  	 * @param {number} value - A value between start and end.
  	 * @return {number} The interpolation factor.
  	 */
  	inverseLerp: inverseLerp,
  	/**
  	 * Returns a value linearly interpolated from two known points based on the given interval -
  	 * `t = 0` will return `x` and `t = 1` will return `y`.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The start point
  	 * @param {number} y - The end point.
  	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
  	 * @return {number} The interpolated value.
  	 */
  	lerp: lerp,
  	/**
  	 * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
  	 * time to maintain frame rate independent movement. For details, see
  	 * [Frame rate independent damping using lerp]{@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The current point.
  	 * @param {number} y - The target point.
  	 * @param {number} lambda - A higher lambda value will make the movement more sudden,
  	 * and a lower value will make the movement more gradual.
  	 * @param {number} dt - Delta time in seconds.
  	 * @return {number} The interpolated value.
  	 */
  	damp: damp,
  	/**
  	 * Returns a value that alternates between `0` and the given `length` parameter.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The value to pingpong.
  	 * @param {number} [length=1] - The positive value the function will pingpong to.
  	 * @return {number} The alternated value.
  	 */
  	pingpong: pingpong,
  	/**
  	 * Returns a value in the range `[0,1]` that represents the percentage that `x` has
  	 * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
  	 * the `min` and `max`.
  	 *
  	 * See [Smoothstep]{@link http://en.wikipedia.org/wiki/Smoothstep} for more details.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The value to evaluate based on its position between min and max.
  	 * @param {number} min - The min value. Any x value below min will be `0`.
  	 * @param {number} max - The max value. Any x value above max will be `1`.
  	 * @return {number} The alternated value.
  	 */
  	smoothstep: smoothstep,
  	/**
  	 * A [variation on smoothstep]{@link https://en.wikipedia.org/wiki/Smoothstep#Variations}
  	 * that has zero 1st and 2nd order derivatives at x=0 and x=1.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} x - The value to evaluate based on its position between min and max.
  	 * @param {number} min - The min value. Any x value below min will be `0`.
  	 * @param {number} max - The max value. Any x value above max will be `1`.
  	 * @return {number} The alternated value.
  	 */
  	smootherstep: smootherstep,
  	/**
  	 * Returns a random integer from `<low, high>` interval.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} low - The lower value boundary.
  	 * @param {number} high - The upper value boundary
  	 * @return {number} A random integer.
  	 */
  	randInt: randInt,
  	/**
  	 * Returns a random float from `<low, high>` interval.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} low - The lower value boundary.
  	 * @param {number} high - The upper value boundary
  	 * @return {number} A random float.
  	 */
  	randFloat: randFloat,
  	/**
  	 * Returns a random integer from `<-range/2, range/2>` interval.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} range - Defines the value range.
  	 * @return {number} A random float.
  	 */
  	randFloatSpread: randFloatSpread,
  	/**
  	 * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} [s] - The integer seed.
  	 * @return {number} A random float.
  	 */
  	seededRandom: seededRandom,
  	/**
  	 * Converts degrees to radians.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} degrees - A value in degrees.
  	 * @return {number} The converted value in radians.
  	 */
  	degToRad: degToRad,
  	/**
  	 * Converts radians to degrees.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} radians - A value in radians.
  	 * @return {number} The converted value in degrees.
  	 */
  	radToDeg: radToDeg,
  	/**
  	 * Returns `true` if the given number is a power of two.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The value to check.
  	 * @return {boolean} Whether the given number is a power of two or not.
  	 */
  	isPowerOfTwo: isPowerOfTwo,
  	/**
  	 * Returns the smallest power of two that is greater than or equal to the given number.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The value to find a POT for.
  	 * @return {number} The smallest power of two that is greater than or equal to the given number.
  	 */
  	ceilPowerOfTwo: ceilPowerOfTwo,
  	/**
  	 * Returns the largest power of two that is less than or equal to the given number.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The value to find a POT for.
  	 * @return {number} The largest power of two that is less than or equal to the given number.
  	 */
  	floorPowerOfTwo: floorPowerOfTwo,
  	/**
  	 * Sets the given quaternion from the [Intrinsic Proper Euler Angles]{@link https://en.wikipedia.org/wiki/Euler_angles}
  	 * defined by the given angles and order.
  	 *
  	 * Rotations are applied to the axes in the order specified by order:
  	 * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
  	 *
  	 * @static
  	 * @method
  	 * @param {Quaternion} q - The quaternion to set.
  	 * @param {number} a - The rotation applied to the first axis, in radians.
  	 * @param {number} b - The rotation applied to the second axis, in radians.
  	 * @param {number} c - The rotation applied to the third axis, in radians.
  	 * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
  	 */
  	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
  	/**
  	 * Normalizes the given value according to the given typed array.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The float value in the range `[0,1]` to normalize.
  	 * @param {TypedArray} array - The typed array that defines the data type of the value.
  	 * @return {number} The normalize value.
  	 */
  	normalize: normalize,
  	/**
  	 * Denormalizes the given value according to the given typed array.
  	 *
  	 * @static
  	 * @method
  	 * @param {number} value - The value to denormalize.
  	 * @param {TypedArray} array - The typed array that defines the data type of the value.
  	 * @return {number} The denormalize (float) value in the range `[0,1]`.
  	 */
  	denormalize: denormalize
  };

  /**
   * Class representing a 2D vector. A 2D vector is an ordered pair of numbers
   * (labeled x and y), which can be used to represent a number of things, such as:
   *
   * - A point in 2D space (i.e. a position on a plane).
   * - A direction and length across a plane. In three.js the length will
   * always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`
   * and the direction is also measured from `(0, 0)` towards `(x, y)`.
   * - Any arbitrary ordered pair of numbers.
   *
   * There are other things a 2D vector can be used to represent, such as
   * momentum vectors, complex numbers and so on, however these are the most
   * common uses in three.js.
   *
   * Iterating through a vector instance will yield its components `(x, y)` in
   * the corresponding order.
   * ```js
   * const a = new THREE.Vector2( 0, 1 );
   *
   * //no arguments; will be initialised to (0, 0)
   * const b = new THREE.Vector2( );
   *
   * const d = a.distanceTo( b );
   * ```
   */
  class Vector2 {

  	/**
  	 * Constructs a new 2D vector.
  	 *
  	 * @param {number} [x=0] - The x value of this vector.
  	 * @param {number} [y=0] - The y value of this vector.
  	 */
  	constructor( x = 0, y = 0 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		Vector2.prototype.isVector2 = true;

  		/**
  		 * The x value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.x = x;

  		/**
  		 * The y value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.y = y;

  	}

  	/**
  	 * Alias for {@link Vector2#x}.
  	 *
  	 * @type {number}
  	 */
  	get width() {

  		return this.x;

  	}

  	set width( value ) {

  		this.x = value;

  	}

  	/**
  	 * Alias for {@link Vector2#y}.
  	 *
  	 * @type {number}
  	 */
  	get height() {

  		return this.y;

  	}

  	set height( value ) {

  		this.y = value;

  	}

  	/**
  	 * Sets the vector components.
  	 *
  	 * @param {number} x - The value of the x component.
  	 * @param {number} y - The value of the y component.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	set( x, y ) {

  		this.x = x;
  		this.y = y;

  		return this;

  	}

  	/**
  	 * Sets the vector components to the same value.
  	 *
  	 * @param {number} scalar - The value to set for all vector components.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;

  		return this;

  	}

  	/**
  	 * Sets the vector's x component to the given value
  	 *
  	 * @param {number} x - The value to set.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	/**
  	 * Sets the vector's y component to the given value
  	 *
  	 * @param {number} y - The value to set.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	/**
  	 * Allows to set a vector component with an index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
  	 * @param {number} value - The value to set.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	/**
  	 * Returns the value of the vector component which matches the given index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y.
  	 * @return {number} A vector component value.
  	 */
  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	/**
  	 * Returns a new vector with copied values from this instance.
  	 *
  	 * @return {Vector2} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this.x, this.y );

  	}

  	/**
  	 * Copies the values of the given vector to this instance.
  	 *
  	 * @param {Vector2} v - The vector to copy.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;

  		return this;

  	}

  	/**
  	 * Adds the given vector to this instance.
  	 *
  	 * @param {Vector2} v - The vector to add.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;

  		return this;

  	}

  	/**
  	 * Adds the given scalar value to all components of this instance.
  	 *
  	 * @param {number} s - The scalar to add.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	addScalar( s ) {

  		this.x += s;
  		this.y += s;

  		return this;

  	}

  	/**
  	 * Adds the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector2} a - The first vector.
  	 * @param {Vector2} b - The second vector.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;

  		return this;

  	}

  	/**
  	 * Adds the given vector scaled by the given factor to this instance.
  	 *
  	 * @param {Vector2} v - The vector.
  	 * @param {number} s - The factor that scales `v`.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vector from this instance.
  	 *
  	 * @param {Vector2} v - The vector to subtract.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;

  		return this;

  	}

  	/**
  	 * Subtracts the given scalar value from all components of this instance.
  	 *
  	 * @param {number} s - The scalar to subtract.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector2} a - The first vector.
  	 * @param {Vector2} b - The second vector.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;

  		return this;

  	}

  	/**
  	 * Multiplies the given vector with this instance.
  	 *
  	 * @param {Vector2} v - The vector to multiply.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;

  		return this;

  	}

  	/**
  	 * Multiplies the given scalar value with all components of this instance.
  	 *
  	 * @param {number} scalar - The scalar to multiply.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;

  		return this;

  	}

  	/**
  	 * Divides this instance by the given vector.
  	 *
  	 * @param {Vector2} v - The vector to divide.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;

  		return this;

  	}

  	/**
  	 * Divides this vector by the given scalar.
  	 *
  	 * @param {number} scalar - The scalar to divide.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	/**
  	 * Multiplies this vector (with an implicit 1 as the 3rd component) by
  	 * the given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The matrix to apply.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	applyMatrix3( m ) {

  		const x = this.x, y = this.y;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

  		return this;

  	}

  	/**
  	 * If this vector's x or y value is greater than the given vector's x or y
  	 * value, replace that value with the corresponding min value.
  	 *
  	 * @param {Vector2} v - The vector.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );

  		return this;

  	}

  	/**
  	 * If this vector's x or y value is less than the given vector's x or y
  	 * value, replace that value with the corresponding max value.
  	 *
  	 * @param {Vector2} v - The vector.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );

  		return this;

  	}

  	/**
  	 * If this vector's x or y value is greater than the max vector's x or y
  	 * value, it is replaced by the corresponding value.
  	 * If this vector's x or y value is less than the min vector's x or y value,
  	 * it is replaced by the corresponding value.
  	 *
  	 * @param {Vector2} min - The minimum x and y values.
  	 * @param {Vector2} max - The maximum x and y values in the desired range.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = clamp( this.x, min.x, max.x );
  		this.y = clamp( this.y, min.y, max.y );

  		return this;

  	}

  	/**
  	 * If this vector's x or y values are greater than the max value, they are
  	 * replaced by the max value.
  	 * If this vector's x or y values are less than the min value, they are
  	 * replaced by the min value.
  	 *
  	 * @param {number} minVal - The minimum value the components will be clamped to.
  	 * @param {number} maxVal - The maximum value the components will be clamped to.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	clampScalar( minVal, maxVal ) {

  		this.x = clamp( this.x, minVal, maxVal );
  		this.y = clamp( this.y, minVal, maxVal );

  		return this;

  	}

  	/**
  	 * If this vector's length is greater than the max value, it is replaced by
  	 * the max value.
  	 * If this vector's length is less than the min value, it is replaced by the
  	 * min value.
  	 *
  	 * @param {number} min - The minimum value the vector length will be clamped to.
  	 * @param {number} max - The maximum value the vector length will be clamped to.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

  	}

  	/**
  	 * The components of this vector are rounded down to the nearest integer value.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded up to the nearest integer value.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded to the nearest integer value
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded towards zero (up if negative,
  	 * down if positive) to an integer value.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );

  		return this;

  	}

  	/**
  	 * Inverts this vector - i.e. sets x = -x and y = -y.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;

  		return this;

  	}

  	/**
  	 * Calculates the dot product of the given vector with this instance.
  	 *
  	 * @param {Vector2} v - The vector to compute the dot product with.
  	 * @return {number} The result of the dot product.
  	 */
  	dot( v ) {

  		return this.x * v.x + this.y * v.y;

  	}

  	/**
  	 * Calculates the cross product of the given vector with this instance.
  	 *
  	 * @param {Vector2} v - The vector to compute the cross product with.
  	 * @return {number} The result of the cross product.
  	 */
  	cross( v ) {

  		return this.x * v.y - this.y * v.x;

  	}

  	/**
  	 * Computes the square of the Euclidean length (straight-line length) from
  	 * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
  	 * compare the length squared instead as it is slightly more efficient to calculate.
  	 *
  	 * @return {number} The square length of this vector.
  	 */
  	lengthSq() {

  		return this.x * this.x + this.y * this.y;

  	}

  	/**
  	 * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y );

  	}

  	/**
  	 * Computes the Manhattan length of this vector.
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y );

  	}

  	/**
  	 * Converts this vector to a unit vector - that is, sets it equal to a vector
  	 * with the same direction as this one, but with a vector length of `1`.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	/**
  	 * Computes the angle in radians of this vector with respect to the positive x-axis.
  	 *
  	 * @return {number} The angle in radians.
  	 */
  	angle() {

  		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

  		return angle;

  	}

  	/**
  	 * Returns the angle between the given vector and this instance in radians.
  	 *
  	 * @param {Vector2} v - The vector to compute the angle with.
  	 * @return {number} The angle in radians.
  	 */
  	angleTo( v ) {

  		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

  		if ( denominator === 0 ) return Math.PI / 2;

  		const theta = this.dot( v ) / denominator;

  		// clamp, to handle numerical problems

  		return Math.acos( clamp( theta, -1, 1 ) );

  	}

  	/**
  	 * Computes the distance from the given vector to this instance.
  	 *
  	 * @param {Vector2} v - The vector to compute the distance to.
  	 * @return {number} The distance.
  	 */
  	distanceTo( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	}

  	/**
  	 * Computes the squared distance from the given vector to this instance.
  	 * If you are just comparing the distance with another distance, you should compare
  	 * the distance squared instead as it is slightly more efficient to calculate.
  	 *
  	 * @param {Vector2} v - The vector to compute the squared distance to.
  	 * @return {number} The squared distance.
  	 */
  	distanceToSquared( v ) {

  		const dx = this.x - v.x, dy = this.y - v.y;
  		return dx * dx + dy * dy;

  	}

  	/**
  	 * Computes the Manhattan distance from the given vector to this instance.
  	 *
  	 * @param {Vector2} v - The vector to compute the Manhattan distance to.
  	 * @return {number} The Manhattan distance.
  	 */
  	manhattanDistanceTo( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

  	}

  	/**
  	 * Sets this vector to a vector with the same direction as this one, but
  	 * with the specified length.
  	 *
  	 * @param {number} length - The new length of this vector.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	/**
  	 * Linearly interpolates between the given vector and this instance, where
  	 * alpha is the percent distance along the line - alpha = 0 will be this
  	 * vector, and alpha = 1 will be the given one.
  	 *
  	 * @param {Vector2} v - The vector to interpolate towards.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;

  		return this;

  	}

  	/**
  	 * Linearly interpolates between the given vectors, where alpha is the percent
  	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
  	 * be the second one. The result is stored in this instance.
  	 *
  	 * @param {Vector2} v1 - The first vector.
  	 * @param {Vector2} v2 - The second vector.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;

  		return this;

  	}

  	/**
  	 * Returns `true` if this vector is equal with the given one.
  	 *
  	 * @param {Vector2} v - The vector to test for equality.
  	 * @return {boolean} Whether this vector is equal with the given one.
  	 */
  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) );

  	}

  	/**
  	 * Sets this vector's x value to be `array[ offset ]` and y
  	 * value to be `array[ offset + 1 ]`.
  	 *
  	 * @param {Array<number>} array - An array holding the vector component values.
  	 * @param {number} [offset=0] - The offset into the array.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];

  		return this;

  	}

  	/**
  	 * Writes the components of this vector to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The vector components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;

  		return array;

  	}

  	/**
  	 * Sets the components of this vector from the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
  	 * @param {number} index - The index into the attribute.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );

  		return this;

  	}

  	/**
  	 * Rotates this vector around the given center by the given angle.
  	 *
  	 * @param {Vector2} center - The point around which to rotate.
  	 * @param {number} angle - The angle to rotate, in radians.
  	 * @return {Vector2} A reference to this vector.
  	 */
  	rotateAround( center, angle ) {

  		const c = Math.cos( angle ), s = Math.sin( angle );

  		const x = this.x - center.x;
  		const y = this.y - center.y;

  		this.x = x * c - y * s + center.x;
  		this.y = x * s + y * c + center.y;

  		return this;

  	}

  	/**
  	 * Sets each component of this vector to a pseudo-random value between `0` and
  	 * `1`, excluding `1`.
  	 *
  	 * @return {Vector2} A reference to this vector.
  	 */
  	random() {

  		this.x = Math.random();
  		this.y = Math.random();

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;

  	}

  }

  /**
   * Class for representing a Quaternion. Quaternions are used in three.js to represent rotations.
   *
   * Iterating through a vector instance will yield its components `(x, y, z, w)` in
   * the corresponding order.
   *
   * Note that three.js expects Quaternions to be normalized.
   * ```js
   * const quaternion = new THREE.Quaternion();
   * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
   *
   * const vector = new THREE.Vector3( 1, 0, 0 );
   * vector.applyQuaternion( quaternion );
   * ```
   */
  class Quaternion {

  	/**
  	 * Constructs a new quaternion.
  	 *
  	 * @param {number} [x=0] - The x value of this quaternion.
  	 * @param {number} [y=0] - The y value of this quaternion.
  	 * @param {number} [z=0] - The z value of this quaternion.
  	 * @param {number} [w=1] - The w value of this quaternion.
  	 */
  	constructor( x = 0, y = 0, z = 0, w = 1 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isQuaternion = true;

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  	}

  	/**
  	 * Interpolates between two quaternions via SLERP. This implementation assumes the
  	 * quaternion data are managed  in flat arrays.
  	 *
  	 * @param {Array<number>} dst - The destination array.
  	 * @param {number} dstOffset - An offset into the destination array.
  	 * @param {Array<number>} src0 - The source array of the first quaternion.
  	 * @param {number} srcOffset0 - An offset into the first source array.
  	 * @param {Array<number>} src1 -  The source array of the second quaternion.
  	 * @param {number} srcOffset1 - An offset into the second source array.
  	 * @param {number} t - The interpolation factor in the range `[0,1]`.
  	 * @see {@link Quaternion#slerp}
  	 */
  	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

  		// fuzz-free, array-based Quaternion SLERP operation

  		let x0 = src0[ srcOffset0 + 0 ],
  			y0 = src0[ srcOffset0 + 1 ],
  			z0 = src0[ srcOffset0 + 2 ],
  			w0 = src0[ srcOffset0 + 3 ];

  		const x1 = src1[ srcOffset1 + 0 ],
  			y1 = src1[ srcOffset1 + 1 ],
  			z1 = src1[ srcOffset1 + 2 ],
  			w1 = src1[ srcOffset1 + 3 ];

  		if ( t === 0 ) {

  			dst[ dstOffset + 0 ] = x0;
  			dst[ dstOffset + 1 ] = y0;
  			dst[ dstOffset + 2 ] = z0;
  			dst[ dstOffset + 3 ] = w0;
  			return;

  		}

  		if ( t === 1 ) {

  			dst[ dstOffset + 0 ] = x1;
  			dst[ dstOffset + 1 ] = y1;
  			dst[ dstOffset + 2 ] = z1;
  			dst[ dstOffset + 3 ] = w1;
  			return;

  		}

  		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

  			let s = 1 - t;
  			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
  				dir = ( cos >= 0 ? 1 : -1 ),
  				sqrSin = 1 - cos * cos;

  			// Skip the Slerp for tiny steps to avoid numeric problems:
  			if ( sqrSin > Number.EPSILON ) {

  				const sin = Math.sqrt( sqrSin ),
  					len = Math.atan2( sin, cos * dir );

  				s = Math.sin( s * len ) / sin;
  				t = Math.sin( t * len ) / sin;

  			}

  			const tDir = t * dir;

  			x0 = x0 * s + x1 * tDir;
  			y0 = y0 * s + y1 * tDir;
  			z0 = z0 * s + z1 * tDir;
  			w0 = w0 * s + w1 * tDir;

  			// Normalize in case we just did a lerp:
  			if ( s === 1 - t ) {

  				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

  				x0 *= f;
  				y0 *= f;
  				z0 *= f;
  				w0 *= f;

  			}

  		}

  		dst[ dstOffset ] = x0;
  		dst[ dstOffset + 1 ] = y0;
  		dst[ dstOffset + 2 ] = z0;
  		dst[ dstOffset + 3 ] = w0;

  	}

  	/**
  	 * Multiplies two quaternions. This implementation assumes the quaternion data are managed
  	 * in flat arrays.
  	 *
  	 * @param {Array<number>} dst - The destination array.
  	 * @param {number} dstOffset - An offset into the destination array.
  	 * @param {Array<number>} src0 - The source array of the first quaternion.
  	 * @param {number} srcOffset0 - An offset into the first source array.
  	 * @param {Array<number>} src1 -  The source array of the second quaternion.
  	 * @param {number} srcOffset1 - An offset into the second source array.
  	 * @return {Array<number>} The destination array.
  	 * @see {@link Quaternion#multiplyQuaternions}.
  	 */
  	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

  		const x0 = src0[ srcOffset0 ];
  		const y0 = src0[ srcOffset0 + 1 ];
  		const z0 = src0[ srcOffset0 + 2 ];
  		const w0 = src0[ srcOffset0 + 3 ];

  		const x1 = src1[ srcOffset1 ];
  		const y1 = src1[ srcOffset1 + 1 ];
  		const z1 = src1[ srcOffset1 + 2 ];
  		const w1 = src1[ srcOffset1 + 3 ];

  		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
  		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
  		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
  		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

  		return dst;

  	}

  	/**
  	 * The x value of this quaternion.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get x() {

  		return this._x;

  	}

  	set x( value ) {

  		this._x = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * The y value of this quaternion.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get y() {

  		return this._y;

  	}

  	set y( value ) {

  		this._y = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * The z value of this quaternion.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get z() {

  		return this._z;

  	}

  	set z( value ) {

  		this._z = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * The w value of this quaternion.
  	 *
  	 * @type {number}
  	 * @default 1
  	 */
  	get w() {

  		return this._w;

  	}

  	set w( value ) {

  		this._w = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * Sets the quaternion components.
  	 *
  	 * @param {number} x - The x value of this quaternion.
  	 * @param {number} y - The y value of this quaternion.
  	 * @param {number} z - The z value of this quaternion.
  	 * @param {number} w - The w value of this quaternion.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	set( x, y, z, w ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Returns a new quaternion with copied values from this instance.
  	 *
  	 * @return {Quaternion} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this._x, this._y, this._z, this._w );

  	}

  	/**
  	 * Copies the values of the given quaternion to this instance.
  	 *
  	 * @param {Quaternion} quaternion - The quaternion to copy.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	copy( quaternion ) {

  		this._x = quaternion.x;
  		this._y = quaternion.y;
  		this._z = quaternion.z;
  		this._w = quaternion.w;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets this quaternion from the rotation specified by the given
  	 * Euler angles.
  	 *
  	 * @param {Euler} euler - The Euler angles.
  	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	setFromEuler( euler, update = true ) {

  		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

  		// http://www.mathworks.com/matlabcentral/fileexchange/
  		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  		//	content/SpinCalc.m

  		const cos = Math.cos;
  		const sin = Math.sin;

  		const c1 = cos( x / 2 );
  		const c2 = cos( y / 2 );
  		const c3 = cos( z / 2 );

  		const s1 = sin( x / 2 );
  		const s2 = sin( y / 2 );
  		const s3 = sin( z / 2 );

  		switch ( order ) {

  			case 'XYZ':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'YXZ':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			case 'ZXY':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'ZYX':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			case 'YZX':
  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;
  				break;

  			case 'XZY':
  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;
  				break;

  			default:
  				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

  		}

  		if ( update === true ) this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets this quaternion from the given axis and angle.
  	 *
  	 * @param {Vector3} axis - The normalized axis.
  	 * @param {number} angle - The angle in radians.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	setFromAxisAngle( axis, angle ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

  		const halfAngle = angle / 2, s = Math.sin( halfAngle );

  		this._x = axis.x * s;
  		this._y = axis.y * s;
  		this._z = axis.z * s;
  		this._w = Math.cos( halfAngle );

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets this quaternion from the given rotation matrix.
  	 *
  	 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	setFromRotationMatrix( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		const te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

  			trace = m11 + m22 + m33;

  		if ( trace > 0 ) {

  			const s = 0.5 / Math.sqrt( trace + 1.0 );

  			this._w = 0.25 / s;
  			this._x = ( m32 - m23 ) * s;
  			this._y = ( m13 - m31 ) * s;
  			this._z = ( m21 - m12 ) * s;

  		} else if ( m11 > m22 && m11 > m33 ) {

  			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

  			this._w = ( m32 - m23 ) / s;
  			this._x = 0.25 * s;
  			this._y = ( m12 + m21 ) / s;
  			this._z = ( m13 + m31 ) / s;

  		} else if ( m22 > m33 ) {

  			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

  			this._w = ( m13 - m31 ) / s;
  			this._x = ( m12 + m21 ) / s;
  			this._y = 0.25 * s;
  			this._z = ( m23 + m32 ) / s;

  		} else {

  			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

  			this._w = ( m21 - m12 ) / s;
  			this._x = ( m13 + m31 ) / s;
  			this._y = ( m23 + m32 ) / s;
  			this._z = 0.25 * s;

  		}

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets this quaternion to the rotation required to rotate the direction vector
  	 * `vFrom` to the direction vector `vTo`.
  	 *
  	 * @param {Vector3} vFrom - The first (normalized) direction vector.
  	 * @param {Vector3} vTo - The second (normalized) direction vector.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	setFromUnitVectors( vFrom, vTo ) {

  		// assumes direction vectors vFrom and vTo are normalized

  		let r = vFrom.dot( vTo ) + 1;

  		if ( r < 1e-8 ) { // the epsilon value has been discussed in #31286

  			// vFrom and vTo point in opposite directions

  			r = 0;

  			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

  				this._x = - vFrom.y;
  				this._y = vFrom.x;
  				this._z = 0;
  				this._w = r;

  			} else {

  				this._x = 0;
  				this._y = - vFrom.z;
  				this._z = vFrom.y;
  				this._w = r;

  			}

  		} else {

  			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

  			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
  			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
  			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
  			this._w = r;

  		}

  		return this.normalize();

  	}

  	/**
  	 * Returns the angle between this quaternion and the given one in radians.
  	 *
  	 * @param {Quaternion} q - The quaternion to compute the angle with.
  	 * @return {number} The angle in radians.
  	 */
  	angleTo( q ) {

  		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), -1, 1 ) ) );

  	}

  	/**
  	 * Rotates this quaternion by a given angular step to the given quaternion.
  	 * The method ensures that the final quaternion will not overshoot `q`.
  	 *
  	 * @param {Quaternion} q - The target quaternion.
  	 * @param {number} step - The angular step in radians.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	rotateTowards( q, step ) {

  		const angle = this.angleTo( q );

  		if ( angle === 0 ) return this;

  		const t = Math.min( 1, step / angle );

  		this.slerp( q, t );

  		return this;

  	}

  	/**
  	 * Sets this quaternion to the identity quaternion; that is, to the
  	 * quaternion that represents "no rotation".
  	 *
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	identity() {

  		return this.set( 0, 0, 0, 1 );

  	}

  	/**
  	 * Inverts this quaternion via {@link Quaternion#conjugate}. The
  	 * quaternion is assumed to have unit length.
  	 *
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	invert() {

  		return this.conjugate();

  	}

  	/**
  	 * Returns the rotational conjugate of this quaternion. The conjugate of a
  	 * quaternion represents the same rotation in the opposite direction about
  	 * the rotational axis.
  	 *
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	conjugate() {

  		this._x *= -1;
  		this._y *= -1;
  		this._z *= -1;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Calculates the dot product of this quaternion and the given one.
  	 *
  	 * @param {Quaternion} v - The quaternion to compute the dot product with.
  	 * @return {number} The result of the dot product.
  	 */
  	dot( v ) {

  		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  	}

  	/**
  	 * Computes the squared Euclidean length (straight-line length) of this quaternion,
  	 * considered as a 4 dimensional vector. This can be useful if you are comparing the
  	 * lengths of two quaternions, as this is a slightly more efficient calculation than
  	 * {@link Quaternion#length}.
  	 *
  	 * @return {number} The squared Euclidean length.
  	 */
  	lengthSq() {

  		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  	}

  	/**
  	 * Computes the Euclidean length (straight-line length) of this quaternion,
  	 * considered as a 4 dimensional vector.
  	 *
  	 * @return {number} The Euclidean length.
  	 */
  	length() {

  		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  	}

  	/**
  	 * Normalizes this quaternion - that is, calculated the quaternion that performs
  	 * the same rotation as this one, but has a length equal to `1`.
  	 *
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	normalize() {

  		let l = this.length();

  		if ( l === 0 ) {

  			this._x = 0;
  			this._y = 0;
  			this._z = 0;
  			this._w = 1;

  		} else {

  			l = 1 / l;

  			this._x = this._x * l;
  			this._y = this._y * l;
  			this._z = this._z * l;
  			this._w = this._w * l;

  		}

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Multiplies this quaternion by the given one.
  	 *
  	 * @param {Quaternion} q - The quaternion.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	multiply( q ) {

  		return this.multiplyQuaternions( this, q );

  	}

  	/**
  	 * Pre-multiplies this quaternion by the given one.
  	 *
  	 * @param {Quaternion} q - The quaternion.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	premultiply( q ) {

  		return this.multiplyQuaternions( q, this );

  	}

  	/**
  	 * Multiplies the given quaternions and stores the result in this instance.
  	 *
  	 * @param {Quaternion} a - The first quaternion.
  	 * @param {Quaternion} b - The second quaternion.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	multiplyQuaternions( a, b ) {

  		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

  		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
  		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

  		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
  		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
  		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
  		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Performs a spherical linear interpolation between quaternions.
  	 *
  	 * @param {Quaternion} qb - The target quaternion.
  	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	slerp( qb, t ) {

  		if ( t === 0 ) return this;
  		if ( t === 1 ) return this.copy( qb );

  		const x = this._x, y = this._y, z = this._z, w = this._w;

  		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

  		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

  		if ( cosHalfTheta < 0 ) {

  			this._w = - qb._w;
  			this._x = - qb._x;
  			this._y = - qb._y;
  			this._z = - qb._z;

  			cosHalfTheta = - cosHalfTheta;

  		} else {

  			this.copy( qb );

  		}

  		if ( cosHalfTheta >= 1.0 ) {

  			this._w = w;
  			this._x = x;
  			this._y = y;
  			this._z = z;

  			return this;

  		}

  		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

  		if ( sqrSinHalfTheta <= Number.EPSILON ) {

  			const s = 1 - t;
  			this._w = s * w + t * this._w;
  			this._x = s * x + t * this._x;
  			this._y = s * y + t * this._y;
  			this._z = s * z + t * this._z;

  			this.normalize(); // normalize calls _onChangeCallback()

  			return this;

  		}

  		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
  		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
  		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
  			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

  		this._w = ( w * ratioA + this._w * ratioB );
  		this._x = ( x * ratioA + this._x * ratioB );
  		this._y = ( y * ratioA + this._y * ratioB );
  		this._z = ( z * ratioA + this._z * ratioB );

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Performs a spherical linear interpolation between the given quaternions
  	 * and stores the result in this quaternion.
  	 *
  	 * @param {Quaternion} qa - The source quaternion.
  	 * @param {Quaternion} qb - The target quaternion.
  	 * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	slerpQuaternions( qa, qb, t ) {

  		return this.copy( qa ).slerp( qb, t );

  	}

  	/**
  	 * Sets this quaternion to a uniformly random, normalized quaternion.
  	 *
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	random() {

  		// Ken Shoemake
  		// Uniform random rotations
  		// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

  		const theta1 = 2 * Math.PI * Math.random();
  		const theta2 = 2 * Math.PI * Math.random();

  		const x0 = Math.random();
  		const r1 = Math.sqrt( 1 - x0 );
  		const r2 = Math.sqrt( x0 );

  		return this.set(
  			r1 * Math.sin( theta1 ),
  			r1 * Math.cos( theta1 ),
  			r2 * Math.sin( theta2 ),
  			r2 * Math.cos( theta2 ),
  		);

  	}

  	/**
  	 * Returns `true` if this quaternion is equal with the given one.
  	 *
  	 * @param {Quaternion} quaternion - The quaternion to test for equality.
  	 * @return {boolean} Whether this quaternion is equal with the given one.
  	 */
  	equals( quaternion ) {

  		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  	}

  	/**
  	 * Sets this quaternion's components from the given array.
  	 *
  	 * @param {Array<number>} array - An array holding the quaternion component values.
  	 * @param {number} [offset=0] - The offset into the array.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	fromArray( array, offset = 0 ) {

  		this._x = array[ offset ];
  		this._y = array[ offset + 1 ];
  		this._z = array[ offset + 2 ];
  		this._w = array[ offset + 3 ];

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Writes the components of this quaternion to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The quaternion components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._w;

  		return array;

  	}

  	/**
  	 * Sets the components of this quaternion from the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
  	 * @param {number} index - The index into the attribute.
  	 * @return {Quaternion} A reference to this quaternion.
  	 */
  	fromBufferAttribute( attribute, index ) {

  		this._x = attribute.getX( index );
  		this._y = attribute.getY( index );
  		this._z = attribute.getZ( index );
  		this._w = attribute.getW( index );

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * This methods defines the serialization result of this class. Returns the
  	 * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
  	 *
  	 * @return {Array<number>} The serialized quaternion.
  	 */
  	toJSON() {

  		return this.toArray();

  	}

  	_onChange( callback ) {

  		this._onChangeCallback = callback;

  		return this;

  	}

  	_onChangeCallback() {}

  	*[ Symbol.iterator ]() {

  		yield this._x;
  		yield this._y;
  		yield this._z;
  		yield this._w;

  	}

  }

  /**
   * Class representing a 3D vector. A 3D vector is an ordered triplet of numbers
   * (labeled x, y and z), which can be used to represent a number of things, such as:
   *
   * - A point in 3D space.
   * - A direction and length in 3D space. In three.js the length will
   * always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`
   * and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.
   * - Any arbitrary ordered triplet of numbers.
   *
   * There are other things a 3D vector can be used to represent, such as
   * momentum vectors and so on, however these are the most
   * common uses in three.js.
   *
   * Iterating through a vector instance will yield its components `(x, y, z)` in
   * the corresponding order.
   * ```js
   * const a = new THREE.Vector3( 0, 1, 0 );
   *
   * //no arguments; will be initialised to (0, 0, 0)
   * const b = new THREE.Vector3( );
   *
   * const d = a.distanceTo( b );
   * ```
   */
  class Vector3 {

  	/**
  	 * Constructs a new 3D vector.
  	 *
  	 * @param {number} [x=0] - The x value of this vector.
  	 * @param {number} [y=0] - The y value of this vector.
  	 * @param {number} [z=0] - The z value of this vector.
  	 */
  	constructor( x = 0, y = 0, z = 0 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		Vector3.prototype.isVector3 = true;

  		/**
  		 * The x value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.x = x;

  		/**
  		 * The y value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.y = y;

  		/**
  		 * The z value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.z = z;

  	}

  	/**
  	 * Sets the vector components.
  	 *
  	 * @param {number} x - The value of the x component.
  	 * @param {number} y - The value of the y component.
  	 * @param {number} z - The value of the z component.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	set( x, y, z ) {

  		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

  		this.x = x;
  		this.y = y;
  		this.z = z;

  		return this;

  	}

  	/**
  	 * Sets the vector components to the same value.
  	 *
  	 * @param {number} scalar - The value to set for all vector components.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;

  		return this;

  	}

  	/**
  	 * Sets the vector's x component to the given value
  	 *
  	 * @param {number} x - The value to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	/**
  	 * Sets the vector's y component to the given value
  	 *
  	 * @param {number} y - The value to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	/**
  	 * Sets the vector's z component to the given value
  	 *
  	 * @param {number} z - The value to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setZ( z ) {

  		this.z = z;

  		return this;

  	}

  	/**
  	 * Allows to set a vector component with an index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
  	 * @param {number} value - The value to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	/**
  	 * Returns the value of the vector component which matches the given index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
  	 * @return {number} A vector component value.
  	 */
  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	/**
  	 * Returns a new vector with copied values from this instance.
  	 *
  	 * @return {Vector3} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this.x, this.y, this.z );

  	}

  	/**
  	 * Copies the values of the given vector to this instance.
  	 *
  	 * @param {Vector3} v - The vector to copy.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;

  		return this;

  	}

  	/**
  	 * Adds the given vector to this instance.
  	 *
  	 * @param {Vector3} v - The vector to add.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;

  		return this;

  	}

  	/**
  	 * Adds the given scalar value to all components of this instance.
  	 *
  	 * @param {number} s - The scalar to add.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	addScalar( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;

  		return this;

  	}

  	/**
  	 * Adds the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector3} a - The first vector.
  	 * @param {Vector3} b - The second vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;

  		return this;

  	}

  	/**
  	 * Adds the given vector scaled by the given factor to this instance.
  	 *
  	 * @param {Vector3|Vector4} v - The vector.
  	 * @param {number} s - The factor that scales `v`.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vector from this instance.
  	 *
  	 * @param {Vector3} v - The vector to subtract.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;

  		return this;

  	}

  	/**
  	 * Subtracts the given scalar value from all components of this instance.
  	 *
  	 * @param {number} s - The scalar to subtract.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector3} a - The first vector.
  	 * @param {Vector3} b - The second vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;

  		return this;

  	}

  	/**
  	 * Multiplies the given vector with this instance.
  	 *
  	 * @param {Vector3} v - The vector to multiply.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;

  		return this;

  	}

  	/**
  	 * Multiplies the given scalar value with all components of this instance.
  	 *
  	 * @param {number} scalar - The scalar to multiply.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;

  		return this;

  	}

  	/**
  	 * Multiplies the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector3} a - The first vector.
  	 * @param {Vector3} b - The second vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	multiplyVectors( a, b ) {

  		this.x = a.x * b.x;
  		this.y = a.y * b.y;
  		this.z = a.z * b.z;

  		return this;

  	}

  	/**
  	 * Applies the given Euler rotation to this vector.
  	 *
  	 * @param {Euler} euler - The Euler angles.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyEuler( euler ) {

  		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

  	}

  	/**
  	 * Applies a rotation specified by an axis and an angle to this vector.
  	 *
  	 * @param {Vector3} axis - A normalized vector representing the rotation axis.
  	 * @param {number} angle - The angle in radians.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyAxisAngle( axis, angle ) {

  		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

  	}

  	/**
  	 * Multiplies this vector with the given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The 3x3 matrix.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyMatrix3( m ) {

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
  		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

  		return this;

  	}

  	/**
  	 * Multiplies this vector by the given normal matrix and normalizes
  	 * the result.
  	 *
  	 * @param {Matrix3} m - The normal matrix.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyNormalMatrix( m ) {

  		return this.applyMatrix3( m ).normalize();

  	}

  	/**
  	 * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
  	 * divides by perspective.
  	 *
  	 * @param {Matrix4} m - The matrix to apply.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyMatrix4( m ) {

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

  		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
  		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
  		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

  		return this;

  	}

  	/**
  	 * Applies the given Quaternion to this vector.
  	 *
  	 * @param {Quaternion} q - The Quaternion.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	applyQuaternion( q ) {

  		// quaternion q is assumed to have unit length

  		const vx = this.x, vy = this.y, vz = this.z;
  		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  		// t = 2 * cross( q.xyz, v );
  		const tx = 2 * ( qy * vz - qz * vy );
  		const ty = 2 * ( qz * vx - qx * vz );
  		const tz = 2 * ( qx * vy - qy * vx );

  		// v + q.w * t + cross( q.xyz, t );
  		this.x = vx + qw * tx + qy * tz - qz * ty;
  		this.y = vy + qw * ty + qz * tx - qx * tz;
  		this.z = vz + qw * tz + qx * ty - qy * tx;

  		return this;

  	}

  	/**
  	 * Projects this vector from world space into the camera's normalized
  	 * device coordinate (NDC) space.
  	 *
  	 * @param {Camera} camera - The camera.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	project( camera ) {

  		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

  	}

  	/**
  	 * Unprojects this vector from the camera's normalized device coordinate (NDC)
  	 * space into world space.
  	 *
  	 * @param {Camera} camera - The camera.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	unproject( camera ) {

  		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

  	}

  	/**
  	 * Transforms the direction of this vector by a matrix (the upper left 3 x 3
  	 * subset of the given 4x4 matrix and then normalizes the result.
  	 *
  	 * @param {Matrix4} m - The matrix.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	transformDirection( m ) {

  		// input: THREE.Matrix4 affine matrix
  		// vector interpreted as a direction

  		const x = this.x, y = this.y, z = this.z;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

  		return this.normalize();

  	}

  	/**
  	 * Divides this instance by the given vector.
  	 *
  	 * @param {Vector3} v - The vector to divide.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;
  		this.z /= v.z;

  		return this;

  	}

  	/**
  	 * Divides this vector by the given scalar.
  	 *
  	 * @param {number} scalar - The scalar to divide.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	/**
  	 * If this vector's x, y or z value is greater than the given vector's x, y or z
  	 * value, replace that value with the corresponding min value.
  	 *
  	 * @param {Vector3} v - The vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );

  		return this;

  	}

  	/**
  	 * If this vector's x, y or z value is less than the given vector's x, y or z
  	 * value, replace that value with the corresponding max value.
  	 *
  	 * @param {Vector3} v - The vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );

  		return this;

  	}

  	/**
  	 * If this vector's x, y or z value is greater than the max vector's x, y or z
  	 * value, it is replaced by the corresponding value.
  	 * If this vector's x, y or z value is less than the min vector's x, y or z value,
  	 * it is replaced by the corresponding value.
  	 *
  	 * @param {Vector3} min - The minimum x, y and z values.
  	 * @param {Vector3} max - The maximum x, y and z values in the desired range.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = clamp( this.x, min.x, max.x );
  		this.y = clamp( this.y, min.y, max.y );
  		this.z = clamp( this.z, min.z, max.z );

  		return this;

  	}

  	/**
  	 * If this vector's x, y or z values are greater than the max value, they are
  	 * replaced by the max value.
  	 * If this vector's x, y or z values are less than the min value, they are
  	 * replaced by the min value.
  	 *
  	 * @param {number} minVal - The minimum value the components will be clamped to.
  	 * @param {number} maxVal - The maximum value the components will be clamped to.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	clampScalar( minVal, maxVal ) {

  		this.x = clamp( this.x, minVal, maxVal );
  		this.y = clamp( this.y, minVal, maxVal );
  		this.z = clamp( this.z, minVal, maxVal );

  		return this;

  	}

  	/**
  	 * If this vector's length is greater than the max value, it is replaced by
  	 * the max value.
  	 * If this vector's length is less than the min value, it is replaced by the
  	 * min value.
  	 *
  	 * @param {number} min - The minimum value the vector length will be clamped to.
  	 * @param {number} max - The maximum value the vector length will be clamped to.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

  	}

  	/**
  	 * The components of this vector are rounded down to the nearest integer value.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded up to the nearest integer value.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded to the nearest integer value
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded towards zero (up if negative,
  	 * down if positive) to an integer value.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );
  		this.z = Math.trunc( this.z );

  		return this;

  	}

  	/**
  	 * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;

  		return this;

  	}

  	/**
  	 * Calculates the dot product of the given vector with this instance.
  	 *
  	 * @param {Vector3} v - The vector to compute the dot product with.
  	 * @return {number} The result of the dot product.
  	 */
  	dot( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z;

  	}

  	// TODO lengthSquared?

  	/**
  	 * Computes the square of the Euclidean length (straight-line length) from
  	 * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
  	 * compare the length squared instead as it is slightly more efficient to calculate.
  	 *
  	 * @return {number} The square length of this vector.
  	 */
  	lengthSq() {

  		return this.x * this.x + this.y * this.y + this.z * this.z;

  	}

  	/**
  	 * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  	}

  	/**
  	 * Computes the Manhattan length of this vector.
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  	}

  	/**
  	 * Converts this vector to a unit vector - that is, sets it equal to a vector
  	 * with the same direction as this one, but with a vector length of `1`.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	/**
  	 * Sets this vector to a vector with the same direction as this one, but
  	 * with the specified length.
  	 *
  	 * @param {number} length - The new length of this vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	/**
  	 * Linearly interpolates between the given vector and this instance, where
  	 * alpha is the percent distance along the line - alpha = 0 will be this
  	 * vector, and alpha = 1 will be the given one.
  	 *
  	 * @param {Vector3} v - The vector to interpolate towards.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;

  		return this;

  	}

  	/**
  	 * Linearly interpolates between the given vectors, where alpha is the percent
  	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
  	 * be the second one. The result is stored in this instance.
  	 *
  	 * @param {Vector3} v1 - The first vector.
  	 * @param {Vector3} v2 - The second vector.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;
  		this.z = v1.z + ( v2.z - v1.z ) * alpha;

  		return this;

  	}

  	/**
  	 * Calculates the cross product of the given vector with this instance.
  	 *
  	 * @param {Vector3} v - The vector to compute the cross product with.
  	 * @return {Vector3} The result of the cross product.
  	 */
  	cross( v ) {

  		return this.crossVectors( this, v );

  	}

  	/**
  	 * Calculates the cross product of the given vectors and stores the result
  	 * in this instance.
  	 *
  	 * @param {Vector3} a - The first vector.
  	 * @param {Vector3} b - The second vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	crossVectors( a, b ) {

  		const ax = a.x, ay = a.y, az = a.z;
  		const bx = b.x, by = b.y, bz = b.z;

  		this.x = ay * bz - az * by;
  		this.y = az * bx - ax * bz;
  		this.z = ax * by - ay * bx;

  		return this;

  	}

  	/**
  	 * Projects this vector onto the given one.
  	 *
  	 * @param {Vector3} v - The vector to project to.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	projectOnVector( v ) {

  		const denominator = v.lengthSq();

  		if ( denominator === 0 ) return this.set( 0, 0, 0 );

  		const scalar = v.dot( this ) / denominator;

  		return this.copy( v ).multiplyScalar( scalar );

  	}

  	/**
  	 * Projects this vector onto a plane by subtracting this
  	 * vector projected onto the plane's normal from this vector.
  	 *
  	 * @param {Vector3} planeNormal - The plane normal.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	projectOnPlane( planeNormal ) {

  		_vector$c.copy( this ).projectOnVector( planeNormal );

  		return this.sub( _vector$c );

  	}

  	/**
  	 * Reflects this vector off a plane orthogonal to the given normal vector.
  	 *
  	 * @param {Vector3} normal - The (normalized) normal vector.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	reflect( normal ) {

  		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

  	}
  	/**
  	 * Returns the angle between the given vector and this instance in radians.
  	 *
  	 * @param {Vector3} v - The vector to compute the angle with.
  	 * @return {number} The angle in radians.
  	 */
  	angleTo( v ) {

  		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

  		if ( denominator === 0 ) return Math.PI / 2;

  		const theta = this.dot( v ) / denominator;

  		// clamp, to handle numerical problems

  		return Math.acos( clamp( theta, -1, 1 ) );

  	}

  	/**
  	 * Computes the distance from the given vector to this instance.
  	 *
  	 * @param {Vector3} v - The vector to compute the distance to.
  	 * @return {number} The distance.
  	 */
  	distanceTo( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	}

  	/**
  	 * Computes the squared distance from the given vector to this instance.
  	 * If you are just comparing the distance with another distance, you should compare
  	 * the distance squared instead as it is slightly more efficient to calculate.
  	 *
  	 * @param {Vector3} v - The vector to compute the squared distance to.
  	 * @return {number} The squared distance.
  	 */
  	distanceToSquared( v ) {

  		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

  		return dx * dx + dy * dy + dz * dz;

  	}

  	/**
  	 * Computes the Manhattan distance from the given vector to this instance.
  	 *
  	 * @param {Vector3} v - The vector to compute the Manhattan distance to.
  	 * @return {number} The Manhattan distance.
  	 */
  	manhattanDistanceTo( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

  	}

  	/**
  	 * Sets the vector components from the given spherical coordinates.
  	 *
  	 * @param {Spherical} s - The spherical coordinates.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromSpherical( s ) {

  		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

  	}

  	/**
  	 * Sets the vector components from the given spherical coordinates.
  	 *
  	 * @param {number} radius - The radius.
  	 * @param {number} phi - The phi angle in radians.
  	 * @param {number} theta - The theta angle in radians.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromSphericalCoords( radius, phi, theta ) {

  		const sinPhiRadius = Math.sin( phi ) * radius;

  		this.x = sinPhiRadius * Math.sin( theta );
  		this.y = Math.cos( phi ) * radius;
  		this.z = sinPhiRadius * Math.cos( theta );

  		return this;

  	}

  	/**
  	 * Sets the vector components from the given cylindrical coordinates.
  	 *
  	 * @param {Cylindrical} c - The cylindrical coordinates.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromCylindrical( c ) {

  		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

  	}

  	/**
  	 * Sets the vector components from the given cylindrical coordinates.
  	 *
  	 * @param {number} radius - The radius.
  	 * @param {number} theta - The theta angle in radians.
  	 * @param {number} y - The y value.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromCylindricalCoords( radius, theta, y ) {

  		this.x = radius * Math.sin( theta );
  		this.y = y;
  		this.z = radius * Math.cos( theta );

  		return this;

  	}

  	/**
  	 * Sets the vector components to the position elements of the
  	 * given transformation matrix.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromMatrixPosition( m ) {

  		const e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];

  		return this;

  	}

  	/**
  	 * Sets the vector components to the scale elements of the
  	 * given transformation matrix.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromMatrixScale( m ) {

  		const sx = this.setFromMatrixColumn( m, 0 ).length();
  		const sy = this.setFromMatrixColumn( m, 1 ).length();
  		const sz = this.setFromMatrixColumn( m, 2 ).length();

  		this.x = sx;
  		this.y = sy;
  		this.z = sz;

  		return this;

  	}

  	/**
  	 * Sets the vector components from the specified matrix column.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @param {number} index - The column index.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromMatrixColumn( m, index ) {

  		return this.fromArray( m.elements, index * 4 );

  	}

  	/**
  	 * Sets the vector components from the specified matrix column.
  	 *
  	 * @param {Matrix3} m - The 3x3 matrix.
  	 * @param {number} index - The column index.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromMatrix3Column( m, index ) {

  		return this.fromArray( m.elements, index * 3 );

  	}

  	/**
  	 * Sets the vector components from the given Euler angles.
  	 *
  	 * @param {Euler} e - The Euler angles to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromEuler( e ) {

  		this.x = e._x;
  		this.y = e._y;
  		this.z = e._z;

  		return this;

  	}

  	/**
  	 * Sets the vector components from the RGB components of the
  	 * given color.
  	 *
  	 * @param {Color} c - The color to set.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	setFromColor( c ) {

  		this.x = c.r;
  		this.y = c.g;
  		this.z = c.b;

  		return this;

  	}

  	/**
  	 * Returns `true` if this vector is equal with the given one.
  	 *
  	 * @param {Vector3} v - The vector to test for equality.
  	 * @return {boolean} Whether this vector is equal with the given one.
  	 */
  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  	}

  	/**
  	 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
  	 * and z value to be `array[ offset + 2 ]`.
  	 *
  	 * @param {Array<number>} array - An array holding the vector component values.
  	 * @param {number} [offset=0] - The offset into the array.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];

  		return this;

  	}

  	/**
  	 * Writes the components of this vector to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The vector components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;

  		return array;

  	}

  	/**
  	 * Sets the components of this vector from the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
  	 * @param {number} index - The index into the attribute.
  	 * @return {Vector3} A reference to this vector.
  	 */
  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );

  		return this;

  	}

  	/**
  	 * Sets each component of this vector to a pseudo-random value between `0` and
  	 * `1`, excluding `1`.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	random() {

  		this.x = Math.random();
  		this.y = Math.random();
  		this.z = Math.random();

  		return this;

  	}

  	/**
  	 * Sets this vector to a uniformly random point on a unit sphere.
  	 *
  	 * @return {Vector3} A reference to this vector.
  	 */
  	randomDirection() {

  		// https://mathworld.wolfram.com/SpherePointPicking.html

  		const theta = Math.random() * Math.PI * 2;
  		const u = Math.random() * 2 - 1;
  		const c = Math.sqrt( 1 - u * u );

  		this.x = c * Math.cos( theta );
  		this.y = u;
  		this.z = c * Math.sin( theta );

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;
  		yield this.z;

  	}

  }

  const _vector$c = /*@__PURE__*/ new Vector3();
  const _quaternion$4 = /*@__PURE__*/ new Quaternion();

  /**
   * Represents a 3x3 matrix.
   *
   * A Note on Row-Major and Column-Major Ordering:
   *
   * The constructor and {@link Matrix3#set} method take arguments in
   * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}
   * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
   * This means that calling:
   * ```js
   * const m = new THREE.Matrix();
   * m.set( 11, 12, 13,
   *        21, 22, 23,
   *        31, 32, 33 );
   * ```
   * will result in the elements array containing:
   * ```js
   * m.elements = [ 11, 21, 31,
   *                12, 22, 32,
   *                13, 23, 33 ];
   * ```
   * and internally all calculations are performed using column-major ordering.
   * However, as the actual ordering makes no difference mathematically and
   * most people are used to thinking about matrices in row-major order, the
   * three.js documentation shows matrices in row-major order. Just bear in
   * mind that if you are reading the source code, you'll have to take the
   * transpose of any matrices outlined here to make sense of the calculations.
   */
  class Matrix3 {

  	/**
  	 * Constructs a new 3x3 matrix. The arguments are supposed to be
  	 * in row-major order. If no arguments are provided, the constructor
  	 * initializes the matrix as an identity matrix.
  	 *
  	 * @param {number} [n11] - 1-1 matrix element.
  	 * @param {number} [n12] - 1-2 matrix element.
  	 * @param {number} [n13] - 1-3 matrix element.
  	 * @param {number} [n21] - 2-1 matrix element.
  	 * @param {number} [n22] - 2-2 matrix element.
  	 * @param {number} [n23] - 2-3 matrix element.
  	 * @param {number} [n31] - 3-1 matrix element.
  	 * @param {number} [n32] - 3-2 matrix element.
  	 * @param {number} [n33] - 3-3 matrix element.
  	 */
  	constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		Matrix3.prototype.isMatrix3 = true;

  		/**
  		 * A column-major list of matrix values.
  		 *
  		 * @type {Array<number>}
  		 */
  		this.elements = [

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		];

  		if ( n11 !== undefined ) {

  			this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

  		}

  	}

  	/**
  	 * Sets the elements of the matrix.The arguments are supposed to be
  	 * in row-major order.
  	 *
  	 * @param {number} [n11] - 1-1 matrix element.
  	 * @param {number} [n12] - 1-2 matrix element.
  	 * @param {number} [n13] - 1-3 matrix element.
  	 * @param {number} [n21] - 2-1 matrix element.
  	 * @param {number} [n22] - 2-2 matrix element.
  	 * @param {number} [n23] - 2-3 matrix element.
  	 * @param {number} [n31] - 3-1 matrix element.
  	 * @param {number} [n32] - 3-2 matrix element.
  	 * @param {number} [n33] - 3-3 matrix element.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		const te = this.elements;

  		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
  		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
  		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

  		return this;

  	}

  	/**
  	 * Sets this matrix to the 3x3 identity matrix.
  	 *
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	identity() {

  		this.set(

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Copies the values of the given matrix to this instance.
  	 *
  	 * @param {Matrix3} m - The matrix to copy.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	copy( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
  		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
  		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

  		return this;

  	}

  	/**
  	 * Extracts the basis of this matrix into the three axis vectors provided.
  	 *
  	 * @param {Vector3} xAxis - The basis's x axis.
  	 * @param {Vector3} yAxis - The basis's y axis.
  	 * @param {Vector3} zAxis - The basis's z axis.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	extractBasis( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrix3Column( this, 0 );
  		yAxis.setFromMatrix3Column( this, 1 );
  		zAxis.setFromMatrix3Column( this, 2 );

  		return this;

  	}

  	/**
  	 * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	setFromMatrix4( m ) {

  		const me = m.elements;

  		this.set(

  			me[ 0 ], me[ 4 ], me[ 8 ],
  			me[ 1 ], me[ 5 ], me[ 9 ],
  			me[ 2 ], me[ 6 ], me[ 10 ]

  		);

  		return this;

  	}

  	/**
  	 * Post-multiplies this matrix by the given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The matrix to multiply with.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	multiply( m ) {

  		return this.multiplyMatrices( this, m );

  	}

  	/**
  	 * Pre-multiplies this matrix by the given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The matrix to multiply with.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	premultiply( m ) {

  		return this.multiplyMatrices( m, this );

  	}

  	/**
  	 * Multiples the given 3x3 matrices and stores the result
  	 * in this matrix.
  	 *
  	 * @param {Matrix3} a - The first matrix.
  	 * @param {Matrix3} b - The second matrix.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	multiplyMatrices( a, b ) {

  		const ae = a.elements;
  		const be = b.elements;
  		const te = this.elements;

  		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
  		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
  		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

  		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
  		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
  		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
  		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
  		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
  		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
  		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
  		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
  		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

  		return this;

  	}

  	/**
  	 * Multiplies every component of the matrix by the given scalar.
  	 *
  	 * @param {number} s - The scalar.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	multiplyScalar( s ) {

  		const te = this.elements;

  		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
  		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
  		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

  		return this;

  	}

  	/**
  	 * Computes and returns the determinant of this matrix.
  	 *
  	 * @return {number} The determinant.
  	 */
  	determinant() {

  		const te = this.elements;

  		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
  			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
  			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

  		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  	}

  	/**
  	 * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
  	 * You can not invert with a determinant of zero. If you attempt this, the method produces
  	 * a zero matrix instead.
  	 *
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	invert() {

  		const te = this.elements,

  			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
  			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
  			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

  			t11 = n33 * n22 - n32 * n23,
  			t12 = n32 * n13 - n33 * n12,
  			t13 = n23 * n12 - n22 * n13,

  			det = n11 * t11 + n21 * t12 + n31 * t13;

  		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

  		const detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
  		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

  		te[ 3 ] = t12 * detInv;
  		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
  		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

  		te[ 6 ] = t13 * detInv;
  		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
  		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

  		return this;

  	}

  	/**
  	 * Transposes this matrix in place.
  	 *
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	transpose() {

  		let tmp;
  		const m = this.elements;

  		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
  		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
  		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

  		return this;

  	}

  	/**
  	 * Computes the normal matrix which is the inverse transpose of the upper
  	 * left 3x3 portion of the given 4x4 matrix.
  	 *
  	 * @param {Matrix4} matrix4 - The 4x4 matrix.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	getNormalMatrix( matrix4 ) {

  		return this.setFromMatrix4( matrix4 ).invert().transpose();

  	}

  	/**
  	 * Transposes this matrix into the supplied array, and returns itself unchanged.
  	 *
  	 * @param {Array<number>} r - An array to store the transposed matrix elements.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	transposeIntoArray( r ) {

  		const m = this.elements;

  		r[ 0 ] = m[ 0 ];
  		r[ 1 ] = m[ 3 ];
  		r[ 2 ] = m[ 6 ];
  		r[ 3 ] = m[ 1 ];
  		r[ 4 ] = m[ 4 ];
  		r[ 5 ] = m[ 7 ];
  		r[ 6 ] = m[ 2 ];
  		r[ 7 ] = m[ 5 ];
  		r[ 8 ] = m[ 8 ];

  		return this;

  	}

  	/**
  	 * Sets the UV transform matrix from offset, repeat, rotation, and center.
  	 *
  	 * @param {number} tx - Offset x.
  	 * @param {number} ty - Offset y.
  	 * @param {number} sx - Repeat x.
  	 * @param {number} sy - Repeat y.
  	 * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
  	 * @param {number} cx - Center x of rotation.
  	 * @param {number} cy - Center y of rotation
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

  		const c = Math.cos( rotation );
  		const s = Math.sin( rotation );

  		this.set(
  			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
  			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
  			0, 0, 1
  		);

  		return this;

  	}

  	/**
  	 * Scales this matrix with the given scalar values.
  	 *
  	 * @param {number} sx - The amount to scale in the X axis.
  	 * @param {number} sy - The amount to scale in the Y axis.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	scale( sx, sy ) {

  		this.premultiply( _m3.makeScale( sx, sy ) );

  		return this;

  	}

  	/**
  	 * Rotates this matrix by the given angle.
  	 *
  	 * @param {number} theta - The rotation in radians.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	rotate( theta ) {

  		this.premultiply( _m3.makeRotation( - theta ) );

  		return this;

  	}

  	/**
  	 * Translates this matrix by the given scalar values.
  	 *
  	 * @param {number} tx - The amount to translate in the X axis.
  	 * @param {number} ty - The amount to translate in the Y axis.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	translate( tx, ty ) {

  		this.premultiply( _m3.makeTranslation( tx, ty ) );

  		return this;

  	}

  	// for 2D Transforms

  	/**
  	 * Sets this matrix as a 2D translation transform.
  	 *
  	 * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
  	 * @param {number} y - The amount to translate in the Y axis.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	makeTranslation( x, y ) {

  		if ( x.isVector2 ) {

  			this.set(

  				1, 0, x.x,
  				0, 1, x.y,
  				0, 0, 1

  			);

  		} else {

  			this.set(

  				1, 0, x,
  				0, 1, y,
  				0, 0, 1

  			);

  		}

  		return this;

  	}

  	/**
  	 * Sets this matrix as a 2D rotational transformation.
  	 *
  	 * @param {number} theta - The rotation in radians.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	makeRotation( theta ) {

  		// counterclockwise

  		const c = Math.cos( theta );
  		const s = Math.sin( theta );

  		this.set(

  			c, - s, 0,
  			s, c, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a 2D scale transform.
  	 *
  	 * @param {number} x - The amount to scale in the X axis.
  	 * @param {number} y - The amount to scale in the Y axis.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	makeScale( x, y ) {

  		this.set(

  			x, 0, 0,
  			0, y, 0,
  			0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Returns `true` if this matrix is equal with the given one.
  	 *
  	 * @param {Matrix3} matrix - The matrix to test for equality.
  	 * @return {boolean} Whether this matrix is equal with the given one.
  	 */
  	equals( matrix ) {

  		const te = this.elements;
  		const me = matrix.elements;

  		for ( let i = 0; i < 9; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	}

  	/**
  	 * Sets the elements of the matrix from the given array.
  	 *
  	 * @param {Array<number>} array - The matrix elements in column-major order.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Matrix3} A reference to this matrix.
  	 */
  	fromArray( array, offset = 0 ) {

  		for ( let i = 0; i < 9; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	}

  	/**
  	 * Writes the elements of this matrix to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The matrix elements in column-major order.
  	 */
  	toArray( array = [], offset = 0 ) {

  		const te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];

  		array[ offset + 3 ] = te[ 3 ];
  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];

  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];
  		array[ offset + 8 ] = te[ 8 ];

  		return array;

  	}

  	/**
  	 * Returns a matrix with copied values from this instance.
  	 *
  	 * @return {Matrix3} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().fromArray( this.elements );

  	}

  }

  const _m3 = /*@__PURE__*/ new Matrix3();

  function arrayNeedsUint32( array ) {

  	// assumes larger values usually on last

  	for ( let i = array.length - 1; i >= 0; -- i ) {

  		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

  	}

  	return false;

  }

  function createElementNS( name ) {

  	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

  }

  function createCanvasElement() {

  	const canvas = createElementNS( 'canvas' );
  	canvas.style.display = 'block';
  	return canvas;

  }

  const _cache = {};

  function warnOnce( message ) {

  	if ( message in _cache ) return;

  	_cache[ message ] = true;

  	console.warn( message );

  }

  function probeAsync( gl, sync, interval ) {

  	return new Promise( function ( resolve, reject ) {

  		function probe() {

  			switch ( gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 ) ) {

  				case gl.WAIT_FAILED:
  					reject();
  					break;

  				case gl.TIMEOUT_EXPIRED:
  					setTimeout( probe, interval );
  					break;

  				default:
  					resolve();

  			}

  		}

  		setTimeout( probe, interval );

  	} );

  }

  const LINEAR_REC709_TO_XYZ = /*@__PURE__*/ new Matrix3().set(
  	0.4123908, 0.3575843, 0.1804808,
  	0.2126390, 0.7151687, 0.0721923,
  	0.0193308, 0.1191948, 0.9505322
  );

  const XYZ_TO_LINEAR_REC709 = /*@__PURE__*/ new Matrix3().set(
  	3.2409699, -1.5373832, -0.4986108,
  	-0.9692436, 1.8759675, 0.0415551,
  	0.0556301, -0.203977, 1.0569715
  );

  function createColorManagement() {

  	const ColorManagement = {

  		enabled: true,

  		workingColorSpace: LinearSRGBColorSpace,

  		/**
  		 * Implementations of supported color spaces.
  		 *
  		 * Required:
  		 *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
  		 *	- whitePoint: reference white [ x y ]
  		 *	- transfer: transfer function (pre-defined)
  		 *	- toXYZ: Matrix3 RGB to XYZ transform
  		 *	- fromXYZ: Matrix3 XYZ to RGB transform
  		 *	- luminanceCoefficients: RGB luminance coefficients
  		 *
  		 * Optional:
  		 *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace, toneMappingMode: 'extended' | 'standard' }
  		 *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
  		 *
  		 * Reference:
  		 * - https://www.russellcottrell.com/photo/matrixCalculator.htm
  		 */
  		spaces: {},

  		convert: function ( color, sourceColorSpace, targetColorSpace ) {

  			if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

  				return color;

  			}

  			if ( this.spaces[ sourceColorSpace ].transfer === SRGBTransfer ) {

  				color.r = SRGBToLinear( color.r );
  				color.g = SRGBToLinear( color.g );
  				color.b = SRGBToLinear( color.b );

  			}

  			if ( this.spaces[ sourceColorSpace ].primaries !== this.spaces[ targetColorSpace ].primaries ) {

  				color.applyMatrix3( this.spaces[ sourceColorSpace ].toXYZ );
  				color.applyMatrix3( this.spaces[ targetColorSpace ].fromXYZ );

  			}

  			if ( this.spaces[ targetColorSpace ].transfer === SRGBTransfer ) {

  				color.r = LinearToSRGB( color.r );
  				color.g = LinearToSRGB( color.g );
  				color.b = LinearToSRGB( color.b );

  			}

  			return color;

  		},

  		workingToColorSpace: function ( color, targetColorSpace ) {

  			return this.convert( color, this.workingColorSpace, targetColorSpace );

  		},

  		colorSpaceToWorking: function ( color, sourceColorSpace ) {

  			return this.convert( color, sourceColorSpace, this.workingColorSpace );

  		},

  		getPrimaries: function ( colorSpace ) {

  			return this.spaces[ colorSpace ].primaries;

  		},

  		getTransfer: function ( colorSpace ) {

  			if ( colorSpace === NoColorSpace ) return LinearTransfer;

  			return this.spaces[ colorSpace ].transfer;

  		},

  		getToneMappingMode: function ( colorSpace ) {

  			return this.spaces[ colorSpace ].outputColorSpaceConfig.toneMappingMode || 'standard';

  		},

  		getLuminanceCoefficients: function ( target, colorSpace = this.workingColorSpace ) {

  			return target.fromArray( this.spaces[ colorSpace ].luminanceCoefficients );

  		},

  		define: function ( colorSpaces ) {

  			Object.assign( this.spaces, colorSpaces );

  		},

  		// Internal APIs

  		_getMatrix: function ( targetMatrix, sourceColorSpace, targetColorSpace ) {

  			return targetMatrix
  				.copy( this.spaces[ sourceColorSpace ].toXYZ )
  				.multiply( this.spaces[ targetColorSpace ].fromXYZ );

  		},

  		_getDrawingBufferColorSpace: function ( colorSpace ) {

  			return this.spaces[ colorSpace ].outputColorSpaceConfig.drawingBufferColorSpace;

  		},

  		_getUnpackColorSpace: function ( colorSpace = this.workingColorSpace ) {

  			return this.spaces[ colorSpace ].workingColorSpaceConfig.unpackColorSpace;

  		},

  		// Deprecated

  		fromWorkingColorSpace: function ( color, targetColorSpace ) {

  			warnOnce( 'THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().' ); // @deprecated, r177

  			return ColorManagement.workingToColorSpace( color, targetColorSpace );

  		},

  		toWorkingColorSpace: function ( color, sourceColorSpace ) {

  			warnOnce( 'THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().' ); // @deprecated, r177

  			return ColorManagement.colorSpaceToWorking( color, sourceColorSpace );

  		},

  	};

  	/******************************************************************************
  	 * sRGB definitions
  	 */

  	const REC709_PRIMARIES = [ 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 ];
  	const REC709_LUMINANCE_COEFFICIENTS = [ 0.2126, 0.7152, 0.0722 ];
  	const D65 = [ 0.3127, 0.3290 ];

  	ColorManagement.define( {

  		[ LinearSRGBColorSpace ]: {
  			primaries: REC709_PRIMARIES,
  			whitePoint: D65,
  			transfer: LinearTransfer,
  			toXYZ: LINEAR_REC709_TO_XYZ,
  			fromXYZ: XYZ_TO_LINEAR_REC709,
  			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
  			workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
  			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
  		},

  		[ SRGBColorSpace ]: {
  			primaries: REC709_PRIMARIES,
  			whitePoint: D65,
  			transfer: SRGBTransfer,
  			toXYZ: LINEAR_REC709_TO_XYZ,
  			fromXYZ: XYZ_TO_LINEAR_REC709,
  			luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
  			outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
  		},

  	} );

  	return ColorManagement;

  }

  const ColorManagement = /*@__PURE__*/ createColorManagement();

  function SRGBToLinear( c ) {

  	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

  }

  function LinearToSRGB( c ) {

  	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

  }

  let _canvas;

  /**
   * A class containing utility functions for images.
   *
   * @hideconstructor
   */
  class ImageUtils {

  	/**
  	 * Returns a data URI containing a representation of the given image.
  	 *
  	 * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
  	 * @param {string} [type='image/png'] - Indicates the image format.
  	 * @return {string} The data URI.
  	 */
  	static getDataURL( image, type = 'image/png' ) {

  		if ( /^data:/i.test( image.src ) ) {

  			return image.src;

  		}

  		if ( typeof HTMLCanvasElement === 'undefined' ) {

  			return image.src;

  		}

  		let canvas;

  		if ( image instanceof HTMLCanvasElement ) {

  			canvas = image;

  		} else {

  			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

  			_canvas.width = image.width;
  			_canvas.height = image.height;

  			const context = _canvas.getContext( '2d' );

  			if ( image instanceof ImageData ) {

  				context.putImageData( image, 0, 0 );

  			} else {

  				context.drawImage( image, 0, 0, image.width, image.height );

  			}

  			canvas = _canvas;

  		}

  		return canvas.toDataURL( type );

  	}

  	/**
  	 * Converts the given sRGB image data to linear color space.
  	 *
  	 * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
  	 * @return {HTMLCanvasElement|Object} The converted image.
  	 */
  	static sRGBToLinear( image ) {

  		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

  			const canvas = createElementNS( 'canvas' );

  			canvas.width = image.width;
  			canvas.height = image.height;

  			const context = canvas.getContext( '2d' );
  			context.drawImage( image, 0, 0, image.width, image.height );

  			const imageData = context.getImageData( 0, 0, image.width, image.height );
  			const data = imageData.data;

  			for ( let i = 0; i < data.length; i ++ ) {

  				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

  			}

  			context.putImageData( imageData, 0, 0 );

  			return canvas;

  		} else if ( image.data ) {

  			const data = image.data.slice( 0 );

  			for ( let i = 0; i < data.length; i ++ ) {

  				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

  					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

  				} else {

  					// assuming float

  					data[ i ] = SRGBToLinear( data[ i ] );

  				}

  			}

  			return {
  				data: data,
  				width: image.width,
  				height: image.height
  			};

  		} else {

  			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
  			return image;

  		}

  	}

  }

  let _sourceId = 0;

  /**
   * Represents the data source of a texture.
   *
   * The main purpose of this class is to decouple the data definition from the texture
   * definition so the same data can be used with multiple texture instances.
   */
  class Source {

  	/**
  	 * Constructs a new video texture.
  	 *
  	 * @param {any} [data=null] - The data definition of a texture.
  	 */
  	constructor( data = null ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSource = true;

  		/**
  		 * The ID of the source.
  		 *
  		 * @name Source#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _sourceId ++ } );

  		/**
  		 * The UUID of the source.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  		/**
  		 * The data definition of a texture.
  		 *
  		 * @type {any}
  		 */
  		this.data = data;

  		/**
  		 * This property is only relevant when {@link Source#needsUpdate} is set to `true` and
  		 * provides more control on how texture data should be processed. When `dataReady` is set
  		 * to `false`, the engine performs the memory allocation (if necessary) but does not transfer
  		 * the data into the GPU memory.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.dataReady = true;

  		/**
  		 * This starts at `0` and counts how many times {@link Source#needsUpdate} is set to `true`.
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default 0
  		 */
  		this.version = 0;

  	}

  	/**
  	 * Returns the dimensions of the source into the given target vector.
  	 *
  	 * @param {(Vector2|Vector3)} target - The target object the result is written into.
  	 * @return {(Vector2|Vector3)} The dimensions of the source.
  	 */
  	getSize( target ) {

  		const data = this.data;

  		if ( ( typeof HTMLVideoElement !== 'undefined' ) && ( data instanceof HTMLVideoElement ) ) {

  			target.set( data.videoWidth, data.videoHeight, 0 );

  		} else if ( data instanceof VideoFrame ) {

  			target.set( data.displayHeight, data.displayWidth, 0 );

  		} else if ( data !== null ) {

  			target.set( data.width, data.height, data.depth || 0 );

  		} else {

  			target.set( 0, 0, 0 );

  		}

  		return target;

  	}

  	/**
  	 * When the property is set to `true`, the engine allocates the memory
  	 * for the texture (if necessary) and triggers the actual texture upload
  	 * to the GPU next time the source is used.
  	 *
  	 * @type {boolean}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	/**
  	 * Serializes the source into JSON.
  	 *
  	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized source.
  	 * @see {@link ObjectLoader#parse}
  	 */
  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

  			return meta.images[ this.uuid ];

  		}

  		const output = {
  			uuid: this.uuid,
  			url: ''
  		};

  		const data = this.data;

  		if ( data !== null ) {

  			let url;

  			if ( Array.isArray( data ) ) {

  				// cube texture

  				url = [];

  				for ( let i = 0, l = data.length; i < l; i ++ ) {

  					if ( data[ i ].isDataTexture ) {

  						url.push( serializeImage( data[ i ].image ) );

  					} else {

  						url.push( serializeImage( data[ i ] ) );

  					}

  				}

  			} else {

  				// texture

  				url = serializeImage( data );

  			}

  			output.url = url;

  		}

  		if ( ! isRootObject ) {

  			meta.images[ this.uuid ] = output;

  		}

  		return output;

  	}

  }

  function serializeImage( image ) {

  	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

  		// default images

  		return ImageUtils.getDataURL( image );

  	} else {

  		if ( image.data ) {

  			// images of DataTexture

  			return {
  				data: Array.from( image.data ),
  				width: image.width,
  				height: image.height,
  				type: image.data.constructor.name
  			};

  		} else {

  			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
  			return {};

  		}

  	}

  }

  let _textureId = 0;

  const _tempVec3 = /*@__PURE__*/ new Vector3();

  /**
   * Base class for all textures.
   *
   * Note: After the initial use of a texture, its dimensions, format, and type
   * cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.
   *
   * @augments EventDispatcher
   */
  class Texture extends EventDispatcher {

  	/**
  	 * Constructs a new texture.
  	 *
  	 * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
  	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
  	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
  	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
  	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
  	 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
  	 * @param {number} [format=RGBAFormat] - The texture format.
  	 * @param {number} [type=UnsignedByteType] - The texture type.
  	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
  	 * @param {string} [colorSpace=NoColorSpace] - The color space.
  	 */
  	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isTexture = true;

  		/**
  		 * The ID of the texture.
  		 *
  		 * @name Texture#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _textureId ++ } );

  		/**
  		 * The UUID of the material.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  		/**
  		 * The name of the material.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';

  		/**
  		 * The data definition of a texture. A reference to the data source can be
  		 * shared across textures. This is often useful in context of spritesheets
  		 * where multiple textures render the same data but with different texture
  		 * transformations.
  		 *
  		 * @type {Source}
  		 */
  		this.source = new Source( image );

  		/**
  		 * An array holding user-defined mipmaps.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.mipmaps = [];

  		/**
  		 * How the texture is applied to the object. The value `UVMapping`
  		 * is the default, where texture or uv coordinates are used to apply the map.
  		 *
  		 * @type {(UVMapping|CubeReflectionMapping|CubeRefractionMapping|EquirectangularReflectionMapping|EquirectangularRefractionMapping|CubeUVReflectionMapping)}
  		 * @default UVMapping
  		*/
  		this.mapping = mapping;

  		/**
  		 * Lets you select the uv attribute to map the texture to. `0` for `uv`,
  		 * `1` for `uv1`, `2` for `uv2` and `3` for `uv3`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.channel = 0;

  		/**
  		 * This defines how the texture is wrapped horizontally and corresponds to
  		 * *U* in UV mapping.
  		 *
  		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
  		 * @default ClampToEdgeWrapping
  		 */
  		this.wrapS = wrapS;

  		/**
  		 * This defines how the texture is wrapped horizontally and corresponds to
  		 * *V* in UV mapping.
  		 *
  		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
  		 * @default ClampToEdgeWrapping
  		 */
  		this.wrapT = wrapT;

  		/**
  		 * How the texture is sampled when a texel covers more than one pixel.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default LinearFilter
  		 */
  		this.magFilter = magFilter;

  		/**
  		 * How the texture is sampled when a texel covers less than one pixel.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default LinearMipmapLinearFilter
  		 */
  		this.minFilter = minFilter;

  		/**
  		 * The number of samples taken along the axis through the pixel that has the
  		 * highest density of texels. By default, this value is `1`. A higher value
  		 * gives a less blurry result than a basic mipmap, at the cost of more
  		 * texture samples being used.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.anisotropy = anisotropy;

  		/**
  		 * The format of the texture.
  		 *
  		 * @type {number}
  		 * @default RGBAFormat
  		 */
  		this.format = format;

  		/**
  		 * The default internal format is derived from {@link Texture#format} and {@link Texture#type} and
  		 * defines how the texture data is going to be stored on the GPU.
  		 *
  		 * This property allows to overwrite the default format.
  		 *
  		 * @type {?string}
  		 * @default null
  		 */
  		this.internalFormat = null;

  		/**
  		 * The data type of the texture.
  		 *
  		 * @type {number}
  		 * @default UnsignedByteType
  		 */
  		this.type = type;

  		/**
  		 * How much a single repetition of the texture is offset from the beginning,
  		 * in each direction U and V. Typical range is `0.0` to `1.0`.
  		 *
  		 * @type {Vector2}
  		 * @default (0,0)
  		 */
  		this.offset = new Vector2( 0, 0 );

  		/**
  		 * How many times the texture is repeated across the surface, in each
  		 * direction U and V. If repeat is set greater than `1` in either direction,
  		 * the corresponding wrap parameter should also be set to `RepeatWrapping`
  		 * or `MirroredRepeatWrapping` to achieve the desired tiling effect.
  		 *
  		 * @type {Vector2}
  		 * @default (1,1)
  		 */
  		this.repeat = new Vector2( 1, 1 );

  		/**
  		 * The point around which rotation occurs. A value of `(0.5, 0.5)` corresponds
  		 * to the center of the texture. Default is `(0, 0)`, the lower left.
  		 *
  		 * @type {Vector2}
  		 * @default (0,0)
  		 */
  		this.center = new Vector2( 0, 0 );

  		/**
  		 * How much the texture is rotated around the center point, in radians.
  		 * Positive values are counter-clockwise.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.rotation = 0;

  		/**
  		 * Whether to update the texture's uv-transformation {@link Texture#matrix}
  		 * from the properties {@link Texture#offset}, {@link Texture#repeat},
  		 * {@link Texture#rotation}, and {@link Texture#center}.
  		 *
  		 * Set this to `false` if you are specifying the uv-transform matrix directly.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.matrixAutoUpdate = true;

  		/**
  		 * The uv-transformation matrix of the texture.
  		 *
  		 * @type {Matrix3}
  		 */
  		this.matrix = new Matrix3();

  		/**
  		 * Whether to generate mipmaps (if possible) for a texture.
  		 *
  		 * Set this to `false` if you are creating mipmaps manually.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.generateMipmaps = true;

  		/**
  		 * If set to `true`, the alpha channel, if present, is multiplied into the
  		 * color channels when the texture is uploaded to the GPU.
  		 *
  		 * Note that this property has no effect when using `ImageBitmap`. You need to
  		 * configure premultiply alpha on bitmap creation instead.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.premultiplyAlpha = false;

  		/**
  		 * If set to `true`, the texture is flipped along the vertical axis when
  		 * uploaded to the GPU.
  		 *
  		 * Note that this property has no effect when using `ImageBitmap`. You need to
  		 * configure the flip on bitmap creation instead.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.flipY = true;

  		/**
  		 * Specifies the alignment requirements for the start of each pixel row in memory.
  		 * The allowable values are `1` (byte-alignment), `2` (rows aligned to even-numbered bytes),
  		 * `4` (word-alignment), and `8` (rows start on double-word boundaries).
  		 *
  		 * @type {number}
  		 * @default 4
  		 */
  		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  		/**
  		 * Textures containing color data should be annotated with `SRGBColorSpace` or `LinearSRGBColorSpace`.
  		 *
  		 * @type {string}
  		 * @default NoColorSpace
  		 */
  		this.colorSpace = colorSpace;

  		/**
  		 * An object that can be used to store custom data about the texture. It
  		 * should not hold references to functions as these will not be cloned.
  		 *
  		 * @type {Object}
  		 */
  		this.userData = {};

  		/**
  		 * This can be used to only update a subregion or specific rows of the texture (for example, just the
  		 * first 3 rows). Use the `addUpdateRange()` function to add ranges to this array.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.updateRanges = [];

  		/**
  		 * This starts at `0` and counts how many times {@link Texture#needsUpdate} is set to `true`.
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default 0
  		 */
  		this.version = 0;

  		/**
  		 * A callback function, called when the texture is updated (e.g., when
  		 * {@link Texture#needsUpdate} has been set to true and then the texture is used).
  		 *
  		 * @type {?Function}
  		 * @default null
  		 */
  		this.onUpdate = null;

  		/**
  		 * An optional back reference to the textures render target.
  		 *
  		 * @type {?(RenderTarget|WebGLRenderTarget)}
  		 * @default null
  		 */
  		this.renderTarget = null;

  		/**
  		 * Indicates whether a texture belongs to a render target or not.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default false
  		 */
  		this.isRenderTargetTexture = false;

  		/**
  		 * Indicates if a texture should be handled like a texture array.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default false
  		 */
  		this.isArrayTexture = image && image.depth && image.depth > 1 ? true : false;

  		/**
  		 * Indicates whether this texture should be processed by `PMREMGenerator` or not
  		 * (only relevant for render target textures).
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default 0
  		 */
  		this.pmremVersion = 0;

  	}

  	/**
  	 * The width of the texture in pixels.
  	 */
  	get width() {

  		return this.source.getSize( _tempVec3 ).x;

  	}

  	/**
  	 * The height of the texture in pixels.
  	 */
  	get height() {

  		return this.source.getSize( _tempVec3 ).y;

  	}

  	/**
  	 * The depth of the texture in pixels.
  	 */
  	get depth() {

  		return this.source.getSize( _tempVec3 ).z;

  	}

  	/**
  	 * The image object holding the texture data.
  	 *
  	 * @type {?Object}
  	 */
  	get image() {

  		return this.source.data;

  	}

  	set image( value = null ) {

  		this.source.data = value;

  	}

  	/**
  	 * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
  	 * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
  	 */
  	updateMatrix() {

  		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

  	}

  	/**
  	 * Adds a range of data in the data texture to be updated on the GPU.
  	 *
  	 * @param {number} start - Position at which to start update.
  	 * @param {number} count - The number of components to update.
  	 */
  	addUpdateRange( start, count ) {

  		this.updateRanges.push( { start, count } );

  	}

  	/**
  	 * Clears the update ranges.
  	 */
  	clearUpdateRanges() {

  		this.updateRanges.length = 0;

  	}

  	/**
  	 * Returns a new texture with copied values from this instance.
  	 *
  	 * @return {Texture} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the values of the given texture to this instance.
  	 *
  	 * @param {Texture} source - The texture to copy.
  	 * @return {Texture} A reference to this instance.
  	 */
  	copy( source ) {

  		this.name = source.name;

  		this.source = source.source;
  		this.mipmaps = source.mipmaps.slice( 0 );

  		this.mapping = source.mapping;
  		this.channel = source.channel;

  		this.wrapS = source.wrapS;
  		this.wrapT = source.wrapT;

  		this.magFilter = source.magFilter;
  		this.minFilter = source.minFilter;

  		this.anisotropy = source.anisotropy;

  		this.format = source.format;
  		this.internalFormat = source.internalFormat;
  		this.type = source.type;

  		this.offset.copy( source.offset );
  		this.repeat.copy( source.repeat );
  		this.center.copy( source.center );
  		this.rotation = source.rotation;

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrix.copy( source.matrix );

  		this.generateMipmaps = source.generateMipmaps;
  		this.premultiplyAlpha = source.premultiplyAlpha;
  		this.flipY = source.flipY;
  		this.unpackAlignment = source.unpackAlignment;
  		this.colorSpace = source.colorSpace;

  		this.renderTarget = source.renderTarget;
  		this.isRenderTargetTexture = source.isRenderTargetTexture;
  		this.isArrayTexture = source.isArrayTexture;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		this.needsUpdate = true;

  		return this;

  	}

  	/**
  	 * Sets this texture's properties based on `values`.
  	 * @param {Object} values - A container with texture parameters.
  	 */
  	setValues( values ) {

  		for ( const key in values ) {

  			const newValue = values[ key ];

  			if ( newValue === undefined ) {

  				console.warn( `THREE.Texture.setValues(): parameter '${ key }' has value of undefined.` );
  				continue;

  			}

  			const currentValue = this[ key ];

  			if ( currentValue === undefined ) {

  				console.warn( `THREE.Texture.setValues(): property '${ key }' does not exist.` );
  				continue;

  			}

  			if ( ( currentValue && newValue ) && ( currentValue.isVector2 && newValue.isVector2 ) ) {

  				currentValue.copy( newValue );

  			} else if ( ( currentValue && newValue ) && ( currentValue.isVector3 && newValue.isVector3 ) ) {

  				currentValue.copy( newValue );

  			} else if ( ( currentValue && newValue ) && ( currentValue.isMatrix3 && newValue.isMatrix3 ) ) {

  				currentValue.copy( newValue );

  			} else {

  				this[ key ] = newValue;

  			}

  		}

  	}

  	/**
  	 * Serializes the texture into JSON.
  	 *
  	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized texture.
  	 * @see {@link ObjectLoader#parse}
  	 */
  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

  			return meta.textures[ this.uuid ];

  		}

  		const output = {

  			metadata: {
  				version: 4.7,
  				type: 'Texture',
  				generator: 'Texture.toJSON'
  			},

  			uuid: this.uuid,
  			name: this.name,

  			image: this.source.toJSON( meta ).uuid,

  			mapping: this.mapping,
  			channel: this.channel,

  			repeat: [ this.repeat.x, this.repeat.y ],
  			offset: [ this.offset.x, this.offset.y ],
  			center: [ this.center.x, this.center.y ],
  			rotation: this.rotation,

  			wrap: [ this.wrapS, this.wrapT ],

  			format: this.format,
  			internalFormat: this.internalFormat,
  			type: this.type,
  			colorSpace: this.colorSpace,

  			minFilter: this.minFilter,
  			magFilter: this.magFilter,
  			anisotropy: this.anisotropy,

  			flipY: this.flipY,

  			generateMipmaps: this.generateMipmaps,
  			premultiplyAlpha: this.premultiplyAlpha,
  			unpackAlignment: this.unpackAlignment

  		};

  		if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

  		if ( ! isRootObject ) {

  			meta.textures[ this.uuid ] = output;

  		}

  		return output;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 *
  	 * @fires Texture#dispose
  	 */
  	dispose() {

  		/**
  		 * Fires when the texture has been disposed of.
  		 *
  		 * @event Texture#dispose
  		 * @type {Object}
  		 */
  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	/**
  	 * Transforms the given uv vector with the textures uv transformation matrix.
  	 *
  	 * @param {Vector2} uv - The uv vector.
  	 * @return {Vector2} The transformed uv vector.
  	 */
  	transformUv( uv ) {

  		if ( this.mapping !== UVMapping ) return uv;

  		uv.applyMatrix3( this.matrix );

  		if ( uv.x < 0 || uv.x > 1 ) {

  			switch ( this.wrapS ) {

  				case RepeatWrapping:

  					uv.x = uv.x - Math.floor( uv.x );
  					break;

  				case ClampToEdgeWrapping:

  					uv.x = uv.x < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

  						uv.x = Math.ceil( uv.x ) - uv.x;

  					} else {

  						uv.x = uv.x - Math.floor( uv.x );

  					}

  					break;

  			}

  		}

  		if ( uv.y < 0 || uv.y > 1 ) {

  			switch ( this.wrapT ) {

  				case RepeatWrapping:

  					uv.y = uv.y - Math.floor( uv.y );
  					break;

  				case ClampToEdgeWrapping:

  					uv.y = uv.y < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

  						uv.y = Math.ceil( uv.y ) - uv.y;

  					} else {

  						uv.y = uv.y - Math.floor( uv.y );

  					}

  					break;

  			}

  		}

  		if ( this.flipY ) {

  			uv.y = 1 - uv.y;

  		}

  		return uv;

  	}

  	/**
  	 * Setting this property to `true` indicates the engine the texture
  	 * must be updated in the next render. This triggers a texture upload
  	 * to the GPU and ensures correct texture parameter configuration.
  	 *
  	 * @type {boolean}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		if ( value === true ) {

  			this.version ++;
  			this.source.needsUpdate = true;

  		}

  	}

  	/**
  	 * Setting this property to `true` indicates the engine the PMREM
  	 * must be regenerated.
  	 *
  	 * @type {boolean}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsPMREMUpdate( value ) {

  		if ( value === true ) {

  			this.pmremVersion ++;

  		}

  	}

  }

  /**
   * The default image for all textures.
   *
   * @static
   * @type {?Image}
   * @default null
   */
  Texture.DEFAULT_IMAGE = null;

  /**
   * The default mapping for all textures.
   *
   * @static
   * @type {number}
   * @default UVMapping
   */
  Texture.DEFAULT_MAPPING = UVMapping;

  /**
   * The default anisotropy value for all textures.
   *
   * @static
   * @type {number}
   * @default 1
   */
  Texture.DEFAULT_ANISOTROPY = 1;

  /**
   * Class representing a 4D vector. A 4D vector is an ordered quadruplet of numbers
   * (labeled x, y, z and w), which can be used to represent a number of things, such as:
   *
   * - A point in 4D space.
   * - A direction and length in 4D space. In three.js the length will
   * always be the Euclidean distance(straight-line distance) from `(0, 0, 0, 0)` to `(x, y, z, w)`
   * and the direction is also measured from `(0, 0, 0, 0)` towards `(x, y, z, w)`.
   * - Any arbitrary ordered quadruplet of numbers.
   *
   * There are other things a 4D vector can be used to represent, however these
   * are the most common uses in *three.js*.
   *
   * Iterating through a vector instance will yield its components `(x, y, z, w)` in
   * the corresponding order.
   * ```js
   * const a = new THREE.Vector4( 0, 1, 0, 0 );
   *
   * //no arguments; will be initialised to (0, 0, 0, 1)
   * const b = new THREE.Vector4( );
   *
   * const d = a.dot( b );
   * ```
   */
  class Vector4 {

  	/**
  	 * Constructs a new 4D vector.
  	 *
  	 * @param {number} [x=0] - The x value of this vector.
  	 * @param {number} [y=0] - The y value of this vector.
  	 * @param {number} [z=0] - The z value of this vector.
  	 * @param {number} [w=1] - The w value of this vector.
  	 */
  	constructor( x = 0, y = 0, z = 0, w = 1 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		Vector4.prototype.isVector4 = true;

  		/**
  		 * The x value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.x = x;

  		/**
  		 * The y value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.y = y;

  		/**
  		 * The z value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.z = z;

  		/**
  		 * The w value of this vector.
  		 *
  		 * @type {number}
  		 */
  		this.w = w;

  	}

  	/**
  	 * Alias for {@link Vector4#z}.
  	 *
  	 * @type {number}
  	 */
  	get width() {

  		return this.z;

  	}

  	set width( value ) {

  		this.z = value;

  	}

  	/**
  	 * Alias for {@link Vector4#w}.
  	 *
  	 * @type {number}
  	 */
  	get height() {

  		return this.w;

  	}

  	set height( value ) {

  		this.w = value;

  	}

  	/**
  	 * Sets the vector components.
  	 *
  	 * @param {number} x - The value of the x component.
  	 * @param {number} y - The value of the y component.
  	 * @param {number} z - The value of the z component.
  	 * @param {number} w - The value of the w component.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	set( x, y, z, w ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  		return this;

  	}

  	/**
  	 * Sets the vector components to the same value.
  	 *
  	 * @param {number} scalar - The value to set for all vector components.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setScalar( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;
  		this.w = scalar;

  		return this;

  	}

  	/**
  	 * Sets the vector's x component to the given value
  	 *
  	 * @param {number} x - The value to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setX( x ) {

  		this.x = x;

  		return this;

  	}

  	/**
  	 * Sets the vector's y component to the given value
  	 *
  	 * @param {number} y - The value to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setY( y ) {

  		this.y = y;

  		return this;

  	}

  	/**
  	 * Sets the vector's z component to the given value
  	 *
  	 * @param {number} z - The value to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setZ( z ) {

  		this.z = z;

  		return this;

  	}

  	/**
  	 * Sets the vector's w component to the given value
  	 *
  	 * @param {number} w - The value to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setW( w ) {

  		this.w = w;

  		return this;

  	}

  	/**
  	 * Allows to set a vector component with an index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
  	 * `2` equals to z, `3` equals to w.
  	 * @param {number} value - The value to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setComponent( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			case 3: this.w = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	}

  	/**
  	 * Returns the value of the vector component which matches the given index.
  	 *
  	 * @param {number} index - The component index. `0` equals to x, `1` equals to y,
  	 * `2` equals to z, `3` equals to w.
  	 * @return {number} A vector component value.
  	 */
  	getComponent( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			case 3: return this.w;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	}

  	/**
  	 * Returns a new vector with copied values from this instance.
  	 *
  	 * @return {Vector4} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this.x, this.y, this.z, this.w );

  	}

  	/**
  	 * Copies the values of the given vector to this instance.
  	 *
  	 * @param {Vector3|Vector4} v - The vector to copy.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	copy( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;
  		this.w = ( v.w !== undefined ) ? v.w : 1;

  		return this;

  	}

  	/**
  	 * Adds the given vector to this instance.
  	 *
  	 * @param {Vector4} v - The vector to add.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	add( v ) {

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;
  		this.w += v.w;

  		return this;

  	}

  	/**
  	 * Adds the given scalar value to all components of this instance.
  	 *
  	 * @param {number} s - The scalar to add.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	addScalar( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;
  		this.w += s;

  		return this;

  	}

  	/**
  	 * Adds the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector4} a - The first vector.
  	 * @param {Vector4} b - The second vector.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	addVectors( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;
  		this.w = a.w + b.w;

  		return this;

  	}

  	/**
  	 * Adds the given vector scaled by the given factor to this instance.
  	 *
  	 * @param {Vector4} v - The vector.
  	 * @param {number} s - The factor that scales `v`.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	addScaledVector( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;
  		this.w += v.w * s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vector from this instance.
  	 *
  	 * @param {Vector4} v - The vector to subtract.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	sub( v ) {

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;
  		this.w -= v.w;

  		return this;

  	}

  	/**
  	 * Subtracts the given scalar value from all components of this instance.
  	 *
  	 * @param {number} s - The scalar to subtract.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	subScalar( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;
  		this.w -= s;

  		return this;

  	}

  	/**
  	 * Subtracts the given vectors and stores the result in this instance.
  	 *
  	 * @param {Vector4} a - The first vector.
  	 * @param {Vector4} b - The second vector.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	subVectors( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;
  		this.w = a.w - b.w;

  		return this;

  	}

  	/**
  	 * Multiplies the given vector with this instance.
  	 *
  	 * @param {Vector4} v - The vector to multiply.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	multiply( v ) {

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;
  		this.w *= v.w;

  		return this;

  	}

  	/**
  	 * Multiplies the given scalar value with all components of this instance.
  	 *
  	 * @param {number} scalar - The scalar to multiply.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	multiplyScalar( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;
  		this.w *= scalar;

  		return this;

  	}

  	/**
  	 * Multiplies this vector with the given 4x4 matrix.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	applyMatrix4( m ) {

  		const x = this.x, y = this.y, z = this.z, w = this.w;
  		const e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
  		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

  		return this;

  	}

  	/**
  	 * Divides this instance by the given vector.
  	 *
  	 * @param {Vector4} v - The vector to divide.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	divide( v ) {

  		this.x /= v.x;
  		this.y /= v.y;
  		this.z /= v.z;
  		this.w /= v.w;

  		return this;

  	}

  	/**
  	 * Divides this vector by the given scalar.
  	 *
  	 * @param {number} scalar - The scalar to divide.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	divideScalar( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	}

  	/**
  	 * Sets the x, y and z components of this
  	 * vector to the quaternion's axis and w to the angle.
  	 *
  	 * @param {Quaternion} q - The Quaternion to set.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setAxisAngleFromQuaternion( q ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

  		// q is assumed to be normalized

  		this.w = 2 * Math.acos( q.w );

  		const s = Math.sqrt( 1 - q.w * q.w );

  		if ( s < 0.0001 ) {

  			this.x = 1;
  			this.y = 0;
  			this.z = 0;

  		} else {

  			this.x = q.x / s;
  			this.y = q.y / s;
  			this.z = q.z / s;

  		}

  		return this;

  	}

  	/**
  	 * Sets the x, y and z components of this
  	 * vector to the axis of rotation and w to the angle.
  	 *
  	 * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setAxisAngleFromRotationMatrix( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		let angle, x, y, z; // variables for result
  		const epsilon = 0.01,		// margin to allow for rounding errors
  			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

  			te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
  		     ( Math.abs( m13 - m31 ) < epsilon ) &&
  		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

  			// singularity found
  			// first check for identity matrix which must have +1 for all terms
  			// in leading diagonal and zero in other terms

  			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
  			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
  			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
  			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

  				// this singularity is identity matrix so angle = 0

  				this.set( 1, 0, 0, 0 );

  				return this; // zero angle, arbitrary axis

  			}

  			// otherwise this singularity is angle = 180

  			angle = Math.PI;

  			const xx = ( m11 + 1 ) / 2;
  			const yy = ( m22 + 1 ) / 2;
  			const zz = ( m33 + 1 ) / 2;
  			const xy = ( m12 + m21 ) / 4;
  			const xz = ( m13 + m31 ) / 4;
  			const yz = ( m23 + m32 ) / 4;

  			if ( ( xx > yy ) && ( xx > zz ) ) {

  				// m11 is the largest diagonal term

  				if ( xx < epsilon ) {

  					x = 0;
  					y = 0.707106781;
  					z = 0.707106781;

  				} else {

  					x = Math.sqrt( xx );
  					y = xy / x;
  					z = xz / x;

  				}

  			} else if ( yy > zz ) {

  				// m22 is the largest diagonal term

  				if ( yy < epsilon ) {

  					x = 0.707106781;
  					y = 0;
  					z = 0.707106781;

  				} else {

  					y = Math.sqrt( yy );
  					x = xy / y;
  					z = yz / y;

  				}

  			} else {

  				// m33 is the largest diagonal term so base result on this

  				if ( zz < epsilon ) {

  					x = 0.707106781;
  					y = 0.707106781;
  					z = 0;

  				} else {

  					z = Math.sqrt( zz );
  					x = xz / z;
  					y = yz / z;

  				}

  			}

  			this.set( x, y, z, angle );

  			return this; // return 180 deg rotation

  		}

  		// as we have reached here there are no singularities so we can handle normally

  		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
  			( m13 - m31 ) * ( m13 - m31 ) +
  			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

  		if ( Math.abs( s ) < 0.001 ) s = 1;

  		// prevent divide by zero, should not happen if matrix is orthogonal and should be
  		// caught by singularity test above, but I've left it in just in case

  		this.x = ( m32 - m23 ) / s;
  		this.y = ( m13 - m31 ) / s;
  		this.z = ( m21 - m12 ) / s;
  		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

  		return this;

  	}

  	/**
  	 * Sets the vector components to the position elements of the
  	 * given transformation matrix.
  	 *
  	 * @param {Matrix4} m - The 4x4 matrix.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setFromMatrixPosition( m ) {

  		const e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];
  		this.w = e[ 15 ];

  		return this;

  	}

  	/**
  	 * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
  	 * value, replace that value with the corresponding min value.
  	 *
  	 * @param {Vector4} v - The vector.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	min( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );
  		this.w = Math.min( this.w, v.w );

  		return this;

  	}

  	/**
  	 * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
  	 * value, replace that value with the corresponding max value.
  	 *
  	 * @param {Vector4} v - The vector.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	max( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );
  		this.w = Math.max( this.w, v.w );

  		return this;

  	}

  	/**
  	 * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
  	 * value, it is replaced by the corresponding value.
  	 * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
  	 * it is replaced by the corresponding value.
  	 *
  	 * @param {Vector4} min - The minimum x, y and z values.
  	 * @param {Vector4} max - The maximum x, y and z values in the desired range.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	clamp( min, max ) {

  		// assumes min < max, componentwise

  		this.x = clamp( this.x, min.x, max.x );
  		this.y = clamp( this.y, min.y, max.y );
  		this.z = clamp( this.z, min.z, max.z );
  		this.w = clamp( this.w, min.w, max.w );

  		return this;

  	}

  	/**
  	 * If this vector's x, y, z or w values are greater than the max value, they are
  	 * replaced by the max value.
  	 * If this vector's x, y, z or w values are less than the min value, they are
  	 * replaced by the min value.
  	 *
  	 * @param {number} minVal - The minimum value the components will be clamped to.
  	 * @param {number} maxVal - The maximum value the components will be clamped to.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	clampScalar( minVal, maxVal ) {

  		this.x = clamp( this.x, minVal, maxVal );
  		this.y = clamp( this.y, minVal, maxVal );
  		this.z = clamp( this.z, minVal, maxVal );
  		this.w = clamp( this.w, minVal, maxVal );

  		return this;

  	}

  	/**
  	 * If this vector's length is greater than the max value, it is replaced by
  	 * the max value.
  	 * If this vector's length is less than the min value, it is replaced by the
  	 * min value.
  	 *
  	 * @param {number} min - The minimum value the vector length will be clamped to.
  	 * @param {number} max - The maximum value the vector length will be clamped to.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	clampLength( min, max ) {

  		const length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );

  	}

  	/**
  	 * The components of this vector are rounded down to the nearest integer value.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	floor() {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );
  		this.w = Math.floor( this.w );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded up to the nearest integer value.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	ceil() {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );
  		this.w = Math.ceil( this.w );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded to the nearest integer value
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	round() {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );
  		this.w = Math.round( this.w );

  		return this;

  	}

  	/**
  	 * The components of this vector are rounded towards zero (up if negative,
  	 * down if positive) to an integer value.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	roundToZero() {

  		this.x = Math.trunc( this.x );
  		this.y = Math.trunc( this.y );
  		this.z = Math.trunc( this.z );
  		this.w = Math.trunc( this.w );

  		return this;

  	}

  	/**
  	 * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	negate() {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;
  		this.w = - this.w;

  		return this;

  	}

  	/**
  	 * Calculates the dot product of the given vector with this instance.
  	 *
  	 * @param {Vector4} v - The vector to compute the dot product with.
  	 * @return {number} The result of the dot product.
  	 */
  	dot( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  	}

  	/**
  	 * Computes the square of the Euclidean length (straight-line length) from
  	 * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
  	 * compare the length squared instead as it is slightly more efficient to calculate.
  	 *
  	 * @return {number} The square length of this vector.
  	 */
  	lengthSq() {

  		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  	}

  	/**
  	 * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	length() {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  	}

  	/**
  	 * Computes the Manhattan length of this vector.
  	 *
  	 * @return {number} The length of this vector.
  	 */
  	manhattanLength() {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  	}

  	/**
  	 * Converts this vector to a unit vector - that is, sets it equal to a vector
  	 * with the same direction as this one, but with a vector length of `1`.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	normalize() {

  		return this.divideScalar( this.length() || 1 );

  	}

  	/**
  	 * Sets this vector to a vector with the same direction as this one, but
  	 * with the specified length.
  	 *
  	 * @param {number} length - The new length of this vector.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	setLength( length ) {

  		return this.normalize().multiplyScalar( length );

  	}

  	/**
  	 * Linearly interpolates between the given vector and this instance, where
  	 * alpha is the percent distance along the line - alpha = 0 will be this
  	 * vector, and alpha = 1 will be the given one.
  	 *
  	 * @param {Vector4} v - The vector to interpolate towards.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	lerp( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;
  		this.w += ( v.w - this.w ) * alpha;

  		return this;

  	}

  	/**
  	 * Linearly interpolates between the given vectors, where alpha is the percent
  	 * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
  	 * be the second one. The result is stored in this instance.
  	 *
  	 * @param {Vector4} v1 - The first vector.
  	 * @param {Vector4} v2 - The second vector.
  	 * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	lerpVectors( v1, v2, alpha ) {

  		this.x = v1.x + ( v2.x - v1.x ) * alpha;
  		this.y = v1.y + ( v2.y - v1.y ) * alpha;
  		this.z = v1.z + ( v2.z - v1.z ) * alpha;
  		this.w = v1.w + ( v2.w - v1.w ) * alpha;

  		return this;

  	}

  	/**
  	 * Returns `true` if this vector is equal with the given one.
  	 *
  	 * @param {Vector4} v - The vector to test for equality.
  	 * @return {boolean} Whether this vector is equal with the given one.
  	 */
  	equals( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  	}

  	/**
  	 * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
  	 * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
  	 *
  	 * @param {Array<number>} array - An array holding the vector component values.
  	 * @param {number} [offset=0] - The offset into the array.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	fromArray( array, offset = 0 ) {

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];
  		this.w = array[ offset + 3 ];

  		return this;

  	}

  	/**
  	 * Writes the components of this vector to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the vector components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The vector components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;
  		array[ offset + 3 ] = this.w;

  		return array;

  	}

  	/**
  	 * Sets the components of this vector from the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
  	 * @param {number} index - The index into the attribute.
  	 * @return {Vector4} A reference to this vector.
  	 */
  	fromBufferAttribute( attribute, index ) {

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );
  		this.w = attribute.getW( index );

  		return this;

  	}

  	/**
  	 * Sets each component of this vector to a pseudo-random value between `0` and
  	 * `1`, excluding `1`.
  	 *
  	 * @return {Vector4} A reference to this vector.
  	 */
  	random() {

  		this.x = Math.random();
  		this.y = Math.random();
  		this.z = Math.random();
  		this.w = Math.random();

  		return this;

  	}

  	*[ Symbol.iterator ]() {

  		yield this.x;
  		yield this.y;
  		yield this.z;
  		yield this.w;

  	}

  }

  /**
   * A render target is a buffer where the video card draws pixels for a scene
   * that is being rendered in the background. It is used in different effects,
   * such as applying postprocessing to a rendered image before displaying it
   * on the screen.
   *
   * @augments EventDispatcher
   */
  class RenderTarget extends EventDispatcher {

  	/**
  	 * Render target options.
  	 *
  	 * @typedef {Object} RenderTarget~Options
  	 * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
  	 * @property {number} [magFilter=LinearFilter] - The mag filter.
  	 * @property {number} [minFilter=LinearFilter] - The min filter.
  	 * @property {number} [format=RGBAFormat] - The texture format.
  	 * @property {number} [type=UnsignedByteType] - The texture type.
  	 * @property {?string} [internalFormat=null] - The texture's internal format.
  	 * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
  	 * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
  	 * @property {number} [anisotropy=1] - The texture's anisotropy value.
  	 * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
  	 * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
  	 * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
  	 * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
  	 * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
  	 * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
  	 * @property {number} [samples=0] - The MSAA samples count.
  	 * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
  	 * @property {number} [depth=1] - The texture depth.
  	 * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
  	 */

  	/**
  	 * Constructs a new render target.
  	 *
  	 * @param {number} [width=1] - The width of the render target.
  	 * @param {number} [height=1] - The height of the render target.
  	 * @param {RenderTarget~Options} [options] - The configuration object.
  	 */
  	constructor( width = 1, height = 1, options = {} ) {

  		super();

  		options = Object.assign( {
  			generateMipmaps: false,
  			internalFormat: null,
  			minFilter: LinearFilter,
  			depthBuffer: true,
  			stencilBuffer: false,
  			resolveDepthBuffer: true,
  			resolveStencilBuffer: true,
  			depthTexture: null,
  			samples: 0,
  			count: 1,
  			depth: 1,
  			multiview: false
  		}, options );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isRenderTarget = true;

  		/**
  		 * The width of the render target.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.width = width;

  		/**
  		 * The height of the render target.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.height = height;

  		/**
  		 * The depth of the render target.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.depth = options.depth;

  		/**
  		 * A rectangular area inside the render target's viewport. Fragments that are
  		 * outside the area will be discarded.
  		 *
  		 * @type {Vector4}
  		 * @default (0,0,width,height)
  		 */
  		this.scissor = new Vector4( 0, 0, width, height );

  		/**
  		 * Indicates whether the scissor test should be enabled when rendering into
  		 * this render target or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.scissorTest = false;

  		/**
  		 * A rectangular area representing the render target's viewport.
  		 *
  		 * @type {Vector4}
  		 * @default (0,0,width,height)
  		 */
  		this.viewport = new Vector4( 0, 0, width, height );

  		const image = { width: width, height: height, depth: options.depth };

  		const texture = new Texture( image );

  		/**
  		 * An array of textures. Each color attachment is represented as a separate texture.
  		 * Has at least a single entry for the default color attachment.
  		 *
  		 * @type {Array<Texture>}
  		 */
  		this.textures = [];

  		const count = options.count;
  		for ( let i = 0; i < count; i ++ ) {

  			this.textures[ i ] = texture.clone();
  			this.textures[ i ].isRenderTargetTexture = true;
  			this.textures[ i ].renderTarget = this;

  		}

  		this._setTextureOptions( options );

  		/**
  		 * Whether to allocate a depth buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.depthBuffer = options.depthBuffer;

  		/**
  		 * Whether to allocate a stencil buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.stencilBuffer = options.stencilBuffer;

  		/**
  		 * Whether to resolve the depth buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.resolveDepthBuffer = options.resolveDepthBuffer;

  		/**
  		 * Whether to resolve the stencil buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.resolveStencilBuffer = options.resolveStencilBuffer;

  		this._depthTexture = null;
  		this.depthTexture = options.depthTexture;

  		/**
  		 * The number of MSAA samples.
  		 *
  		 * A value of `0` disables MSAA.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.samples = options.samples;

  		/**
  		 * Whether to this target is used in multiview rendering.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.multiview = options.multiview;

  	}

  	_setTextureOptions( options = {} ) {

  		const values = {
  			minFilter: LinearFilter,
  			generateMipmaps: false,
  			flipY: false,
  			internalFormat: null
  		};

  		if ( options.mapping !== undefined ) values.mapping = options.mapping;
  		if ( options.wrapS !== undefined ) values.wrapS = options.wrapS;
  		if ( options.wrapT !== undefined ) values.wrapT = options.wrapT;
  		if ( options.wrapR !== undefined ) values.wrapR = options.wrapR;
  		if ( options.magFilter !== undefined ) values.magFilter = options.magFilter;
  		if ( options.minFilter !== undefined ) values.minFilter = options.minFilter;
  		if ( options.format !== undefined ) values.format = options.format;
  		if ( options.type !== undefined ) values.type = options.type;
  		if ( options.anisotropy !== undefined ) values.anisotropy = options.anisotropy;
  		if ( options.colorSpace !== undefined ) values.colorSpace = options.colorSpace;
  		if ( options.flipY !== undefined ) values.flipY = options.flipY;
  		if ( options.generateMipmaps !== undefined ) values.generateMipmaps = options.generateMipmaps;
  		if ( options.internalFormat !== undefined ) values.internalFormat = options.internalFormat;

  		for ( let i = 0; i < this.textures.length; i ++ ) {

  			const texture = this.textures[ i ];
  			texture.setValues( values );

  		}

  	}

  	/**
  	 * The texture representing the default color attachment.
  	 *
  	 * @type {Texture}
  	 */
  	get texture() {

  		return this.textures[ 0 ];

  	}

  	set texture( value ) {

  		this.textures[ 0 ] = value;

  	}

  	set depthTexture( current ) {

  		if ( this._depthTexture !== null ) this._depthTexture.renderTarget = null;
  		if ( current !== null ) current.renderTarget = this;

  		this._depthTexture = current;

  	}

  	/**
  	 * Instead of saving the depth in a renderbuffer, a texture
  	 * can be used instead which is useful for further processing
  	 * e.g. in context of post-processing.
  	 *
  	 * @type {?DepthTexture}
  	 * @default null
  	 */
  	get depthTexture() {

  		return this._depthTexture;

  	}

  	/**
  	 * Sets the size of this render target.
  	 *
  	 * @param {number} width - The width.
  	 * @param {number} height - The height.
  	 * @param {number} [depth=1] - The depth.
  	 */
  	setSize( width, height, depth = 1 ) {

  		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

  			this.width = width;
  			this.height = height;
  			this.depth = depth;

  			for ( let i = 0, il = this.textures.length; i < il; i ++ ) {

  				this.textures[ i ].image.width = width;
  				this.textures[ i ].image.height = height;
  				this.textures[ i ].image.depth = depth;
  				this.textures[ i ].isArrayTexture = this.textures[ i ].image.depth > 1;

  			}

  			this.dispose();

  		}

  		this.viewport.set( 0, 0, width, height );
  		this.scissor.set( 0, 0, width, height );

  	}

  	/**
  	 * Returns a new render target with copied values from this instance.
  	 *
  	 * @return {RenderTarget} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the settings of the given render target. This is a structural copy so
  	 * no resources are shared between render targets after the copy. That includes
  	 * all MRT textures and the depth texture.
  	 *
  	 * @param {RenderTarget} source - The render target to copy.
  	 * @return {RenderTarget} A reference to this instance.
  	 */
  	copy( source ) {

  		this.width = source.width;
  		this.height = source.height;
  		this.depth = source.depth;

  		this.scissor.copy( source.scissor );
  		this.scissorTest = source.scissorTest;

  		this.viewport.copy( source.viewport );

  		this.textures.length = 0;

  		for ( let i = 0, il = source.textures.length; i < il; i ++ ) {

  			this.textures[ i ] = source.textures[ i ].clone();
  			this.textures[ i ].isRenderTargetTexture = true;
  			this.textures[ i ].renderTarget = this;

  			// ensure image object is not shared, see #20328

  			const image = Object.assign( {}, source.textures[ i ].image );
  			this.textures[ i ].source = new Source( image );

  		}

  		this.depthBuffer = source.depthBuffer;
  		this.stencilBuffer = source.stencilBuffer;

  		this.resolveDepthBuffer = source.resolveDepthBuffer;
  		this.resolveStencilBuffer = source.resolveStencilBuffer;

  		if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

  		this.samples = source.samples;

  		return this;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 *
  	 * @fires RenderTarget#dispose
  	 */
  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  }

  /**
   * A render target used in context of {@link WebGLRenderer}.
   *
   * @augments RenderTarget
   */
  class WebGLRenderTarget extends RenderTarget {

  	/**
  	 * Constructs a new 3D render target.
  	 *
  	 * @param {number} [width=1] - The width of the render target.
  	 * @param {number} [height=1] - The height of the render target.
  	 * @param {RenderTarget~Options} [options] - The configuration object.
  	 */
  	constructor( width = 1, height = 1, options = {} ) {

  		super( width, height, options );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isWebGLRenderTarget = true;

  	}

  }

  /**
   * Creates an array of textures directly from raw buffer data.
   *
   * @augments Texture
   */
  class DataArrayTexture extends Texture {

  	/**
  	 * Constructs a new data array texture.
  	 *
  	 * @param {?TypedArray} [data=null] - The buffer data.
  	 * @param {number} [width=1] - The width of the texture.
  	 * @param {number} [height=1] - The height of the texture.
  	 * @param {number} [depth=1] - The depth of the texture.
  	 */
  	constructor( data = null, width = 1, height = 1, depth = 1 ) {

  		super( null );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isDataArrayTexture = true;

  		/**
  		 * The image definition of a data texture.
  		 *
  		 * @type {{data:TypedArray,width:number,height:number,depth:number}}
  		 */
  		this.image = { data, width, height, depth };

  		/**
  		 * How the texture is sampled when a texel covers more than one pixel.
  		 *
  		 * Overwritten and set to `NearestFilter` by default.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default NearestFilter
  		 */
  		this.magFilter = NearestFilter;

  		/**
  		 * How the texture is sampled when a texel covers less than one pixel.
  		 *
  		 * Overwritten and set to `NearestFilter` by default.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default NearestFilter
  		 */
  		this.minFilter = NearestFilter;

  		/**
  		 * This defines how the texture is wrapped in the depth and corresponds to
  		 * *W* in UVW mapping.
  		 *
  		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
  		 * @default ClampToEdgeWrapping
  		 */
  		this.wrapR = ClampToEdgeWrapping;

  		/**
  		 * Whether to generate mipmaps (if possible) for a texture.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.generateMipmaps = false;

  		/**
  		 * If set to `true`, the texture is flipped along the vertical axis when
  		 * uploaded to the GPU.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flipY = false;

  		/**
  		 * Specifies the alignment requirements for the start of each pixel row in memory.
  		 *
  		 * Overwritten and set to `1` by default.
  		 *
  		 * @type {boolean}
  		 * @default 1
  		 */
  		this.unpackAlignment = 1;

  		/**
  		 * A set of all layers which need to be updated in the texture.
  		 *
  		 * @type {Set<number>}
  		 */
  		this.layerUpdates = new Set();

  	}

  	/**
  	 * Describes that a specific layer of the texture needs to be updated.
  	 * Normally when {@link Texture#needsUpdate} is set to `true`, the
  	 * entire data texture array is sent to the GPU. Marking specific
  	 * layers will only transmit subsets of all mipmaps associated with a
  	 * specific depth in the array which is often much more performant.
  	 *
  	 * @param {number} layerIndex - The layer index that should be updated.
  	 */
  	addLayerUpdate( layerIndex ) {

  		this.layerUpdates.add( layerIndex );

  	}

  	/**
  	 * Resets the layer updates registry.
  	 */
  	clearLayerUpdates() {

  		this.layerUpdates.clear();

  	}

  }

  /**
   * Creates a three-dimensional texture from raw data, with parameters to
   * divide it into width, height, and depth.
   *
   * @augments Texture
   */
  class Data3DTexture extends Texture {

  	/**
  	 * Constructs a new data array texture.
  	 *
  	 * @param {?TypedArray} [data=null] - The buffer data.
  	 * @param {number} [width=1] - The width of the texture.
  	 * @param {number} [height=1] - The height of the texture.
  	 * @param {number} [depth=1] - The depth of the texture.
  	 */
  	constructor( data = null, width = 1, height = 1, depth = 1 ) {

  		// We're going to add .setXXX() methods for setting properties later.
  		// Users can still set in Data3DTexture directly.
  		//
  		//	const texture = new THREE.Data3DTexture( data, width, height, depth );
  		// 	texture.anisotropy = 16;
  		//
  		// See #14839

  		super( null );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isData3DTexture = true;

  		/**
  		 * The image definition of a data texture.
  		 *
  		 * @type {{data:TypedArray,width:number,height:number,depth:number}}
  		 */
  		this.image = { data, width, height, depth };

  		/**
  		 * How the texture is sampled when a texel covers more than one pixel.
  		 *
  		 * Overwritten and set to `NearestFilter` by default.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default NearestFilter
  		 */
  		this.magFilter = NearestFilter;

  		/**
  		 * How the texture is sampled when a texel covers less than one pixel.
  		 *
  		 * Overwritten and set to `NearestFilter` by default.
  		 *
  		 * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}
  		 * @default NearestFilter
  		 */
  		this.minFilter = NearestFilter;

  		/**
  		 * This defines how the texture is wrapped in the depth and corresponds to
  		 * *W* in UVW mapping.
  		 *
  		 * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}
  		 * @default ClampToEdgeWrapping
  		 */
  		this.wrapR = ClampToEdgeWrapping;

  		/**
  		 * Whether to generate mipmaps (if possible) for a texture.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.generateMipmaps = false;

  		/**
  		 * If set to `true`, the texture is flipped along the vertical axis when
  		 * uploaded to the GPU.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flipY = false;

  		/**
  		 * Specifies the alignment requirements for the start of each pixel row in memory.
  		 *
  		 * Overwritten and set to `1` by default.
  		 *
  		 * @type {boolean}
  		 * @default 1
  		 */
  		this.unpackAlignment = 1;

  	}

  }

  /**
   * Represents an axis-aligned bounding box (AABB) in 3D space.
   */
  class Box3 {

  	/**
  	 * Constructs a new bounding box.
  	 *
  	 * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
  	 * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
  	 */
  	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBox3 = true;

  		/**
  		 * The lower boundary of the box.
  		 *
  		 * @type {Vector3}
  		 */
  		this.min = min;

  		/**
  		 * The upper boundary of the box.
  		 *
  		 * @type {Vector3}
  		 */
  		this.max = max;

  	}

  	/**
  	 * Sets the lower and upper boundaries of this box.
  	 * Please note that this method only copies the values from the given objects.
  	 *
  	 * @param {Vector3} min - The lower boundary of the box.
  	 * @param {Vector3} max - The upper boundary of the box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	set( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	}

  	/**
  	 * Sets the upper and lower bounds of this box so it encloses the position data
  	 * in the given array.
  	 *
  	 * @param {Array<number>} array - An array holding 3D position data.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	setFromArray( array ) {

  		this.makeEmpty();

  		for ( let i = 0, il = array.length; i < il; i += 3 ) {

  			this.expandByPoint( _vector$b.fromArray( array, i ) );

  		}

  		return this;

  	}

  	/**
  	 * Sets the upper and lower bounds of this box so it encloses the position data
  	 * in the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	setFromBufferAttribute( attribute ) {

  		this.makeEmpty();

  		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

  			this.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );

  		}

  		return this;

  	}

  	/**
  	 * Sets the upper and lower bounds of this box so it encloses the position data
  	 * in the given array.
  	 *
  	 * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	setFromPoints( points ) {

  		this.makeEmpty();

  		for ( let i = 0, il = points.length; i < il; i ++ ) {

  			this.expandByPoint( points[ i ] );

  		}

  		return this;

  	}

  	/**
  	 * Centers this box on the given center vector and sets this box's width, height and
  	 * depth to the given size values.
  	 *
  	 * @param {Vector3} center - The center of the box.
  	 * @param {Vector3} size - The x, y and z dimensions of the box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	setFromCenterAndSize( center, size ) {

  		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

  		this.min.copy( center ).sub( halfSize );
  		this.max.copy( center ).add( halfSize );

  		return this;

  	}

  	/**
  	 * Computes the world-axis-aligned bounding box for the given 3D object
  	 * (including its children), accounting for the object's, and children's,
  	 * world transforms. The function may result in a larger box than strictly necessary.
  	 *
  	 * @param {Object3D} object - The 3D object to compute the bounding box for.
  	 * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
  	 * world-axis-aligned bounding box at the expense of more computation.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	setFromObject( object, precise = false ) {

  		this.makeEmpty();

  		return this.expandByObject( object, precise );

  	}

  	/**
  	 * Returns a new box with copied values from this instance.
  	 *
  	 * @return {Box3} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the values of the given box to this instance.
  	 *
  	 * @param {Box3} box - The box to copy.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	copy( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	}

  	/**
  	 * Makes this box empty which means in encloses a zero space in 3D.
  	 *
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	makeEmpty() {

  		this.min.x = this.min.y = this.min.z = + Infinity;
  		this.max.x = this.max.y = this.max.z = - Infinity;

  		return this;

  	}

  	/**
  	 * Returns true if this box includes zero points within its bounds.
  	 * Note that a box with equal lower and upper bounds still includes one
  	 * point, the one both bounds share.
  	 *
  	 * @return {boolean} Whether this box is empty or not.
  	 */
  	isEmpty() {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  	}

  	/**
  	 * Returns the center point of this box.
  	 *
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The center point.
  	 */
  	getCenter( target ) {

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	}

  	/**
  	 * Returns the dimensions of this box.
  	 *
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The size.
  	 */
  	getSize( target ) {

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

  	}

  	/**
  	 * Expands the boundaries of this box to include the given point.
  	 *
  	 * @param {Vector3} point - The point that should be included by the bounding box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	expandByPoint( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	}

  	/**
  	 * Expands this box equilaterally by the given vector. The width of this
  	 * box will be expanded by the x component of the vector in both
  	 * directions. The height of this box will be expanded by the y component of
  	 * the vector in both directions. The depth of this box will be
  	 * expanded by the z component of the vector in both directions.
  	 *
  	 * @param {Vector3} vector - The vector that should expand the bounding box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	expandByVector( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	}

  	/**
  	 * Expands each dimension of the box by the given scalar. If negative, the
  	 * dimensions of the box will be contracted.
  	 *
  	 * @param {number} scalar - The scalar value that should expand the bounding box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	expandByScalar( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	}

  	/**
  	 * Expands the boundaries of this box to include the given 3D object and
  	 * its children, accounting for the object's, and children's, world
  	 * transforms. The function may result in a larger box than strictly
  	 * necessary (unless the precise parameter is set to true).
  	 *
  	 * @param {Object3D} object - The 3D object that should expand the bounding box.
  	 * @param {boolean} precise - If set to `true`, the method expands the bounding box
  	 * as little as necessary at the expense of more computation.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	expandByObject( object, precise = false ) {

  		// Computes the world-axis-aligned bounding box of an object (including its children),
  		// accounting for both the object's, and children's, world transforms

  		object.updateWorldMatrix( false, false );

  		const geometry = object.geometry;

  		if ( geometry !== undefined ) {

  			const positionAttribute = geometry.getAttribute( 'position' );

  			// precise AABB computation based on vertex data requires at least a position attribute.
  			// instancing isn't supported so far and uses the normal (conservative) code path.

  			if ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {

  				for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

  					if ( object.isMesh === true ) {

  						object.getVertexPosition( i, _vector$b );

  					} else {

  						_vector$b.fromBufferAttribute( positionAttribute, i );

  					}

  					_vector$b.applyMatrix4( object.matrixWorld );
  					this.expandByPoint( _vector$b );

  				}

  			} else {

  				if ( object.boundingBox !== undefined ) {

  					// object-level bounding box

  					if ( object.boundingBox === null ) {

  						object.computeBoundingBox();

  					}

  					_box$4.copy( object.boundingBox );


  				} else {

  					// geometry-level bounding box

  					if ( geometry.boundingBox === null ) {

  						geometry.computeBoundingBox();

  					}

  					_box$4.copy( geometry.boundingBox );

  				}

  				_box$4.applyMatrix4( object.matrixWorld );

  				this.union( _box$4 );

  			}

  		}

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			this.expandByObject( children[ i ], precise );

  		}

  		return this;

  	}

  	/**
  	 * Returns `true` if the given point lies within or on the boundaries of this box.
  	 *
  	 * @param {Vector3} point - The point to test.
  	 * @return {boolean} Whether the bounding box contains the given point or not.
  	 */
  	containsPoint( point ) {

  		return point.x >= this.min.x && point.x <= this.max.x &&
  			point.y >= this.min.y && point.y <= this.max.y &&
  			point.z >= this.min.z && point.z <= this.max.z;

  	}

  	/**
  	 * Returns `true` if this bounding box includes the entirety of the given bounding box.
  	 * If this box and the given one are identical, this function also returns `true`.
  	 *
  	 * @param {Box3} box - The bounding box to test.
  	 * @return {boolean} Whether the bounding box contains the given bounding box or not.
  	 */
  	containsBox( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y &&
  			this.min.z <= box.min.z && box.max.z <= this.max.z;

  	}

  	/**
  	 * Returns a point as a proportion of this box's width, height and depth.
  	 *
  	 * @param {Vector3} point - A point in 3D space.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} A point as a proportion of this box's width, height and depth.
  	 */
  	getParameter( point, target ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		return target.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
  			( point.z - this.min.z ) / ( this.max.z - this.min.z )
  		);

  	}

  	/**
  	 * Returns `true` if the given bounding box intersects with this bounding box.
  	 *
  	 * @param {Box3} box - The bounding box to test.
  	 * @return {boolean} Whether the given bounding box intersects with this bounding box.
  	 */
  	intersectsBox( box ) {

  		// using 6 splitting planes to rule out intersections.
  		return box.max.x >= this.min.x && box.min.x <= this.max.x &&
  			box.max.y >= this.min.y && box.min.y <= this.max.y &&
  			box.max.z >= this.min.z && box.min.z <= this.max.z;

  	}

  	/**
  	 * Returns `true` if the given bounding sphere intersects with this bounding box.
  	 *
  	 * @param {Sphere} sphere - The bounding sphere to test.
  	 * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
  	 */
  	intersectsSphere( sphere ) {

  		// Find the point on the AABB closest to the sphere center.
  		this.clampPoint( sphere.center, _vector$b );

  		// If that point is inside the sphere, the AABB and sphere intersect.
  		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

  	}

  	/**
  	 * Returns `true` if the given plane intersects with this bounding box.
  	 *
  	 * @param {Plane} plane - The plane to test.
  	 * @return {boolean} Whether the given plane intersects with this bounding box.
  	 */
  	intersectsPlane( plane ) {

  		// We compute the minimum and maximum dot product values. If those values
  		// are on the same side (back or front) of the plane, then there is no intersection.

  		let min, max;

  		if ( plane.normal.x > 0 ) {

  			min = plane.normal.x * this.min.x;
  			max = plane.normal.x * this.max.x;

  		} else {

  			min = plane.normal.x * this.max.x;
  			max = plane.normal.x * this.min.x;

  		}

  		if ( plane.normal.y > 0 ) {

  			min += plane.normal.y * this.min.y;
  			max += plane.normal.y * this.max.y;

  		} else {

  			min += plane.normal.y * this.max.y;
  			max += plane.normal.y * this.min.y;

  		}

  		if ( plane.normal.z > 0 ) {

  			min += plane.normal.z * this.min.z;
  			max += plane.normal.z * this.max.z;

  		} else {

  			min += plane.normal.z * this.max.z;
  			max += plane.normal.z * this.min.z;

  		}

  		return ( min <= - plane.constant && max >= - plane.constant );

  	}

  	/**
  	 * Returns `true` if the given triangle intersects with this bounding box.
  	 *
  	 * @param {Triangle} triangle - The triangle to test.
  	 * @return {boolean} Whether the given triangle intersects with this bounding box.
  	 */
  	intersectsTriangle( triangle ) {

  		if ( this.isEmpty() ) {

  			return false;

  		}

  		// compute box center and extents
  		this.getCenter( _center );
  		_extents.subVectors( this.max, _center );

  		// translate triangle to aabb origin
  		_v0$2.subVectors( triangle.a, _center );
  		_v1$7.subVectors( triangle.b, _center );
  		_v2$4.subVectors( triangle.c, _center );

  		// compute edge vectors for triangle
  		_f0.subVectors( _v1$7, _v0$2 );
  		_f1.subVectors( _v2$4, _v1$7 );
  		_f2.subVectors( _v0$2, _v2$4 );

  		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
  		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
  		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
  		let axes = [
  			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
  			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
  			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
  		];
  		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

  			return false;

  		}

  		// test 3 face normals from the aabb
  		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
  		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

  			return false;

  		}

  		// finally testing the face normal of the triangle
  		// use already existing triangle edge vectors here
  		_triangleNormal.crossVectors( _f0, _f1 );
  		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

  		return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

  	}

  	/**
  	 * Clamps the given point within the bounds of this box.
  	 *
  	 * @param {Vector3} point - The point to clamp.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The clamped point.
  	 */
  	clampPoint( point, target ) {

  		return target.copy( point ).clamp( this.min, this.max );

  	}

  	/**
  	 * Returns the euclidean distance from any edge of this box to the specified point. If
  	 * the given point lies inside of this box, the distance will be `0`.
  	 *
  	 * @param {Vector3} point - The point to compute the distance to.
  	 * @return {number} The euclidean distance.
  	 */
  	distanceToPoint( point ) {

  		return this.clampPoint( point, _vector$b ).distanceTo( point );

  	}

  	/**
  	 * Returns a bounding sphere that encloses this bounding box.
  	 *
  	 * @param {Sphere} target - The target sphere that is used to store the method's result.
  	 * @return {Sphere} The bounding sphere that encloses this bounding box.
  	 */
  	getBoundingSphere( target ) {

  		if ( this.isEmpty() ) {

  			target.makeEmpty();

  		} else {

  			this.getCenter( target.center );

  			target.radius = this.getSize( _vector$b ).length() * 0.5;

  		}

  		return target;

  	}

  	/**
  	 * Computes the intersection of this bounding box and the given one, setting the upper
  	 * bound of this box to the lesser of the two boxes' upper bounds and the
  	 * lower bound of this box to the greater of the two boxes' lower bounds. If
  	 * there's no overlap, makes this box empty.
  	 *
  	 * @param {Box3} box - The bounding box to intersect with.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	intersect( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  		if ( this.isEmpty() ) this.makeEmpty();

  		return this;

  	}

  	/**
  	 * Computes the union of this box and another and the given one, setting the upper
  	 * bound of this box to the greater of the two boxes' upper bounds and the
  	 * lower bound of this box to the lesser of the two boxes' lower bounds.
  	 *
  	 * @param {Box3} box - The bounding box that will be unioned with this instance.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	union( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	}

  	/**
  	 * Transforms this bounding box by the given 4x4 transformation matrix.
  	 *
  	 * @param {Matrix4} matrix - The transformation matrix.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	applyMatrix4( matrix ) {

  		// transform of empty box is an empty box.
  		if ( this.isEmpty() ) return this;

  		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
  		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
  		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
  		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
  		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
  		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
  		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
  		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

  		this.setFromPoints( _points );

  		return this;

  	}

  	/**
  	 * Adds the given offset to both the upper and lower bounds of this bounding box,
  	 * effectively moving it in 3D space.
  	 *
  	 * @param {Vector3} offset - The offset that should be used to translate the bounding box.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	translate( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	}

  	/**
  	 * Returns `true` if this bounding box is equal with the given one.
  	 *
  	 * @param {Box3} box - The box to test for equality.
  	 * @return {boolean} Whether this bounding box is equal with the given one.
  	 */
  	equals( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  	/**
  	 * Returns a serialized structure of the bounding box.
  	 *
  	 * @return {Object} Serialized structure with fields representing the object state.
  	 */
  	toJSON() {

  		return {
  			min: this.min.toArray(),
  			max: this.max.toArray()
  		};

  	}

  	/**
  	 * Returns a serialized structure of the bounding box.
  	 *
  	 * @param {Object} json - The serialized json to set the box from.
  	 * @return {Box3} A reference to this bounding box.
  	 */
  	fromJSON( json ) {

  		this.min.fromArray( json.min );
  		this.max.fromArray( json.max );
  		return this;

  	}

  }

  const _points = [
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3(),
  	/*@__PURE__*/ new Vector3()
  ];

  const _vector$b = /*@__PURE__*/ new Vector3();

  const _box$4 = /*@__PURE__*/ new Box3();

  // triangle centered vertices

  const _v0$2 = /*@__PURE__*/ new Vector3();
  const _v1$7 = /*@__PURE__*/ new Vector3();
  const _v2$4 = /*@__PURE__*/ new Vector3();

  // triangle edge vectors

  const _f0 = /*@__PURE__*/ new Vector3();
  const _f1 = /*@__PURE__*/ new Vector3();
  const _f2 = /*@__PURE__*/ new Vector3();

  const _center = /*@__PURE__*/ new Vector3();
  const _extents = /*@__PURE__*/ new Vector3();
  const _triangleNormal = /*@__PURE__*/ new Vector3();
  const _testAxis = /*@__PURE__*/ new Vector3();

  function satForAxes( axes, v0, v1, v2, extents ) {

  	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

  		_testAxis.fromArray( axes, i );
  		// project the aabb onto the separating axis
  		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
  		// project all 3 vertices of the triangle onto the separating axis
  		const p0 = v0.dot( _testAxis );
  		const p1 = v1.dot( _testAxis );
  		const p2 = v2.dot( _testAxis );
  		// actual test, basically see if either of the most extreme of the triangle points intersects r
  		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

  			// points of the projected triangle are outside the projected half-length of the aabb
  			// the axis is separating and we can exit
  			return false;

  		}

  	}

  	return true;

  }

  const _box$3 = /*@__PURE__*/ new Box3();
  const _v1$6 = /*@__PURE__*/ new Vector3();
  const _v2$3 = /*@__PURE__*/ new Vector3();

  /**
   * An analytical 3D sphere defined by a center and radius. This class is mainly
   * used as a Bounding Sphere for 3D objects.
   */
  class Sphere {

  	/**
  	 * Constructs a new sphere.
  	 *
  	 * @param {Vector3} [center=(0,0,0)] - The center of the sphere
  	 * @param {number} [radius=-1] - The radius of the sphere.
  	 */
  	constructor( center = new Vector3(), radius = -1 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSphere = true;

  		/**
  		 * The center of the sphere
  		 *
  		 * @type {Vector3}
  		 */
  		this.center = center;

  		/**
  		 * The radius of the sphere.
  		 *
  		 * @type {number}
  		 */
  		this.radius = radius;

  	}

  	/**
  	 * Sets the sphere's components by copying the given values.
  	 *
  	 * @param {Vector3} center - The center.
  	 * @param {number} radius - The radius.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	set( center, radius ) {

  		this.center.copy( center );
  		this.radius = radius;

  		return this;

  	}

  	/**
  	 * Computes the minimum bounding sphere for list of points.
  	 * If the optional center point is given, it is used as the sphere's
  	 * center. Otherwise, the center of the axis-aligned bounding box
  	 * encompassing the points is calculated.
  	 *
  	 * @param {Array<Vector3>} points - A list of points in 3D space.
  	 * @param {Vector3} [optionalCenter] - The center of the sphere.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	setFromPoints( points, optionalCenter ) {

  		const center = this.center;

  		if ( optionalCenter !== undefined ) {

  			center.copy( optionalCenter );

  		} else {

  			_box$3.setFromPoints( points ).getCenter( center );

  		}

  		let maxRadiusSq = 0;

  		for ( let i = 0, il = points.length; i < il; i ++ ) {

  			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

  		}

  		this.radius = Math.sqrt( maxRadiusSq );

  		return this;

  	}

  	/**
  	 * Copies the values of the given sphere to this instance.
  	 *
  	 * @param {Sphere} sphere - The sphere to copy.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	copy( sphere ) {

  		this.center.copy( sphere.center );
  		this.radius = sphere.radius;

  		return this;

  	}

  	/**
  	 * Returns `true` if the sphere is empty (the radius set to a negative number).
  	 *
  	 * Spheres with a radius of `0` contain only their center point and are not
  	 * considered to be empty.
  	 *
  	 * @return {boolean} Whether this sphere is empty or not.
  	 */
  	isEmpty() {

  		return ( this.radius < 0 );

  	}

  	/**
  	 * Makes this sphere empty which means in encloses a zero space in 3D.
  	 *
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	makeEmpty() {

  		this.center.set( 0, 0, 0 );
  		this.radius = -1;

  		return this;

  	}

  	/**
  	 * Returns `true` if this sphere contains the given point inclusive of
  	 * the surface of the sphere.
  	 *
  	 * @param {Vector3} point - The point to check.
  	 * @return {boolean} Whether this sphere contains the given point or not.
  	 */
  	containsPoint( point ) {

  		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  	}

  	/**
  	 * Returns the closest distance from the boundary of the sphere to the
  	 * given point. If the sphere contains the point, the distance will
  	 * be negative.
  	 *
  	 * @param {Vector3} point - The point to compute the distance to.
  	 * @return {number} The distance to the point.
  	 */
  	distanceToPoint( point ) {

  		return ( point.distanceTo( this.center ) - this.radius );

  	}

  	/**
  	 * Returns `true` if this sphere intersects with the given one.
  	 *
  	 * @param {Sphere} sphere - The sphere to test.
  	 * @return {boolean} Whether this sphere intersects with the given one or not.
  	 */
  	intersectsSphere( sphere ) {

  		const radiusSum = this.radius + sphere.radius;

  		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  	}

  	/**
  	 * Returns `true` if this sphere intersects with the given box.
  	 *
  	 * @param {Box3} box - The box to test.
  	 * @return {boolean} Whether this sphere intersects with the given box or not.
  	 */
  	intersectsBox( box ) {

  		return box.intersectsSphere( this );

  	}

  	/**
  	 * Returns `true` if this sphere intersects with the given plane.
  	 *
  	 * @param {Plane} plane - The plane to test.
  	 * @return {boolean} Whether this sphere intersects with the given plane or not.
  	 */
  	intersectsPlane( plane ) {

  		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

  	}

  	/**
  	 * Clamps a point within the sphere. If the point is outside the sphere, it
  	 * will clamp it to the closest point on the edge of the sphere. Points
  	 * already inside the sphere will not be affected.
  	 *
  	 * @param {Vector3} point - The plane to clamp.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The clamped point.
  	 */
  	clampPoint( point, target ) {

  		const deltaLengthSq = this.center.distanceToSquared( point );

  		target.copy( point );

  		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

  			target.sub( this.center ).normalize();
  			target.multiplyScalar( this.radius ).add( this.center );

  		}

  		return target;

  	}

  	/**
  	 * Returns a bounding box that encloses this sphere.
  	 *
  	 * @param {Box3} target - The target box that is used to store the method's result.
  	 * @return {Box3} The bounding box that encloses this sphere.
  	 */
  	getBoundingBox( target ) {

  		if ( this.isEmpty() ) {

  			// Empty sphere produces empty bounding box
  			target.makeEmpty();
  			return target;

  		}

  		target.set( this.center, this.center );
  		target.expandByScalar( this.radius );

  		return target;

  	}

  	/**
  	 * Transforms this sphere with the given 4x4 transformation matrix.
  	 *
  	 * @param {Matrix4} matrix - The transformation matrix.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	applyMatrix4( matrix ) {

  		this.center.applyMatrix4( matrix );
  		this.radius = this.radius * matrix.getMaxScaleOnAxis();

  		return this;

  	}

  	/**
  	 * Translates the sphere's center by the given offset.
  	 *
  	 * @param {Vector3} offset - The offset.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	translate( offset ) {

  		this.center.add( offset );

  		return this;

  	}

  	/**
  	 * Expands the boundaries of this sphere to include the given point.
  	 *
  	 * @param {Vector3} point - The point to include.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	expandByPoint( point ) {

  		if ( this.isEmpty() ) {

  			this.center.copy( point );

  			this.radius = 0;

  			return this;

  		}

  		_v1$6.subVectors( point, this.center );

  		const lengthSq = _v1$6.lengthSq();

  		if ( lengthSq > ( this.radius * this.radius ) ) {

  			// calculate the minimal sphere

  			const length = Math.sqrt( lengthSq );

  			const delta = ( length - this.radius ) * 0.5;

  			this.center.addScaledVector( _v1$6, delta / length );

  			this.radius += delta;

  		}

  		return this;

  	}

  	/**
  	 * Expands this sphere to enclose both the original sphere and the given sphere.
  	 *
  	 * @param {Sphere} sphere - The sphere to include.
  	 * @return {Sphere} A reference to this sphere.
  	 */
  	union( sphere ) {

  		if ( sphere.isEmpty() ) {

  			return this;

  		}

  		if ( this.isEmpty() ) {

  			this.copy( sphere );

  			return this;

  		}

  		if ( this.center.equals( sphere.center ) === true ) {

  			 this.radius = Math.max( this.radius, sphere.radius );

  		} else {

  			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

  			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

  			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

  		}

  		return this;

  	}

  	/**
  	 * Returns `true` if this sphere is equal with the given one.
  	 *
  	 * @param {Sphere} sphere - The sphere to test for equality.
  	 * @return {boolean} Whether this bounding sphere is equal with the given one.
  	 */
  	equals( sphere ) {

  		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  	}

  	/**
  	 * Returns a new sphere with copied values from this instance.
  	 *
  	 * @return {Sphere} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Returns a serialized structure of the bounding sphere.
  	 *
  	 * @return {Object} Serialized structure with fields representing the object state.
  	 */
  	toJSON() {

  		return {
  			radius: this.radius,
  			center: this.center.toArray()
  		};

  	}

  	/**
  	 * Returns a serialized structure of the bounding sphere.
  	 *
  	 * @param {Object} json - The serialized json to set the sphere from.
  	 * @return {Box3} A reference to this bounding sphere.
  	 */
  	fromJSON( json ) {

  		this.radius = json.radius;
  		this.center.fromArray( json.center );
  		return this;

  	}

  }

  const _vector$a = /*@__PURE__*/ new Vector3();
  const _segCenter = /*@__PURE__*/ new Vector3();
  const _segDir = /*@__PURE__*/ new Vector3();
  const _diff = /*@__PURE__*/ new Vector3();

  const _edge1 = /*@__PURE__*/ new Vector3();
  const _edge2 = /*@__PURE__*/ new Vector3();
  const _normal$1 = /*@__PURE__*/ new Vector3();

  /**
   * A ray that emits from an origin in a certain direction. The class is used by
   * {@link Raycaster} to assist with raycasting. Raycasting is used for
   * mouse picking (working out what objects in the 3D space the mouse is over)
   * amongst other things.
   */
  class Ray {

  	/**
  	 * Constructs a new ray.
  	 *
  	 * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
  	 * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
  	 */
  	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, -1 ) ) {

  		/**
  		 * The origin of the ray.
  		 *
  		 * @type {Vector3}
  		 */
  		this.origin = origin;

  		/**
  		 * The (normalized) direction of the ray.
  		 *
  		 * @type {Vector3}
  		 */
  		this.direction = direction;

  	}

  	/**
  	 * Sets the ray's components by copying the given values.
  	 *
  	 * @param {Vector3} origin - The origin.
  	 * @param {Vector3} direction - The direction.
  	 * @return {Ray} A reference to this ray.
  	 */
  	set( origin, direction ) {

  		this.origin.copy( origin );
  		this.direction.copy( direction );

  		return this;

  	}

  	/**
  	 * Copies the values of the given ray to this instance.
  	 *
  	 * @param {Ray} ray - The ray to copy.
  	 * @return {Ray} A reference to this ray.
  	 */
  	copy( ray ) {

  		this.origin.copy( ray.origin );
  		this.direction.copy( ray.direction );

  		return this;

  	}

  	/**
  	 * Returns a vector that is located at a given distance along this ray.
  	 *
  	 * @param {number} t - The distance along the ray to retrieve a position for.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} A position on the ray.
  	 */
  	at( t, target ) {

  		return target.copy( this.origin ).addScaledVector( this.direction, t );

  	}

  	/**
  	 * Adjusts the direction of the ray to point at the given vector in world space.
  	 *
  	 * @param {Vector3} v - The target position.
  	 * @return {Ray} A reference to this ray.
  	 */
  	lookAt( v ) {

  		this.direction.copy( v ).sub( this.origin ).normalize();

  		return this;

  	}

  	/**
  	 * Shift the origin of this ray along its direction by the given distance.
  	 *
  	 * @param {number} t - The distance along the ray to interpolate.
  	 * @return {Ray} A reference to this ray.
  	 */
  	recast( t ) {

  		this.origin.copy( this.at( t, _vector$a ) );

  		return this;

  	}

  	/**
  	 * Returns the point along this ray that is closest to the given point.
  	 *
  	 * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The closest point on this ray.
  	 */
  	closestPointToPoint( point, target ) {

  		target.subVectors( point, this.origin );

  		const directionDistance = target.dot( this.direction );

  		if ( directionDistance < 0 ) {

  			return target.copy( this.origin );

  		}

  		return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

  	}

  	/**
  	 * Returns the distance of the closest approach between this ray and the given point.
  	 *
  	 * @param {Vector3} point - A point in 3D space to compute the distance to.
  	 * @return {number} The distance.
  	 */
  	distanceToPoint( point ) {

  		return Math.sqrt( this.distanceSqToPoint( point ) );

  	}

  	/**
  	 * Returns the squared distance of the closest approach between this ray and the given point.
  	 *
  	 * @param {Vector3} point - A point in 3D space to compute the distance to.
  	 * @return {number} The squared distance.
  	 */
  	distanceSqToPoint( point ) {

  		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

  		// point behind the ray

  		if ( directionDistance < 0 ) {

  			return this.origin.distanceToSquared( point );

  		}

  		_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );

  		return _vector$a.distanceToSquared( point );

  	}

  	/**
  	 * Returns the squared distance between this ray and the given line segment.
  	 *
  	 * @param {Vector3} v0 - The start point of the line segment.
  	 * @param {Vector3} v1 - The end point of the line segment.
  	 * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
  	 * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
  	 * @return {number} The squared distance.
  	 */
  	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

  		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
  		// It returns the min distance between the ray and the segment
  		// defined by v0 and v1
  		// It can also set two optional targets :
  		// - The closest point on the ray
  		// - The closest point on the segment

  		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
  		_segDir.copy( v1 ).sub( v0 ).normalize();
  		_diff.copy( this.origin ).sub( _segCenter );

  		const segExtent = v0.distanceTo( v1 ) * 0.5;
  		const a01 = - this.direction.dot( _segDir );
  		const b0 = _diff.dot( this.direction );
  		const b1 = - _diff.dot( _segDir );
  		const c = _diff.lengthSq();
  		const det = Math.abs( 1 - a01 * a01 );
  		let s0, s1, sqrDist, extDet;

  		if ( det > 0 ) {

  			// The ray and segment are not parallel.

  			s0 = a01 * b1 - b0;
  			s1 = a01 * b0 - b1;
  			extDet = segExtent * det;

  			if ( s0 >= 0 ) {

  				if ( s1 >= - extDet ) {

  					if ( s1 <= extDet ) {

  						// region 0
  						// Minimum at interior points of ray and segment.

  						const invDet = 1 / det;
  						s0 *= invDet;
  						s1 *= invDet;
  						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

  					} else {

  						// region 1

  						s1 = segExtent;
  						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				} else {

  					// region 5

  					s1 = - segExtent;
  					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				}

  			} else {

  				if ( s1 <= - extDet ) {

  					// region 4

  					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
  					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				} else if ( s1 <= extDet ) {

  					// region 3

  					s0 = 0;
  					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

  				} else {

  					// region 2

  					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
  					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				}

  			}

  		} else {

  			// Ray and segment are parallel.

  			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
  			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  		}

  		if ( optionalPointOnRay ) {

  			optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

  		}

  		if ( optionalPointOnSegment ) {

  			optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

  		}

  		return sqrDist;

  	}

  	/**
  	 * Intersects this ray with the given sphere, returning the intersection
  	 * point or `null` if there is no intersection.
  	 *
  	 * @param {Sphere} sphere - The sphere to intersect.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The intersection point.
  	 */
  	intersectSphere( sphere, target ) {

  		_vector$a.subVectors( sphere.center, this.origin );
  		const tca = _vector$a.dot( this.direction );
  		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
  		const radius2 = sphere.radius * sphere.radius;

  		if ( d2 > radius2 ) return null;

  		const thc = Math.sqrt( radius2 - d2 );

  		// t0 = first intersect point - entrance on front of sphere
  		const t0 = tca - thc;

  		// t1 = second intersect point - exit point on back of sphere
  		const t1 = tca + thc;

  		// test to see if t1 is behind the ray - if so, return null
  		if ( t1 < 0 ) return null;

  		// test to see if t0 is behind the ray:
  		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  		// in order to always return an intersect point that is in front of the ray.
  		if ( t0 < 0 ) return this.at( t1, target );

  		// else t0 is in front of the ray, so return the first collision point scaled by t0
  		return this.at( t0, target );

  	}

  	/**
  	 * Returns `true` if this ray intersects with the given sphere.
  	 *
  	 * @param {Sphere} sphere - The sphere to intersect.
  	 * @return {boolean} Whether this ray intersects with the given sphere or not.
  	 */
  	intersectsSphere( sphere ) {

  		if ( sphere.radius < 0 ) return false; // handle empty spheres, see #31187

  		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

  	}

  	/**
  	 * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
  	 * does not intersect with the plane.
  	 *
  	 * @param {Plane} plane - The plane to compute the distance to.
  	 * @return {?number} Whether this ray intersects with the given sphere or not.
  	 */
  	distanceToPlane( plane ) {

  		const denominator = plane.normal.dot( this.direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( plane.distanceToPoint( this.origin ) === 0 ) {

  				return 0;

  			}

  			// Null is preferable to undefined since undefined means.... it is undefined

  			return null;

  		}

  		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

  		// Return if the ray never intersects the plane

  		return t >= 0 ? t : null;

  	}

  	/**
  	 * Intersects this ray with the given plane, returning the intersection
  	 * point or `null` if there is no intersection.
  	 *
  	 * @param {Plane} plane - The plane to intersect.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The intersection point.
  	 */
  	intersectPlane( plane, target ) {

  		const t = this.distanceToPlane( plane );

  		if ( t === null ) {

  			return null;

  		}

  		return this.at( t, target );

  	}

  	/**
  	 * Returns `true` if this ray intersects with the given plane.
  	 *
  	 * @param {Plane} plane - The plane to intersect.
  	 * @return {boolean} Whether this ray intersects with the given plane or not.
  	 */
  	intersectsPlane( plane ) {

  		// check if the ray lies on the plane first

  		const distToPoint = plane.distanceToPoint( this.origin );

  		if ( distToPoint === 0 ) {

  			return true;

  		}

  		const denominator = plane.normal.dot( this.direction );

  		if ( denominator * distToPoint < 0 ) {

  			return true;

  		}

  		// ray origin is behind the plane (and is pointing behind it)

  		return false;

  	}

  	/**
  	 * Intersects this ray with the given bounding box, returning the intersection
  	 * point or `null` if there is no intersection.
  	 *
  	 * @param {Box3} box - The box to intersect.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The intersection point.
  	 */
  	intersectBox( box, target ) {

  		let tmin, tmax, tymin, tymax, tzmin, tzmax;

  		const invdirx = 1 / this.direction.x,
  			invdiry = 1 / this.direction.y,
  			invdirz = 1 / this.direction.z;

  		const origin = this.origin;

  		if ( invdirx >= 0 ) {

  			tmin = ( box.min.x - origin.x ) * invdirx;
  			tmax = ( box.max.x - origin.x ) * invdirx;

  		} else {

  			tmin = ( box.max.x - origin.x ) * invdirx;
  			tmax = ( box.min.x - origin.x ) * invdirx;

  		}

  		if ( invdiry >= 0 ) {

  			tymin = ( box.min.y - origin.y ) * invdiry;
  			tymax = ( box.max.y - origin.y ) * invdiry;

  		} else {

  			tymin = ( box.max.y - origin.y ) * invdiry;
  			tymax = ( box.min.y - origin.y ) * invdiry;

  		}

  		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

  		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

  		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

  		if ( invdirz >= 0 ) {

  			tzmin = ( box.min.z - origin.z ) * invdirz;
  			tzmax = ( box.max.z - origin.z ) * invdirz;

  		} else {

  			tzmin = ( box.max.z - origin.z ) * invdirz;
  			tzmax = ( box.min.z - origin.z ) * invdirz;

  		}

  		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

  		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

  		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

  		//return point closest to the ray (positive side)

  		if ( tmax < 0 ) return null;

  		return this.at( tmin >= 0 ? tmin : tmax, target );

  	}

  	/**
  	 * Returns `true` if this ray intersects with the given box.
  	 *
  	 * @param {Box3} box - The box to intersect.
  	 * @return {boolean} Whether this ray intersects with the given box or not.
  	 */
  	intersectsBox( box ) {

  		return this.intersectBox( box, _vector$a ) !== null;

  	}

  	/**
  	 * Intersects this ray with the given triangle, returning the intersection
  	 * point or `null` if there is no intersection.
  	 *
  	 * @param {Vector3} a - The first vertex of the triangle.
  	 * @param {Vector3} b - The second vertex of the triangle.
  	 * @param {Vector3} c - The third vertex of the triangle.
  	 * @param {boolean} backfaceCulling - Whether to use backface culling or not.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The intersection point.
  	 */
  	intersectTriangle( a, b, c, backfaceCulling, target ) {

  		// Compute the offset origin, edges, and normal.

  		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

  		_edge1.subVectors( b, a );
  		_edge2.subVectors( c, a );
  		_normal$1.crossVectors( _edge1, _edge2 );

  		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  		let DdN = this.direction.dot( _normal$1 );
  		let sign;

  		if ( DdN > 0 ) {

  			if ( backfaceCulling ) return null;
  			sign = 1;

  		} else if ( DdN < 0 ) {

  			sign = -1;
  			DdN = - DdN;

  		} else {

  			return null;

  		}

  		_diff.subVectors( this.origin, a );
  		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

  		// b1 < 0, no intersection
  		if ( DdQxE2 < 0 ) {

  			return null;

  		}

  		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

  		// b2 < 0, no intersection
  		if ( DdE1xQ < 0 ) {

  			return null;

  		}

  		// b1+b2 > 1, no intersection
  		if ( DdQxE2 + DdE1xQ > DdN ) {

  			return null;

  		}

  		// Line intersects triangle, check if ray does.
  		const QdN = - sign * _diff.dot( _normal$1 );

  		// t < 0, no intersection
  		if ( QdN < 0 ) {

  			return null;

  		}

  		// Ray intersects triangle.
  		return this.at( QdN / DdN, target );

  	}

  	/**
  	 * Transforms this ray with the given 4x4 transformation matrix.
  	 *
  	 * @param {Matrix4} matrix4 - The transformation matrix.
  	 * @return {Ray} A reference to this ray.
  	 */
  	applyMatrix4( matrix4 ) {

  		this.origin.applyMatrix4( matrix4 );
  		this.direction.transformDirection( matrix4 );

  		return this;

  	}

  	/**
  	 * Returns `true` if this ray is equal with the given one.
  	 *
  	 * @param {Ray} ray - The ray to test for equality.
  	 * @return {boolean} Whether this ray is equal with the given one.
  	 */
  	equals( ray ) {

  		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  	}

  	/**
  	 * Returns a new ray with copied values from this instance.
  	 *
  	 * @return {Ray} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  /**
   * Represents a 4x4 matrix.
   *
   * The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.
   * For an introduction to transformation matrices as used in WebGL, check out [this tutorial]{@link https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices}
   *
   * This allows a 3D vector representing a point in 3D space to undergo
   * transformations such as translation, rotation, shear, scale, reflection,
   * orthogonal or perspective projection and so on, by being multiplied by the
   * matrix. This is known as `applying` the matrix to the vector.
   *
   * A Note on Row-Major and Column-Major Ordering:
   *
   * The constructor and {@link Matrix3#set} method take arguments in
   * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}
   * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.
   * This means that calling:
   * ```js
   * const m = new THREE.Matrix4();
   * m.set( 11, 12, 13, 14,
   *        21, 22, 23, 24,
   *        31, 32, 33, 34,
   *        41, 42, 43, 44 );
   * ```
   * will result in the elements array containing:
   * ```js
   * m.elements = [ 11, 21, 31, 41,
   *                12, 22, 32, 42,
   *                13, 23, 33, 43,
   *                14, 24, 34, 44 ];
   * ```
   * and internally all calculations are performed using column-major ordering.
   * However, as the actual ordering makes no difference mathematically and
   * most people are used to thinking about matrices in row-major order, the
   * three.js documentation shows matrices in row-major order. Just bear in
   * mind that if you are reading the source code, you'll have to take the
   * transpose of any matrices outlined here to make sense of the calculations.
   */
  class Matrix4 {

  	/**
  	 * Constructs a new 4x4 matrix. The arguments are supposed to be
  	 * in row-major order. If no arguments are provided, the constructor
  	 * initializes the matrix as an identity matrix.
  	 *
  	 * @param {number} [n11] - 1-1 matrix element.
  	 * @param {number} [n12] - 1-2 matrix element.
  	 * @param {number} [n13] - 1-3 matrix element.
  	 * @param {number} [n14] - 1-4 matrix element.
  	 * @param {number} [n21] - 2-1 matrix element.
  	 * @param {number} [n22] - 2-2 matrix element.
  	 * @param {number} [n23] - 2-3 matrix element.
  	 * @param {number} [n24] - 2-4 matrix element.
  	 * @param {number} [n31] - 3-1 matrix element.
  	 * @param {number} [n32] - 3-2 matrix element.
  	 * @param {number} [n33] - 3-3 matrix element.
  	 * @param {number} [n34] - 3-4 matrix element.
  	 * @param {number} [n41] - 4-1 matrix element.
  	 * @param {number} [n42] - 4-2 matrix element.
  	 * @param {number} [n43] - 4-3 matrix element.
  	 * @param {number} [n44] - 4-4 matrix element.
  	 */
  	constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		Matrix4.prototype.isMatrix4 = true;

  		/**
  		 * A column-major list of matrix values.
  		 *
  		 * @type {Array<number>}
  		 */
  		this.elements = [

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		];

  		if ( n11 !== undefined ) {

  			this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

  		}

  	}

  	/**
  	 * Sets the elements of the matrix.The arguments are supposed to be
  	 * in row-major order.
  	 *
  	 * @param {number} [n11] - 1-1 matrix element.
  	 * @param {number} [n12] - 1-2 matrix element.
  	 * @param {number} [n13] - 1-3 matrix element.
  	 * @param {number} [n14] - 1-4 matrix element.
  	 * @param {number} [n21] - 2-1 matrix element.
  	 * @param {number} [n22] - 2-2 matrix element.
  	 * @param {number} [n23] - 2-3 matrix element.
  	 * @param {number} [n24] - 2-4 matrix element.
  	 * @param {number} [n31] - 3-1 matrix element.
  	 * @param {number} [n32] - 3-2 matrix element.
  	 * @param {number} [n33] - 3-3 matrix element.
  	 * @param {number} [n34] - 3-4 matrix element.
  	 * @param {number} [n41] - 4-1 matrix element.
  	 * @param {number} [n42] - 4-2 matrix element.
  	 * @param {number} [n43] - 4-3 matrix element.
  	 * @param {number} [n44] - 4-4 matrix element.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		const te = this.elements;

  		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
  		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
  		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
  		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

  		return this;

  	}

  	/**
  	 * Sets this matrix to the 4x4 identity matrix.
  	 *
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	identity() {

  		this.set(

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Returns a matrix with copied values from this instance.
  	 *
  	 * @return {Matrix4} A clone of this instance.
  	 */
  	clone() {

  		return new Matrix4().fromArray( this.elements );

  	}

  	/**
  	 * Copies the values of the given matrix to this instance.
  	 *
  	 * @param {Matrix4} m - The matrix to copy.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	copy( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
  		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
  		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
  		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

  		return this;

  	}

  	/**
  	 * Copies the translation component of the given matrix
  	 * into this matrix's translation component.
  	 *
  	 * @param {Matrix4} m - The matrix to copy the translation component.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	copyPosition( m ) {

  		const te = this.elements, me = m.elements;

  		te[ 12 ] = me[ 12 ];
  		te[ 13 ] = me[ 13 ];
  		te[ 14 ] = me[ 14 ];

  		return this;

  	}

  	/**
  	 * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The 3x3 matrix.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	setFromMatrix3( m ) {

  		const me = m.elements;

  		this.set(

  			me[ 0 ], me[ 3 ], me[ 6 ], 0,
  			me[ 1 ], me[ 4 ], me[ 7 ], 0,
  			me[ 2 ], me[ 5 ], me[ 8 ], 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Extracts the basis of this matrix into the three axis vectors provided.
  	 *
  	 * @param {Vector3} xAxis - The basis's x axis.
  	 * @param {Vector3} yAxis - The basis's y axis.
  	 * @param {Vector3} zAxis - The basis's z axis.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	extractBasis( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrixColumn( this, 0 );
  		yAxis.setFromMatrixColumn( this, 1 );
  		zAxis.setFromMatrixColumn( this, 2 );

  		return this;

  	}

  	/**
  	 * Sets the given basis vectors to this matrix.
  	 *
  	 * @param {Vector3} xAxis - The basis's x axis.
  	 * @param {Vector3} yAxis - The basis's y axis.
  	 * @param {Vector3} zAxis - The basis's z axis.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeBasis( xAxis, yAxis, zAxis ) {

  		this.set(
  			xAxis.x, yAxis.x, zAxis.x, 0,
  			xAxis.y, yAxis.y, zAxis.y, 0,
  			xAxis.z, yAxis.z, zAxis.z, 0,
  			0, 0, 0, 1
  		);

  		return this;

  	}

  	/**
  	 * Extracts the rotation component of the given matrix
  	 * into this matrix's rotation component.
  	 *
  	 * Note: This method does not support reflection matrices.
  	 *
  	 * @param {Matrix4} m - The matrix.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	extractRotation( m ) {

  		const te = this.elements;
  		const me = m.elements;

  		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
  		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
  		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

  		te[ 0 ] = me[ 0 ] * scaleX;
  		te[ 1 ] = me[ 1 ] * scaleX;
  		te[ 2 ] = me[ 2 ] * scaleX;
  		te[ 3 ] = 0;

  		te[ 4 ] = me[ 4 ] * scaleY;
  		te[ 5 ] = me[ 5 ] * scaleY;
  		te[ 6 ] = me[ 6 ] * scaleY;
  		te[ 7 ] = 0;

  		te[ 8 ] = me[ 8 ] * scaleZ;
  		te[ 9 ] = me[ 9 ] * scaleZ;
  		te[ 10 ] = me[ 10 ] * scaleZ;
  		te[ 11 ] = 0;

  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	}

  	/**
  	 * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
  	 * the rotation specified by the given Euler angles. The rest of
  	 * the matrix is set to the identity. Depending on the {@link Euler#order},
  	 * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}
  	 * for a complete list.
  	 *
  	 * @param {Euler} euler - The Euler angles.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationFromEuler( euler ) {

  		const te = this.elements;

  		const x = euler.x, y = euler.y, z = euler.z;
  		const a = Math.cos( x ), b = Math.sin( x );
  		const c = Math.cos( y ), d = Math.sin( y );
  		const e = Math.cos( z ), f = Math.sin( z );

  		if ( euler.order === 'XYZ' ) {

  			const ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - c * f;
  			te[ 8 ] = d;

  			te[ 1 ] = af + be * d;
  			te[ 5 ] = ae - bf * d;
  			te[ 9 ] = - b * c;

  			te[ 2 ] = bf - ae * d;
  			te[ 6 ] = be + af * d;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YXZ' ) {

  			const ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce + df * b;
  			te[ 4 ] = de * b - cf;
  			te[ 8 ] = a * d;

  			te[ 1 ] = a * f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b;

  			te[ 2 ] = cf * b - de;
  			te[ 6 ] = df + ce * b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZXY' ) {

  			const ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce - df * b;
  			te[ 4 ] = - a * f;
  			te[ 8 ] = de + cf * b;

  			te[ 1 ] = cf + de * b;
  			te[ 5 ] = a * e;
  			te[ 9 ] = df - ce * b;

  			te[ 2 ] = - a * d;
  			te[ 6 ] = b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZYX' ) {

  			const ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = be * d - af;
  			te[ 8 ] = ae * d + bf;

  			te[ 1 ] = c * f;
  			te[ 5 ] = bf * d + ae;
  			te[ 9 ] = af * d - be;

  			te[ 2 ] = - d;
  			te[ 6 ] = b * c;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YZX' ) {

  			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = bd - ac * f;
  			te[ 8 ] = bc * f + ad;

  			te[ 1 ] = f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b * e;

  			te[ 2 ] = - d * e;
  			te[ 6 ] = ad * f + bc;
  			te[ 10 ] = ac - bd * f;

  		} else if ( euler.order === 'XZY' ) {

  			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - f;
  			te[ 8 ] = d * e;

  			te[ 1 ] = ac * f + bd;
  			te[ 5 ] = a * e;
  			te[ 9 ] = ad * f - bc;

  			te[ 2 ] = bc * f - ad;
  			te[ 6 ] = b * e;
  			te[ 10 ] = bd * f + ac;

  		}

  		// bottom row
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// last column
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	}

  	/**
  	 * Sets the rotation component of this matrix to the rotation specified by
  	 * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}
  	 * The rest of the matrix is set to the identity.
  	 *
  	 * @param {Quaternion} q - The Quaternion.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationFromQuaternion( q ) {

  		return this.compose( _zero, q, _one );

  	}

  	/**
  	 * Sets the rotation component of the transformation matrix, looking from `eye` towards
  	 * `target`, and oriented by the up-direction.
  	 *
  	 * @param {Vector3} eye - The eye vector.
  	 * @param {Vector3} target - The target vector.
  	 * @param {Vector3} up - The up vector.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	lookAt( eye, target, up ) {

  		const te = this.elements;

  		_z.subVectors( eye, target );

  		if ( _z.lengthSq() === 0 ) {

  			// eye and target are in the same position

  			_z.z = 1;

  		}

  		_z.normalize();
  		_x.crossVectors( up, _z );

  		if ( _x.lengthSq() === 0 ) {

  			// up and z are parallel

  			if ( Math.abs( up.z ) === 1 ) {

  				_z.x += 0.0001;

  			} else {

  				_z.z += 0.0001;

  			}

  			_z.normalize();
  			_x.crossVectors( up, _z );

  		}

  		_x.normalize();
  		_y.crossVectors( _z, _x );

  		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
  		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
  		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

  		return this;

  	}

  	/**
  	 * Post-multiplies this matrix by the given 4x4 matrix.
  	 *
  	 * @param {Matrix4} m - The matrix to multiply with.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	multiply( m ) {

  		return this.multiplyMatrices( this, m );

  	}

  	/**
  	 * Pre-multiplies this matrix by the given 4x4 matrix.
  	 *
  	 * @param {Matrix4} m - The matrix to multiply with.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	premultiply( m ) {

  		return this.multiplyMatrices( m, this );

  	}

  	/**
  	 * Multiples the given 4x4 matrices and stores the result
  	 * in this matrix.
  	 *
  	 * @param {Matrix4} a - The first matrix.
  	 * @param {Matrix4} b - The second matrix.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	multiplyMatrices( a, b ) {

  		const ae = a.elements;
  		const be = b.elements;
  		const te = this.elements;

  		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
  		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
  		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
  		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

  		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
  		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
  		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
  		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

  		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

  		return this;

  	}

  	/**
  	 * Multiplies every component of the matrix by the given scalar.
  	 *
  	 * @param {number} s - The scalar.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	multiplyScalar( s ) {

  		const te = this.elements;

  		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
  		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
  		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
  		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

  		return this;

  	}

  	/**
  	 * Computes and returns the determinant of this matrix.
  	 *
  	 * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.
  	 *
  	 * @return {number} The determinant.
  	 */
  	determinant() {

  		const te = this.elements;

  		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
  		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
  		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
  		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

  		//TODO: make this more efficient

  		return (
  			n41 * (
  				+ n14 * n23 * n32
  				 - n13 * n24 * n32
  				 - n14 * n22 * n33
  				 + n12 * n24 * n33
  				 + n13 * n22 * n34
  				 - n12 * n23 * n34
  			) +
  			n42 * (
  				+ n11 * n23 * n34
  				 - n11 * n24 * n33
  				 + n14 * n21 * n33
  				 - n13 * n21 * n34
  				 + n13 * n24 * n31
  				 - n14 * n23 * n31
  			) +
  			n43 * (
  				+ n11 * n24 * n32
  				 - n11 * n22 * n34
  				 - n14 * n21 * n32
  				 + n12 * n21 * n34
  				 + n14 * n22 * n31
  				 - n12 * n24 * n31
  			) +
  			n44 * (
  				- n13 * n22 * n31
  				 - n11 * n23 * n32
  				 + n11 * n22 * n33
  				 + n13 * n21 * n32
  				 - n12 * n21 * n33
  				 + n12 * n23 * n31
  			)

  		);

  	}

  	/**
  	 * Transposes this matrix in place.
  	 *
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	transpose() {

  		const te = this.elements;
  		let tmp;

  		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
  		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
  		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

  		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
  		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
  		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

  		return this;

  	}

  	/**
  	 * Sets the position component for this matrix from the given vector,
  	 * without affecting the rest of the matrix.
  	 *
  	 * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
  	 * @param {number} y - The y component of the vector.
  	 * @param {number} z - The z component of the vector.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	setPosition( x, y, z ) {

  		const te = this.elements;

  		if ( x.isVector3 ) {

  			te[ 12 ] = x.x;
  			te[ 13 ] = x.y;
  			te[ 14 ] = x.z;

  		} else {

  			te[ 12 ] = x;
  			te[ 13 ] = y;
  			te[ 14 ] = z;

  		}

  		return this;

  	}

  	/**
  	 * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
  	 * You can not invert with a determinant of zero. If you attempt this, the method produces
  	 * a zero matrix instead.
  	 *
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	invert() {

  		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  		const te = this.elements,

  			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
  			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
  			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
  			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

  			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
  			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
  			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
  			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

  		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

  		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

  		const detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
  		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
  		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

  		te[ 4 ] = t12 * detInv;
  		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
  		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
  		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

  		te[ 8 ] = t13 * detInv;
  		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
  		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
  		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

  		te[ 12 ] = t14 * detInv;
  		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
  		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
  		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

  		return this;

  	}

  	/**
  	 * Multiplies the columns of this matrix by the given vector.
  	 *
  	 * @param {Vector3} v - The scale vector.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	scale( v ) {

  		const te = this.elements;
  		const x = v.x, y = v.y, z = v.z;

  		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
  		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
  		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
  		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

  		return this;

  	}

  	/**
  	 * Gets the maximum scale value of the three axes.
  	 *
  	 * @return {number} The maximum scale.
  	 */
  	getMaxScaleOnAxis() {

  		const te = this.elements;

  		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
  		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
  		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

  		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

  	}

  	/**
  	 * Sets this matrix as a translation transform from the given vector.
  	 *
  	 * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
  	 * @param {number} y - The amount to translate in the Y axis.
  	 * @param {number} z - The amount to translate in the z axis.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeTranslation( x, y, z ) {

  		if ( x.isVector3 ) {

  			this.set(

  				1, 0, 0, x.x,
  				0, 1, 0, x.y,
  				0, 0, 1, x.z,
  				0, 0, 0, 1

  			);

  		} else {

  			this.set(

  				1, 0, 0, x,
  				0, 1, 0, y,
  				0, 0, 1, z,
  				0, 0, 0, 1

  			);

  		}

  		return this;

  	}

  	/**
  	 * Sets this matrix as a rotational transformation around the X axis by
  	 * the given angle.
  	 *
  	 * @param {number} theta - The rotation in radians.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationX( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			1, 0, 0, 0,
  			0, c, - s, 0,
  			0, s, c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a rotational transformation around the Y axis by
  	 * the given angle.
  	 *
  	 * @param {number} theta - The rotation in radians.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationY( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			 c, 0, s, 0,
  			 0, 1, 0, 0,
  			- s, 0, c, 0,
  			 0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a rotational transformation around the Z axis by
  	 * the given angle.
  	 *
  	 * @param {number} theta - The rotation in radians.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationZ( theta ) {

  		const c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			c, - s, 0, 0,
  			s, c, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a rotational transformation around the given axis by
  	 * the given angle.
  	 *
  	 * This is a somewhat controversial but mathematically sound alternative to
  	 * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.
  	 *
  	 * @param {Vector3} axis - The normalized rotation axis.
  	 * @param {number} angle - The rotation in radians.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeRotationAxis( axis, angle ) {

  		// Based on http://www.gamedev.net/reference/articles/article1199.asp

  		const c = Math.cos( angle );
  		const s = Math.sin( angle );
  		const t = 1 - c;
  		const x = axis.x, y = axis.y, z = axis.z;
  		const tx = t * x, ty = t * y;

  		this.set(

  			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
  			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
  			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a scale transformation.
  	 *
  	 * @param {number} x - The amount to scale in the X axis.
  	 * @param {number} y - The amount to scale in the Y axis.
  	 * @param {number} z - The amount to scale in the Z axis.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeScale( x, y, z ) {

  		this.set(

  			x, 0, 0, 0,
  			0, y, 0, 0,
  			0, 0, z, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix as a shear transformation.
  	 *
  	 * @param {number} xy - The amount to shear X by Y.
  	 * @param {number} xz - The amount to shear X by Z.
  	 * @param {number} yx - The amount to shear Y by X.
  	 * @param {number} yz - The amount to shear Y by Z.
  	 * @param {number} zx - The amount to shear Z by X.
  	 * @param {number} zy - The amount to shear Z by Y.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeShear( xy, xz, yx, yz, zx, zy ) {

  		this.set(

  			1, yx, zx, 0,
  			xy, 1, zy, 0,
  			xz, yz, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	}

  	/**
  	 * Sets this matrix to the transformation composed of the given position,
  	 * rotation (Quaternion) and scale.
  	 *
  	 * @param {Vector3} position - The position vector.
  	 * @param {Quaternion} quaternion - The rotation as a Quaternion.
  	 * @param {Vector3} scale - The scale vector.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	compose( position, quaternion, scale ) {

  		const te = this.elements;

  		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
  		const x2 = x + x,	y2 = y + y, z2 = z + z;
  		const xx = x * x2, xy = x * y2, xz = x * z2;
  		const yy = y * y2, yz = y * z2, zz = z * z2;
  		const wx = w * x2, wy = w * y2, wz = w * z2;

  		const sx = scale.x, sy = scale.y, sz = scale.z;

  		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
  		te[ 1 ] = ( xy + wz ) * sx;
  		te[ 2 ] = ( xz - wy ) * sx;
  		te[ 3 ] = 0;

  		te[ 4 ] = ( xy - wz ) * sy;
  		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
  		te[ 6 ] = ( yz + wx ) * sy;
  		te[ 7 ] = 0;

  		te[ 8 ] = ( xz + wy ) * sz;
  		te[ 9 ] = ( yz - wx ) * sz;
  		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
  		te[ 11 ] = 0;

  		te[ 12 ] = position.x;
  		te[ 13 ] = position.y;
  		te[ 14 ] = position.z;
  		te[ 15 ] = 1;

  		return this;

  	}

  	/**
  	 * Decomposes this matrix into its position, rotation and scale components
  	 * and provides the result in the given objects.
  	 *
  	 * Note: Not all matrices are decomposable in this way. For example, if an
  	 * object has a non-uniformly scaled parent, then the object's world matrix
  	 * may not be decomposable, and this method may not be appropriate.
  	 *
  	 * @param {Vector3} position - The position vector.
  	 * @param {Quaternion} quaternion - The rotation as a Quaternion.
  	 * @param {Vector3} scale - The scale vector.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	decompose( position, quaternion, scale ) {

  		const te = this.elements;

  		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
  		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
  		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

  		// if determine is negative, we need to invert one scale
  		const det = this.determinant();
  		if ( det < 0 ) sx = - sx;

  		position.x = te[ 12 ];
  		position.y = te[ 13 ];
  		position.z = te[ 14 ];

  		// scale the rotation part
  		_m1$2.copy( this );

  		const invSX = 1 / sx;
  		const invSY = 1 / sy;
  		const invSZ = 1 / sz;

  		_m1$2.elements[ 0 ] *= invSX;
  		_m1$2.elements[ 1 ] *= invSX;
  		_m1$2.elements[ 2 ] *= invSX;

  		_m1$2.elements[ 4 ] *= invSY;
  		_m1$2.elements[ 5 ] *= invSY;
  		_m1$2.elements[ 6 ] *= invSY;

  		_m1$2.elements[ 8 ] *= invSZ;
  		_m1$2.elements[ 9 ] *= invSZ;
  		_m1$2.elements[ 10 ] *= invSZ;

  		quaternion.setFromRotationMatrix( _m1$2 );

  		scale.x = sx;
  		scale.y = sy;
  		scale.z = sz;

  		return this;

  	}

  	/**
  	 * Creates a perspective projection matrix. This is used internally by
  	 * {@link PerspectiveCamera#updateProjectionMatrix}.

  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {

  		const te = this.elements;

  		const x = 2 * near / ( right - left );
  		const y = 2 * near / ( top - bottom );

  		const a = ( right + left ) / ( right - left );
  		const b = ( top + bottom ) / ( top - bottom );

  		let c, d;

  		if ( reversedDepth ) {

  			c = near / ( far - near );
  			d = ( far * near ) / ( far - near );

  		} else {

  			if ( coordinateSystem === WebGLCoordinateSystem ) {

  				c = - ( far + near ) / ( far - near );
  				d = ( -2 * far * near ) / ( far - near );

  			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  				c = - far / ( far - near );
  				d = ( - far * near ) / ( far - near );

  			} else {

  				throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

  			}

  		}

  		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
  		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = -1;	te[ 15 ] = 0;

  		return this;

  	}

  	/**
  	 * Creates a orthographic projection matrix. This is used internally by
  	 * {@link OrthographicCamera#updateProjectionMatrix}.

  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {

  		const te = this.elements;

  		const x = 2 / ( right - left );
  		const y = 2 / ( top - bottom );

  		const a = - ( right + left ) / ( right - left );
  		const b = - ( top + bottom ) / ( top - bottom );

  		let c, d;

  		if ( reversedDepth ) {

  			c = 1 / ( far - near );
  			d = far / ( far - near );

  		} else {

  			if ( coordinateSystem === WebGLCoordinateSystem ) {

  				c = -2 / ( far - near );
  				d = - ( far + near ) / ( far - near );

  			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  				c = -1 / ( far - near );
  				d = - near / ( far - near );

  			} else {

  				throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

  			}

  		}

  		te[ 0 ] = x;		te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = a;
  		te[ 1 ] = 0; 		te[ 5 ] = y;		te[ 9 ] = 0; 		te[ 13 ] = b;
  		te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = c;		te[ 14 ] = d;
  		te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

  		return this;

  	}

  	/**
  	 * Returns `true` if this matrix is equal with the given one.
  	 *
  	 * @param {Matrix4} matrix - The matrix to test for equality.
  	 * @return {boolean} Whether this matrix is equal with the given one.
  	 */
  	equals( matrix ) {

  		const te = this.elements;
  		const me = matrix.elements;

  		for ( let i = 0; i < 16; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	}

  	/**
  	 * Sets the elements of the matrix from the given array.
  	 *
  	 * @param {Array<number>} array - The matrix elements in column-major order.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  	fromArray( array, offset = 0 ) {

  		for ( let i = 0; i < 16; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	}

  	/**
  	 * Writes the elements of this matrix to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The matrix elements in column-major order.
  	 */
  	toArray( array = [], offset = 0 ) {

  		const te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];
  		array[ offset + 3 ] = te[ 3 ];

  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];
  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];

  		array[ offset + 8 ] = te[ 8 ];
  		array[ offset + 9 ] = te[ 9 ];
  		array[ offset + 10 ] = te[ 10 ];
  		array[ offset + 11 ] = te[ 11 ];

  		array[ offset + 12 ] = te[ 12 ];
  		array[ offset + 13 ] = te[ 13 ];
  		array[ offset + 14 ] = te[ 14 ];
  		array[ offset + 15 ] = te[ 15 ];

  		return array;

  	}

  }

  const _v1$5 = /*@__PURE__*/ new Vector3();
  const _m1$2 = /*@__PURE__*/ new Matrix4();
  const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
  const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
  const _x = /*@__PURE__*/ new Vector3();
  const _y = /*@__PURE__*/ new Vector3();
  const _z = /*@__PURE__*/ new Vector3();

  const _matrix$2 = /*@__PURE__*/ new Matrix4();
  const _quaternion$3 = /*@__PURE__*/ new Quaternion();

  /**
   * A class representing Euler angles.
   *
   * Euler angles describe a rotational transformation by rotating an object on
   * its various axes in specified amounts per axis, and a specified axis
   * order.
   *
   * Iterating through an instance will yield its components (x, y, z,
   * order) in the corresponding order.
   *
   * ```js
   * const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
   * const b = new THREE.Vector3( 1, 0, 1 );
   * b.applyEuler(a);
   * ```
   */
  class Euler {

  	/**
  	 * Constructs a new euler instance.
  	 *
  	 * @param {number} [x=0] - The angle of the x axis in radians.
  	 * @param {number} [y=0] - The angle of the y axis in radians.
  	 * @param {number} [z=0] - The angle of the z axis in radians.
  	 * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
  	 */
  	constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isEuler = true;

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order;

  	}

  	/**
  	 * The angle of the x axis in radians.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get x() {

  		return this._x;

  	}

  	set x( value ) {

  		this._x = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * The angle of the y axis in radians.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get y() {

  		return this._y;

  	}

  	set y( value ) {

  		this._y = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * The angle of the z axis in radians.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get z() {

  		return this._z;

  	}

  	set z( value ) {

  		this._z = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * A string representing the order that the rotations are applied.
  	 *
  	 * @type {string}
  	 * @default 'XYZ'
  	 */
  	get order() {

  		return this._order;

  	}

  	set order( value ) {

  		this._order = value;
  		this._onChangeCallback();

  	}

  	/**
  	 * Sets the Euler components.
  	 *
  	 * @param {number} x - The angle of the x axis in radians.
  	 * @param {number} y - The angle of the y axis in radians.
  	 * @param {number} z - The angle of the z axis in radians.
  	 * @param {string} [order] - A string representing the order that the rotations are applied.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	set( x, y, z, order = this._order ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Returns a new Euler instance with copied values from this instance.
  	 *
  	 * @return {Euler} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this._x, this._y, this._z, this._order );

  	}

  	/**
  	 * Copies the values of the given Euler instance to this instance.
  	 *
  	 * @param {Euler} euler - The Euler instance to copy.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	copy( euler ) {

  		this._x = euler._x;
  		this._y = euler._y;
  		this._z = euler._z;
  		this._order = euler._order;

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets the angles of this Euler instance from a pure rotation matrix.
  	 *
  	 * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
  	 * @param {string} [order] - A string representing the order that the rotations are applied.
  	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	setFromRotationMatrix( m, order = this._order, update = true ) {

  		const te = m.elements;
  		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
  		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
  		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		switch ( order ) {

  			case 'XYZ':

  				this._y = Math.asin( clamp( m13, -1, 1 ) );

  				if ( Math.abs( m13 ) < 0.9999999 ) {

  					this._x = Math.atan2( - m23, m33 );
  					this._z = Math.atan2( - m12, m11 );

  				} else {

  					this._x = Math.atan2( m32, m22 );
  					this._z = 0;

  				}

  				break;

  			case 'YXZ':

  				this._x = Math.asin( - clamp( m23, -1, 1 ) );

  				if ( Math.abs( m23 ) < 0.9999999 ) {

  					this._y = Math.atan2( m13, m33 );
  					this._z = Math.atan2( m21, m22 );

  				} else {

  					this._y = Math.atan2( - m31, m11 );
  					this._z = 0;

  				}

  				break;

  			case 'ZXY':

  				this._x = Math.asin( clamp( m32, -1, 1 ) );

  				if ( Math.abs( m32 ) < 0.9999999 ) {

  					this._y = Math.atan2( - m31, m33 );
  					this._z = Math.atan2( - m12, m22 );

  				} else {

  					this._y = 0;
  					this._z = Math.atan2( m21, m11 );

  				}

  				break;

  			case 'ZYX':

  				this._y = Math.asin( - clamp( m31, -1, 1 ) );

  				if ( Math.abs( m31 ) < 0.9999999 ) {

  					this._x = Math.atan2( m32, m33 );
  					this._z = Math.atan2( m21, m11 );

  				} else {

  					this._x = 0;
  					this._z = Math.atan2( - m12, m22 );

  				}

  				break;

  			case 'YZX':

  				this._z = Math.asin( clamp( m21, -1, 1 ) );

  				if ( Math.abs( m21 ) < 0.9999999 ) {

  					this._x = Math.atan2( - m23, m22 );
  					this._y = Math.atan2( - m31, m11 );

  				} else {

  					this._x = 0;
  					this._y = Math.atan2( m13, m33 );

  				}

  				break;

  			case 'XZY':

  				this._z = Math.asin( - clamp( m12, -1, 1 ) );

  				if ( Math.abs( m12 ) < 0.9999999 ) {

  					this._x = Math.atan2( m32, m22 );
  					this._y = Math.atan2( m13, m11 );

  				} else {

  					this._x = Math.atan2( - m23, m33 );
  					this._y = 0;

  				}

  				break;

  			default:

  				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

  		}

  		this._order = order;

  		if ( update === true ) this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Sets the angles of this Euler instance from a normalized quaternion.
  	 *
  	 * @param {Quaternion} q - A normalized Quaternion.
  	 * @param {string} [order] - A string representing the order that the rotations are applied.
  	 * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	setFromQuaternion( q, order, update ) {

  		_matrix$2.makeRotationFromQuaternion( q );

  		return this.setFromRotationMatrix( _matrix$2, order, update );

  	}

  	/**
  	 * Sets the angles of this Euler instance from the given vector.
  	 *
  	 * @param {Vector3} v - The vector.
  	 * @param {string} [order] - A string representing the order that the rotations are applied.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	setFromVector3( v, order = this._order ) {

  		return this.set( v.x, v.y, v.z, order );

  	}

  	/**
  	 * Resets the euler angle with a new order by creating a quaternion from this
  	 * euler angle and then setting this euler angle with the quaternion and the
  	 * new order.
  	 *
  	 * Warning: This discards revolution information.
  	 *
  	 * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	reorder( newOrder ) {

  		_quaternion$3.setFromEuler( this );

  		return this.setFromQuaternion( _quaternion$3, newOrder );

  	}

  	/**
  	 * Returns `true` if this Euler instance is equal with the given one.
  	 *
  	 * @param {Euler} euler - The Euler instance to test for equality.
  	 * @return {boolean} Whether this Euler instance is equal with the given one.
  	 */
  	equals( euler ) {

  		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  	}

  	/**
  	 * Sets this Euler instance's components to values from the given array. The first three
  	 * entries of the array are assign to the x,y and z components. An optional fourth entry
  	 * defines the Euler order.
  	 *
  	 * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
  	 * @return {Euler} A reference to this Euler instance.
  	 */
  	fromArray( array ) {

  		this._x = array[ 0 ];
  		this._y = array[ 1 ];
  		this._z = array[ 2 ];
  		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

  		this._onChangeCallback();

  		return this;

  	}

  	/**
  	 * Writes the components of this Euler instance to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number,number,number,string>} The Euler components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._order;

  		return array;

  	}

  	_onChange( callback ) {

  		this._onChangeCallback = callback;

  		return this;

  	}

  	_onChangeCallback() {}

  	*[ Symbol.iterator ]() {

  		yield this._x;
  		yield this._y;
  		yield this._z;
  		yield this._order;

  	}

  }

  /**
   * The default Euler angle order.
   *
   * @static
   * @type {string}
   * @default 'XYZ'
   */
  Euler.DEFAULT_ORDER = 'XYZ';

  /**
   * A layers object assigns an 3D object to 1 or more of 32
   * layers numbered `0` to `31` - internally the layers are stored as a
   * bit mask], and by default all 3D objects are a member of layer `0`.
   *
   * This can be used to control visibility - an object must share a layer with
   * a camera to be visible when that camera's view is
   * rendered.
   *
   * All classes that inherit from {@link Object3D} have an `layers` property which
   * is an instance of this class.
   */
  class Layers {

  	/**
  	 * Constructs a new layers instance, with membership
  	 * initially set to layer `0`.
  	 */
  	constructor() {

  		/**
  		 * A bit mask storing which of the 32 layers this layers object is currently
  		 * a member of.
  		 *
  		 * @type {number}
  		 */
  		this.mask = 1 | 0;

  	}

  	/**
  	 * Sets membership to the given layer, and remove membership all other layers.
  	 *
  	 * @param {number} layer - The layer to set.
  	 */
  	set( layer ) {

  		this.mask = ( 1 << layer | 0 ) >>> 0;

  	}

  	/**
  	 * Adds membership of the given layer.
  	 *
  	 * @param {number} layer - The layer to enable.
  	 */
  	enable( layer ) {

  		this.mask |= 1 << layer | 0;

  	}

  	/**
  	 * Adds membership to all layers.
  	 */
  	enableAll() {

  		this.mask = 0xffffffff | 0;

  	}

  	/**
  	 * Toggles the membership of the given layer.
  	 *
  	 * @param {number} layer - The layer to toggle.
  	 */
  	toggle( layer ) {

  		this.mask ^= 1 << layer | 0;

  	}

  	/**
  	 * Removes membership of the given layer.
  	 *
  	 * @param {number} layer - The layer to enable.
  	 */
  	disable( layer ) {

  		this.mask &= ~ ( 1 << layer | 0 );

  	}

  	/**
  	 * Removes the membership from all layers.
  	 */
  	disableAll() {

  		this.mask = 0;

  	}

  	/**
  	 * Returns `true` if this and the given layers object have at least one
  	 * layer in common.
  	 *
  	 * @param {Layers} layers - The layers to test.
  	 * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
  	 */
  	test( layers ) {

  		return ( this.mask & layers.mask ) !== 0;

  	}

  	/**
  	 * Returns `true` if the given layer is enabled.
  	 *
  	 * @param {number} layer - The layer to test.
  	 * @return {boolean } Whether the given layer is enabled or not.
  	 */
  	isEnabled( layer ) {

  		return ( this.mask & ( 1 << layer | 0 ) ) !== 0;

  	}

  }

  let _object3DId = 0;

  const _v1$4 = /*@__PURE__*/ new Vector3();
  const _q1 = /*@__PURE__*/ new Quaternion();
  const _m1$1$1 = /*@__PURE__*/ new Matrix4();
  const _target = /*@__PURE__*/ new Vector3();

  const _position$3 = /*@__PURE__*/ new Vector3();
  const _scale$2 = /*@__PURE__*/ new Vector3();
  const _quaternion$2 = /*@__PURE__*/ new Quaternion();

  const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
  const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
  const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

  /**
   * Fires when the object has been added to its parent object.
   *
   * @event Object3D#added
   * @type {Object}
   */
  const _addedEvent = { type: 'added' };

  /**
   * Fires when the object has been removed from its parent object.
   *
   * @event Object3D#removed
   * @type {Object}
   */
  const _removedEvent = { type: 'removed' };

  /**
   * Fires when a new child object has been added.
   *
   * @event Object3D#childadded
   * @type {Object}
   */
  const _childaddedEvent = { type: 'childadded', child: null };

  /**
   * Fires when a child object has been removed.
   *
   * @event Object3D#childremoved
   * @type {Object}
   */
  const _childremovedEvent = { type: 'childremoved', child: null };

  /**
   * This is the base class for most objects in three.js and provides a set of
   * properties and methods for manipulating objects in 3D space.
   *
   * @augments EventDispatcher
   */
  class Object3D extends EventDispatcher {

  	/**
  	 * Constructs a new 3D object.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isObject3D = true;

  		/**
  		 * The ID of the 3D object.
  		 *
  		 * @name Object3D#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

  		/**
  		 * The UUID of the 3D object.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  		/**
  		 * The name of the 3D object.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';

  		/**
  		 * The type property is used for detecting the object type
  		 * in context of serialization/deserialization.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.type = 'Object3D';

  		/**
  		 * A reference to the parent object.
  		 *
  		 * @type {?Object3D}
  		 * @default null
  		 */
  		this.parent = null;

  		/**
  		 * An array holding the child 3D objects of this instance.
  		 *
  		 * @type {Array<Object3D>}
  		 */
  		this.children = [];

  		/**
  		 * Defines the `up` direction of the 3D object which influences
  		 * the orientation via methods like {@link Object3D#lookAt}.
  		 *
  		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_UP`.
  		 *
  		 * @type {Vector3}
  		 */
  		this.up = Object3D.DEFAULT_UP.clone();

  		const position = new Vector3();
  		const rotation = new Euler();
  		const quaternion = new Quaternion();
  		const scale = new Vector3( 1, 1, 1 );

  		function onRotationChange() {

  			quaternion.setFromEuler( rotation, false );

  		}

  		function onQuaternionChange() {

  			rotation.setFromQuaternion( quaternion, undefined, false );

  		}

  		rotation._onChange( onRotationChange );
  		quaternion._onChange( onQuaternionChange );

  		Object.defineProperties( this, {
  			/**
  			 * Represents the object's local position.
  			 *
  			 * @name Object3D#position
  			 * @type {Vector3}
  			 * @default (0,0,0)
  			 */
  			position: {
  				configurable: true,
  				enumerable: true,
  				value: position
  			},
  			/**
  			 * Represents the object's local rotation as Euler angles, in radians.
  			 *
  			 * @name Object3D#rotation
  			 * @type {Euler}
  			 * @default (0,0,0)
  			 */
  			rotation: {
  				configurable: true,
  				enumerable: true,
  				value: rotation
  			},
  			/**
  			 * Represents the object's local rotation as Quaternions.
  			 *
  			 * @name Object3D#quaternion
  			 * @type {Quaternion}
  			 */
  			quaternion: {
  				configurable: true,
  				enumerable: true,
  				value: quaternion
  			},
  			/**
  			 * Represents the object's local scale.
  			 *
  			 * @name Object3D#scale
  			 * @type {Vector3}
  			 * @default (1,1,1)
  			 */
  			scale: {
  				configurable: true,
  				enumerable: true,
  				value: scale
  			},
  			/**
  			 * Represents the object's model-view matrix.
  			 *
  			 * @name Object3D#modelViewMatrix
  			 * @type {Matrix4}
  			 */
  			modelViewMatrix: {
  				value: new Matrix4()
  			},
  			/**
  			 * Represents the object's normal matrix.
  			 *
  			 * @name Object3D#normalMatrix
  			 * @type {Matrix3}
  			 */
  			normalMatrix: {
  				value: new Matrix3()
  			}
  		} );

  		/**
  		 * Represents the object's transformation matrix in local space.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.matrix = new Matrix4();

  		/**
  		 * Represents the object's transformation matrix in world space.
  		 * If the 3D object has no parent, then it's identical to the local transformation matrix
  		 *
  		 * @type {Matrix4}
  		 */
  		this.matrixWorld = new Matrix4();

  		/**
  		 * When set to `true`, the engine automatically computes the local matrix from position,
  		 * rotation and scale every frame.
  		 *
  		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_AUTO_UPDATE`.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;

  		/**
  		 * When set to `true`, the engine automatically computes the world matrix from the current local
  		 * matrix and the object's transformation hierarchy.
  		 *
  		 * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

  		/**
  		 * When set to `true`, it calculates the world matrix in that frame and resets this property
  		 * to `false`.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.matrixWorldNeedsUpdate = false;

  		/**
  		 * The layer membership of the 3D object. The 3D object is only visible if it has
  		 * at least one layer in common with the camera in use. This property can also be
  		 * used to filter out unwanted objects in ray-intersection tests when using {@link Raycaster}.
  		 *
  		 * @type {Layers}
  		 */
  		this.layers = new Layers();

  		/**
  		 * When set to `true`, the 3D object gets rendered.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.visible = true;

  		/**
  		 * When set to `true`, the 3D object gets rendered into shadow maps.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.castShadow = false;

  		/**
  		 * When set to `true`, the 3D object is affected by shadows in the scene.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.receiveShadow = false;

  		/**
  		 * When set to `true`, the 3D object is honored by view frustum culling.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.frustumCulled = true;

  		/**
  		 * This value allows the default rendering order of scene graph objects to be
  		 * overridden although opaque and transparent objects remain sorted independently.
  		 * When this property is set for an instance of {@link Group},all descendants
  		 * objects will be sorted and rendered together. Sorting is from lowest to highest
  		 * render order.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.renderOrder = 0;

  		/**
  		 * An array holding the animation clips of the 3D object.
  		 *
  		 * @type {Array<AnimationClip>}
  		 */
  		this.animations = [];

  		/**
  		 * Custom depth material to be used when rendering to the depth map. Can only be used
  		 * in context of meshes. When shadow-casting with a {@link DirectionalLight} or {@link SpotLight},
  		 * if you are modifying vertex positions in the vertex shader you must specify a custom depth
  		 * material for proper shadows.
  		 *
  		 * Only relevant in context of {@link WebGLRenderer}.
  		 *
  		 * @type {(Material|undefined)}
  		 * @default undefined
  		 */
  		this.customDepthMaterial = undefined;

  		/**
  		 * Same as {@link Object3D#customDepthMaterial}, but used with {@link PointLight}.
  		 *
  		 * Only relevant in context of {@link WebGLRenderer}.
  		 *
  		 * @type {(Material|undefined)}
  		 * @default undefined
  		 */
  		this.customDistanceMaterial = undefined;

  		/**
  		 * An object that can be used to store custom data about the 3D object. It
  		 * should not hold references to functions as these will not be cloned.
  		 *
  		 * @type {Object}
  		 */
  		this.userData = {};

  	}

  	/**
  	 * A callback that is executed immediately before a 3D object is rendered to a shadow map.
  	 *
  	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {Camera} shadowCamera - The shadow camera.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Material} depthMaterial - The depth material.
  	 * @param {Object} group - The geometry group data.
  	 */
  	onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

  	/**
  	 * A callback that is executed immediately after a 3D object is rendered to a shadow map.
  	 *
  	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {Camera} shadowCamera - The shadow camera.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Material} depthMaterial - The depth material.
  	 * @param {Object} group - The geometry group data.
  	 */
  	onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}

  	/**
  	 * A callback that is executed immediately before a 3D object is rendered.
  	 *
  	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Material} material - The 3D object's material.
  	 * @param {Object} group - The geometry group data.
  	 */
  	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

  	/**
  	 * A callback that is executed immediately after a 3D object is rendered.
  	 *
  	 * @param {Renderer|WebGLRenderer} renderer - The renderer.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Material} material - The 3D object's material.
  	 * @param {Object} group - The geometry group data.
  	 */
  	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

  	/**
  	 * Applies the given transformation matrix to the object and updates the object's position,
  	 * rotation and scale.
  	 *
  	 * @param {Matrix4} matrix - The transformation matrix.
  	 */
  	applyMatrix4( matrix ) {

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		this.matrix.premultiply( matrix );

  		this.matrix.decompose( this.position, this.quaternion, this.scale );

  	}

  	/**
  	 * Applies a rotation represented by given the quaternion to the 3D object.
  	 *
  	 * @param {Quaternion} q - The quaternion.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	applyQuaternion( q ) {

  		this.quaternion.premultiply( q );

  		return this;

  	}

  	/**
  	 * Sets the given rotation represented as an axis/angle couple to the 3D object.
  	 *
  	 * @param {Vector3} axis - The (normalized) axis vector.
  	 * @param {number} angle - The angle in radians.
  	 */
  	setRotationFromAxisAngle( axis, angle ) {

  		// assumes axis is normalized

  		this.quaternion.setFromAxisAngle( axis, angle );

  	}

  	/**
  	 * Sets the given rotation represented as Euler angles to the 3D object.
  	 *
  	 * @param {Euler} euler - The Euler angles.
  	 */
  	setRotationFromEuler( euler ) {

  		this.quaternion.setFromEuler( euler, true );

  	}

  	/**
  	 * Sets the given rotation represented as rotation matrix to the 3D object.
  	 *
  	 * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
  	 * a pure rotation matrix (i.e, unscaled).
  	 */
  	setRotationFromMatrix( m ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		this.quaternion.setFromRotationMatrix( m );

  	}

  	/**
  	 * Sets the given rotation represented as a Quaternion to the 3D object.
  	 *
  	 * @param {Quaternion} q - The Quaternion
  	 */
  	setRotationFromQuaternion( q ) {

  		// assumes q is normalized

  		this.quaternion.copy( q );

  	}

  	/**
  	 * Rotates the 3D object along an axis in local space.
  	 *
  	 * @param {Vector3} axis - The (normalized) axis vector.
  	 * @param {number} angle - The angle in radians.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	rotateOnAxis( axis, angle ) {

  		// rotate object on axis in object space
  		// axis is assumed to be normalized

  		_q1.setFromAxisAngle( axis, angle );

  		this.quaternion.multiply( _q1 );

  		return this;

  	}

  	/**
  	 * Rotates the 3D object along an axis in world space.
  	 *
  	 * @param {Vector3} axis - The (normalized) axis vector.
  	 * @param {number} angle - The angle in radians.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	rotateOnWorldAxis( axis, angle ) {

  		// rotate object on axis in world space
  		// axis is assumed to be normalized
  		// method assumes no rotated parent

  		_q1.setFromAxisAngle( axis, angle );

  		this.quaternion.premultiply( _q1 );

  		return this;

  	}

  	/**
  	 * Rotates the 3D object around its X axis in local space.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	rotateX( angle ) {

  		return this.rotateOnAxis( _xAxis, angle );

  	}

  	/**
  	 * Rotates the 3D object around its Y axis in local space.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	rotateY( angle ) {

  		return this.rotateOnAxis( _yAxis, angle );

  	}

  	/**
  	 * Rotates the 3D object around its Z axis in local space.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	rotateZ( angle ) {

  		return this.rotateOnAxis( _zAxis, angle );

  	}

  	/**
  	 * Translate the 3D object by a distance along the given axis in local space.
  	 *
  	 * @param {Vector3} axis - The (normalized) axis vector.
  	 * @param {number} distance - The distance in world units.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	translateOnAxis( axis, distance ) {

  		// translate object by distance along axis in object space
  		// axis is assumed to be normalized

  		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

  		this.position.add( _v1$4.multiplyScalar( distance ) );

  		return this;

  	}

  	/**
  	 * Translate the 3D object by a distance along its X-axis in local space.
  	 *
  	 * @param {number} distance - The distance in world units.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	translateX( distance ) {

  		return this.translateOnAxis( _xAxis, distance );

  	}

  	/**
  	 * Translate the 3D object by a distance along its Y-axis in local space.
  	 *
  	 * @param {number} distance - The distance in world units.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	translateY( distance ) {

  		return this.translateOnAxis( _yAxis, distance );

  	}

  	/**
  	 * Translate the 3D object by a distance along its Z-axis in local space.
  	 *
  	 * @param {number} distance - The distance in world units.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	translateZ( distance ) {

  		return this.translateOnAxis( _zAxis, distance );

  	}

  	/**
  	 * Converts the given vector from this 3D object's local space to world space.
  	 *
  	 * @param {Vector3} vector - The vector to convert.
  	 * @return {Vector3} The converted vector.
  	 */
  	localToWorld( vector ) {

  		this.updateWorldMatrix( true, false );

  		return vector.applyMatrix4( this.matrixWorld );

  	}

  	/**
  	 * Converts the given vector from this 3D object's word space to local space.
  	 *
  	 * @param {Vector3} vector - The vector to convert.
  	 * @return {Vector3} The converted vector.
  	 */
  	worldToLocal( vector ) {

  		this.updateWorldMatrix( true, false );

  		return vector.applyMatrix4( _m1$1$1.copy( this.matrixWorld ).invert() );

  	}

  	/**
  	 * Rotates the object to face a point in world space.
  	 *
  	 * This method does not support objects having non-uniformly-scaled parent(s).
  	 *
  	 * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
  	 * @param {number} [y] - The y coordinate in world space.
  	 * @param {number} [z] - The z coordinate in world space.
  	 */
  	lookAt( x, y, z ) {

  		// This method does not support objects having non-uniformly-scaled parent(s)

  		if ( x.isVector3 ) {

  			_target.copy( x );

  		} else {

  			_target.set( x, y, z );

  		}

  		const parent = this.parent;

  		this.updateWorldMatrix( true, false );

  		_position$3.setFromMatrixPosition( this.matrixWorld );

  		if ( this.isCamera || this.isLight ) {

  			_m1$1$1.lookAt( _position$3, _target, this.up );

  		} else {

  			_m1$1$1.lookAt( _target, _position$3, this.up );

  		}

  		this.quaternion.setFromRotationMatrix( _m1$1$1 );

  		if ( parent ) {

  			_m1$1$1.extractRotation( parent.matrixWorld );
  			_q1.setFromRotationMatrix( _m1$1$1 );
  			this.quaternion.premultiply( _q1.invert() );

  		}

  	}

  	/**
  	 * Adds the given 3D object as a child to this 3D object. An arbitrary number of
  	 * objects may be added. Any current parent on an object passed in here will be
  	 * removed, since an object can have at most one parent.
  	 *
  	 * @fires Object3D#added
  	 * @fires Object3D#childadded
  	 * @param {Object3D} object - The 3D object to add.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	add( object ) {

  		if ( arguments.length > 1 ) {

  			for ( let i = 0; i < arguments.length; i ++ ) {

  				this.add( arguments[ i ] );

  			}

  			return this;

  		}

  		if ( object === this ) {

  			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
  			return this;

  		}

  		if ( object && object.isObject3D ) {

  			object.removeFromParent();
  			object.parent = this;
  			this.children.push( object );

  			object.dispatchEvent( _addedEvent );

  			_childaddedEvent.child = object;
  			this.dispatchEvent( _childaddedEvent );
  			_childaddedEvent.child = null;

  		} else {

  			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

  		}

  		return this;

  	}

  	/**
  	 * Removes the given 3D object as child from this 3D object.
  	 * An arbitrary number of objects may be removed.
  	 *
  	 * @fires Object3D#removed
  	 * @fires Object3D#childremoved
  	 * @param {Object3D} object - The 3D object to remove.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	remove( object ) {

  		if ( arguments.length > 1 ) {

  			for ( let i = 0; i < arguments.length; i ++ ) {

  				this.remove( arguments[ i ] );

  			}

  			return this;

  		}

  		const index = this.children.indexOf( object );

  		if ( index !== -1 ) {

  			object.parent = null;
  			this.children.splice( index, 1 );

  			object.dispatchEvent( _removedEvent );

  			_childremovedEvent.child = object;
  			this.dispatchEvent( _childremovedEvent );
  			_childremovedEvent.child = null;

  		}

  		return this;

  	}

  	/**
  	 * Removes this 3D object from its current parent.
  	 *
  	 * @fires Object3D#removed
  	 * @fires Object3D#childremoved
  	 * @return {Object3D} A reference to this instance.
  	 */
  	removeFromParent() {

  		const parent = this.parent;

  		if ( parent !== null ) {

  			parent.remove( this );

  		}

  		return this;

  	}

  	/**
  	 * Removes all child objects.
  	 *
  	 * @fires Object3D#removed
  	 * @fires Object3D#childremoved
  	 * @return {Object3D} A reference to this instance.
  	 */
  	clear() {

  		return this.remove( ... this.children );

  	}

  	/**
  	 * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
  	 * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
  	 *
  	 * @fires Object3D#added
  	 * @fires Object3D#childadded
  	 * @param {Object3D} object - The 3D object to attach.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	attach( object ) {

  		// adds object as a child of this, while maintaining the object's world transform

  		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

  		this.updateWorldMatrix( true, false );

  		_m1$1$1.copy( this.matrixWorld ).invert();

  		if ( object.parent !== null ) {

  			object.parent.updateWorldMatrix( true, false );

  			_m1$1$1.multiply( object.parent.matrixWorld );

  		}

  		object.applyMatrix4( _m1$1$1 );

  		object.removeFromParent();
  		object.parent = this;
  		this.children.push( object );

  		object.updateWorldMatrix( false, true );

  		object.dispatchEvent( _addedEvent );

  		_childaddedEvent.child = object;
  		this.dispatchEvent( _childaddedEvent );
  		_childaddedEvent.child = null;

  		return this;

  	}

  	/**
  	 * Searches through the 3D object and its children, starting with the 3D object
  	 * itself, and returns the first with a matching ID.
  	 *
  	 * @param {number} id - The id.
  	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
  	 */
  	getObjectById( id ) {

  		return this.getObjectByProperty( 'id', id );

  	}

  	/**
  	 * Searches through the 3D object and its children, starting with the 3D object
  	 * itself, and returns the first with a matching name.
  	 *
  	 * @param {string} name - The name.
  	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
  	 */
  	getObjectByName( name ) {

  		return this.getObjectByProperty( 'name', name );

  	}

  	/**
  	 * Searches through the 3D object and its children, starting with the 3D object
  	 * itself, and returns the first with a matching property value.
  	 *
  	 * @param {string} name - The name of the property.
  	 * @param {any} value - The value.
  	 * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
  	 */
  	getObjectByProperty( name, value ) {

  		if ( this[ name ] === value ) return this;

  		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

  			const child = this.children[ i ];
  			const object = child.getObjectByProperty( name, value );

  			if ( object !== undefined ) {

  				return object;

  			}

  		}

  		return undefined;

  	}

  	/**
  	 * Searches through the 3D object and its children, starting with the 3D object
  	 * itself, and returns all 3D objects with a matching property value.
  	 *
  	 * @param {string} name - The name of the property.
  	 * @param {any} value - The value.
  	 * @param {Array<Object3D>} result - The method stores the result in this array.
  	 * @return {Array<Object3D>} The found 3D objects.
  	 */
  	getObjectsByProperty( name, value, result = [] ) {

  		if ( this[ name ] === value ) result.push( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].getObjectsByProperty( name, value, result );

  		}

  		return result;

  	}

  	/**
  	 * Returns a vector representing the position of the 3D object in world space.
  	 *
  	 * @param {Vector3} target - The target vector the result is stored to.
  	 * @return {Vector3} The 3D object's position in world space.
  	 */
  	getWorldPosition( target ) {

  		this.updateWorldMatrix( true, false );

  		return target.setFromMatrixPosition( this.matrixWorld );

  	}

  	/**
  	 * Returns a Quaternion representing the position of the 3D object in world space.
  	 *
  	 * @param {Quaternion} target - The target Quaternion the result is stored to.
  	 * @return {Quaternion} The 3D object's rotation in world space.
  	 */
  	getWorldQuaternion( target ) {

  		this.updateWorldMatrix( true, false );

  		this.matrixWorld.decompose( _position$3, target, _scale$2 );

  		return target;

  	}

  	/**
  	 * Returns a vector representing the scale of the 3D object in world space.
  	 *
  	 * @param {Vector3} target - The target vector the result is stored to.
  	 * @return {Vector3} The 3D object's scale in world space.
  	 */
  	getWorldScale( target ) {

  		this.updateWorldMatrix( true, false );

  		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

  		return target;

  	}

  	/**
  	 * Returns a vector representing the ("look") direction of the 3D object in world space.
  	 *
  	 * @param {Vector3} target - The target vector the result is stored to.
  	 * @return {Vector3} The 3D object's direction in world space.
  	 */
  	getWorldDirection( target ) {

  		this.updateWorldMatrix( true, false );

  		const e = this.matrixWorld.elements;

  		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

  	}

  	/**
  	 * Abstract method to get intersections between a casted ray and this
  	 * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
  	 * implement this method in order to use raycasting.
  	 *
  	 * @abstract
  	 * @param {Raycaster} raycaster - The raycaster.
  	 * @param {Array<Object>} intersects - An array holding the result of the method.
  	 */
  	raycast( /* raycaster, intersects */ ) {}

  	/**
  	 * Executes the callback on this 3D object and all descendants.
  	 *
  	 * Note: Modifying the scene graph inside the callback is discouraged.
  	 *
  	 * @param {Function} callback - A callback function that allows to process the current 3D object.
  	 */
  	traverse( callback ) {

  		callback( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverse( callback );

  		}

  	}

  	/**
  	 * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
  	 * Descendants of invisible 3D objects are not traversed.
  	 *
  	 * Note: Modifying the scene graph inside the callback is discouraged.
  	 *
  	 * @param {Function} callback - A callback function that allows to process the current 3D object.
  	 */
  	traverseVisible( callback ) {

  		if ( this.visible === false ) return;

  		callback( this );

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverseVisible( callback );

  		}

  	}

  	/**
  	 * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
  	 *
  	 * Note: Modifying the scene graph inside the callback is discouraged.
  	 *
  	 * @param {Function} callback - A callback function that allows to process the current 3D object.
  	 */
  	traverseAncestors( callback ) {

  		const parent = this.parent;

  		if ( parent !== null ) {

  			callback( parent );

  			parent.traverseAncestors( callback );

  		}

  	}

  	/**
  	 * Updates the transformation matrix in local space by computing it from the current
  	 * position, rotation and scale values.
  	 */
  	updateMatrix() {

  		this.matrix.compose( this.position, this.quaternion, this.scale );

  		this.matrixWorldNeedsUpdate = true;

  	}

  	/**
  	 * Updates the transformation matrix in world space of this 3D objects and its descendants.
  	 *
  	 * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
  	 * local space. The computation of the local and world matrix can be controlled with the
  	 * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
  	 * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
  	 *
  	 * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
  	 * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
  	 */
  	updateMatrixWorld( force ) {

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		if ( this.matrixWorldNeedsUpdate || force ) {

  			if ( this.matrixWorldAutoUpdate === true ) {

  				if ( this.parent === null ) {

  					this.matrixWorld.copy( this.matrix );

  				} else {

  					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  				}

  			}

  			this.matrixWorldNeedsUpdate = false;

  			force = true;

  		}

  		// make sure descendants are updated if required

  		const children = this.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			const child = children[ i ];

  			child.updateMatrixWorld( force );

  		}

  	}

  	/**
  	 * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
  	 * update of ancestor and descendant nodes.
  	 *
  	 * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
  	 * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
  	 */
  	updateWorldMatrix( updateParents, updateChildren ) {

  		const parent = this.parent;

  		if ( updateParents === true && parent !== null ) {

  			parent.updateWorldMatrix( true, false );

  		}

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		if ( this.matrixWorldAutoUpdate === true ) {

  			if ( this.parent === null ) {

  				this.matrixWorld.copy( this.matrix );

  			} else {

  				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  			}

  		}

  		// make sure descendants are updated

  		if ( updateChildren === true ) {

  			const children = this.children;

  			for ( let i = 0, l = children.length; i < l; i ++ ) {

  				const child = children[ i ];

  				child.updateWorldMatrix( false, true );

  			}

  		}

  	}

  	/**
  	 * Serializes the 3D object into JSON.
  	 *
  	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized 3D object.
  	 * @see {@link ObjectLoader#parse}
  	 */
  	toJSON( meta ) {

  		// meta is a string when called from JSON.stringify
  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		const output = {};

  		// meta is a hash used to collect geometries, materials.
  		// not providing it implies that this is the root object
  		// being serialized.
  		if ( isRootObject ) {

  			// initialize meta obj
  			meta = {
  				geometries: {},
  				materials: {},
  				textures: {},
  				images: {},
  				shapes: {},
  				skeletons: {},
  				animations: {},
  				nodes: {}
  			};

  			output.metadata = {
  				version: 4.7,
  				type: 'Object',
  				generator: 'Object3D.toJSON'
  			};

  		}

  		// standard Object3D serialization

  		const object = {};

  		object.uuid = this.uuid;
  		object.type = this.type;

  		if ( this.name !== '' ) object.name = this.name;
  		if ( this.castShadow === true ) object.castShadow = true;
  		if ( this.receiveShadow === true ) object.receiveShadow = true;
  		if ( this.visible === false ) object.visible = false;
  		if ( this.frustumCulled === false ) object.frustumCulled = false;
  		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
  		if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

  		object.layers = this.layers.mask;
  		object.matrix = this.matrix.toArray();
  		object.up = this.up.toArray();

  		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

  		// object specific properties

  		if ( this.isInstancedMesh ) {

  			object.type = 'InstancedMesh';
  			object.count = this.count;
  			object.instanceMatrix = this.instanceMatrix.toJSON();
  			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

  		}

  		if ( this.isBatchedMesh ) {

  			object.type = 'BatchedMesh';
  			object.perObjectFrustumCulled = this.perObjectFrustumCulled;
  			object.sortObjects = this.sortObjects;

  			object.drawRanges = this._drawRanges;
  			object.reservedRanges = this._reservedRanges;

  			object.geometryInfo = this._geometryInfo.map( info => ( {
  				...info,
  				boundingBox: info.boundingBox ? info.boundingBox.toJSON() : undefined,
  				boundingSphere: info.boundingSphere ? info.boundingSphere.toJSON() : undefined
  			} ) );
  			object.instanceInfo = this._instanceInfo.map( info => ( { ...info } ) );

  			object.availableInstanceIds = this._availableInstanceIds.slice();
  			object.availableGeometryIds = this._availableGeometryIds.slice();

  			object.nextIndexStart = this._nextIndexStart;
  			object.nextVertexStart = this._nextVertexStart;
  			object.geometryCount = this._geometryCount;

  			object.maxInstanceCount = this._maxInstanceCount;
  			object.maxVertexCount = this._maxVertexCount;
  			object.maxIndexCount = this._maxIndexCount;

  			object.geometryInitialized = this._geometryInitialized;

  			object.matricesTexture = this._matricesTexture.toJSON( meta );

  			object.indirectTexture = this._indirectTexture.toJSON( meta );

  			if ( this._colorsTexture !== null ) {

  				object.colorsTexture = this._colorsTexture.toJSON( meta );

  			}

  			if ( this.boundingSphere !== null ) {

  				object.boundingSphere = this.boundingSphere.toJSON();

  			}

  			if ( this.boundingBox !== null ) {

  				object.boundingBox = this.boundingBox.toJSON();

  			}

  		}

  		//

  		function serialize( library, element ) {

  			if ( library[ element.uuid ] === undefined ) {

  				library[ element.uuid ] = element.toJSON( meta );

  			}

  			return element.uuid;

  		}

  		if ( this.isScene ) {

  			if ( this.background ) {

  				if ( this.background.isColor ) {

  					object.background = this.background.toJSON();

  				} else if ( this.background.isTexture ) {

  					object.background = this.background.toJSON( meta ).uuid;

  				}

  			}

  			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

  				object.environment = this.environment.toJSON( meta ).uuid;

  			}

  		} else if ( this.isMesh || this.isLine || this.isPoints ) {

  			object.geometry = serialize( meta.geometries, this.geometry );

  			const parameters = this.geometry.parameters;

  			if ( parameters !== undefined && parameters.shapes !== undefined ) {

  				const shapes = parameters.shapes;

  				if ( Array.isArray( shapes ) ) {

  					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

  						const shape = shapes[ i ];

  						serialize( meta.shapes, shape );

  					}

  				} else {

  					serialize( meta.shapes, shapes );

  				}

  			}

  		}

  		if ( this.isSkinnedMesh ) {

  			object.bindMode = this.bindMode;
  			object.bindMatrix = this.bindMatrix.toArray();

  			if ( this.skeleton !== undefined ) {

  				serialize( meta.skeletons, this.skeleton );

  				object.skeleton = this.skeleton.uuid;

  			}

  		}

  		if ( this.material !== undefined ) {

  			if ( Array.isArray( this.material ) ) {

  				const uuids = [];

  				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

  					uuids.push( serialize( meta.materials, this.material[ i ] ) );

  				}

  				object.material = uuids;

  			} else {

  				object.material = serialize( meta.materials, this.material );

  			}

  		}

  		//

  		if ( this.children.length > 0 ) {

  			object.children = [];

  			for ( let i = 0; i < this.children.length; i ++ ) {

  				object.children.push( this.children[ i ].toJSON( meta ).object );

  			}

  		}

  		//

  		if ( this.animations.length > 0 ) {

  			object.animations = [];

  			for ( let i = 0; i < this.animations.length; i ++ ) {

  				const animation = this.animations[ i ];

  				object.animations.push( serialize( meta.animations, animation ) );

  			}

  		}

  		if ( isRootObject ) {

  			const geometries = extractFromCache( meta.geometries );
  			const materials = extractFromCache( meta.materials );
  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );
  			const shapes = extractFromCache( meta.shapes );
  			const skeletons = extractFromCache( meta.skeletons );
  			const animations = extractFromCache( meta.animations );
  			const nodes = extractFromCache( meta.nodes );

  			if ( geometries.length > 0 ) output.geometries = geometries;
  			if ( materials.length > 0 ) output.materials = materials;
  			if ( textures.length > 0 ) output.textures = textures;
  			if ( images.length > 0 ) output.images = images;
  			if ( shapes.length > 0 ) output.shapes = shapes;
  			if ( skeletons.length > 0 ) output.skeletons = skeletons;
  			if ( animations.length > 0 ) output.animations = animations;
  			if ( nodes.length > 0 ) output.nodes = nodes;

  		}

  		output.object = object;

  		return output;

  		// extract data from the cache hash
  		// remove metadata on each item
  		// and return as array
  		function extractFromCache( cache ) {

  			const values = [];
  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  	}

  	/**
  	 * Returns a new 3D object with copied values from this instance.
  	 *
  	 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
  	 * @return {Object3D} A clone of this instance.
  	 */
  	clone( recursive ) {

  		return new this.constructor().copy( this, recursive );

  	}

  	/**
  	 * Copies the values of the given 3D object to this instance.
  	 *
  	 * @param {Object3D} source - The 3D object to copy.
  	 * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
  	 * @return {Object3D} A reference to this instance.
  	 */
  	copy( source, recursive = true ) {

  		this.name = source.name;

  		this.up.copy( source.up );

  		this.position.copy( source.position );
  		this.rotation.order = source.rotation.order;
  		this.quaternion.copy( source.quaternion );
  		this.scale.copy( source.scale );

  		this.matrix.copy( source.matrix );
  		this.matrixWorld.copy( source.matrixWorld );

  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
  		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

  		this.layers.mask = source.layers.mask;
  		this.visible = source.visible;

  		this.castShadow = source.castShadow;
  		this.receiveShadow = source.receiveShadow;

  		this.frustumCulled = source.frustumCulled;
  		this.renderOrder = source.renderOrder;

  		this.animations = source.animations.slice();

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		if ( recursive === true ) {

  			for ( let i = 0; i < source.children.length; i ++ ) {

  				const child = source.children[ i ];
  				this.add( child.clone() );

  			}

  		}

  		return this;

  	}

  }

  /**
   * The default up direction for objects, also used as the default
   * position for {@link DirectionalLight} and {@link HemisphereLight}.
   *
   * @static
   * @type {Vector3}
   * @default (0,1,0)
   */
  Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );

  /**
   * The default setting for {@link Object3D#matrixAutoUpdate} for
   * newly created 3D objects.
   *
   * @static
   * @type {boolean}
   * @default true
   */
  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;

  /**
   * The default setting for {@link Object3D#matrixWorldAutoUpdate} for
   * newly created 3D objects.
   *
   * @static
   * @type {boolean}
   * @default true
   */
  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

  const _v0$1 = /*@__PURE__*/ new Vector3();
  const _v1$3 = /*@__PURE__*/ new Vector3();
  const _v2$2 = /*@__PURE__*/ new Vector3();
  const _v3$2 = /*@__PURE__*/ new Vector3();

  const _vab = /*@__PURE__*/ new Vector3();
  const _vac = /*@__PURE__*/ new Vector3();
  const _vbc = /*@__PURE__*/ new Vector3();
  const _vap = /*@__PURE__*/ new Vector3();
  const _vbp = /*@__PURE__*/ new Vector3();
  const _vcp = /*@__PURE__*/ new Vector3();

  const _v40 = /*@__PURE__*/ new Vector4();
  const _v41 = /*@__PURE__*/ new Vector4();
  const _v42 = /*@__PURE__*/ new Vector4();

  /**
   * A geometric triangle as defined by three vectors representing its three corners.
   */
  class Triangle {

  	/**
  	 * Constructs a new triangle.
  	 *
  	 * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
  	 * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
  	 * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
  	 */
  	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

  		/**
  		 * The first corner of the triangle.
  		 *
  		 * @type {Vector3}
  		 */
  		this.a = a;

  		/**
  		 * The second corner of the triangle.
  		 *
  		 * @type {Vector3}
  		 */
  		this.b = b;

  		/**
  		 * The third corner of the triangle.
  		 *
  		 * @type {Vector3}
  		 */
  		this.c = c;

  	}

  	/**
  	 * Computes the normal vector of a triangle.
  	 *
  	 * @param {Vector3} a - The first corner of the triangle.
  	 * @param {Vector3} b - The second corner of the triangle.
  	 * @param {Vector3} c - The third corner of the triangle.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The triangle's normal.
  	 */
  	static getNormal( a, b, c, target ) {

  		target.subVectors( c, b );
  		_v0$1.subVectors( a, b );
  		target.cross( _v0$1 );

  		const targetLengthSq = target.lengthSq();
  		if ( targetLengthSq > 0 ) {

  			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

  		}

  		return target.set( 0, 0, 0 );

  	}

  	/**
  	 * Computes a barycentric coordinates from the given vector.
  	 * Returns `null` if the triangle is degenerate.
  	 *
  	 * @param {Vector3} point - A point in 3D space.
  	 * @param {Vector3} a - The first corner of the triangle.
  	 * @param {Vector3} b - The second corner of the triangle.
  	 * @param {Vector3} c - The third corner of the triangle.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The barycentric coordinates for the given point
  	 */
  	static getBarycoord( point, a, b, c, target ) {

  		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html

  		_v0$1.subVectors( c, a );
  		_v1$3.subVectors( b, a );
  		_v2$2.subVectors( point, a );

  		const dot00 = _v0$1.dot( _v0$1 );
  		const dot01 = _v0$1.dot( _v1$3 );
  		const dot02 = _v0$1.dot( _v2$2 );
  		const dot11 = _v1$3.dot( _v1$3 );
  		const dot12 = _v1$3.dot( _v2$2 );

  		const denom = ( dot00 * dot11 - dot01 * dot01 );

  		// collinear or singular triangle
  		if ( denom === 0 ) {

  			target.set( 0, 0, 0 );
  			return null;

  		}

  		const invDenom = 1 / denom;
  		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
  		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

  		// barycentric coordinates must always sum to 1
  		return target.set( 1 - u - v, v, u );

  	}

  	/**
  	 * Returns `true` if the given point, when projected onto the plane of the
  	 * triangle, lies within the triangle.
  	 *
  	 * @param {Vector3} point - The point in 3D space to test.
  	 * @param {Vector3} a - The first corner of the triangle.
  	 * @param {Vector3} b - The second corner of the triangle.
  	 * @param {Vector3} c - The third corner of the triangle.
  	 * @return {boolean} Whether the given point, when projected onto the plane of the
  	 * triangle, lies within the triangle or not.
  	 */
  	static containsPoint( point, a, b, c ) {

  		// if the triangle is degenerate then we can't contain a point
  		if ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {

  			return false;

  		}

  		return ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );

  	}

  	/**
  	 * Computes the value barycentrically interpolated for the given point on the
  	 * triangle. Returns `null` if the triangle is degenerate.
  	 *
  	 * @param {Vector3} point - Position of interpolated point.
  	 * @param {Vector3} p1 - The first corner of the triangle.
  	 * @param {Vector3} p2 - The second corner of the triangle.
  	 * @param {Vector3} p3 - The third corner of the triangle.
  	 * @param {Vector3} v1 - Value to interpolate of first vertex.
  	 * @param {Vector3} v2 - Value to interpolate of second vertex.
  	 * @param {Vector3} v3 - Value to interpolate of third vertex.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The interpolated value.
  	 */
  	static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

  		if ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {

  			target.x = 0;
  			target.y = 0;
  			if ( 'z' in target ) target.z = 0;
  			if ( 'w' in target ) target.w = 0;
  			return null;

  		}

  		target.setScalar( 0 );
  		target.addScaledVector( v1, _v3$2.x );
  		target.addScaledVector( v2, _v3$2.y );
  		target.addScaledVector( v3, _v3$2.z );

  		return target;

  	}

  	/**
  	 * Computes the value barycentrically interpolated for the given attribute and indices.
  	 *
  	 * @param {BufferAttribute} attr - The attribute to interpolate.
  	 * @param {number} i1 - Index of first vertex.
  	 * @param {number} i2 - Index of second vertex.
  	 * @param {number} i3 - Index of third vertex.
  	 * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The interpolated attribute value.
  	 */
  	static getInterpolatedAttribute( attr, i1, i2, i3, barycoord, target ) {

  		_v40.setScalar( 0 );
  		_v41.setScalar( 0 );
  		_v42.setScalar( 0 );

  		_v40.fromBufferAttribute( attr, i1 );
  		_v41.fromBufferAttribute( attr, i2 );
  		_v42.fromBufferAttribute( attr, i3 );

  		target.setScalar( 0 );
  		target.addScaledVector( _v40, barycoord.x );
  		target.addScaledVector( _v41, barycoord.y );
  		target.addScaledVector( _v42, barycoord.z );

  		return target;

  	}

  	/**
  	 * Returns `true` if the triangle is oriented towards the given direction.
  	 *
  	 * @param {Vector3} a - The first corner of the triangle.
  	 * @param {Vector3} b - The second corner of the triangle.
  	 * @param {Vector3} c - The third corner of the triangle.
  	 * @param {Vector3} direction - The (normalized) direction vector.
  	 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
  	 */
  	static isFrontFacing( a, b, c, direction ) {

  		_v0$1.subVectors( c, b );
  		_v1$3.subVectors( a, b );

  		// strictly front facing
  		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

  	}

  	/**
  	 * Sets the triangle's vertices by copying the given values.
  	 *
  	 * @param {Vector3} a - The first corner of the triangle.
  	 * @param {Vector3} b - The second corner of the triangle.
  	 * @param {Vector3} c - The third corner of the triangle.
  	 * @return {Triangle} A reference to this triangle.
  	 */
  	set( a, b, c ) {

  		this.a.copy( a );
  		this.b.copy( b );
  		this.c.copy( c );

  		return this;

  	}

  	/**
  	 * Sets the triangle's vertices by copying the given array values.
  	 *
  	 * @param {Array<Vector3>} points - An array with 3D points.
  	 * @param {number} i0 - The array index representing the first corner of the triangle.
  	 * @param {number} i1 - The array index representing the second corner of the triangle.
  	 * @param {number} i2 - The array index representing the third corner of the triangle.
  	 * @return {Triangle} A reference to this triangle.
  	 */
  	setFromPointsAndIndices( points, i0, i1, i2 ) {

  		this.a.copy( points[ i0 ] );
  		this.b.copy( points[ i1 ] );
  		this.c.copy( points[ i2 ] );

  		return this;

  	}

  	/**
  	 * Sets the triangle's vertices by copying the given attribute values.
  	 *
  	 * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
  	 * @param {number} i0 - The attribute index representing the first corner of the triangle.
  	 * @param {number} i1 - The attribute index representing the second corner of the triangle.
  	 * @param {number} i2 - The attribute index representing the third corner of the triangle.
  	 * @return {Triangle} A reference to this triangle.
  	 */
  	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

  		this.a.fromBufferAttribute( attribute, i0 );
  		this.b.fromBufferAttribute( attribute, i1 );
  		this.c.fromBufferAttribute( attribute, i2 );

  		return this;

  	}

  	/**
  	 * Returns a new triangle with copied values from this instance.
  	 *
  	 * @return {Triangle} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the values of the given triangle to this instance.
  	 *
  	 * @param {Triangle} triangle - The triangle to copy.
  	 * @return {Triangle} A reference to this triangle.
  	 */
  	copy( triangle ) {

  		this.a.copy( triangle.a );
  		this.b.copy( triangle.b );
  		this.c.copy( triangle.c );

  		return this;

  	}

  	/**
  	 * Computes the area of the triangle.
  	 *
  	 * @return {number} The triangle's area.
  	 */
  	getArea() {

  		_v0$1.subVectors( this.c, this.b );
  		_v1$3.subVectors( this.a, this.b );

  		return _v0$1.cross( _v1$3 ).length() * 0.5;

  	}

  	/**
  	 * Computes the midpoint of the triangle.
  	 *
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The triangle's midpoint.
  	 */
  	getMidpoint( target ) {

  		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  	}

  	/**
  	 * Computes the normal of the triangle.
  	 *
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The triangle's normal.
  	 */
  	getNormal( target ) {

  		return Triangle.getNormal( this.a, this.b, this.c, target );

  	}

  	/**
  	 * Computes a plane the triangle lies within.
  	 *
  	 * @param {Plane} target - The target vector that is used to store the method's result.
  	 * @return {Plane} The plane the triangle lies within.
  	 */
  	getPlane( target ) {

  		return target.setFromCoplanarPoints( this.a, this.b, this.c );

  	}

  	/**
  	 * Computes a barycentric coordinates from the given vector.
  	 * Returns `null` if the triangle is degenerate.
  	 *
  	 * @param {Vector3} point - A point in 3D space.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The barycentric coordinates for the given point
  	 */
  	getBarycoord( point, target ) {

  		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

  	}

  	/**
  	 * Computes the value barycentrically interpolated for the given point on the
  	 * triangle. Returns `null` if the triangle is degenerate.
  	 *
  	 * @param {Vector3} point - Position of interpolated point.
  	 * @param {Vector3} v1 - Value to interpolate of first vertex.
  	 * @param {Vector3} v2 - Value to interpolate of second vertex.
  	 * @param {Vector3} v3 - Value to interpolate of third vertex.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The interpolated value.
  	 */
  	getInterpolation( point, v1, v2, v3, target ) {

  		return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

  	}

  	/**
  	 * Returns `true` if the given point, when projected onto the plane of the
  	 * triangle, lies within the triangle.
  	 *
  	 * @param {Vector3} point - The point in 3D space to test.
  	 * @return {boolean} Whether the given point, when projected onto the plane of the
  	 * triangle, lies within the triangle or not.
  	 */
  	containsPoint( point ) {

  		return Triangle.containsPoint( point, this.a, this.b, this.c );

  	}

  	/**
  	 * Returns `true` if the triangle is oriented towards the given direction.
  	 *
  	 * @param {Vector3} direction - The (normalized) direction vector.
  	 * @return {boolean} Whether the triangle is oriented towards the given direction or not.
  	 */
  	isFrontFacing( direction ) {

  		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

  	}

  	/**
  	 * Returns `true` if this triangle intersects with the given box.
  	 *
  	 * @param {Box3} box - The box to intersect.
  	 * @return {boolean} Whether this triangle intersects with the given box or not.
  	 */
  	intersectsBox( box ) {

  		return box.intersectsTriangle( this );

  	}

  	/**
  	 * Returns the closest point on the triangle to the given point.
  	 *
  	 * @param {Vector3} p - The point to compute the closest point for.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The closest point on the triangle.
  	 */
  	closestPointToPoint( p, target ) {

  		const a = this.a, b = this.b, c = this.c;
  		let v, w;

  		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
  		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
  		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
  		// basically, we're distinguishing which of the voronoi regions of the triangle
  		// the point lies in with the minimum amount of redundant computation.

  		_vab.subVectors( b, a );
  		_vac.subVectors( c, a );
  		_vap.subVectors( p, a );
  		const d1 = _vab.dot( _vap );
  		const d2 = _vac.dot( _vap );
  		if ( d1 <= 0 && d2 <= 0 ) {

  			// vertex region of A; barycentric coords (1, 0, 0)
  			return target.copy( a );

  		}

  		_vbp.subVectors( p, b );
  		const d3 = _vab.dot( _vbp );
  		const d4 = _vac.dot( _vbp );
  		if ( d3 >= 0 && d4 <= d3 ) {

  			// vertex region of B; barycentric coords (0, 1, 0)
  			return target.copy( b );

  		}

  		const vc = d1 * d4 - d3 * d2;
  		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

  			v = d1 / ( d1 - d3 );
  			// edge region of AB; barycentric coords (1-v, v, 0)
  			return target.copy( a ).addScaledVector( _vab, v );

  		}

  		_vcp.subVectors( p, c );
  		const d5 = _vab.dot( _vcp );
  		const d6 = _vac.dot( _vcp );
  		if ( d6 >= 0 && d5 <= d6 ) {

  			// vertex region of C; barycentric coords (0, 0, 1)
  			return target.copy( c );

  		}

  		const vb = d5 * d2 - d1 * d6;
  		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

  			w = d2 / ( d2 - d6 );
  			// edge region of AC; barycentric coords (1-w, 0, w)
  			return target.copy( a ).addScaledVector( _vac, w );

  		}

  		const va = d3 * d6 - d5 * d4;
  		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

  			_vbc.subVectors( c, b );
  			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
  			// edge region of BC; barycentric coords (0, 1-w, w)
  			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

  		}

  		// face region
  		const denom = 1 / ( va + vb + vc );
  		// u = va * denom
  		v = vb * denom;
  		w = vc * denom;

  		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

  	}

  	/**
  	 * Returns `true` if this triangle is equal with the given one.
  	 *
  	 * @param {Triangle} triangle - The triangle to test for equality.
  	 * @return {boolean} Whether this triangle is equal with the given one.
  	 */
  	equals( triangle ) {

  		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  	}

  }

  const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
  	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
  	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
  	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
  	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
  	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
  	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
  	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
  	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
  	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
  	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
  	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
  	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
  	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
  	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
  	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
  	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
  	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
  	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
  	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
  	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
  	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
  	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
  	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

  const _hslA = { h: 0, s: 0, l: 0 };
  const _hslB = { h: 0, s: 0, l: 0 };

  function hue2rgb( p, q, t ) {

  	if ( t < 0 ) t += 1;
  	if ( t > 1 ) t -= 1;
  	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
  	if ( t < 1 / 2 ) return q;
  	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
  	return p;

  }

  /**
   * A Color instance is represented by RGB components in the linear <i>working
   * color space</i>, which defaults to `LinearSRGBColorSpace`. Inputs
   * conventionally using `SRGBColorSpace` (such as hexadecimals and CSS
   * strings) are converted to the working color space automatically.
   *
   * ```js
   * // converted automatically from SRGBColorSpace to LinearSRGBColorSpace
   * const color = new THREE.Color().setHex( 0x112233 );
   * ```
   * Source color spaces may be specified explicitly, to ensure correct conversions.
   * ```js
   * // assumed already LinearSRGBColorSpace; no conversion
   * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5 );
   *
   * // converted explicitly from SRGBColorSpace to LinearSRGBColorSpace
   * const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5, SRGBColorSpace );
   * ```
   * If THREE.ColorManagement is disabled, no conversions occur. For details,
   * see <i>Color management</i>. Iterating through a Color instance will yield
   * its components (r, g, b) in the corresponding order. A Color can be initialised
   * in any of the following ways:
   * ```js
   * //empty constructor - will default white
   * const color1 = new THREE.Color();
   *
   * //Hexadecimal color (recommended)
   * const color2 = new THREE.Color( 0xff0000 );
   *
   * //RGB string
   * const color3 = new THREE.Color("rgb(255, 0, 0)");
   * const color4 = new THREE.Color("rgb(100%, 0%, 0%)");
   *
   * //X11 color name - all 140 color names are supported.
   * //Note the lack of CamelCase in the name
   * const color5 = new THREE.Color( 'skyblue' );
   * //HSL string
   * const color6 = new THREE.Color("hsl(0, 100%, 50%)");
   *
   * //Separate RGB values between 0 and 1
   * const color7 = new THREE.Color( 1, 0, 0 );
   * ```
   */
  class Color {

  	/**
  	 * Constructs a new color.
  	 *
  	 * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
  	 * and that method is used throughout the rest of the documentation.
  	 *
  	 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
  	 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
  	 * @param {number} [g] - The green component.
  	 * @param {number} [b] - The blue component.
  	 */
  	constructor( r, g, b ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isColor = true;

  		/**
  		 * The red component.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.r = 1;

  		/**
  		 * The green component.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.g = 1;

  		/**
  		 * The blue component.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.b = 1;

  		return this.set( r, g, b );

  	}

  	/**
  	 * Sets the colors's components from the given values.
  	 *
  	 * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
  	 * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
  	 * @param {number} [g] - The green component.
  	 * @param {number} [b] - The blue component.
  	 * @return {Color} A reference to this color.
  	 */
  	set( r, g, b ) {

  		if ( g === undefined && b === undefined ) {

  			// r is THREE.Color, hex or string

  			const value = r;

  			if ( value && value.isColor ) {

  				this.copy( value );

  			} else if ( typeof value === 'number' ) {

  				this.setHex( value );

  			} else if ( typeof value === 'string' ) {

  				this.setStyle( value );

  			}

  		} else {

  			this.setRGB( r, g, b );

  		}

  		return this;

  	}

  	/**
  	 * Sets the colors's components to the given scalar value.
  	 *
  	 * @param {number} scalar - The scalar value.
  	 * @return {Color} A reference to this color.
  	 */
  	setScalar( scalar ) {

  		this.r = scalar;
  		this.g = scalar;
  		this.b = scalar;

  		return this;

  	}

  	/**
  	 * Sets this color from a hexadecimal value.
  	 *
  	 * @param {number} hex - The hexadecimal value.
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {Color} A reference to this color.
  	 */
  	setHex( hex, colorSpace = SRGBColorSpace ) {

  		hex = Math.floor( hex );

  		this.r = ( hex >> 16 & 255 ) / 255;
  		this.g = ( hex >> 8 & 255 ) / 255;
  		this.b = ( hex & 255 ) / 255;

  		ColorManagement.colorSpaceToWorking( this, colorSpace );

  		return this;

  	}

  	/**
  	 * Sets this color from RGB values.
  	 *
  	 * @param {number} r - Red channel value between `0.0` and `1.0`.
  	 * @param {number} g - Green channel value between `0.0` and `1.0`.
  	 * @param {number} b - Blue channel value between `0.0` and `1.0`.
  	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
  	 * @return {Color} A reference to this color.
  	 */
  	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

  		this.r = r;
  		this.g = g;
  		this.b = b;

  		ColorManagement.colorSpaceToWorking( this, colorSpace );

  		return this;

  	}

  	/**
  	 * Sets this color from RGB values.
  	 *
  	 * @param {number} h - Hue value between `0.0` and `1.0`.
  	 * @param {number} s - Saturation value between `0.0` and `1.0`.
  	 * @param {number} l - Lightness value between `0.0` and `1.0`.
  	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
  	 * @return {Color} A reference to this color.
  	 */
  	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

  		// h,s,l ranges are in 0.0 - 1.0
  		h = euclideanModulo( h, 1 );
  		s = clamp( s, 0, 1 );
  		l = clamp( l, 0, 1 );

  		if ( s === 0 ) {

  			this.r = this.g = this.b = l;

  		} else {

  			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
  			const q = ( 2 * l ) - p;

  			this.r = hue2rgb( q, p, h + 1 / 3 );
  			this.g = hue2rgb( q, p, h );
  			this.b = hue2rgb( q, p, h - 1 / 3 );

  		}

  		ColorManagement.colorSpaceToWorking( this, colorSpace );

  		return this;

  	}

  	/**
  	 * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
  	 * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
  	 * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
  	 * all 140 color names are supported).
  	 *
  	 * @param {string} style - Color as a CSS-style string.
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {Color} A reference to this color.
  	 */
  	setStyle( style, colorSpace = SRGBColorSpace ) {

  		function handleAlpha( string ) {

  			if ( string === undefined ) return;

  			if ( parseFloat( string ) < 1 ) {

  				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

  			}

  		}


  		let m;

  		if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

  			// rgb / hsl

  			let color;
  			const name = m[ 1 ];
  			const components = m[ 2 ];

  			switch ( name ) {

  				case 'rgb':
  				case 'rgba':

  					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// rgb(255,0,0) rgba(255,0,0,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setRGB(
  							Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
  							Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
  							Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
  							colorSpace
  						);

  					}

  					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setRGB(
  							Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
  							Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
  							Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
  							colorSpace
  						);

  					}

  					break;

  				case 'hsl':
  				case 'hsla':

  					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

  						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

  						handleAlpha( color[ 4 ] );

  						return this.setHSL(
  							parseFloat( color[ 1 ] ) / 360,
  							parseFloat( color[ 2 ] ) / 100,
  							parseFloat( color[ 3 ] ) / 100,
  							colorSpace
  						);

  					}

  					break;

  				default:

  					console.warn( 'THREE.Color: Unknown color model ' + style );

  			}

  		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

  			// hex color

  			const hex = m[ 1 ];
  			const size = hex.length;

  			if ( size === 3 ) {

  				// #ff0
  				return this.setRGB(
  					parseInt( hex.charAt( 0 ), 16 ) / 15,
  					parseInt( hex.charAt( 1 ), 16 ) / 15,
  					parseInt( hex.charAt( 2 ), 16 ) / 15,
  					colorSpace
  				);

  			} else if ( size === 6 ) {

  				// #ff0000
  				return this.setHex( parseInt( hex, 16 ), colorSpace );

  			} else {

  				console.warn( 'THREE.Color: Invalid hex color ' + style );

  			}

  		} else if ( style && style.length > 0 ) {

  			return this.setColorName( style, colorSpace );

  		}

  		return this;

  	}

  	/**
  	 * Sets this color from a color name. Faster than {@link Color#setStyle} if
  	 * you don't need the other CSS-style formats.
  	 *
  	 * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
  	 * ```js
  	 * Color.NAMES.aliceblue // returns 0xF0F8FF
  	 * ```
  	 *
  	 * @param {string} style - The color name.
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {Color} A reference to this color.
  	 */
  	setColorName( style, colorSpace = SRGBColorSpace ) {

  		// color keywords
  		const hex = _colorKeywords[ style.toLowerCase() ];

  		if ( hex !== undefined ) {

  			// red
  			this.setHex( hex, colorSpace );

  		} else {

  			// unknown color
  			console.warn( 'THREE.Color: Unknown color ' + style );

  		}

  		return this;

  	}

  	/**
  	 * Returns a new color with copied values from this instance.
  	 *
  	 * @return {Color} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this.r, this.g, this.b );

  	}

  	/**
  	 * Copies the values of the given color to this instance.
  	 *
  	 * @param {Color} color - The color to copy.
  	 * @return {Color} A reference to this color.
  	 */
  	copy( color ) {

  		this.r = color.r;
  		this.g = color.g;
  		this.b = color.b;

  		return this;

  	}

  	/**
  	 * Copies the given color into this color, and then converts this color from
  	 * `SRGBColorSpace` to `LinearSRGBColorSpace`.
  	 *
  	 * @param {Color} color - The color to copy/convert.
  	 * @return {Color} A reference to this color.
  	 */
  	copySRGBToLinear( color ) {

  		this.r = SRGBToLinear( color.r );
  		this.g = SRGBToLinear( color.g );
  		this.b = SRGBToLinear( color.b );

  		return this;

  	}

  	/**
  	 * Copies the given color into this color, and then converts this color from
  	 * `LinearSRGBColorSpace` to `SRGBColorSpace`.
  	 *
  	 * @param {Color} color - The color to copy/convert.
  	 * @return {Color} A reference to this color.
  	 */
  	copyLinearToSRGB( color ) {

  		this.r = LinearToSRGB( color.r );
  		this.g = LinearToSRGB( color.g );
  		this.b = LinearToSRGB( color.b );

  		return this;

  	}

  	/**
  	 * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
  	 *
  	 * @return {Color} A reference to this color.
  	 */
  	convertSRGBToLinear() {

  		this.copySRGBToLinear( this );

  		return this;

  	}

  	/**
  	 * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
  	 *
  	 * @return {Color} A reference to this color.
  	 */
  	convertLinearToSRGB() {

  		this.copyLinearToSRGB( this );

  		return this;

  	}

  	/**
  	 * Returns the hexadecimal value of this color.
  	 *
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {number} The hexadecimal value.
  	 */
  	getHex( colorSpace = SRGBColorSpace ) {

  		ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

  		return Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );

  	}

  	/**
  	 * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
  	 *
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {string} The hexadecimal value as a string.
  	 */
  	getHexString( colorSpace = SRGBColorSpace ) {

  		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( -6 );

  	}

  	/**
  	 * Converts the colors RGB values into the HSL format and stores them into the
  	 * given target object.
  	 *
  	 * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
  	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
  	 * @return {{h:number,s:number,l:number}} The HSL representation of this color.
  	 */
  	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

  		// h,s,l ranges are in 0.0 - 1.0

  		ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

  		const r = _color.r, g = _color.g, b = _color.b;

  		const max = Math.max( r, g, b );
  		const min = Math.min( r, g, b );

  		let hue, saturation;
  		const lightness = ( min + max ) / 2.0;

  		if ( min === max ) {

  			hue = 0;
  			saturation = 0;

  		} else {

  			const delta = max - min;

  			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

  			switch ( max ) {

  				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
  				case g: hue = ( b - r ) / delta + 2; break;
  				case b: hue = ( r - g ) / delta + 4; break;

  			}

  			hue /= 6;

  		}

  		target.h = hue;
  		target.s = saturation;
  		target.l = lightness;

  		return target;

  	}

  	/**
  	 * Returns the RGB values of this color and stores them into the given target object.
  	 *
  	 * @param {Color} target - The target color that is used to store the method's result.
  	 * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
  	 * @return {Color} The RGB representation of this color.
  	 */
  	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

  		ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

  		target.r = _color.r;
  		target.g = _color.g;
  		target.b = _color.b;

  		return target;

  	}

  	/**
  	 * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
  	 *
  	 * @param {string} [colorSpace=SRGBColorSpace] - The color space.
  	 * @return {string} The CSS representation of this color.
  	 */
  	getStyle( colorSpace = SRGBColorSpace ) {

  		ColorManagement.workingToColorSpace( _color.copy( this ), colorSpace );

  		const r = _color.r, g = _color.g, b = _color.b;

  		if ( colorSpace !== SRGBColorSpace ) {

  			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
  			return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

  		}

  		return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

  	}

  	/**
  	 * Adds the given HSL values to this color's values.
  	 * Internally, this converts the color's RGB values to HSL, adds HSL
  	 * and then converts the color back to RGB.
  	 *
  	 * @param {number} h - Hue value between `0.0` and `1.0`.
  	 * @param {number} s - Saturation value between `0.0` and `1.0`.
  	 * @param {number} l - Lightness value between `0.0` and `1.0`.
  	 * @return {Color} A reference to this color.
  	 */
  	offsetHSL( h, s, l ) {

  		this.getHSL( _hslA );

  		return this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );

  	}

  	/**
  	 * Adds the RGB values of the given color to the RGB values of this color.
  	 *
  	 * @param {Color} color - The color to add.
  	 * @return {Color} A reference to this color.
  	 */
  	add( color ) {

  		this.r += color.r;
  		this.g += color.g;
  		this.b += color.b;

  		return this;

  	}

  	/**
  	 * Adds the RGB values of the given colors and stores the result in this instance.
  	 *
  	 * @param {Color} color1 - The first color.
  	 * @param {Color} color2 - The second color.
  	 * @return {Color} A reference to this color.
  	 */
  	addColors( color1, color2 ) {

  		this.r = color1.r + color2.r;
  		this.g = color1.g + color2.g;
  		this.b = color1.b + color2.b;

  		return this;

  	}

  	/**
  	 * Adds the given scalar value to the RGB values of this color.
  	 *
  	 * @param {number} s - The scalar to add.
  	 * @return {Color} A reference to this color.
  	 */
  	addScalar( s ) {

  		this.r += s;
  		this.g += s;
  		this.b += s;

  		return this;

  	}

  	/**
  	 * Subtracts the RGB values of the given color from the RGB values of this color.
  	 *
  	 * @param {Color} color - The color to subtract.
  	 * @return {Color} A reference to this color.
  	 */
  	sub( color ) {

  		this.r = Math.max( 0, this.r - color.r );
  		this.g = Math.max( 0, this.g - color.g );
  		this.b = Math.max( 0, this.b - color.b );

  		return this;

  	}

  	/**
  	 * Multiplies the RGB values of the given color with the RGB values of this color.
  	 *
  	 * @param {Color} color - The color to multiply.
  	 * @return {Color} A reference to this color.
  	 */
  	multiply( color ) {

  		this.r *= color.r;
  		this.g *= color.g;
  		this.b *= color.b;

  		return this;

  	}

  	/**
  	 * Multiplies the given scalar value with the RGB values of this color.
  	 *
  	 * @param {number} s - The scalar to multiply.
  	 * @return {Color} A reference to this color.
  	 */
  	multiplyScalar( s ) {

  		this.r *= s;
  		this.g *= s;
  		this.b *= s;

  		return this;

  	}

  	/**
  	 * Linearly interpolates this color's RGB values toward the RGB values of the
  	 * given color. The alpha argument can be thought of as the ratio between
  	 * the two colors, where `0.0` is this color and `1.0` is the first argument.
  	 *
  	 * @param {Color} color - The color to converge on.
  	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
  	 * @return {Color} A reference to this color.
  	 */
  	lerp( color, alpha ) {

  		this.r += ( color.r - this.r ) * alpha;
  		this.g += ( color.g - this.g ) * alpha;
  		this.b += ( color.b - this.b ) * alpha;

  		return this;

  	}

  	/**
  	 * Linearly interpolates between the given colors and stores the result in this instance.
  	 * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
  	 * is the first and `1.0` is the second color.
  	 *
  	 * @param {Color} color1 - The first color.
  	 * @param {Color} color2 - The second color.
  	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
  	 * @return {Color} A reference to this color.
  	 */
  	lerpColors( color1, color2, alpha ) {

  		this.r = color1.r + ( color2.r - color1.r ) * alpha;
  		this.g = color1.g + ( color2.g - color1.g ) * alpha;
  		this.b = color1.b + ( color2.b - color1.b ) * alpha;

  		return this;

  	}

  	/**
  	 * Linearly interpolates this color's HSL values toward the HSL values of the
  	 * given color. It differs from {@link Color#lerp} by not interpolating straight
  	 * from one color to the other, but instead going through all the hues in between
  	 * those two colors. The alpha argument can be thought of as the ratio between
  	 * the two colors, where 0.0 is this color and 1.0 is the first argument.
  	 *
  	 * @param {Color} color - The color to converge on.
  	 * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
  	 * @return {Color} A reference to this color.
  	 */
  	lerpHSL( color, alpha ) {

  		this.getHSL( _hslA );
  		color.getHSL( _hslB );

  		const h = lerp( _hslA.h, _hslB.h, alpha );
  		const s = lerp( _hslA.s, _hslB.s, alpha );
  		const l = lerp( _hslA.l, _hslB.l, alpha );

  		this.setHSL( h, s, l );

  		return this;

  	}

  	/**
  	 * Sets the color's RGB components from the given 3D vector.
  	 *
  	 * @param {Vector3} v - The vector to set.
  	 * @return {Color} A reference to this color.
  	 */
  	setFromVector3( v ) {

  		this.r = v.x;
  		this.g = v.y;
  		this.b = v.z;

  		return this;

  	}

  	/**
  	 * Transforms this color with the given 3x3 matrix.
  	 *
  	 * @param {Matrix3} m - The matrix.
  	 * @return {Color} A reference to this color.
  	 */
  	applyMatrix3( m ) {

  		const r = this.r, g = this.g, b = this.b;
  		const e = m.elements;

  		this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
  		this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
  		this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

  		return this;

  	}

  	/**
  	 * Returns `true` if this color is equal with the given one.
  	 *
  	 * @param {Color} c - The color to test for equality.
  	 * @return {boolean} Whether this bounding color is equal with the given one.
  	 */
  	equals( c ) {

  		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  	}

  	/**
  	 * Sets this color's RGB components from the given array.
  	 *
  	 * @param {Array<number>} array - An array holding the RGB values.
  	 * @param {number} [offset=0] - The offset into the array.
  	 * @return {Color} A reference to this color.
  	 */
  	fromArray( array, offset = 0 ) {

  		this.r = array[ offset ];
  		this.g = array[ offset + 1 ];
  		this.b = array[ offset + 2 ];

  		return this;

  	}

  	/**
  	 * Writes the RGB components of this color to the given array. If no array is provided,
  	 * the method returns a new instance.
  	 *
  	 * @param {Array<number>} [array=[]] - The target array holding the color components.
  	 * @param {number} [offset=0] - Index of the first element in the array.
  	 * @return {Array<number>} The color components.
  	 */
  	toArray( array = [], offset = 0 ) {

  		array[ offset ] = this.r;
  		array[ offset + 1 ] = this.g;
  		array[ offset + 2 ] = this.b;

  		return array;

  	}

  	/**
  	 * Sets the components of this color from the given buffer attribute.
  	 *
  	 * @param {BufferAttribute} attribute - The buffer attribute holding color data.
  	 * @param {number} index - The index into the attribute.
  	 * @return {Color} A reference to this color.
  	 */
  	fromBufferAttribute( attribute, index ) {

  		this.r = attribute.getX( index );
  		this.g = attribute.getY( index );
  		this.b = attribute.getZ( index );

  		return this;

  	}

  	/**
  	 * This methods defines the serialization result of this class. Returns the color
  	 * as a hexadecimal value.
  	 *
  	 * @return {number} The hexadecimal value.
  	 */
  	toJSON() {

  		return this.getHex();

  	}

  	*[ Symbol.iterator ]() {

  		yield this.r;
  		yield this.g;
  		yield this.b;

  	}

  }

  const _color = /*@__PURE__*/ new Color();

  /**
   * A dictionary with X11 color names.
   *
   * Note that multiple words such as Dark Orange become the string 'darkorange'.
   *
   * @static
   * @type {Object}
   */
  Color.NAMES = _colorKeywords;

  let _materialId = 0;

  /**
   * Abstract base class for materials.
   *
   * Materials define the appearance of renderable 3D objects.
   *
   * @abstract
   * @augments EventDispatcher
   */
  class Material extends EventDispatcher {

  	/**
  	 * Constructs a new material.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMaterial = true;

  		/**
  		 * The ID of the material.
  		 *
  		 * @name Material#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _materialId ++ } );

  		/**
  		 * The UUID of the material.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  		/**
  		 * The name of the material.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';

  		/**
  		 * The type property is used for detecting the object type
  		 * in context of serialization/deserialization.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.type = 'Material';

  		/**
  		 * Defines the blending type of the material.
  		 *
  		 * It must be set to `CustomBlending` if custom blending properties like
  		 * {@link Material#blendSrc}, {@link Material#blendDst} or {@link Material#blendEquation}
  		 * should have any effect.
  		 *
  		 * @type {(NoBlending|NormalBlending|AdditiveBlending|SubtractiveBlending|MultiplyBlending|CustomBlending)}
  		 * @default NormalBlending
  		 */
  		this.blending = NormalBlending;

  		/**
  		 * Defines which side of faces will be rendered - front, back or both.
  		 *
  		 * @type {(FrontSide|BackSide|DoubleSide)}
  		 * @default FrontSide
  		 */
  		this.side = FrontSide;

  		/**
  		 * If set to `true`, vertex colors should be used.
  		 *
  		 * The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or
  		 * four (RGBA) component color buffer attribute is used.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.vertexColors = false;

  		/**
  		 * Defines how transparent the material is.
  		 * A value of `0.0` indicates fully transparent, `1.0` is fully opaque.
  		 *
  		 * If the {@link Material#transparent} is not set to `true`,
  		 * the material will remain fully opaque and this value will only affect its color.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.opacity = 1;

  		/**
  		 * Defines whether this material is transparent. This has an effect on
  		 * rendering as transparent objects need special treatment and are rendered
  		 * after non-transparent objects.
  		 *
  		 * When set to true, the extent to which the material is transparent is
  		 * controlled by {@link Material#opacity}.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.transparent = false;

  		/**
  		 * Enables alpha hashed transparency, an alternative to {@link Material#transparent} or
  		 * {@link Material#alphaTest}. The material will not be rendered if opacity is lower than
  		 * a random threshold. Randomization introduces some grain or noise, but approximates alpha
  		 * blending without the associated problems of sorting. Using TAA can reduce the resulting noise.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.alphaHash = false;

  		/**
  		 * Defines the blending source factor.
  		 *
  		 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
  		 * @default SrcAlphaFactor
  		 */
  		this.blendSrc = SrcAlphaFactor;

  		/**
  		 * Defines the blending destination factor.
  		 *
  		 * @type {(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
  		 * @default OneMinusSrcAlphaFactor
  		 */
  		this.blendDst = OneMinusSrcAlphaFactor;

  		/**
  		 * Defines the blending equation.
  		 *
  		 * @type {(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
  		 * @default AddEquation
  		 */
  		this.blendEquation = AddEquation;

  		/**
  		 * Defines the blending source alpha factor.
  		 *
  		 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
  		 * @default null
  		 */
  		this.blendSrcAlpha = null;

  		/**
  		 * Defines the blending destination alpha factor.
  		 *
  		 * @type {?(ZeroFactor|OneFactor|SrcColorFactor|OneMinusSrcColorFactor|SrcAlphaFactor|OneMinusSrcAlphaFactor|DstAlphaFactor|OneMinusDstAlphaFactor|DstColorFactor|OneMinusDstColorFactor|SrcAlphaSaturateFactor|ConstantColorFactor|OneMinusConstantColorFactor|ConstantAlphaFactor|OneMinusConstantAlphaFactor)}
  		 * @default null
  		 */
  		this.blendDstAlpha = null;

  		/**
  		 * Defines the blending equation of the alpha channel.
  		 *
  		 * @type {?(AddEquation|SubtractEquation|ReverseSubtractEquation|MinEquation|MaxEquation)}
  		 * @default null
  		 */
  		this.blendEquationAlpha = null;

  		/**
  		 * Represents the RGB values of the constant blend color.
  		 *
  		 * This property has only an effect when using custom blending with `ConstantColor` or `OneMinusConstantColor`.
  		 *
  		 * @type {Color}
  		 * @default (0,0,0)
  		 */
  		this.blendColor = new Color( 0, 0, 0 );

  		/**
  		 * Represents the alpha value of the constant blend color.
  		 *
  		 * This property has only an effect when using custom blending with `ConstantAlpha` or `OneMinusConstantAlpha`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.blendAlpha = 0;

  		/**
  		 * Defines the depth function.
  		 *
  		 * @type {(NeverDepth|AlwaysDepth|LessDepth|LessEqualDepth|EqualDepth|GreaterEqualDepth|GreaterDepth|NotEqualDepth)}
  		 * @default LessEqualDepth
  		 */
  		this.depthFunc = LessEqualDepth;

  		/**
  		 * Whether to have depth test enabled when rendering this material.
  		 * When the depth test is disabled, the depth write will also be implicitly disabled.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.depthTest = true;

  		/**
  		 * Whether rendering this material has any effect on the depth buffer.
  		 *
  		 * When drawing 2D overlays it can be useful to disable the depth writing in
  		 * order to layer several things together without creating z-index artifacts.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.depthWrite = true;

  		/**
  		 * The bit mask to use when writing to the stencil buffer.
  		 *
  		 * @type {number}
  		 * @default 0xff
  		 */
  		this.stencilWriteMask = 0xff;

  		/**
  		 * The stencil comparison function to use.
  		 *
  		 * @type {NeverStencilFunc|LessStencilFunc|EqualStencilFunc|LessEqualStencilFunc|GreaterStencilFunc|NotEqualStencilFunc|GreaterEqualStencilFunc|AlwaysStencilFunc}
  		 * @default AlwaysStencilFunc
  		 */
  		this.stencilFunc = AlwaysStencilFunc;

  		/**
  		 * The value to use when performing stencil comparisons or stencil operations.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.stencilRef = 0;

  		/**
  		 * The bit mask to use when comparing against the stencil buffer.
  		 *
  		 * @type {number}
  		 * @default 0xff
  		 */
  		this.stencilFuncMask = 0xff;

  		/**
  		 * Which stencil operation to perform when the comparison function returns `false`.
  		 *
  		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
  		 * @default KeepStencilOp
  		 */
  		this.stencilFail = KeepStencilOp;

  		/**
  		 * Which stencil operation to perform when the comparison function returns
  		 * `true` but the depth test fails.
  		 *
  		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
  		 * @default KeepStencilOp
  		 */
  		this.stencilZFail = KeepStencilOp;

  		/**
  		 * Which stencil operation to perform when the comparison function returns
  		 * `true` and the depth test passes.
  		 *
  		 * @type {ZeroStencilOp|KeepStencilOp|ReplaceStencilOp|IncrementStencilOp|DecrementStencilOp|IncrementWrapStencilOp|DecrementWrapStencilOp|InvertStencilOp}
  		 * @default KeepStencilOp
  		 */
  		this.stencilZPass = KeepStencilOp;

  		/**
  		 * Whether stencil operations are performed against the stencil buffer. In
  		 * order to perform writes or comparisons against the stencil buffer this
  		 * value must be `true`.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.stencilWrite = false;

  		/**
  		 * User-defined clipping planes specified as THREE.Plane objects in world
  		 * space. These planes apply to the objects this material is attached to.
  		 * Points in space whose signed distance to the plane is negative are clipped
  		 * (not rendered). This requires {@link WebGLRenderer#localClippingEnabled} to
  		 * be `true`.
  		 *
  		 * @type {?Array<Plane>}
  		 * @default null
  		 */
  		this.clippingPlanes = null;

  		/**
  		 * Changes the behavior of clipping planes so that only their intersection is
  		 * clipped, rather than their union.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.clipIntersection = false;

  		/**
  		 * Defines whether to clip shadows according to the clipping planes specified
  		 * on this material.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.clipShadows = false;

  		/**
  		 * Defines which side of faces cast shadows. If `null`, the side casting shadows
  		 * is determined as follows:
  		 *
  		 * - When {@link Material#side} is set to `FrontSide`, the back side cast shadows.
  		 * - When {@link Material#side} is set to `BackSide`, the front side cast shadows.
  		 * - When {@link Material#side} is set to `DoubleSide`, both sides cast shadows.
  		 *
  		 * @type {?(FrontSide|BackSide|DoubleSide)}
  		 * @default null
  		 */
  		this.shadowSide = null;

  		/**
  		 * Whether to render the material's color.
  		 *
  		 * This can be used in conjunction with {@link Object3D#renderOder} to create invisible
  		 * objects that occlude other objects.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.colorWrite = true;

  		/**
  		 * Override the renderer's default precision for this material.
  		 *
  		 * @type {?('highp'|'mediump'|'lowp')}
  		 * @default null
  		 */
  		this.precision = null;

  		/**
  		 * Whether to use polygon offset or not. When enabled, each fragment's depth value will
  		 * be offset after it is interpolated from the depth values of the appropriate vertices.
  		 * The offset is added before the depth test is performed and before the value is written
  		 * into the depth buffer.
  		 *
  		 * Can be useful for rendering hidden-line images, for applying decals to surfaces, and for
  		 * rendering solids with highlighted edges.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.polygonOffset = false;

  		/**
  		 * Specifies a scale factor that is used to create a variable depth offset for each polygon.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.polygonOffsetFactor = 0;

  		/**
  		 * Is multiplied by an implementation-specific value to create a constant depth offset.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.polygonOffsetUnits = 0;

  		/**
  		 * Whether to apply dithering to the color to remove the appearance of banding.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.dithering = false;

  		/**
  		 * Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts
  		 * (meaning when the renderer was created with *antialias* parameter set to `true`). Enabling this
  		 * will smooth aliasing on clip plane edges and alphaTest-clipped edges.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.alphaToCoverage = false;

  		/**
  		 * Whether to premultiply the alpha (transparency) value.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.premultipliedAlpha = false;

  		/**
  		 * Whether double-sided, transparent objects should be rendered with a single pass or not.
  		 *
  		 * The engine renders double-sided, transparent objects with two draw calls (back faces first,
  		 * then front faces) to mitigate transparency artifacts. There are scenarios however where this
  		 * approach produces no quality gains but still doubles draw calls e.g. when rendering flat
  		 * vegetation like grass sprites. In these cases, set the `forceSinglePass` flag to `true` to
  		 * disable the two pass rendering to avoid performance issues.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.forceSinglePass = false;

  		/**
  		 * Whether it's possible to override the material with {@link Scene#overrideMaterial} or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.allowOverride = true;

  		/**
  		 * Defines whether 3D objects using this material are visible.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.visible = true;

  		/**
  		 * Defines whether this material is tone mapped according to the renderer's tone mapping setting.
  		 *
  		 * It is ignored when rendering to a render target or using post processing or when using
  		 * `WebGPURenderer`. In all these cases, all materials are honored by tone mapping.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.toneMapped = true;

  		/**
  		 * An object that can be used to store custom data about the Material. It
  		 * should not hold references to functions as these will not be cloned.
  		 *
  		 * @type {Object}
  		 */
  		this.userData = {};

  		/**
  		 * This starts at `0` and counts how many times {@link Material#needsUpdate} is set to `true`.
  		 *
  		 * @type {number}
  		 * @readonly
  		 * @default 0
  		 */
  		this.version = 0;

  		this._alphaTest = 0;

  	}

  	/**
  	 * Sets the alpha value to be used when running an alpha test. The material
  	 * will not be rendered if the opacity is lower than this value.
  	 *
  	 * @type {number}
  	 * @readonly
  	 * @default 0
  	 */
  	get alphaTest() {

  		return this._alphaTest;

  	}

  	set alphaTest( value ) {

  		if ( this._alphaTest > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._alphaTest = value;

  	}

  	/**
  	 * An optional callback that is executed immediately before the material is used to render a 3D object.
  	 *
  	 * This method can only be used when rendering with {@link WebGLRenderer}.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {Scene} scene - The scene.
  	 * @param {Camera} camera - The camera that is used to render the scene.
  	 * @param {BufferGeometry} geometry - The 3D object's geometry.
  	 * @param {Object3D} object - The 3D object.
  	 * @param {Object} group - The geometry group data.
  	 */
  	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

  	/**
  	 * An optional callback that is executed immediately before the shader
  	 * program is compiled. This function is called with the shader source code
  	 * as a parameter. Useful for the modification of built-in materials.
  	 *
  	 * This method can only be used when rendering with {@link WebGLRenderer}. The
  	 * recommended approach when customizing materials is to use `WebGPURenderer` with the new
  	 * Node Material system and [TSL]{@link https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language}.
  	 *
  	 * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
  	 * @param {WebGLRenderer} renderer - A reference to the renderer.
  	 */
  	onBeforeCompile( /* shaderobject, renderer */ ) {}

  	/**
  	 * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
  	 * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
  	 * shader or recompile the shader for this material as needed.
  	 *
  	 * This method can only be used when rendering with {@link WebGLRenderer}.
  	 *
  	 * @return {string} The custom program cache key.
  	 */
  	customProgramCacheKey() {

  		return this.onBeforeCompile.toString();

  	}

  	/**
  	 * This method can be used to set default values from parameter objects.
  	 * It is a generic implementation so it can be used with different types
  	 * of materials.
  	 *
  	 * @param {Object} [values] - The material values to set.
  	 */
  	setValues( values ) {

  		if ( values === undefined ) return;

  		for ( const key in values ) {

  			const newValue = values[ key ];

  			if ( newValue === undefined ) {

  				console.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );
  				continue;

  			}

  			const currentValue = this[ key ];

  			if ( currentValue === undefined ) {

  				console.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );
  				continue;

  			}

  			if ( currentValue && currentValue.isColor ) {

  				currentValue.set( newValue );

  			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

  				currentValue.copy( newValue );

  			} else {

  				this[ key ] = newValue;

  			}

  		}

  	}

  	/**
  	 * Serializes the material into JSON.
  	 *
  	 * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized material.
  	 * @see {@link ObjectLoader#parse}
  	 */
  	toJSON( meta ) {

  		const isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( isRootObject ) {

  			meta = {
  				textures: {},
  				images: {}
  			};

  		}

  		const data = {
  			metadata: {
  				version: 4.7,
  				type: 'Material',
  				generator: 'Material.toJSON'
  			}
  		};

  		// standard Material serialization
  		data.uuid = this.uuid;
  		data.type = this.type;

  		if ( this.name !== '' ) data.name = this.name;

  		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

  		if ( this.roughness !== undefined ) data.roughness = this.roughness;
  		if ( this.metalness !== undefined ) data.metalness = this.metalness;

  		if ( this.sheen !== undefined ) data.sheen = this.sheen;
  		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
  		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
  		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
  		if ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

  		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
  		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
  		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
  		if ( this.shininess !== undefined ) data.shininess = this.shininess;
  		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
  		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

  		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

  			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

  		}

  		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

  			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

  		}

  		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

  			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
  			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

  		}

  		if ( this.sheenColorMap && this.sheenColorMap.isTexture ) {

  			data.sheenColorMap = this.sheenColorMap.toJSON( meta ).uuid;

  		}

  		if ( this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture ) {

  			data.sheenRoughnessMap = this.sheenRoughnessMap.toJSON( meta ).uuid;

  		}

  		if ( this.dispersion !== undefined ) data.dispersion = this.dispersion;

  		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
  		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
  		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

  		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

  			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

  		}

  		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

  			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

  		}

  		if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
  		if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

  		if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

  			data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

  		}

  		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
  		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
  		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

  		if ( this.lightMap && this.lightMap.isTexture ) {

  			data.lightMap = this.lightMap.toJSON( meta ).uuid;
  			data.lightMapIntensity = this.lightMapIntensity;

  		}

  		if ( this.aoMap && this.aoMap.isTexture ) {

  			data.aoMap = this.aoMap.toJSON( meta ).uuid;
  			data.aoMapIntensity = this.aoMapIntensity;

  		}

  		if ( this.bumpMap && this.bumpMap.isTexture ) {

  			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
  			data.bumpScale = this.bumpScale;

  		}

  		if ( this.normalMap && this.normalMap.isTexture ) {

  			data.normalMap = this.normalMap.toJSON( meta ).uuid;
  			data.normalMapType = this.normalMapType;
  			data.normalScale = this.normalScale.toArray();

  		}

  		if ( this.displacementMap && this.displacementMap.isTexture ) {

  			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
  			data.displacementScale = this.displacementScale;
  			data.displacementBias = this.displacementBias;

  		}

  		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
  		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

  		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
  		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
  		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
  		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

  		if ( this.envMap && this.envMap.isTexture ) {

  			data.envMap = this.envMap.toJSON( meta ).uuid;

  			if ( this.combine !== undefined ) data.combine = this.combine;

  		}

  		if ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();
  		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
  		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
  		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

  		if ( this.gradientMap && this.gradientMap.isTexture ) {

  			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

  		}

  		if ( this.transmission !== undefined ) data.transmission = this.transmission;
  		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
  		if ( this.thickness !== undefined ) data.thickness = this.thickness;
  		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
  		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
  		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

  		if ( this.size !== undefined ) data.size = this.size;
  		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
  		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

  		if ( this.blending !== NormalBlending ) data.blending = this.blending;
  		if ( this.side !== FrontSide ) data.side = this.side;
  		if ( this.vertexColors === true ) data.vertexColors = true;

  		if ( this.opacity < 1 ) data.opacity = this.opacity;
  		if ( this.transparent === true ) data.transparent = true;

  		if ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;
  		if ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;
  		if ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;
  		if ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;
  		if ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;
  		if ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;
  		if ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();
  		if ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;

  		if ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;
  		if ( this.depthTest === false ) data.depthTest = this.depthTest;
  		if ( this.depthWrite === false ) data.depthWrite = this.depthWrite;
  		if ( this.colorWrite === false ) data.colorWrite = this.colorWrite;

  		if ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;
  		if ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;
  		if ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;
  		if ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;
  		if ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;
  		if ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;
  		if ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;
  		if ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;

  		// rotation (SpriteMaterial)
  		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

  		if ( this.polygonOffset === true ) data.polygonOffset = true;
  		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
  		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

  		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
  		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
  		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
  		if ( this.scale !== undefined ) data.scale = this.scale;

  		if ( this.dithering === true ) data.dithering = true;

  		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
  		if ( this.alphaHash === true ) data.alphaHash = true;
  		if ( this.alphaToCoverage === true ) data.alphaToCoverage = true;
  		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;
  		if ( this.forceSinglePass === true ) data.forceSinglePass = true;

  		if ( this.wireframe === true ) data.wireframe = true;
  		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
  		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
  		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

  		if ( this.flatShading === true ) data.flatShading = true;

  		if ( this.visible === false ) data.visible = false;

  		if ( this.toneMapped === false ) data.toneMapped = false;

  		if ( this.fog === false ) data.fog = false;

  		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			const values = [];

  			for ( const key in cache ) {

  				const data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRootObject ) {

  			const textures = extractFromCache( meta.textures );
  			const images = extractFromCache( meta.images );

  			if ( textures.length > 0 ) data.textures = textures;
  			if ( images.length > 0 ) data.images = images;

  		}

  		return data;

  	}

  	/**
  	 * Returns a new material with copied values from this instance.
  	 *
  	 * @return {Material} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the values of the given material to this instance.
  	 *
  	 * @param {Material} source - The material to copy.
  	 * @return {Material} A reference to this instance.
  	 */
  	copy( source ) {

  		this.name = source.name;

  		this.blending = source.blending;
  		this.side = source.side;
  		this.vertexColors = source.vertexColors;

  		this.opacity = source.opacity;
  		this.transparent = source.transparent;

  		this.blendSrc = source.blendSrc;
  		this.blendDst = source.blendDst;
  		this.blendEquation = source.blendEquation;
  		this.blendSrcAlpha = source.blendSrcAlpha;
  		this.blendDstAlpha = source.blendDstAlpha;
  		this.blendEquationAlpha = source.blendEquationAlpha;
  		this.blendColor.copy( source.blendColor );
  		this.blendAlpha = source.blendAlpha;

  		this.depthFunc = source.depthFunc;
  		this.depthTest = source.depthTest;
  		this.depthWrite = source.depthWrite;

  		this.stencilWriteMask = source.stencilWriteMask;
  		this.stencilFunc = source.stencilFunc;
  		this.stencilRef = source.stencilRef;
  		this.stencilFuncMask = source.stencilFuncMask;
  		this.stencilFail = source.stencilFail;
  		this.stencilZFail = source.stencilZFail;
  		this.stencilZPass = source.stencilZPass;
  		this.stencilWrite = source.stencilWrite;

  		const srcPlanes = source.clippingPlanes;
  		let dstPlanes = null;

  		if ( srcPlanes !== null ) {

  			const n = srcPlanes.length;
  			dstPlanes = new Array( n );

  			for ( let i = 0; i !== n; ++ i ) {

  				dstPlanes[ i ] = srcPlanes[ i ].clone();

  			}

  		}

  		this.clippingPlanes = dstPlanes;
  		this.clipIntersection = source.clipIntersection;
  		this.clipShadows = source.clipShadows;

  		this.shadowSide = source.shadowSide;

  		this.colorWrite = source.colorWrite;

  		this.precision = source.precision;

  		this.polygonOffset = source.polygonOffset;
  		this.polygonOffsetFactor = source.polygonOffsetFactor;
  		this.polygonOffsetUnits = source.polygonOffsetUnits;

  		this.dithering = source.dithering;

  		this.alphaTest = source.alphaTest;
  		this.alphaHash = source.alphaHash;
  		this.alphaToCoverage = source.alphaToCoverage;
  		this.premultipliedAlpha = source.premultipliedAlpha;
  		this.forceSinglePass = source.forceSinglePass;

  		this.visible = source.visible;

  		this.toneMapped = source.toneMapped;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		return this;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 *
  	 * @fires Material#dispose
  	 */
  	dispose() {

  		/**
  		 * Fires when the material has been disposed of.
  		 *
  		 * @event Material#dispose
  		 * @type {Object}
  		 */
  		this.dispatchEvent( { type: 'dispose' } );

  	}

  	/**
  	 * Setting this property to `true` indicates the engine the material
  	 * needs to be recompiled.
  	 *
  	 * @type {boolean}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  }

  /**
   * A material for drawing geometries in a simple shaded (flat or wireframe) way.
   *
   * This material is not affected by lights.
   *
   * @augments Material
   */
  class MeshBasicMaterial extends Material {

  	/**
  	 * Constructs a new mesh basic material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshBasicMaterial = true;

  		this.type = 'MeshBasicMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff ); // diffuse

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The light map. Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.lightMap = null;

  		/**
  		 * Intensity of the baked light.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.lightMapIntensity = 1.0;

  		/**
  		 * The red channel of this texture is used as the ambient occlusion map.
  		 * Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.aoMap = null;

  		/**
  		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
  		 * disables ambient occlusion. Where intensity is `1` and the AO map's
  		 * red channel is also `1`, ambient light is fully occluded on a surface.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.aoMapIntensity = 1.0;

  		/**
  		 * Specular map used by the material.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.specularMap = null;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * The environment map.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.envMap = null;

  		/**
  		 * The rotation of the environment map in radians.
  		 *
  		 * @type {Euler}
  		 * @default (0,0,0)
  		 */
  		this.envMapRotation = new Euler();

  		/**
  		 * How to combine the result of the surface's color with the environment map, if any.
  		 *
  		 * When set to `MixOperation`, the {@link MeshBasicMaterial#reflectivity} is used to
  		 * blend between the two colors.
  		 *
  		 * @type {(MultiplyOperation|MixOperation|AddOperation)}
  		 * @default MultiplyOperation
  		 */
  		this.combine = MultiplyOperation;

  		/**
  		 * How much the environment map affects the surface.
  		 * The valid range is between `0` (no reflections) and `1` (full reflections).
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.reflectivity = 1;

  		/**
  		 * The index of refraction (IOR) of air (approximately 1) divided by the
  		 * index of refraction of the material. It is used with environment mapping
  		 * modes {@link CubeRefractionMapping} and {@link EquirectangularRefractionMapping}.
  		 * The refraction ratio should not exceed `1`.
  		 *
  		 * @type {number}
  		 * @default 0.98
  		 */
  		this.refractionRatio = 0.98;

  		/**
  		 * Renders the geometry as a wireframe.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.wireframe = false;

  		/**
  		 * Controls the thickness of the wireframe.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.wireframeLinewidth = 1;

  		/**
  		 * Defines appearance of wireframe ends.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinecap = 'round';

  		/**
  		 * Defines appearance of wireframe joints.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinejoin = 'round';

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.fog = source.fog;

  		return this;

  	}

  }

  const _vector$9 = /*@__PURE__*/ new Vector3();
  const _vector2$1 = /*@__PURE__*/ new Vector2();

  let _id$2 = 0;

  /**
   * This class stores data for an attribute (such as vertex positions, face
   * indices, normals, colors, UVs, and any custom attributes ) associated with
   * a geometry, which allows for more efficient passing of data to the GPU.
   *
   * When working with vector-like data, the `fromBufferAttribute( attribute, index )`
   * helper methods on vector and color class might be helpful. E.g. {@link Vector3#fromBufferAttribute}.
   */
  class BufferAttribute {

  	/**
  	 * Constructs a new buffer attribute.
  	 *
  	 * @param {TypedArray} array - The array holding the attribute data.
  	 * @param {number} itemSize - The item size.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 */
  	constructor( array, itemSize, normalized = false ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  		}

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBufferAttribute = true;

  		/**
  		 * The ID of the buffer attribute.
  		 *
  		 * @name BufferAttribute#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _id$2 ++ } );

  		/**
  		 * The name of the buffer attribute.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';

  		/**
  		 * The array holding the attribute data. It should have `itemSize * numVertices`
  		 * elements, where `numVertices` is the number of vertices in the associated geometry.
  		 *
  		 * @type {TypedArray}
  		 */
  		this.array = array;

  		/**
  		 * The number of values of the array that should be associated with a particular vertex.
  		 * For instance, if this attribute is storing a 3-component vector (such as a position,
  		 * normal, or color), then the value should be `3`.
  		 *
  		 * @type {number}
  		 */
  		this.itemSize = itemSize;

  		/**
  		 * Represents the number of items this buffer attribute stores. It is internally computed
  		 * by dividing the `array` length by the `itemSize`.
  		 *
  		 * @type {number}
  		 * @readonly
  		 */
  		this.count = array !== undefined ? array.length / itemSize : 0;

  		/**
  		 * Applies to integer data only. Indicates how the underlying data in the buffer maps to
  		 * the values in the GLSL code. For instance, if `array` is an instance of `UInt16Array`,
  		 * and `normalized` is `true`, the values `0 - +65535` in the array data will be mapped to
  		 * `0.0f - +1.0f` in the GLSL attribute. If `normalized` is `false`, the values will be converted
  		 * to floats unmodified, i.e. `65535` becomes `65535.0f`.
  		 *
  		 * @type {boolean}
  		 */
  		this.normalized = normalized;

  		/**
  		 * Defines the intended usage pattern of the data store for optimization purposes.
  		 *
  		 * Note: After the initial use of a buffer, its usage cannot be changed. Instead,
  		 * instantiate a new one and set the desired usage before the next render.
  		 *
  		 * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
  		 * @default StaticDrawUsage
  		 */
  		this.usage = StaticDrawUsage;

  		/**
  		 * This can be used to only update some components of stored vectors (for example, just the
  		 * component related to color). Use the `addUpdateRange()` function to add ranges to this array.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.updateRanges = [];

  		/**
  		 * Configures the bound GPU type for use in shaders.
  		 *
  		 * Note: this only has an effect for integer arrays and is not configurable for float arrays.
  		 * For lower precision float types, use `Float16BufferAttribute`.
  		 *
  		 * @type {(FloatType|IntType)}
  		 * @default FloatType
  		 */
  		this.gpuType = FloatType;

  		/**
  		 * A version number, incremented every time the `needsUpdate` is set to `true`.
  		 *
  		 * @type {number}
  		 */
  		this.version = 0;

  	}

  	/**
  	 * A callback function that is executed after the renderer has transferred the attribute
  	 * array data to the GPU.
  	 */
  	onUploadCallback() {}

  	/**
  	 * Flag to indicate that this attribute has changed and should be re-sent to
  	 * the GPU. Set this to `true` when you modify the value of the array.
  	 *
  	 * @type {number}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	/**
  	 * Sets the usage of this buffer attribute.
  	 *
  	 * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
  	 * @return {BufferAttribute} A reference to this buffer attribute.
  	 */
  	setUsage( value ) {

  		this.usage = value;

  		return this;

  	}

  	/**
  	 * Adds a range of data in the data array to be updated on the GPU.
  	 *
  	 * @param {number} start - Position at which to start update.
  	 * @param {number} count - The number of components to update.
  	 */
  	addUpdateRange( start, count ) {

  		this.updateRanges.push( { start, count } );

  	}

  	/**
  	 * Clears the update ranges.
  	 */
  	clearUpdateRanges() {

  		this.updateRanges.length = 0;

  	}

  	/**
  	 * Copies the values of the given buffer attribute to this instance.
  	 *
  	 * @param {BufferAttribute} source - The buffer attribute to copy.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	copy( source ) {

  		this.name = source.name;
  		this.array = new source.array.constructor( source.array );
  		this.itemSize = source.itemSize;
  		this.count = source.count;
  		this.normalized = source.normalized;

  		this.usage = source.usage;
  		this.gpuType = source.gpuType;

  		return this;

  	}

  	/**
  	 * Copies a vector from the given buffer attribute to this one. The start
  	 * and destination position in the attribute buffers are represented by the
  	 * given indices.
  	 *
  	 * @param {number} index1 - The destination index into this buffer attribute.
  	 * @param {BufferAttribute} attribute - The buffer attribute to copy from.
  	 * @param {number} index2 - The source index into the given buffer attribute.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	copyAt( index1, attribute, index2 ) {

  		index1 *= this.itemSize;
  		index2 *= attribute.itemSize;

  		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

  			this.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	}

  	/**
  	 * Copies the given array data into this buffer attribute.
  	 *
  	 * @param {(TypedArray|Array)} array - The array to copy.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	copyArray( array ) {

  		this.array.set( array );

  		return this;

  	}

  	/**
  	 * Applies the given 3x3 matrix to the given attribute. Works with
  	 * item size `2` and `3`.
  	 *
  	 * @param {Matrix3} m - The matrix to apply.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	applyMatrix3( m ) {

  		if ( this.itemSize === 2 ) {

  			for ( let i = 0, l = this.count; i < l; i ++ ) {

  				_vector2$1.fromBufferAttribute( this, i );
  				_vector2$1.applyMatrix3( m );

  				this.setXY( i, _vector2$1.x, _vector2$1.y );

  			}

  		} else if ( this.itemSize === 3 ) {

  			for ( let i = 0, l = this.count; i < l; i ++ ) {

  				_vector$9.fromBufferAttribute( this, i );
  				_vector$9.applyMatrix3( m );

  				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  			}

  		}

  		return this;

  	}

  	/**
  	 * Applies the given 4x4 matrix to the given attribute. Only works with
  	 * item size `3`.
  	 *
  	 * @param {Matrix4} m - The matrix to apply.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	applyMatrix4( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.applyMatrix4( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	/**
  	 * Applies the given 3x3 normal matrix to the given attribute. Only works with
  	 * item size `3`.
  	 *
  	 * @param {Matrix3} m - The normal matrix to apply.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	applyNormalMatrix( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.applyNormalMatrix( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	/**
  	 * Applies the given 4x4 matrix to the given attribute. Only works with
  	 * item size `3` and with direction vectors.
  	 *
  	 * @param {Matrix4} m - The matrix to apply.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	transformDirection( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$9.fromBufferAttribute( this, i );

  			_vector$9.transformDirection( m );

  			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

  		}

  		return this;

  	}

  	/**
  	 * Sets the given array data in the buffer attribute.
  	 *
  	 * @param {(TypedArray|Array)} value - The array data to set.
  	 * @param {number} [offset=0] - The offset in this buffer attribute's array.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	set( value, offset = 0 ) {

  		// Matching BufferAttribute constructor, do not normalize the array.
  		this.array.set( value, offset );

  		return this;

  	}

  	/**
  	 * Returns the given component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} component - The component index.
  	 * @return {number} The returned value.
  	 */
  	getComponent( index, component ) {

  		let value = this.array[ index * this.itemSize + component ];

  		if ( this.normalized ) value = denormalize( value, this.array );

  		return value;

  	}

  	/**
  	 * Sets the given value to the given component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} component - The component index.
  	 * @param {number} value - The value to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setComponent( index, component, value ) {

  		if ( this.normalized ) value = normalize( value, this.array );

  		this.array[ index * this.itemSize + component ] = value;

  		return this;

  	}

  	/**
  	 * Returns the x component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The x component.
  	 */
  	getX( index ) {

  		let x = this.array[ index * this.itemSize ];

  		if ( this.normalized ) x = denormalize( x, this.array );

  		return x;

  	}

  	/**
  	 * Sets the x component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setX( index, x ) {

  		if ( this.normalized ) x = normalize( x, this.array );

  		this.array[ index * this.itemSize ] = x;

  		return this;

  	}

  	/**
  	 * Returns the y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The y component.
  	 */
  	getY( index ) {

  		let y = this.array[ index * this.itemSize + 1 ];

  		if ( this.normalized ) y = denormalize( y, this.array );

  		return y;

  	}

  	/**
  	 * Sets the y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} y - The value to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setY( index, y ) {

  		if ( this.normalized ) y = normalize( y, this.array );

  		this.array[ index * this.itemSize + 1 ] = y;

  		return this;

  	}

  	/**
  	 * Returns the z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The z component.
  	 */
  	getZ( index ) {

  		let z = this.array[ index * this.itemSize + 2 ];

  		if ( this.normalized ) z = denormalize( z, this.array );

  		return z;

  	}

  	/**
  	 * Sets the z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} z - The value to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setZ( index, z ) {

  		if ( this.normalized ) z = normalize( z, this.array );

  		this.array[ index * this.itemSize + 2 ] = z;

  		return this;

  	}

  	/**
  	 * Returns the w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The w component.
  	 */
  	getW( index ) {

  		let w = this.array[ index * this.itemSize + 3 ];

  		if ( this.normalized ) w = denormalize( w, this.array );

  		return w;

  	}

  	/**
  	 * Sets the w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} w - The value to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setW( index, w ) {

  		if ( this.normalized ) w = normalize( w, this.array );

  		this.array[ index * this.itemSize + 3 ] = w;

  		return this;

  	}

  	/**
  	 * Sets the x and y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setXY( index, x, y ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;

  		return this;

  	}

  	/**
  	 * Sets the x, y and z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @param {number} z - The value for the z component to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setXYZ( index, x, y, z ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );
  			z = normalize( z, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;

  		return this;

  	}

  	/**
  	 * Sets the x, y, z and w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @param {number} z - The value for the z component to set.
  	 * @param {number} w - The value for the w component to set.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	setXYZW( index, x, y, z, w ) {

  		index *= this.itemSize;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );
  			z = normalize( z, this.array );
  			w = normalize( w, this.array );

  		}

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;
  		this.array[ index + 3 ] = w;

  		return this;

  	}

  	/**
  	 * Sets the given callback function that is executed after the Renderer has transferred
  	 * the attribute array data to the GPU. Can be used to perform clean-up operations after
  	 * the upload when attribute data are not needed anymore on the CPU side.
  	 *
  	 * @param {Function} callback - The `onUpload()` callback.
  	 * @return {BufferAttribute} A reference to this instance.
  	 */
  	onUpload( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  	/**
  	 * Returns a new buffer attribute with copied values from this instance.
  	 *
  	 * @return {BufferAttribute} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor( this.array, this.itemSize ).copy( this );

  	}

  	/**
  	 * Serializes the buffer attribute into JSON.
  	 *
  	 * @return {Object} A JSON object representing the serialized buffer attribute.
  	 */
  	toJSON() {

  		const data = {
  			itemSize: this.itemSize,
  			type: this.array.constructor.name,
  			array: Array.from( this.array ),
  			normalized: this.normalized
  		};

  		if ( this.name !== '' ) data.name = this.name;
  		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;

  		return data;

  	}

  }

  /**
   * Convenient class that can be used when creating a `UInt16` buffer attribute with
   * a plain `Array` instance.
   *
   * @augments BufferAttribute
   */
  class Uint16BufferAttribute extends BufferAttribute {

  	/**
  	 * Constructs a new buffer attribute.
  	 *
  	 * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
  	 * @param {number} itemSize - The item size.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 */
  	constructor( array, itemSize, normalized ) {

  		super( new Uint16Array( array ), itemSize, normalized );

  	}

  }

  /**
   * Convenient class that can be used when creating a `UInt32` buffer attribute with
   * a plain `Array` instance.
   *
   * @augments BufferAttribute
   */
  class Uint32BufferAttribute extends BufferAttribute {

  	/**
  	 * Constructs a new buffer attribute.
  	 *
  	 * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
  	 * @param {number} itemSize - The item size.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 */
  	constructor( array, itemSize, normalized ) {

  		super( new Uint32Array( array ), itemSize, normalized );

  	}

  }

  /**
   * Convenient class that can be used when creating a `Float32` buffer attribute with
   * a plain `Array` instance.
   *
   * @augments BufferAttribute
   */
  class Float32BufferAttribute extends BufferAttribute {

  	/**
  	 * Constructs a new buffer attribute.
  	 *
  	 * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
  	 * @param {number} itemSize - The item size.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 */
  	constructor( array, itemSize, normalized ) {

  		super( new Float32Array( array ), itemSize, normalized );

  	}

  }

  let _id$1 = 0;

  const _m1$3 = /*@__PURE__*/ new Matrix4();
  const _obj = /*@__PURE__*/ new Object3D();
  const _offset = /*@__PURE__*/ new Vector3();
  const _box$2 = /*@__PURE__*/ new Box3();
  const _boxMorphTargets = /*@__PURE__*/ new Box3();
  const _vector$8 = /*@__PURE__*/ new Vector3();

  /**
   * A representation of mesh, line, or point geometry. Includes vertex
   * positions, face indices, normals, colors, UVs, and custom attributes
   * within buffers, reducing the cost of passing all this data to the GPU.
   *
   * ```js
   * const geometry = new THREE.BufferGeometry();
   * // create a simple square shape. We duplicate the top left and bottom right
   * // vertices because each vertex needs to appear once per triangle.
   * const vertices = new Float32Array( [
   * 	-1.0, -1.0,  1.0, // v0
   * 	 1.0, -1.0,  1.0, // v1
   * 	 1.0,  1.0,  1.0, // v2
   *
   * 	 1.0,  1.0,  1.0, // v3
   * 	-1.0,  1.0,  1.0, // v4
   * 	-1.0, -1.0,  1.0  // v5
   * ] );
   * // itemSize = 3 because there are 3 values (components) per vertex
   * geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
   * const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
   * const mesh = new THREE.Mesh( geometry, material );
   * ```
   *
   * @augments EventDispatcher
   */
  class BufferGeometry extends EventDispatcher {

  	/**
  	 * Constructs a new geometry.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBufferGeometry = true;

  		/**
  		 * The ID of the geometry.
  		 *
  		 * @name BufferGeometry#id
  		 * @type {number}
  		 * @readonly
  		 */
  		Object.defineProperty( this, 'id', { value: _id$1 ++ } );

  		/**
  		 * The UUID of the geometry.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  		/**
  		 * The name of the geometry.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';
  		this.type = 'BufferGeometry';

  		/**
  		 * Allows for vertices to be re-used across multiple triangles; this is
  		 * called using "indexed triangles". Each triangle is associated with the
  		 * indices of three vertices. This attribute therefore stores the index of
  		 * each vertex for each triangular face. If this attribute is not set, the
  		 * renderer assumes that each three contiguous positions represent a single triangle.
  		 *
  		 * @type {?BufferAttribute}
  		 * @default null
  		 */
  		this.index = null;

  		/**
  		 * A (storage) buffer attribute which was generated with a compute shader and
  		 * now defines indirect draw calls.
  		 *
  		 * Can only be used with {@link WebGPURenderer} and a WebGPU backend.
  		 *
  		 * @type {?BufferAttribute}
  		 * @default null
  		 */
  		this.indirect = null;

  		/**
  		 * This dictionary has as id the name of the attribute to be set and as value
  		 * the buffer attribute to set it to. Rather than accessing this property directly,
  		 * use `setAttribute()` and `getAttribute()` to access attributes of this geometry.
  		 *
  		 * @type {Object<string,(BufferAttribute|InterleavedBufferAttribute)>}
  		 */
  		this.attributes = {};

  		/**
  		 * This dictionary holds the morph targets of the geometry.
  		 *
  		 * Note: Once the geometry has been rendered, the morph attribute data cannot
  		 * be changed. You will have to call `dispose()?, and create a new geometry instance.
  		 *
  		 * @type {Object}
  		 */
  		this.morphAttributes = {};

  		/**
  		 * Used to control the morph target behavior; when set to `true`, the morph
  		 * target data is treated as relative offsets, rather than as absolute
  		 * positions/normals.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.morphTargetsRelative = false;

  		/**
  		 * Split the geometry into groups, each of which will be rendered in a
  		 * separate draw call. This allows an array of materials to be used with the geometry.
  		 *
  		 * Use `addGroup()` and `clearGroups()` to edit groups, rather than modifying this array directly.
  		 *
  		 * Every vertex and index must belong to exactly one group  groups must not share vertices or
  		 * indices, and must not leave vertices or indices unused.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.groups = [];

  		/**
  		 * Bounding box for the geometry which can be calculated with `computeBoundingBox()`.
  		 *
  		 * @type {?Box3}
  		 * @default null
  		 */
  		this.boundingBox = null;

  		/**
  		 * Bounding sphere for the geometry which can be calculated with `computeBoundingSphere()`.
  		 *
  		 * @type {?Sphere}
  		 * @default null
  		 */
  		this.boundingSphere = null;

  		/**
  		 * Determines the part of the geometry to render. This should not be set directly,
  		 * instead use `setDrawRange()`.
  		 *
  		 * @type {{start:number,count:number}}
  		 */
  		this.drawRange = { start: 0, count: Infinity };

  		/**
  		 * An object that can be used to store custom data about the geometry.
  		 * It should not hold references to functions as these will not be cloned.
  		 *
  		 * @type {Object}
  		 */
  		this.userData = {};

  	}

  	/**
  	 * Returns the index of this geometry.
  	 *
  	 * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
  	 */
  	getIndex() {

  		return this.index;

  	}

  	/**
  	 * Sets the given index to this geometry.
  	 *
  	 * @param {Array<number>|BufferAttribute} index - The index to set.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	setIndex( index ) {

  		if ( Array.isArray( index ) ) {

  			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

  		} else {

  			this.index = index;

  		}

  		return this;

  	}

  	/**
  	 * Sets the given indirect attribute to this geometry.
  	 *
  	 * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	setIndirect( indirect ) {

  		this.indirect = indirect;

  		return this;

  	}

  	/**
  	 * Returns the indirect attribute of this geometry.
  	 *
  	 * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
  	 */
  	getIndirect() {

  		return this.indirect;

  	}

  	/**
  	 * Returns the buffer attribute for the given name.
  	 *
  	 * @param {string} name - The attribute name.
  	 * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
  	 * Returns `undefined` if not attribute has been found.
  	 */
  	getAttribute( name ) {

  		return this.attributes[ name ];

  	}

  	/**
  	 * Sets the given attribute for the given name.
  	 *
  	 * @param {string} name - The attribute name.
  	 * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	setAttribute( name, attribute ) {

  		this.attributes[ name ] = attribute;

  		return this;

  	}

  	/**
  	 * Deletes the attribute for the given name.
  	 *
  	 * @param {string} name - The attribute name to delete.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	deleteAttribute( name ) {

  		delete this.attributes[ name ];

  		return this;

  	}

  	/**
  	 * Returns `true` if this geometry has an attribute for the given name.
  	 *
  	 * @param {string} name - The attribute name.
  	 * @return {boolean} Whether this geometry has an attribute for the given name or not.
  	 */
  	hasAttribute( name ) {

  		return this.attributes[ name ] !== undefined;

  	}

  	/**
  	 * Adds a group to this geometry.
  	 *
  	 * @param {number} start - The first element in this draw call. That is the first
  	 * vertex for non-indexed geometry, otherwise the first triangle index.
  	 * @param {number} count - Specifies how many vertices (or indices) are part of this group.
  	 * @param {number} [materialIndex=0] - The material array index to use.
  	 */
  	addGroup( start, count, materialIndex = 0 ) {

  		this.groups.push( {

  			start: start,
  			count: count,
  			materialIndex: materialIndex

  		} );

  	}

  	/**
  	 * Clears all groups.
  	 */
  	clearGroups() {

  		this.groups = [];

  	}

  	/**
  	 * Sets the draw range for this geometry.
  	 *
  	 * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
  	 * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
  	 * For indexed BufferGeometry, `count` is the number of indices to render.
  	 */
  	setDrawRange( start, count ) {

  		this.drawRange.start = start;
  		this.drawRange.count = count;

  	}

  	/**
  	 * Applies the given 4x4 transformation matrix to the geometry.
  	 *
  	 * @param {Matrix4} matrix - The matrix to apply.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	applyMatrix4( matrix ) {

  		const position = this.attributes.position;

  		if ( position !== undefined ) {

  			position.applyMatrix4( matrix );

  			position.needsUpdate = true;

  		}

  		const normal = this.attributes.normal;

  		if ( normal !== undefined ) {

  			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

  			normal.applyNormalMatrix( normalMatrix );

  			normal.needsUpdate = true;

  		}

  		const tangent = this.attributes.tangent;

  		if ( tangent !== undefined ) {

  			tangent.transformDirection( matrix );

  			tangent.needsUpdate = true;

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		return this;

  	}

  	/**
  	 * Applies the rotation represented by the Quaternion to the geometry.
  	 *
  	 * @param {Quaternion} q - The Quaternion to apply.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	applyQuaternion( q ) {

  		_m1$3.makeRotationFromQuaternion( q );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Rotates the geometry about the X axis. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	rotateX( angle ) {

  		// rotate geometry around world x-axis

  		_m1$3.makeRotationX( angle );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Rotates the geometry about the Y axis. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	rotateY( angle ) {

  		// rotate geometry around world y-axis

  		_m1$3.makeRotationY( angle );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Rotates the geometry about the Z axis. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#rotation} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {number} angle - The angle in radians.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	rotateZ( angle ) {

  		// rotate geometry around world z-axis

  		_m1$3.makeRotationZ( angle );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Translates the geometry. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#position} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {number} x - The x offset.
  	 * @param {number} y - The y offset.
  	 * @param {number} z - The z offset.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	translate( x, y, z ) {

  		// translate geometry

  		_m1$3.makeTranslation( x, y, z );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Scales the geometry. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#scale} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {number} x - The x scale.
  	 * @param {number} y - The y scale.
  	 * @param {number} z - The z scale.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	scale( x, y, z ) {

  		// scale geometry

  		_m1$3.makeScale( x, y, z );

  		this.applyMatrix4( _m1$3 );

  		return this;

  	}

  	/**
  	 * Rotates the geometry to face a point in 3D space. This is typically done as a one time
  	 * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
  	 * real-time mesh rotation.
  	 *
  	 * @param {Vector3} vector - The target point.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	lookAt( vector ) {

  		_obj.lookAt( vector );

  		_obj.updateMatrix();

  		this.applyMatrix4( _obj.matrix );

  		return this;

  	}

  	/**
  	 * Center the geometry based on its bounding box.
  	 *
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	center() {

  		this.computeBoundingBox();

  		this.boundingBox.getCenter( _offset ).negate();

  		this.translate( _offset.x, _offset.y, _offset.z );

  		return this;

  	}

  	/**
  	 * Defines a geometry by creating a `position` attribute based on the given array of points. The array
  	 * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
  	 * set to `0`.
  	 *
  	 * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
  	 * data from the array. The length of the array must match the vertex count.
  	 *
  	 * @param {Array<Vector2>|Array<Vector3>} points - The points.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	setFromPoints( points ) {

  		const positionAttribute = this.getAttribute( 'position' );

  		if ( positionAttribute === undefined ) {

  			const position = [];

  			for ( let i = 0, l = points.length; i < l; i ++ ) {

  				const point = points[ i ];
  				position.push( point.x, point.y, point.z || 0 );

  			}

  			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

  		} else {

  			const l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size

  			for ( let i = 0; i < l; i ++ ) {

  				const point = points[ i ];
  				positionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );

  			}

  			if ( points.length > positionAttribute.count ) {

  				console.warn( 'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );

  			}

  			positionAttribute.needsUpdate = true;

  		}

  		return this;

  	}

  	/**
  	 * Computes the bounding box of the geometry, and updates the `boundingBox` member.
  	 * The bounding box is not computed by the engine; it must be computed by your app.
  	 * You may need to recompute the bounding box if the geometry vertices are modified.
  	 */
  	computeBoundingBox() {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		const position = this.attributes.position;
  		const morphAttributesPosition = this.morphAttributes.position;

  		if ( position && position.isGLBufferAttribute ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );

  			this.boundingBox.set(
  				new Vector3( - Infinity, - Infinity, - Infinity ),
  				new Vector3( + Infinity, + Infinity, + Infinity )
  			);

  			return;

  		}

  		if ( position !== undefined ) {

  			this.boundingBox.setFromBufferAttribute( position );

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					_box$2.setFromBufferAttribute( morphAttribute );

  					if ( this.morphTargetsRelative ) {

  						_vector$8.addVectors( this.boundingBox.min, _box$2.min );
  						this.boundingBox.expandByPoint( _vector$8 );

  						_vector$8.addVectors( this.boundingBox.max, _box$2.max );
  						this.boundingBox.expandByPoint( _vector$8 );

  					} else {

  						this.boundingBox.expandByPoint( _box$2.min );
  						this.boundingBox.expandByPoint( _box$2.max );

  					}

  				}

  			}

  		} else {

  			this.boundingBox.makeEmpty();

  		}

  		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

  		}

  	}

  	/**
  	 * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
  	 * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
  	 * You may need to recompute the bounding sphere if the geometry vertices are modified.
  	 */
  	computeBoundingSphere() {

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere();

  		}

  		const position = this.attributes.position;
  		const morphAttributesPosition = this.morphAttributes.position;

  		if ( position && position.isGLBufferAttribute ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );

  			this.boundingSphere.set( new Vector3(), Infinity );

  			return;

  		}

  		if ( position ) {

  			// first, find the center of the bounding sphere

  			const center = this.boundingSphere.center;

  			_box$2.setFromBufferAttribute( position );

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

  					if ( this.morphTargetsRelative ) {

  						_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );
  						_box$2.expandByPoint( _vector$8 );

  						_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );
  						_box$2.expandByPoint( _vector$8 );

  					} else {

  						_box$2.expandByPoint( _boxMorphTargets.min );
  						_box$2.expandByPoint( _boxMorphTargets.max );

  					}

  				}

  			}

  			_box$2.getCenter( center );

  			// second, try to find a boundingSphere with a radius smaller than the
  			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

  			let maxRadiusSq = 0;

  			for ( let i = 0, il = position.count; i < il; i ++ ) {

  				_vector$8.fromBufferAttribute( position, i );

  				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

  			}

  			// process morph attributes if present

  			if ( morphAttributesPosition ) {

  				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  					const morphAttribute = morphAttributesPosition[ i ];
  					const morphTargetsRelative = this.morphTargetsRelative;

  					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

  						_vector$8.fromBufferAttribute( morphAttribute, j );

  						if ( morphTargetsRelative ) {

  							_offset.fromBufferAttribute( position, j );
  							_vector$8.add( _offset );

  						}

  						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

  					}

  				}

  			}

  			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

  			if ( isNaN( this.boundingSphere.radius ) ) {

  				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

  			}

  		}

  	}

  	/**
  	 * Calculates and adds a tangent attribute to this geometry.
  	 *
  	 * The computation is only supported for indexed geometries and if position, normal, and uv attributes
  	 * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
  	 * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
  	 */
  	computeTangents() {

  		const index = this.index;
  		const attributes = this.attributes;

  		// based on http://www.terathon.com/code/tangent.html
  		// (per vertex tangents)

  		if ( index === null ||
  			 attributes.position === undefined ||
  			 attributes.normal === undefined ||
  			 attributes.uv === undefined ) {

  			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
  			return;

  		}

  		const positionAttribute = attributes.position;
  		const normalAttribute = attributes.normal;
  		const uvAttribute = attributes.uv;

  		if ( this.hasAttribute( 'tangent' ) === false ) {

  			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );

  		}

  		const tangentAttribute = this.getAttribute( 'tangent' );

  		const tan1 = [], tan2 = [];

  		for ( let i = 0; i < positionAttribute.count; i ++ ) {

  			tan1[ i ] = new Vector3();
  			tan2[ i ] = new Vector3();

  		}

  		const vA = new Vector3(),
  			vB = new Vector3(),
  			vC = new Vector3(),

  			uvA = new Vector2(),
  			uvB = new Vector2(),
  			uvC = new Vector2(),

  			sdir = new Vector3(),
  			tdir = new Vector3();

  		function handleTriangle( a, b, c ) {

  			vA.fromBufferAttribute( positionAttribute, a );
  			vB.fromBufferAttribute( positionAttribute, b );
  			vC.fromBufferAttribute( positionAttribute, c );

  			uvA.fromBufferAttribute( uvAttribute, a );
  			uvB.fromBufferAttribute( uvAttribute, b );
  			uvC.fromBufferAttribute( uvAttribute, c );

  			vB.sub( vA );
  			vC.sub( vA );

  			uvB.sub( uvA );
  			uvC.sub( uvA );

  			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

  			// silently ignore degenerate uv triangles having coincident or colinear vertices

  			if ( ! isFinite( r ) ) return;

  			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
  			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

  			tan1[ a ].add( sdir );
  			tan1[ b ].add( sdir );
  			tan1[ c ].add( sdir );

  			tan2[ a ].add( tdir );
  			tan2[ b ].add( tdir );
  			tan2[ c ].add( tdir );

  		}

  		let groups = this.groups;

  		if ( groups.length === 0 ) {

  			groups = [ {
  				start: 0,
  				count: index.count
  			} ];

  		}

  		for ( let i = 0, il = groups.length; i < il; ++ i ) {

  			const group = groups[ i ];

  			const start = group.start;
  			const count = group.count;

  			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

  				handleTriangle(
  					index.getX( j + 0 ),
  					index.getX( j + 1 ),
  					index.getX( j + 2 )
  				);

  			}

  		}

  		const tmp = new Vector3(), tmp2 = new Vector3();
  		const n = new Vector3(), n2 = new Vector3();

  		function handleVertex( v ) {

  			n.fromBufferAttribute( normalAttribute, v );
  			n2.copy( n );

  			const t = tan1[ v ];

  			// Gram-Schmidt orthogonalize

  			tmp.copy( t );
  			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

  			// Calculate handedness

  			tmp2.crossVectors( n2, t );
  			const test = tmp2.dot( tan2[ v ] );
  			const w = ( test < 0.0 ) ? -1 : 1.0;

  			tangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );

  		}

  		for ( let i = 0, il = groups.length; i < il; ++ i ) {

  			const group = groups[ i ];

  			const start = group.start;
  			const count = group.count;

  			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

  				handleVertex( index.getX( j + 0 ) );
  				handleVertex( index.getX( j + 1 ) );
  				handleVertex( index.getX( j + 2 ) );

  			}

  		}

  	}

  	/**
  	 * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
  	 * each vertex normal to be the average of the face normals of the faces that share that vertex.
  	 * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
  	 * to be the same as the face normal.
  	 */
  	computeVertexNormals() {

  		const index = this.index;
  		const positionAttribute = this.getAttribute( 'position' );

  		if ( positionAttribute !== undefined ) {

  			let normalAttribute = this.getAttribute( 'normal' );

  			if ( normalAttribute === undefined ) {

  				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
  				this.setAttribute( 'normal', normalAttribute );

  			} else {

  				// reset existing normals to zero

  				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

  					normalAttribute.setXYZ( i, 0, 0, 0 );

  				}

  			}

  			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
  			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
  			const cb = new Vector3(), ab = new Vector3();

  			// indexed elements

  			if ( index ) {

  				for ( let i = 0, il = index.count; i < il; i += 3 ) {

  					const vA = index.getX( i + 0 );
  					const vB = index.getX( i + 1 );
  					const vC = index.getX( i + 2 );

  					pA.fromBufferAttribute( positionAttribute, vA );
  					pB.fromBufferAttribute( positionAttribute, vB );
  					pC.fromBufferAttribute( positionAttribute, vC );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					nA.fromBufferAttribute( normalAttribute, vA );
  					nB.fromBufferAttribute( normalAttribute, vB );
  					nC.fromBufferAttribute( normalAttribute, vC );

  					nA.add( cb );
  					nB.add( cb );
  					nC.add( cb );

  					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
  					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
  					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

  				}

  			} else {

  				// non-indexed elements (unconnected triangle soup)

  				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

  					pA.fromBufferAttribute( positionAttribute, i + 0 );
  					pB.fromBufferAttribute( positionAttribute, i + 1 );
  					pC.fromBufferAttribute( positionAttribute, i + 2 );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
  					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
  					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

  				}

  			}

  			this.normalizeNormals();

  			normalAttribute.needsUpdate = true;

  		}

  	}

  	/**
  	 * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
  	 * correct lighting on the geometry surfaces.
  	 */
  	normalizeNormals() {

  		const normals = this.attributes.normal;

  		for ( let i = 0, il = normals.count; i < il; i ++ ) {

  			_vector$8.fromBufferAttribute( normals, i );

  			_vector$8.normalize();

  			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

  		}

  	}

  	/**
  	 * Return a new non-index version of this indexed geometry. If the geometry
  	 * is already non-indexed, the method is a NOOP.
  	 *
  	 * @return {BufferGeometry} The non-indexed version of this indexed geometry.
  	 */
  	toNonIndexed() {

  		function convertBufferAttribute( attribute, indices ) {

  			const array = attribute.array;
  			const itemSize = attribute.itemSize;
  			const normalized = attribute.normalized;

  			const array2 = new array.constructor( indices.length * itemSize );

  			let index = 0, index2 = 0;

  			for ( let i = 0, l = indices.length; i < l; i ++ ) {

  				if ( attribute.isInterleavedBufferAttribute ) {

  					index = indices[ i ] * attribute.data.stride + attribute.offset;

  				} else {

  					index = indices[ i ] * itemSize;

  				}

  				for ( let j = 0; j < itemSize; j ++ ) {

  					array2[ index2 ++ ] = array[ index ++ ];

  				}

  			}

  			return new BufferAttribute( array2, itemSize, normalized );

  		}

  		//

  		if ( this.index === null ) {

  			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
  			return this;

  		}

  		const geometry2 = new BufferGeometry();

  		const indices = this.index.array;
  		const attributes = this.attributes;

  		// attributes

  		for ( const name in attributes ) {

  			const attribute = attributes[ name ];

  			const newAttribute = convertBufferAttribute( attribute, indices );

  			geometry2.setAttribute( name, newAttribute );

  		}

  		// morph attributes

  		const morphAttributes = this.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const morphArray = [];
  			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

  				const attribute = morphAttribute[ i ];

  				const newAttribute = convertBufferAttribute( attribute, indices );

  				morphArray.push( newAttribute );

  			}

  			geometry2.morphAttributes[ name ] = morphArray;

  		}

  		geometry2.morphTargetsRelative = this.morphTargetsRelative;

  		// groups

  		const groups = this.groups;

  		for ( let i = 0, l = groups.length; i < l; i ++ ) {

  			const group = groups[ i ];
  			geometry2.addGroup( group.start, group.count, group.materialIndex );

  		}

  		return geometry2;

  	}

  	/**
  	 * Serializes the geometry into JSON.
  	 *
  	 * @return {Object} A JSON object representing the serialized geometry.
  	 */
  	toJSON() {

  		const data = {
  			metadata: {
  				version: 4.7,
  				type: 'BufferGeometry',
  				generator: 'BufferGeometry.toJSON'
  			}
  		};

  		// standard BufferGeometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) data.name = this.name;
  		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

  		if ( this.parameters !== undefined ) {

  			const parameters = this.parameters;

  			for ( const key in parameters ) {

  				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

  			}

  			return data;

  		}

  		// for simplicity the code assumes attributes are not shared across geometries, see #15811

  		data.data = { attributes: {} };

  		const index = this.index;

  		if ( index !== null ) {

  			data.data.index = {
  				type: index.array.constructor.name,
  				array: Array.prototype.slice.call( index.array )
  			};

  		}

  		const attributes = this.attributes;

  		for ( const key in attributes ) {

  			const attribute = attributes[ key ];

  			data.data.attributes[ key ] = attribute.toJSON( data.data );

  		}

  		const morphAttributes = {};
  		let hasMorphAttributes = false;

  		for ( const key in this.morphAttributes ) {

  			const attributeArray = this.morphAttributes[ key ];

  			const array = [];

  			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

  				const attribute = attributeArray[ i ];

  				array.push( attribute.toJSON( data.data ) );

  			}

  			if ( array.length > 0 ) {

  				morphAttributes[ key ] = array;

  				hasMorphAttributes = true;

  			}

  		}

  		if ( hasMorphAttributes ) {

  			data.data.morphAttributes = morphAttributes;
  			data.data.morphTargetsRelative = this.morphTargetsRelative;

  		}

  		const groups = this.groups;

  		if ( groups.length > 0 ) {

  			data.data.groups = JSON.parse( JSON.stringify( groups ) );

  		}

  		const boundingSphere = this.boundingSphere;

  		if ( boundingSphere !== null ) {

  			data.data.boundingSphere = boundingSphere.toJSON();

  		}

  		return data;

  	}

  	/**
  	 * Returns a new geometry with copied values from this instance.
  	 *
  	 * @return {BufferGeometry} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Copies the values of the given geometry to this instance.
  	 *
  	 * @param {BufferGeometry} source - The geometry to copy.
  	 * @return {BufferGeometry} A reference to this instance.
  	 */
  	copy( source ) {

  		// reset

  		this.index = null;
  		this.attributes = {};
  		this.morphAttributes = {};
  		this.groups = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// used for storing cloned, shared data

  		const data = {};

  		// name

  		this.name = source.name;

  		// index

  		const index = source.index;

  		if ( index !== null ) {

  			this.setIndex( index.clone() );

  		}

  		// attributes

  		const attributes = source.attributes;

  		for ( const name in attributes ) {

  			const attribute = attributes[ name ];
  			this.setAttribute( name, attribute.clone( data ) );

  		}

  		// morph attributes

  		const morphAttributes = source.morphAttributes;

  		for ( const name in morphAttributes ) {

  			const array = [];
  			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

  				array.push( morphAttribute[ i ].clone( data ) );

  			}

  			this.morphAttributes[ name ] = array;

  		}

  		this.morphTargetsRelative = source.morphTargetsRelative;

  		// groups

  		const groups = source.groups;

  		for ( let i = 0, l = groups.length; i < l; i ++ ) {

  			const group = groups[ i ];
  			this.addGroup( group.start, group.count, group.materialIndex );

  		}

  		// bounding box

  		const boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		const boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// draw range

  		this.drawRange.start = source.drawRange.start;
  		this.drawRange.count = source.drawRange.count;

  		// user data

  		this.userData = source.userData;

  		return this;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 *
  	 * @fires BufferGeometry#dispose
  	 */
  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  }

  const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();
  const _ray$3 = /*@__PURE__*/ new Ray();
  const _sphere$6 = /*@__PURE__*/ new Sphere();
  const _sphereHitAt = /*@__PURE__*/ new Vector3();

  const _vA$1 = /*@__PURE__*/ new Vector3();
  const _vB$1 = /*@__PURE__*/ new Vector3();
  const _vC$1 = /*@__PURE__*/ new Vector3();

  const _tempA = /*@__PURE__*/ new Vector3();
  const _morphA = /*@__PURE__*/ new Vector3();

  const _intersectionPoint = /*@__PURE__*/ new Vector3();
  const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

  /**
   * Class representing triangular polygon mesh based objects.
   *
   * ```js
   * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
   * const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
   * const mesh = new THREE.Mesh( geometry, material );
   * scene.add( mesh );
   * ```
   *
   * @augments Object3D
   */
  class Mesh extends Object3D {

  	/**
  	 * Constructs a new mesh.
  	 *
  	 * @param {BufferGeometry} [geometry] - The mesh geometry.
  	 * @param {Material|Array<Material>} [material] - The mesh material.
  	 */
  	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMesh = true;

  		this.type = 'Mesh';

  		/**
  		 * The mesh geometry.
  		 *
  		 * @type {BufferGeometry}
  		 */
  		this.geometry = geometry;

  		/**
  		 * The mesh material.
  		 *
  		 * @type {Material|Array<Material>}
  		 * @default MeshBasicMaterial
  		 */
  		this.material = material;

  		/**
  		 * A dictionary representing the morph targets in the geometry. The key is the
  		 * morph targets name, the value its attribute index. This member is `undefined`
  		 * by default and only set when morph targets are detected in the geometry.
  		 *
  		 * @type {Object<String,number>|undefined}
  		 * @default undefined
  		 */
  		this.morphTargetDictionary = undefined;

  		/**
  		 * An array of weights typically in the range `[0,1]` that specify how much of the morph
  		 * is applied. This member is `undefined` by default and only set when morph targets are
  		 * detected in the geometry.
  		 *
  		 * @type {Array<number>|undefined}
  		 * @default undefined
  		 */
  		this.morphTargetInfluences = undefined;

  		/**
  		 * The number of instances of this mesh.
  		 * Can only be used with {@link WebGPURenderer}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.count = 1;

  		this.updateMorphTargets();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		if ( source.morphTargetInfluences !== undefined ) {

  			this.morphTargetInfluences = source.morphTargetInfluences.slice();

  		}

  		if ( source.morphTargetDictionary !== undefined ) {

  			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

  		}

  		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
  		this.geometry = source.geometry;

  		return this;

  	}

  	/**
  	 * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
  	 * to make sure existing morph targets can influence this 3D object.
  	 */
  	updateMorphTargets() {

  		const geometry = this.geometry;

  		const morphAttributes = geometry.morphAttributes;
  		const keys = Object.keys( morphAttributes );

  		if ( keys.length > 0 ) {

  			const morphAttribute = morphAttributes[ keys[ 0 ] ];

  			if ( morphAttribute !== undefined ) {

  				this.morphTargetInfluences = [];
  				this.morphTargetDictionary = {};

  				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  					const name = morphAttribute[ m ].name || String( m );

  					this.morphTargetInfluences.push( 0 );
  					this.morphTargetDictionary[ name ] = m;

  				}

  			}

  		}

  	}

  	/**
  	 * Returns the local-space position of the vertex at the given index, taking into
  	 * account the current animation state of both morph targets and skinning.
  	 *
  	 * @param {number} index - The vertex index.
  	 * @param {Vector3} target - The target object that is used to store the method's result.
  	 * @return {Vector3} The vertex position in local space.
  	 */
  	getVertexPosition( index, target ) {

  		const geometry = this.geometry;
  		const position = geometry.attributes.position;
  		const morphPosition = geometry.morphAttributes.position;
  		const morphTargetsRelative = geometry.morphTargetsRelative;

  		target.fromBufferAttribute( position, index );

  		const morphInfluences = this.morphTargetInfluences;

  		if ( morphPosition && morphInfluences ) {

  			_morphA.set( 0, 0, 0 );

  			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

  				const influence = morphInfluences[ i ];
  				const morphAttribute = morphPosition[ i ];

  				if ( influence === 0 ) continue;

  				_tempA.fromBufferAttribute( morphAttribute, index );

  				if ( morphTargetsRelative ) {

  					_morphA.addScaledVector( _tempA, influence );

  				} else {

  					_morphA.addScaledVector( _tempA.sub( target ), influence );

  				}

  			}

  			target.add( _morphA );

  		}

  		return target;

  	}

  	/**
  	 * Computes intersection points between a casted ray and this line.
  	 *
  	 * @param {Raycaster} raycaster - The raycaster.
  	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
  	 */
  	raycast( raycaster, intersects ) {

  		const geometry = this.geometry;
  		const material = this.material;
  		const matrixWorld = this.matrixWorld;

  		if ( material === undefined ) return;

  		// test with bounding sphere in world space

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere$6.copy( geometry.boundingSphere );
  		_sphere$6.applyMatrix4( matrixWorld );

  		// check distance from ray origin to bounding sphere

  		_ray$3.copy( raycaster.ray ).recast( raycaster.near );

  		if ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {

  			if ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;

  			if ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

  		}

  		// convert ray to local space of mesh

  		_inverseMatrix$3.copy( matrixWorld ).invert();
  		_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );

  		// test with bounding box in local space

  		if ( geometry.boundingBox !== null ) {

  			if ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;

  		}

  		// test for intersections with geometry

  		this._computeIntersections( raycaster, intersects, _ray$3 );

  	}

  	_computeIntersections( raycaster, intersects, rayLocalSpace ) {

  		let intersection;

  		const geometry = this.geometry;
  		const material = this.material;

  		const index = geometry.index;
  		const position = geometry.attributes.position;
  		const uv = geometry.attributes.uv;
  		const uv1 = geometry.attributes.uv1;
  		const normal = geometry.attributes.normal;
  		const groups = geometry.groups;
  		const drawRange = geometry.drawRange;

  		if ( index !== null ) {

  			// indexed buffer geometry

  			if ( Array.isArray( material ) ) {

  				for ( let i = 0, il = groups.length; i < il; i ++ ) {

  					const group = groups[ i ];
  					const groupMaterial = material[ group.materialIndex ];

  					const start = Math.max( group.start, drawRange.start );
  					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

  					for ( let j = start, jl = end; j < jl; j += 3 ) {

  						const a = index.getX( j );
  						const b = index.getX( j + 1 );
  						const c = index.getX( j + 2 );

  						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
  							intersection.face.materialIndex = group.materialIndex;
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, il = end; i < il; i += 3 ) {

  					const a = index.getX( i );
  					const b = index.getX( i + 1 );
  					const c = index.getX( i + 2 );

  					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  					if ( intersection ) {

  						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
  						intersects.push( intersection );

  					}

  				}

  			}

  		} else if ( position !== undefined ) {

  			// non-indexed buffer geometry

  			if ( Array.isArray( material ) ) {

  				for ( let i = 0, il = groups.length; i < il; i ++ ) {

  					const group = groups[ i ];
  					const groupMaterial = material[ group.materialIndex ];

  					const start = Math.max( group.start, drawRange.start );
  					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

  					for ( let j = start, jl = end; j < jl; j += 3 ) {

  						const a = j;
  						const b = j + 1;
  						const c = j + 2;

  						intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
  							intersection.face.materialIndex = group.materialIndex;
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else {

  				const start = Math.max( 0, drawRange.start );
  				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

  				for ( let i = start, il = end; i < il; i += 3 ) {

  					const a = i;
  					const b = i + 1;
  					const c = i + 2;

  					intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

  					if ( intersection ) {

  						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
  						intersects.push( intersection );

  					}

  				}

  			}

  		}

  	}

  }

  function checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {

  	let intersect;

  	if ( material.side === BackSide ) {

  		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

  	} else {

  		intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

  	}

  	if ( intersect === null ) return null;

  	_intersectionPointWorld.copy( point );
  	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

  	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

  	if ( distance < raycaster.near || distance > raycaster.far ) return null;

  	return {
  		distance: distance,
  		point: _intersectionPointWorld.clone(),
  		object: object
  	};

  }

  function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

  	object.getVertexPosition( a, _vA$1 );
  	object.getVertexPosition( b, _vB$1 );
  	object.getVertexPosition( c, _vC$1 );

  	const intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

  	if ( intersection ) {

  		const barycoord = new Vector3();
  		Triangle.getBarycoord( _intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord );

  		if ( uv ) {

  			intersection.uv = Triangle.getInterpolatedAttribute( uv, a, b, c, barycoord, new Vector2() );

  		}

  		if ( uv1 ) {

  			intersection.uv1 = Triangle.getInterpolatedAttribute( uv1, a, b, c, barycoord, new Vector2() );

  		}

  		if ( normal ) {

  			intersection.normal = Triangle.getInterpolatedAttribute( normal, a, b, c, barycoord, new Vector3() );

  			if ( intersection.normal.dot( ray.direction ) > 0 ) {

  				intersection.normal.multiplyScalar( -1 );

  			}

  		}

  		const face = {
  			a: a,
  			b: b,
  			c: c,
  			normal: new Vector3(),
  			materialIndex: 0
  		};

  		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

  		intersection.face = face;
  		intersection.barycoord = barycoord;

  	}

  	return intersection;

  }

  /**
   * A geometry class for a rectangular cuboid with a given width, height, and depth.
   * On creation, the cuboid is centred on the origin, with each edge parallel to one
   * of the axes.
   *
   * ```js
   * const geometry = new THREE.BoxGeometry( 1, 1, 1 );
   * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
   * const cube = new THREE.Mesh( geometry, material );
   * scene.add( cube );
   * ```
   *
   * @augments BufferGeometry
   */
  class BoxGeometry extends BufferGeometry {

  	/**
  	 * Constructs a new box geometry.
  	 *
  	 * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
  	 * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
  	 * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
  	 * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
  	 * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
  	 * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
  	 */
  	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

  		super();

  		this.type = 'BoxGeometry';

  		/**
  		 * Holds the constructor parameters that have been
  		 * used to generate the geometry. Any modification
  		 * after instantiation does not change the geometry.
  		 *
  		 * @type {Object}
  		 */
  		this.parameters = {
  			width: width,
  			height: height,
  			depth: depth,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			depthSegments: depthSegments
  		};

  		const scope = this;

  		// segments

  		widthSegments = Math.floor( widthSegments );
  		heightSegments = Math.floor( heightSegments );
  		depthSegments = Math.floor( depthSegments );

  		// buffers

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		// helper variables

  		let numberOfVertices = 0;
  		let groupStart = 0;

  		// build each side of the box geometry

  		buildPlane( 'z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0 ); // px
  		buildPlane( 'z', 'y', 'x', 1, -1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
  		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
  		buildPlane( 'x', 'z', 'y', 1, -1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
  		buildPlane( 'x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
  		buildPlane( 'x', 'y', 'z', -1, -1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

  		// build geometry

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

  			const segmentWidth = width / gridX;
  			const segmentHeight = height / gridY;

  			const widthHalf = width / 2;
  			const heightHalf = height / 2;
  			const depthHalf = depth / 2;

  			const gridX1 = gridX + 1;
  			const gridY1 = gridY + 1;

  			let vertexCounter = 0;
  			let groupCount = 0;

  			const vector = new Vector3();

  			// generate vertices, normals and uvs

  			for ( let iy = 0; iy < gridY1; iy ++ ) {

  				const y = iy * segmentHeight - heightHalf;

  				for ( let ix = 0; ix < gridX1; ix ++ ) {

  					const x = ix * segmentWidth - widthHalf;

  					// set values to correct vector component

  					vector[ u ] = x * udir;
  					vector[ v ] = y * vdir;
  					vector[ w ] = depthHalf;

  					// now apply vector to vertex buffer

  					vertices.push( vector.x, vector.y, vector.z );

  					// set values to correct vector component

  					vector[ u ] = 0;
  					vector[ v ] = 0;
  					vector[ w ] = depth > 0 ? 1 : -1;

  					// now apply vector to normal buffer

  					normals.push( vector.x, vector.y, vector.z );

  					// uvs

  					uvs.push( ix / gridX );
  					uvs.push( 1 - ( iy / gridY ) );

  					// counters

  					vertexCounter += 1;

  				}

  			}

  			// indices

  			// 1. you need three indices to draw a single face
  			// 2. a single segment consists of two faces
  			// 3. so we need to generate six (2*3) indices per segment

  			for ( let iy = 0; iy < gridY; iy ++ ) {

  				for ( let ix = 0; ix < gridX; ix ++ ) {

  					const a = numberOfVertices + ix + gridX1 * iy;
  					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
  					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
  					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

  					// faces

  					indices.push( a, b, d );
  					indices.push( b, c, d );

  					// increase counter

  					groupCount += 6;

  				}

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, materialIndex );

  			// calculate new start value for groups

  			groupStart += groupCount;

  			// update total number of vertices

  			numberOfVertices += vertexCounter;

  		}

  	}

  	copy( source ) {

  		super.copy( source );

  		this.parameters = Object.assign( {}, source.parameters );

  		return this;

  	}

  	/**
  	 * Factory method for creating an instance of this class from the given
  	 * JSON object.
  	 *
  	 * @param {Object} data - A JSON object representing the serialized geometry.
  	 * @return {BoxGeometry} A new instance.
  	 */
  	static fromJSON( data ) {

  		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

  	}

  }

  // Uniform Utilities

  function cloneUniforms( src ) {

  	const dst = {};

  	for ( const u in src ) {

  		dst[ u ] = {};

  		for ( const p in src[ u ] ) {

  			const property = src[ u ][ p ];

  			if ( property && ( property.isColor ||
  				property.isMatrix3 || property.isMatrix4 ||
  				property.isVector2 || property.isVector3 || property.isVector4 ||
  				property.isTexture || property.isQuaternion ) ) {

  				if ( property.isRenderTargetTexture ) {

  					console.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );
  					dst[ u ][ p ] = null;

  				} else {

  					dst[ u ][ p ] = property.clone();

  				}

  			} else if ( Array.isArray( property ) ) {

  				dst[ u ][ p ] = property.slice();

  			} else {

  				dst[ u ][ p ] = property;

  			}

  		}

  	}

  	return dst;

  }

  function mergeUniforms( uniforms ) {

  	const merged = {};

  	for ( let u = 0; u < uniforms.length; u ++ ) {

  		const tmp = cloneUniforms( uniforms[ u ] );

  		for ( const p in tmp ) {

  			merged[ p ] = tmp[ p ];

  		}

  	}

  	return merged;

  }

  function cloneUniformsGroups( src ) {

  	const dst = [];

  	for ( let u = 0; u < src.length; u ++ ) {

  		dst.push( src[ u ].clone() );

  	}

  	return dst;

  }

  function getUnlitUniformColorSpace( renderer ) {

  	const currentRenderTarget = renderer.getRenderTarget();

  	if ( currentRenderTarget === null ) {

  		// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
  		return renderer.outputColorSpace;

  	}

  	// https://github.com/mrdoob/three.js/issues/27868
  	if ( currentRenderTarget.isXRRenderTarget === true ) {

  		return currentRenderTarget.texture.colorSpace;

  	}

  	return ColorManagement.workingColorSpace;

  }

  // Legacy

  const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

  var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

  var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

  /**
   * A material rendered with custom shaders. A shader is a small program written in GLSL.
   * that runs on the GPU. You may want to use a custom shader if you need to implement an
   * effect not included with any of the built-in materials.
   *
   * There are the following notes to bear in mind when using a `ShaderMaterial`:
   *
   * - `ShaderMaterial` can only be used with {@link WebGLRenderer}.
   * - Built in attributes and uniforms are passed to the shaders along with your code. If
   * you don't want that, use {@link RawShaderMaterial} instead.
   * - You can use the directive `#pragma unroll_loop_start` and `#pragma unroll_loop_end`
   * in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has
   * to be placed right above the loop. The loop formatting has to correspond to a defined standard.
   *   - The loop has to be [normalized]{@link https://en.wikipedia.org/wiki/Normalized_loop}.
   *   - The loop variable has to be *i*.
   *   - The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly
   * value of *i* for the given iteration and can be used in preprocessor
   * statements.
   *
   * ```js
   * const material = new THREE.ShaderMaterial( {
   * 	uniforms: {
   * 		time: { value: 1.0 },
   * 		resolution: { value: new THREE.Vector2() }
   * 	},
   * 	vertexShader: document.getElementById( 'vertexShader' ).textContent,
   * 	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
   * } );
   * ```
   *
   * @augments Material
   */
  class ShaderMaterial extends Material {

  	/**
  	 * Constructs a new shader material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isShaderMaterial = true;

  		this.type = 'ShaderMaterial';

  		/**
  		 * Defines custom constants using `#define` directives within the GLSL code
  		 * for both the vertex shader and the fragment shader; each key/value pair
  		 * yields another directive.
  		 * ```js
  		 * defines: {
  		 * 	FOO: 15,
  		 * 	BAR: true
  		 * }
  		 * ```
  		 * Yields the lines:
  		 * ```
  		 * #define FOO 15
  		 * #define BAR true
  		 * ```
  		 *
  		 * @type {Object}
  		 */
  		this.defines = {};

  		/**
  		 * An object of the form:
  		 * ```js
  		 * {
  		 * 	"uniform1": { value: 1.0 },
  		 * 	"uniform2": { value: 2 }
  		 * }
  		 * ```
  		 * specifying the uniforms to be passed to the shader code; keys are uniform
  		 * names, values are definitions of the form
  		 * ```
  		 * {
  		 * 	value: 1.0
  		 * }
  		 * ```
  		 * where `value` is the value of the uniform. Names must match the name of
  		 * the uniform, as defined in the GLSL code. Note that uniforms are refreshed
  		 * on every frame, so updating the value of the uniform will immediately
  		 * update the value available to the GLSL code.
  		 *
  		 * @type {Object}
  		 */
  		this.uniforms = {};

  		/**
  		 * An array holding uniforms groups for configuring UBOs.
  		 *
  		 * @type {Array<UniformsGroup>}
  		 */
  		this.uniformsGroups = [];

  		/**
  		 * Vertex shader GLSL code. This is the actual code for the shader.
  		 *
  		 * @type {string}
  		 */
  		this.vertexShader = default_vertex;

  		/**
  		 * Fragment shader GLSL code. This is the actual code for the shader.
  		 *
  		 * @type {string}
  		 */
  		this.fragmentShader = default_fragment;

  		/**
  		 * Controls line thickness or lines.
  		 *
  		 * WebGL and WebGPU ignore this setting and always render line primitives with a
  		 * width of one pixel.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.linewidth = 1;

  		/**
  		 * Renders the geometry as a wireframe.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.wireframe = false;

  		/**
  		 * Controls the thickness of the wireframe.
  		 *
  		 * WebGL and WebGPU ignore this property and always render
  		 * 1 pixel wide lines.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.wireframeLinewidth = 1;

  		/**
  		 * Define whether the material color is affected by global fog settings; `true`
  		 * to pass fog uniforms to the shader.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.fog = false;

  		/**
  		 * Defines whether this material uses lighting; `true` to pass uniform data
  		 * related to lighting to this shader.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.lights = false;

  		/**
  		 * Defines whether this material supports clipping; `true` to let the renderer
  		 * pass the clippingPlanes uniform.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.clipping = false;

  		/**
  		 * Overwritten and set to `true` by default.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.forceSinglePass = true;

  		/**
  		 * This object allows to enable certain WebGL 2 extensions.
  		 *
  		 * - clipCullDistance: set to `true` to use vertex shader clipping
  		 * - multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID
  		 *
  		 * @type {{clipCullDistance:false,multiDraw:false}}
  		 */
  		this.extensions = {
  			clipCullDistance: false, // set to use vertex shader clipping
  			multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
  		};

  		/**
  		 * When the rendered geometry doesn't include these attributes but the
  		 * material does, these default values will be passed to the shaders. This
  		 * avoids errors when buffer data is missing.
  		 *
  		 * - color: [ 1, 1, 1 ]
  		 * - uv: [ 0, 0 ]
  		 * - uv1: [ 0, 0 ]
  		 *
  		 * @type {Object}
  		 */
  		this.defaultAttributeValues = {
  			'color': [ 1, 1, 1 ],
  			'uv': [ 0, 0 ],
  			'uv1': [ 0, 0 ]
  		};

  		/**
  		 * If set, this calls [gl.bindAttribLocation]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation}
  		 * to bind a generic vertex index to an attribute variable.
  		 *
  		 * @type {string|undefined}
  		 * @default undefined
  		 */
  		this.index0AttributeName = undefined;

  		/**
  		 * Can be used to force a uniform update while changing uniforms in
  		 * {@link Object3D#onBeforeRender}.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.uniformsNeedUpdate = false;

  		/**
  		 * Defines the GLSL version of custom shader code.
  		 *
  		 * @type {?(GLSL1|GLSL3)}
  		 * @default null
  		 */
  		this.glslVersion = null;

  		if ( parameters !== undefined ) {

  			this.setValues( parameters );

  		}

  	}

  	copy( source ) {

  		super.copy( source );

  		this.fragmentShader = source.fragmentShader;
  		this.vertexShader = source.vertexShader;

  		this.uniforms = cloneUniforms( source.uniforms );
  		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

  		this.defines = Object.assign( {}, source.defines );

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		this.fog = source.fog;
  		this.lights = source.lights;
  		this.clipping = source.clipping;

  		this.extensions = Object.assign( {}, source.extensions );

  		this.glslVersion = source.glslVersion;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.glslVersion = this.glslVersion;
  		data.uniforms = {};

  		for ( const name in this.uniforms ) {

  			const uniform = this.uniforms[ name ];
  			const value = uniform.value;

  			if ( value && value.isTexture ) {

  				data.uniforms[ name ] = {
  					type: 't',
  					value: value.toJSON( meta ).uuid
  				};

  			} else if ( value && value.isColor ) {

  				data.uniforms[ name ] = {
  					type: 'c',
  					value: value.getHex()
  				};

  			} else if ( value && value.isVector2 ) {

  				data.uniforms[ name ] = {
  					type: 'v2',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector3 ) {

  				data.uniforms[ name ] = {
  					type: 'v3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector4 ) {

  				data.uniforms[ name ] = {
  					type: 'v4',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix3 ) {

  				data.uniforms[ name ] = {
  					type: 'm3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix4 ) {

  				data.uniforms[ name ] = {
  					type: 'm4',
  					value: value.toArray()
  				};

  			} else {

  				data.uniforms[ name ] = {
  					value: value
  				};

  				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

  			}

  		}

  		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

  		data.vertexShader = this.vertexShader;
  		data.fragmentShader = this.fragmentShader;

  		data.lights = this.lights;
  		data.clipping = this.clipping;

  		const extensions = {};

  		for ( const key in this.extensions ) {

  			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

  		}

  		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

  		return data;

  	}

  }

  /**
   * Abstract base class for cameras. This class should always be inherited
   * when you build a new camera.
   *
   * @abstract
   * @augments Object3D
   */
  class Camera extends Object3D {

  	/**
  	 * Constructs a new camera.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isCamera = true;

  		this.type = 'Camera';

  		/**
  		 * The inverse of the camera's world matrix.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.matrixWorldInverse = new Matrix4();

  		/**
  		 * The camera's projection matrix.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.projectionMatrix = new Matrix4();

  		/**
  		 * The inverse of the camera's projection matrix.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.projectionMatrixInverse = new Matrix4();

  		/**
  		 * The coordinate system in which the camera is used.
  		 *
  		 * @type {(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
  		 */
  		this.coordinateSystem = WebGLCoordinateSystem;

  		this._reversedDepth = false;

  	}

  	/**
  	 * The flag that indicates whether the camera uses a reversed depth buffer.
  	 *
  	 * @type {boolean}
  	 * @default false
  	 */
  	get reversedDepth() {

  		return this._reversedDepth;

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.matrixWorldInverse.copy( source.matrixWorldInverse );

  		this.projectionMatrix.copy( source.projectionMatrix );
  		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

  		this.coordinateSystem = source.coordinateSystem;

  		return this;

  	}

  	/**
  	 * Returns a vector representing the ("look") direction of the 3D object in world space.
  	 *
  	 * This method is overwritten since cameras have a different forward vector compared to other
  	 * 3D objects. A camera looks down its local, negative z-axis by default.
  	 *
  	 * @param {Vector3} target - The target vector the result is stored to.
  	 * @return {Vector3} The 3D object's direction in world space.
  	 */
  	getWorldDirection( target ) {

  		return super.getWorldDirection( target ).negate();

  	}

  	updateMatrixWorld( force ) {

  		super.updateMatrixWorld( force );

  		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

  	}

  	updateWorldMatrix( updateParents, updateChildren ) {

  		super.updateWorldMatrix( updateParents, updateChildren );

  		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

  	}

  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _v3$1 = /*@__PURE__*/ new Vector3();
  const _minTarget = /*@__PURE__*/ new Vector2();
  const _maxTarget = /*@__PURE__*/ new Vector2();

  /**
   * Camera that uses [perspective projection]{@link https://en.wikipedia.org/wiki/Perspective_(graphical)}.
   *
   * This projection mode is designed to mimic the way the human eye sees. It
   * is the most common projection mode used for rendering a 3D scene.
   *
   * ```js
   * const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
   * scene.add( camera );
   * ```
   *
   * @augments Camera
   */
  class PerspectiveCamera extends Camera {

  	/**
  	 * Constructs a new perspective camera.
  	 *
  	 * @param {number} [fov=50] - The vertical field of view.
  	 * @param {number} [aspect=1] - The aspect ratio.
  	 * @param {number} [near=0.1] - The camera's near plane.
  	 * @param {number} [far=2000] - The camera's far plane.
  	 */
  	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPerspectiveCamera = true;

  		this.type = 'PerspectiveCamera';

  		/**
  		 * The vertical field of view, from bottom to top of view,
  		 * in degrees.
  		 *
  		 * @type {number}
  		 * @default 50
  		 */
  		this.fov = fov;

  		/**
  		 * The zoom factor of the camera.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.zoom = 1;

  		/**
  		 * The camera's near plane. The valid range is greater than `0`
  		 * and less than the current value of {@link PerspectiveCamera#far}.
  		 *
  		 * Note that, unlike for the {@link OrthographicCamera}, `0` is <em>not</em> a
  		 * valid value for a perspective camera's near plane.
  		 *
  		 * @type {number}
  		 * @default 0.1
  		 */
  		this.near = near;

  		/**
  		 * The camera's far plane. Must be greater than the
  		 * current value of {@link PerspectiveCamera#near}.
  		 *
  		 * @type {number}
  		 * @default 2000
  		 */
  		this.far = far;

  		/**
  		 * Object distance used for stereoscopy and depth-of-field effects. This
  		 * parameter does not influence the projection matrix unless a
  		 * {@link StereoCamera} is being used.
  		 *
  		 * @type {number}
  		 * @default 10
  		 */
  		this.focus = 10;

  		/**
  		 * The aspect ratio, usually the canvas width / canvas height.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.aspect = aspect;

  		/**
  		 * Represents the frustum window specification. This property should not be edited
  		 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.view = null;

  		/**
  		 * Film size used for the larger axis. Default is `35` (millimeters). This
  		 * parameter does not influence the projection matrix unless {@link PerspectiveCamera#filmOffset}
  		 * is set to a nonzero value.
  		 *
  		 * @type {number}
  		 * @default 35
  		 */
  		this.filmGauge = 35;

  		/**
  		 * Horizontal off-center offset in the same unit as {@link PerspectiveCamera#filmGauge}.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.filmOffset = 0;

  		this.updateProjectionMatrix();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.fov = source.fov;
  		this.zoom = source.zoom;

  		this.near = source.near;
  		this.far = source.far;
  		this.focus = source.focus;

  		this.aspect = source.aspect;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		this.filmGauge = source.filmGauge;
  		this.filmOffset = source.filmOffset;

  		return this;

  	}

  	/**
  	 * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
  	 */
  	setFocalLength( focalLength ) {

  		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
  		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

  		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Returns the focal length from the current {@link PerspectiveCamera#fov} and
  	 * {@link PerspectiveCamera#filmGauge}.
  	 *
  	 * @return {number} The computed focal length.
  	 */
  	getFocalLength() {

  		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

  		return 0.5 * this.getFilmHeight() / vExtentSlope;

  	}

  	/**
  	 * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
  	 *
  	 * @return {number} The effective FOV.
  	 */
  	getEffectiveFOV() {

  		return RAD2DEG * 2 * Math.atan(
  			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

  	}

  	/**
  	 * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
  	 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
  	 *
  	 * @return {number} The film width.
  	 */
  	getFilmWidth() {

  		// film not completely covered in portrait format (aspect < 1)
  		return this.filmGauge * Math.min( this.aspect, 1 );

  	}

  	/**
  	 * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
  	 * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
  	 *
  	 * @return {number} The film width.
  	 */
  	getFilmHeight() {

  		// film not completely covered in landscape format (aspect > 1)
  		return this.filmGauge / Math.max( this.aspect, 1 );

  	}

  	/**
  	 * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
  	 * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
  	 *
  	 * @param {number} distance - The viewing distance.
  	 * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
  	 * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
  	 */
  	getViewBounds( distance, minTarget, maxTarget ) {

  		_v3$1.set( -1, -1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

  		minTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

  		_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );

  		maxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );

  	}

  	/**
  	 * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
  	 *
  	 * @param {number} distance - The viewing distance.
  	 * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
  	 * @returns {Vector2} The view size.
  	 */
  	getViewSize( distance, target ) {

  		this.getViewBounds( distance, _minTarget, _maxTarget );

  		return target.subVectors( _maxTarget, _minTarget );

  	}

  	/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *```
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *```
  	 * then for each monitor you would call it like this:
  	 *```js
  	 * const w = 1920;
  	 * const h = 1080;
  	 * const fullWidth = w * 3;
  	 * const fullHeight = h * 2;
  	 *
  	 * // --A--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 * // --B--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 * // --C--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 * // --D--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 * // --E--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 * // --F--
  	 * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 * ```
  	 *
  	 * Note there is no reason monitors have to be the same size or in a grid.
  	 *
  	 * @param {number} fullWidth - The full width of multiview setup.
  	 * @param {number} fullHeight - The full height of multiview setup.
  	 * @param {number} x - The horizontal offset of the subcamera.
  	 * @param {number} y - The vertical offset of the subcamera.
  	 * @param {number} width - The width of subcamera.
  	 * @param {number} height - The height of subcamera.
  	 */
  	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

  		this.aspect = fullWidth / fullHeight;

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Removes the view offset from the projection matrix.
  	 */
  	clearViewOffset() {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Updates the camera's projection matrix. Must be called after any change of
  	 * camera properties.
  	 */
  	updateProjectionMatrix() {

  		const near = this.near;
  		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
  		let height = 2 * top;
  		let width = this.aspect * height;
  		let left = -0.5 * width;
  		const view = this.view;

  		if ( this.view !== null && this.view.enabled ) {

  			const fullWidth = view.fullWidth,
  				fullHeight = view.fullHeight;

  			left += view.offsetX * width / fullWidth;
  			top -= view.offsetY * height / fullHeight;
  			width *= view.width / fullWidth;
  			height *= view.height / fullHeight;

  		}

  		const skew = this.filmOffset;
  		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

  		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem, this.reversedDepth );

  		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.fov = this.fov;
  		data.object.zoom = this.zoom;

  		data.object.near = this.near;
  		data.object.far = this.far;
  		data.object.focus = this.focus;

  		data.object.aspect = this.aspect;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		data.object.filmGauge = this.filmGauge;
  		data.object.filmOffset = this.filmOffset;

  		return data;

  	}

  }

  const fov = -90; // negative fov is not an error
  const aspect = 1;

  /**
   * A special type of camera that is positioned in 3D space to render its surroundings into a
   * cube render target. The render target can then be used as an environment map for rendering
   * realtime reflections in your scene.
   *
   * ```js
   * // Create cube render target
   * const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256, { generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter } );
   *
   * // Create cube camera
   * const cubeCamera = new THREE.CubeCamera( 1, 100000, cubeRenderTarget );
   * scene.add( cubeCamera );
   *
   * // Create car
   * const chromeMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: cubeRenderTarget.texture } );
   * const car = new THREE.Mesh( carGeometry, chromeMaterial );
   * scene.add( car );
   *
   * // Update the render target cube
   * car.visible = false;
   * cubeCamera.position.copy( car.position );
   * cubeCamera.update( renderer, scene );
   *
   * // Render the scene
   * car.visible = true;
   * renderer.render( scene, camera );
   * ```
   *
   * @augments Object3D
   */
  class CubeCamera extends Object3D {

  	/**
  	 * Constructs a new cube camera.
  	 *
  	 * @param {number} near - The camera's near plane.
  	 * @param {number} far - The camera's far plane.
  	 * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
  	 */
  	constructor( near, far, renderTarget ) {

  		super();

  		this.type = 'CubeCamera';

  		/**
  		 * A reference to the cube render target.
  		 *
  		 * @type {WebGLCubeRenderTarget}
  		 */
  		this.renderTarget = renderTarget;

  		/**
  		 * The current active coordinate system.
  		 *
  		 * @type {?(WebGLCoordinateSystem|WebGPUCoordinateSystem)}
  		 * @default null
  		 */
  		this.coordinateSystem = null;

  		/**
  		 * The current active mipmap level
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.activeMipmapLevel = 0;

  		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPX.layers = this.layers;
  		this.add( cameraPX );

  		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNX.layers = this.layers;
  		this.add( cameraNX );

  		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPY.layers = this.layers;
  		this.add( cameraPY );

  		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNY.layers = this.layers;
  		this.add( cameraNY );

  		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPZ.layers = this.layers;
  		this.add( cameraPZ );

  		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNZ.layers = this.layers;
  		this.add( cameraNZ );

  	}

  	/**
  	 * Must be called when the coordinate system of the cube camera is changed.
  	 */
  	updateCoordinateSystem() {

  		const coordinateSystem = this.coordinateSystem;

  		const cameras = this.children.concat();

  		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

  		for ( const camera of cameras ) this.remove( camera );

  		if ( coordinateSystem === WebGLCoordinateSystem ) {

  			cameraPX.up.set( 0, 1, 0 );
  			cameraPX.lookAt( 1, 0, 0 );

  			cameraNX.up.set( 0, 1, 0 );
  			cameraNX.lookAt( -1, 0, 0 );

  			cameraPY.up.set( 0, 0, -1 );
  			cameraPY.lookAt( 0, 1, 0 );

  			cameraNY.up.set( 0, 0, 1 );
  			cameraNY.lookAt( 0, -1, 0 );

  			cameraPZ.up.set( 0, 1, 0 );
  			cameraPZ.lookAt( 0, 0, 1 );

  			cameraNZ.up.set( 0, 1, 0 );
  			cameraNZ.lookAt( 0, 0, -1 );

  		} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  			cameraPX.up.set( 0, -1, 0 );
  			cameraPX.lookAt( -1, 0, 0 );

  			cameraNX.up.set( 0, -1, 0 );
  			cameraNX.lookAt( 1, 0, 0 );

  			cameraPY.up.set( 0, 0, 1 );
  			cameraPY.lookAt( 0, 1, 0 );

  			cameraNY.up.set( 0, 0, -1 );
  			cameraNY.lookAt( 0, -1, 0 );

  			cameraPZ.up.set( 0, -1, 0 );
  			cameraPZ.lookAt( 0, 0, 1 );

  			cameraNZ.up.set( 0, -1, 0 );
  			cameraNZ.lookAt( 0, 0, -1 );

  		} else {

  			throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

  		}

  		for ( const camera of cameras ) {

  			this.add( camera );

  			camera.updateMatrixWorld();

  		}

  	}

  	/**
  	 * Calling this method will render the given scene with the given renderer
  	 * into the cube render target of the camera.
  	 *
  	 * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
  	 * @param {Scene} scene - The scene to render.
  	 */
  	update( renderer, scene ) {

  		if ( this.parent === null ) this.updateMatrixWorld();

  		const { renderTarget, activeMipmapLevel } = this;

  		if ( this.coordinateSystem !== renderer.coordinateSystem ) {

  			this.coordinateSystem = renderer.coordinateSystem;

  			this.updateCoordinateSystem();

  		}

  		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

  		const currentRenderTarget = renderer.getRenderTarget();
  		const currentActiveCubeFace = renderer.getActiveCubeFace();
  		const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();

  		const currentXrEnabled = renderer.xr.enabled;

  		renderer.xr.enabled = false;

  		const generateMipmaps = renderTarget.texture.generateMipmaps;

  		renderTarget.texture.generateMipmaps = false;

  		renderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );
  		renderer.render( scene, cameraPX );

  		renderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );
  		renderer.render( scene, cameraNX );

  		renderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );
  		renderer.render( scene, cameraPY );

  		renderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );
  		renderer.render( scene, cameraNY );

  		renderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );
  		renderer.render( scene, cameraPZ );

  		// mipmaps are generated during the last call of render()
  		// at this point, all sides of the cube render target are defined

  		renderTarget.texture.generateMipmaps = generateMipmaps;

  		renderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );
  		renderer.render( scene, cameraNZ );

  		renderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

  		renderer.xr.enabled = currentXrEnabled;

  		renderTarget.texture.needsPMREMUpdate = true;

  	}

  }

  /**
   * Creates a cube texture made up of six images.
   *
   * ```js
   * const loader = new THREE.CubeTextureLoader();
   * loader.setPath( 'textures/cube/pisa/' );
   *
   * const textureCube = loader.load( [
   * 	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
   * ] );
   *
   * const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );
   * ```
   *
   * @augments Texture
   */
  class CubeTexture extends Texture {

  	/**
  	 * Constructs a new cube texture.
  	 *
  	 * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
  	 * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
  	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
  	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
  	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
  	 * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
  	 * @param {number} [format=RGBAFormat] - The texture format.
  	 * @param {number} [type=UnsignedByteType] - The texture type.
  	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
  	 * @param {string} [colorSpace=NoColorSpace] - The color space value.
  	 */
  	constructor( images = [], mapping = CubeReflectionMapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

  		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isCubeTexture = true;

  		/**
  		 * If set to `true`, the texture is flipped along the vertical axis when
  		 * uploaded to the GPU.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flipY = false;

  	}

  	/**
  	 * Alias for {@link CubeTexture#image}.
  	 *
  	 * @type {Array<Image>}
  	 */
  	get images() {

  		return this.image;

  	}

  	set images( value ) {

  		this.image = value;

  	}

  }

  /**
   * A cube render target used in context of {@link WebGLRenderer}.
   *
   * @augments WebGLRenderTarget
   */
  class WebGLCubeRenderTarget extends WebGLRenderTarget {

  	/**
  	 * Constructs a new cube render target.
  	 *
  	 * @param {number} [size=1] - The size of the render target.
  	 * @param {RenderTarget~Options} [options] - The configuration object.
  	 */
  	constructor( size = 1, options = {} ) {

  		super( size, size, options );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isWebGLCubeRenderTarget = true;

  		const image = { width: size, height: size, depth: 1 };
  		const images = [ image, image, image, image, image, image ];

  		/**
  		 * Overwritten with a different texture type.
  		 *
  		 * @type {DataArrayTexture}
  		 */
  		this.texture = new CubeTexture( images );
  		this._setTextureOptions( options );

  		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
  		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
  		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

  		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
  		// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
  		// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

  		this.texture.isRenderTargetTexture = true;

  	}

  	/**
  	 * Converts the given equirectangular texture to a cube map.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {Texture} texture - The equirectangular texture.
  	 * @return {WebGLCubeRenderTarget} A reference to this cube render target.
  	 */
  	fromEquirectangularTexture( renderer, texture ) {

  		this.texture.type = texture.type;
  		this.texture.colorSpace = texture.colorSpace;

  		this.texture.generateMipmaps = texture.generateMipmaps;
  		this.texture.minFilter = texture.minFilter;
  		this.texture.magFilter = texture.magFilter;

  		const shader = {

  			uniforms: {
  				tEquirect: { value: null },
  			},

  			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

  			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
  		};

  		const geometry = new BoxGeometry( 5, 5, 5 );

  		const material = new ShaderMaterial( {

  			name: 'CubemapFromEquirect',

  			uniforms: cloneUniforms( shader.uniforms ),
  			vertexShader: shader.vertexShader,
  			fragmentShader: shader.fragmentShader,
  			side: BackSide,
  			blending: NoBlending

  		} );

  		material.uniforms.tEquirect.value = texture;

  		const mesh = new Mesh( geometry, material );

  		const currentMinFilter = texture.minFilter;

  		// Avoid blurred poles
  		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

  		const camera = new CubeCamera( 1, 10, this );
  		camera.update( renderer, mesh );

  		texture.minFilter = currentMinFilter;

  		mesh.geometry.dispose();
  		mesh.material.dispose();

  		return this;

  	}

  	/**
  	 * Clears this cube render target.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
  	 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
  	 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
  	 */
  	clear( renderer, color = true, depth = true, stencil = true ) {

  		const currentRenderTarget = renderer.getRenderTarget();

  		for ( let i = 0; i < 6; i ++ ) {

  			renderer.setRenderTarget( this, i );

  			renderer.clear( color, depth, stencil );

  		}

  		renderer.setRenderTarget( currentRenderTarget );

  	}

  }

  /**
   * This is almost identical to an {@link Object3D}. Its purpose is to
   * make working with groups of objects syntactically clearer.
   *
   * ```js
   * // Create a group and add the two cubes.
   * // These cubes can now be rotated / scaled etc as a group.
   * const group = new THREE.Group();
   *
   * group.add( meshA );
   * group.add( meshB );
   *
   * scene.add( group );
   * ```
   *
   * @augments Object3D
   */
  class Group extends Object3D {

  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isGroup = true;

  		this.type = 'Group';

  	}

  }

  const _moveEvent = { type: 'move' };

  /**
   * Class for representing a XR controller with its
   * different coordinate systems.
   *
   * @private
   */
  class WebXRController {

  	/**
  	 * Constructs a new XR controller.
  	 */
  	constructor() {

  		/**
  		 * A group representing the target ray space
  		 * of the XR controller.
  		 *
  		 * @private
  		 * @type {?Group}
  		 * @default null
  		 */
  		this._targetRay = null;

  		/**
  		 * A group representing the grip space
  		 * of the XR controller.
  		 *
  		 * @private
  		 * @type {?Group}
  		 * @default null
  		 */
  		this._grip = null;

  		/**
  		 * A group representing the hand space
  		 * of the XR controller.
  		 *
  		 * @private
  		 * @type {?Group}
  		 * @default null
  		 */
  		this._hand = null;

  	}

  	/**
  	 * Returns a group representing the hand space of the XR controller.
  	 *
  	 * @return {Group} A group representing the hand space of the XR controller.
  	 */
  	getHandSpace() {

  		if ( this._hand === null ) {

  			this._hand = new Group();
  			this._hand.matrixAutoUpdate = false;
  			this._hand.visible = false;

  			this._hand.joints = {};
  			this._hand.inputState = { pinching: false };

  		}

  		return this._hand;

  	}

  	/**
  	 * Returns a group representing the target ray space of the XR controller.
  	 *
  	 * @return {Group} A group representing the target ray space of the XR controller.
  	 */
  	getTargetRaySpace() {

  		if ( this._targetRay === null ) {

  			this._targetRay = new Group();
  			this._targetRay.matrixAutoUpdate = false;
  			this._targetRay.visible = false;
  			this._targetRay.hasLinearVelocity = false;
  			this._targetRay.linearVelocity = new Vector3();
  			this._targetRay.hasAngularVelocity = false;
  			this._targetRay.angularVelocity = new Vector3();

  		}

  		return this._targetRay;

  	}

  	/**
  	 * Returns a group representing the grip space of the XR controller.
  	 *
  	 * @return {Group} A group representing the grip space of the XR controller.
  	 */
  	getGripSpace() {

  		if ( this._grip === null ) {

  			this._grip = new Group();
  			this._grip.matrixAutoUpdate = false;
  			this._grip.visible = false;
  			this._grip.hasLinearVelocity = false;
  			this._grip.linearVelocity = new Vector3();
  			this._grip.hasAngularVelocity = false;
  			this._grip.angularVelocity = new Vector3();

  		}

  		return this._grip;

  	}

  	/**
  	 * Dispatches the given event to the groups representing
  	 * the different coordinate spaces of the XR controller.
  	 *
  	 * @param {Object} event - The event to dispatch.
  	 * @return {WebXRController} A reference to this instance.
  	 */
  	dispatchEvent( event ) {

  		if ( this._targetRay !== null ) {

  			this._targetRay.dispatchEvent( event );

  		}

  		if ( this._grip !== null ) {

  			this._grip.dispatchEvent( event );

  		}

  		if ( this._hand !== null ) {

  			this._hand.dispatchEvent( event );

  		}

  		return this;

  	}

  	/**
  	 * Connects the controller with the given XR input source.
  	 *
  	 * @param {XRInputSource} inputSource - The input source.
  	 * @return {WebXRController} A reference to this instance.
  	 */
  	connect( inputSource ) {

  		if ( inputSource && inputSource.hand ) {

  			const hand = this._hand;

  			if ( hand ) {

  				for ( const inputjoint of inputSource.hand.values() ) {

  					// Initialize hand with joints when connected
  					this._getHandJoint( hand, inputjoint );

  				}

  			}

  		}

  		this.dispatchEvent( { type: 'connected', data: inputSource } );

  		return this;

  	}

  	/**
  	 * Disconnects the controller from the given XR input source.
  	 *
  	 * @param {XRInputSource} inputSource - The input source.
  	 * @return {WebXRController} A reference to this instance.
  	 */
  	disconnect( inputSource ) {

  		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

  		if ( this._targetRay !== null ) {

  			this._targetRay.visible = false;

  		}

  		if ( this._grip !== null ) {

  			this._grip.visible = false;

  		}

  		if ( this._hand !== null ) {

  			this._hand.visible = false;

  		}

  		return this;

  	}

  	/**
  	 * Updates the controller with the given input source, XR frame and reference space.
  	 * This updates the transformations of the groups that represent the different
  	 * coordinate systems of the controller.
  	 *
  	 * @param {XRInputSource} inputSource - The input source.
  	 * @param {XRFrame} frame - The XR frame.
  	 * @param {XRReferenceSpace} referenceSpace - The reference space.
  	 * @return {WebXRController} A reference to this instance.
  	 */
  	update( inputSource, frame, referenceSpace ) {

  		let inputPose = null;
  		let gripPose = null;
  		let handPose = null;

  		const targetRay = this._targetRay;
  		const grip = this._grip;
  		const hand = this._hand;

  		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

  			if ( hand && inputSource.hand ) {

  				handPose = true;

  				for ( const inputjoint of inputSource.hand.values() ) {

  					// Update the joints groups with the XRJoint poses
  					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

  					// The transform of this joint will be updated with the joint pose on each frame
  					const joint = this._getHandJoint( hand, inputjoint );

  					if ( jointPose !== null ) {

  						joint.matrix.fromArray( jointPose.transform.matrix );
  						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
  						joint.matrixWorldNeedsUpdate = true;
  						joint.jointRadius = jointPose.radius;

  					}

  					joint.visible = jointPose !== null;

  				}

  				// Custom events

  				// Check pinchz
  				const indexTip = hand.joints[ 'index-finger-tip' ];
  				const thumbTip = hand.joints[ 'thumb-tip' ];
  				const distance = indexTip.position.distanceTo( thumbTip.position );

  				const distanceToPinch = 0.02;
  				const threshold = 0.005;

  				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

  					hand.inputState.pinching = false;
  					this.dispatchEvent( {
  						type: 'pinchend',
  						handedness: inputSource.handedness,
  						target: this
  					} );

  				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

  					hand.inputState.pinching = true;
  					this.dispatchEvent( {
  						type: 'pinchstart',
  						handedness: inputSource.handedness,
  						target: this
  					} );

  				}

  			} else {

  				if ( grip !== null && inputSource.gripSpace ) {

  					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

  					if ( gripPose !== null ) {

  						grip.matrix.fromArray( gripPose.transform.matrix );
  						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );
  						grip.matrixWorldNeedsUpdate = true;

  						if ( gripPose.linearVelocity ) {

  							grip.hasLinearVelocity = true;
  							grip.linearVelocity.copy( gripPose.linearVelocity );

  						} else {

  							grip.hasLinearVelocity = false;

  						}

  						if ( gripPose.angularVelocity ) {

  							grip.hasAngularVelocity = true;
  							grip.angularVelocity.copy( gripPose.angularVelocity );

  						} else {

  							grip.hasAngularVelocity = false;

  						}

  					}

  				}

  			}

  			if ( targetRay !== null ) {

  				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

  				// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
  				if ( inputPose === null && gripPose !== null ) {

  					inputPose = gripPose;

  				}

  				if ( inputPose !== null ) {

  					targetRay.matrix.fromArray( inputPose.transform.matrix );
  					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );
  					targetRay.matrixWorldNeedsUpdate = true;

  					if ( inputPose.linearVelocity ) {

  						targetRay.hasLinearVelocity = true;
  						targetRay.linearVelocity.copy( inputPose.linearVelocity );

  					} else {

  						targetRay.hasLinearVelocity = false;

  					}

  					if ( inputPose.angularVelocity ) {

  						targetRay.hasAngularVelocity = true;
  						targetRay.angularVelocity.copy( inputPose.angularVelocity );

  					} else {

  						targetRay.hasAngularVelocity = false;

  					}

  					this.dispatchEvent( _moveEvent );

  				}

  			}


  		}

  		if ( targetRay !== null ) {

  			targetRay.visible = ( inputPose !== null );

  		}

  		if ( grip !== null ) {

  			grip.visible = ( gripPose !== null );

  		}

  		if ( hand !== null ) {

  			hand.visible = ( handPose !== null );

  		}

  		return this;

  	}

  	/**
  	 * Returns a group representing the hand joint for the given input joint.
  	 *
  	 * @private
  	 * @param {Group} hand - The group representing the hand space.
  	 * @param {XRJointSpace} inputjoint - The hand joint data.
  	 * @return {Group} A group representing the hand joint for the given input joint.
  	 */
  	_getHandJoint( hand, inputjoint ) {

  		if ( hand.joints[ inputjoint.jointName ] === undefined ) {

  			const joint = new Group();
  			joint.matrixAutoUpdate = false;
  			joint.visible = false;
  			hand.joints[ inputjoint.jointName ] = joint;

  			hand.add( joint );

  		}

  		return hand.joints[ inputjoint.jointName ];

  	}

  }

  /**
   * Scenes allow you to set up what is to be rendered and where by three.js.
   * This is where you place 3D objects like meshes, lines or lights.
   *
   * @augments Object3D
   */
  class Scene extends Object3D {

  	/**
  	 * Constructs a new scene.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isScene = true;

  		this.type = 'Scene';

  		/**
  		 * Defines the background of the scene. Valid inputs are:
  		 *
  		 * - A color for defining a uniform colored background.
  		 * - A texture for defining a (flat) textured background.
  		 * - Cube textures or equirectangular textures for defining a skybox.
  		 *
  		 * @type {?(Color|Texture)}
  		 * @default null
  		 */
  		this.background = null;

  		/**
  		 * Sets the environment map for all physical materials in the scene. However,
  		 * it's not possible to overwrite an existing texture assigned to the `envMap`
  		 * material property.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.environment = null;

  		/**
  		 * A fog instance defining the type of fog that affects everything
  		 * rendered in the scene.
  		 *
  		 * @type {?(Fog|FogExp2)}
  		 * @default null
  		 */
  		this.fog = null;

  		/**
  		 * Sets the blurriness of the background. Only influences environment maps
  		 * assigned to {@link Scene#background}. Valid input is a float between `0`
  		 * and `1`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.backgroundBlurriness = 0;

  		/**
  		 * Attenuates the color of the background. Only applies to background textures.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.backgroundIntensity = 1;

  		/**
  		 * The rotation of the background in radians. Only influences environment maps
  		 * assigned to {@link Scene#background}.
  		 *
  		 * @type {Euler}
  		 * @default (0,0,0)
  		 */
  		this.backgroundRotation = new Euler();

  		/**
  		 * Attenuates the color of the environment. Only influences environment maps
  		 * assigned to {@link Scene#environment}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.environmentIntensity = 1;

  		/**
  		 * The rotation of the environment map in radians. Only influences physical materials
  		 * in the scene when {@link Scene#environment} is used.
  		 *
  		 * @type {Euler}
  		 * @default (0,0,0)
  		 */
  		this.environmentRotation = new Euler();

  		/**
  		 * Forces everything in the scene to be rendered with the defined material. It is possible
  		 * to exclude materials from override by setting {@link Material#allowOverride} to `false`.
  		 *
  		 * @type {?Material}
  		 * @default null
  		 */
  		this.overrideMaterial = null;

  		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

  		}

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		if ( source.background !== null ) this.background = source.background.clone();
  		if ( source.environment !== null ) this.environment = source.environment.clone();
  		if ( source.fog !== null ) this.fog = source.fog.clone();

  		this.backgroundBlurriness = source.backgroundBlurriness;
  		this.backgroundIntensity = source.backgroundIntensity;
  		this.backgroundRotation.copy( source.backgroundRotation );

  		this.environmentIntensity = source.environmentIntensity;
  		this.environmentRotation.copy( source.environmentRotation );

  		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

  		if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
  		if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;
  		data.object.backgroundRotation = this.backgroundRotation.toArray();

  		if ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;
  		data.object.environmentRotation = this.environmentRotation.toArray();

  		return data;

  	}

  }

  /**
   * "Interleaved" means that multiple attributes, possibly of different types,
   * (e.g., position, normal, uv, color) are packed into a single array buffer.
   *
   * An introduction into interleaved arrays can be found here: [Interleaved array basics]{@link https://blog.tojicode.com/2011/05/interleaved-array-basics.html}
   */
  class InterleavedBuffer {

  	/**
  	 * Constructs a new interleaved buffer.
  	 *
  	 * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
  	 * @param {number} stride - The number of typed-array elements per vertex.
  	 */
  	constructor( array, stride ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isInterleavedBuffer = true;

  		/**
  		 * A typed array with a shared buffer storing attribute data.
  		 *
  		 * @type {TypedArray}
  		 */
  		this.array = array;

  		/**
  		 * The number of typed-array elements per vertex.
  		 *
  		 * @type {number}
  		 */
  		this.stride = stride;

  		/**
  		 * The total number of elements in the array
  		 *
  		 * @type {number}
  		 * @readonly
  		 */
  		this.count = array !== undefined ? array.length / stride : 0;

  		/**
  		 * Defines the intended usage pattern of the data store for optimization purposes.
  		 *
  		 * Note: After the initial use of a buffer, its usage cannot be changed. Instead,
  		 * instantiate a new one and set the desired usage before the next render.
  		 *
  		 * @type {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)}
  		 * @default StaticDrawUsage
  		 */
  		this.usage = StaticDrawUsage;

  		/**
  		 * This can be used to only update some components of stored vectors (for example, just the
  		 * component related to color). Use the `addUpdateRange()` function to add ranges to this array.
  		 *
  		 * @type {Array<Object>}
  		 */
  		this.updateRanges = [];

  		/**
  		 * A version number, incremented every time the `needsUpdate` is set to `true`.
  		 *
  		 * @type {number}
  		 */
  		this.version = 0;

  		/**
  		 * The UUID of the interleaved buffer.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  	}

  	/**
  	 * A callback function that is executed after the renderer has transferred the attribute array
  	 * data to the GPU.
  	 */
  	onUploadCallback() {}

  	/**
  	 * Flag to indicate that this attribute has changed and should be re-sent to
  	 * the GPU. Set this to `true` when you modify the value of the array.
  	 *
  	 * @type {number}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		if ( value === true ) this.version ++;

  	}

  	/**
  	 * Sets the usage of this interleaved buffer.
  	 *
  	 * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
  	 * @return {InterleavedBuffer} A reference to this interleaved buffer.
  	 */
  	setUsage( value ) {

  		this.usage = value;

  		return this;

  	}

  	/**
  	 * Adds a range of data in the data array to be updated on the GPU.
  	 *
  	 * @param {number} start - Position at which to start update.
  	 * @param {number} count - The number of components to update.
  	 */
  	addUpdateRange( start, count ) {

  		this.updateRanges.push( { start, count } );

  	}

  	/**
  	 * Clears the update ranges.
  	 */
  	clearUpdateRanges() {

  		this.updateRanges.length = 0;

  	}

  	/**
  	 * Copies the values of the given interleaved buffer to this instance.
  	 *
  	 * @param {InterleavedBuffer} source - The interleaved buffer to copy.
  	 * @return {InterleavedBuffer} A reference to this instance.
  	 */
  	copy( source ) {

  		this.array = new source.array.constructor( source.array );
  		this.count = source.count;
  		this.stride = source.stride;
  		this.usage = source.usage;

  		return this;

  	}

  	/**
  	 * Copies a vector from the given interleaved buffer to this one. The start
  	 * and destination position in the attribute buffers are represented by the
  	 * given indices.
  	 *
  	 * @param {number} index1 - The destination index into this interleaved buffer.
  	 * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
  	 * @param {number} index2 - The source index into the given interleaved buffer.
  	 * @return {InterleavedBuffer} A reference to this instance.
  	 */
  	copyAt( index1, interleavedBuffer, index2 ) {

  		index1 *= this.stride;
  		index2 *= interleavedBuffer.stride;

  		for ( let i = 0, l = this.stride; i < l; i ++ ) {

  			this.array[ index1 + i ] = interleavedBuffer.array[ index2 + i ];

  		}

  		return this;

  	}

  	/**
  	 * Sets the given array data in the interleaved buffer.
  	 *
  	 * @param {(TypedArray|Array)} value - The array data to set.
  	 * @param {number} [offset=0] - The offset in this interleaved buffer's array.
  	 * @return {InterleavedBuffer} A reference to this instance.
  	 */
  	set( value, offset = 0 ) {

  		this.array.set( value, offset );

  		return this;

  	}

  	/**
  	 * Returns a new interleaved buffer with copied values from this instance.
  	 *
  	 * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
  	 * @return {InterleavedBuffer} A clone of this instance.
  	 */
  	clone( data ) {

  		if ( data.arrayBuffers === undefined ) {

  			data.arrayBuffers = {};

  		}

  		if ( this.array.buffer._uuid === undefined ) {

  			this.array.buffer._uuid = generateUUID();

  		}

  		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

  			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

  		}

  		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

  		const ib = new this.constructor( array, this.stride );
  		ib.setUsage( this.usage );

  		return ib;

  	}

  	/**
  	 * Sets the given callback function that is executed after the Renderer has transferred
  	 * the array data to the GPU. Can be used to perform clean-up operations after
  	 * the upload when data are not needed anymore on the CPU side.
  	 *
  	 * @param {Function} callback - The `onUpload()` callback.
  	 * @return {InterleavedBuffer} A reference to this instance.
  	 */
  	onUpload( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  	/**
  	 * Serializes the interleaved buffer into JSON.
  	 *
  	 * @param {Object} [data] - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized interleaved buffer.
  	 */
  	toJSON( data ) {

  		if ( data.arrayBuffers === undefined ) {

  			data.arrayBuffers = {};

  		}

  		// generate UUID for array buffer if necessary

  		if ( this.array.buffer._uuid === undefined ) {

  			this.array.buffer._uuid = generateUUID();

  		}

  		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

  			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

  		}

  		//

  		return {
  			uuid: this.uuid,
  			buffer: this.array.buffer._uuid,
  			type: this.array.constructor.name,
  			stride: this.stride
  		};

  	}

  }

  const _vector$7 = /*@__PURE__*/ new Vector3();

  /**
   * An alternative version of a buffer attribute with interleaved data. Interleaved
   * attributes share a common interleaved data storage ({@link InterleavedBuffer}) and refer with
   * different offsets into the buffer.
   */
  class InterleavedBufferAttribute {

  	/**
  	 * Constructs a new interleaved buffer attribute.
  	 *
  	 * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
  	 * @param {number} itemSize - The item size.
  	 * @param {number} offset - The attribute offset into the buffer.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 */
  	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isInterleavedBufferAttribute = true;

  		/**
  		 * The name of the buffer attribute.
  		 *
  		 * @type {string}
  		 */
  		this.name = '';

  		/**
  		 * The buffer holding the interleaved data.
  		 *
  		 * @type {InterleavedBuffer}
  		 */
  		this.data = interleavedBuffer;

  		/**
  		 * The item size, see {@link BufferAttribute#itemSize}.
  		 *
  		 * @type {number}
  		 */
  		this.itemSize = itemSize;

  		/**
  		 * The attribute offset into the buffer.
  		 *
  		 * @type {number}
  		 */
  		this.offset = offset;

  		/**
  		 * Whether the data are normalized or not, see {@link BufferAttribute#normalized}
  		 *
  		 * @type {InterleavedBuffer}
  		 */
  		this.normalized = normalized;

  	}

  	/**
  	 * The item count of this buffer attribute.
  	 *
  	 * @type {number}
  	 * @readonly
  	 */
  	get count() {

  		return this.data.count;

  	}

  	/**
  	 * The array holding the interleaved buffer attribute data.
  	 *
  	 * @type {TypedArray}
  	 */
  	get array() {

  		return this.data.array;

  	}

  	/**
  	 * Flag to indicate that this attribute has changed and should be re-sent to
  	 * the GPU. Set this to `true` when you modify the value of the array.
  	 *
  	 * @type {number}
  	 * @default false
  	 * @param {boolean} value
  	 */
  	set needsUpdate( value ) {

  		this.data.needsUpdate = value;

  	}

  	/**
  	 * Applies the given 4x4 matrix to the given attribute. Only works with
  	 * item size `3`.
  	 *
  	 * @param {Matrix4} m - The matrix to apply.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	applyMatrix4( m ) {

  		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

  			_vector$7.fromBufferAttribute( this, i );

  			_vector$7.applyMatrix4( m );

  			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

  		}

  		return this;

  	}

  	/**
  	 * Applies the given 3x3 normal matrix to the given attribute. Only works with
  	 * item size `3`.
  	 *
  	 * @param {Matrix3} m - The normal matrix to apply.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	applyNormalMatrix( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$7.fromBufferAttribute( this, i );

  			_vector$7.applyNormalMatrix( m );

  			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

  		}

  		return this;

  	}

  	/**
  	 * Applies the given 4x4 matrix to the given attribute. Only works with
  	 * item size `3` and with direction vectors.
  	 *
  	 * @param {Matrix4} m - The matrix to apply.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	transformDirection( m ) {

  		for ( let i = 0, l = this.count; i < l; i ++ ) {

  			_vector$7.fromBufferAttribute( this, i );

  			_vector$7.transformDirection( m );

  			this.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

  		}

  		return this;

  	}

  	/**
  	 * Returns the given component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} component - The component index.
  	 * @return {number} The returned value.
  	 */
  	getComponent( index, component ) {

  		let value = this.array[ index * this.data.stride + this.offset + component ];

  		if ( this.normalized ) value = denormalize( value, this.array );

  		return value;

  	}

  	/**
  	 * Sets the given value to the given component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} component - The component index.
  	 * @param {number} value - The value to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setComponent( index, component, value ) {

  		if ( this.normalized ) value = normalize( value, this.array );

  		this.data.array[ index * this.data.stride + this.offset + component ] = value;

  		return this;

  	}

  	/**
  	 * Sets the x component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setX( index, x ) {

  		if ( this.normalized ) x = normalize( x, this.array );

  		this.data.array[ index * this.data.stride + this.offset ] = x;

  		return this;

  	}

  	/**
  	 * Sets the y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} y - The value to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setY( index, y ) {

  		if ( this.normalized ) y = normalize( y, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

  		return this;

  	}

  	/**
  	 * Sets the z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} z - The value to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setZ( index, z ) {

  		if ( this.normalized ) z = normalize( z, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

  		return this;

  	}

  	/**
  	 * Sets the w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} w - The value to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setW( index, w ) {

  		if ( this.normalized ) w = normalize( w, this.array );

  		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

  		return this;

  	}

  	/**
  	 * Returns the x component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The x component.
  	 */
  	getX( index ) {

  		let x = this.data.array[ index * this.data.stride + this.offset ];

  		if ( this.normalized ) x = denormalize( x, this.array );

  		return x;

  	}

  	/**
  	 * Returns the y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The y component.
  	 */
  	getY( index ) {

  		let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

  		if ( this.normalized ) y = denormalize( y, this.array );

  		return y;

  	}

  	/**
  	 * Returns the z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The z component.
  	 */
  	getZ( index ) {

  		let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

  		if ( this.normalized ) z = denormalize( z, this.array );

  		return z;

  	}

  	/**
  	 * Returns the w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @return {number} The w component.
  	 */
  	getW( index ) {

  		let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

  		if ( this.normalized ) w = denormalize( w, this.array );

  		return w;

  	}

  	/**
  	 * Sets the x and y component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setXY( index, x, y ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;

  		return this;

  	}

  	/**
  	 * Sets the x, y and z component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @param {number} z - The value for the z component to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setXYZ( index, x, y, z ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );
  			z = normalize( z, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;

  		return this;

  	}

  	/**
  	 * Sets the x, y, z and w component of the vector at the given index.
  	 *
  	 * @param {number} index - The index into the buffer attribute.
  	 * @param {number} x - The value for the x component to set.
  	 * @param {number} y - The value for the y component to set.
  	 * @param {number} z - The value for the z component to set.
  	 * @param {number} w - The value for the w component to set.
  	 * @return {InterleavedBufferAttribute} A reference to this instance.
  	 */
  	setXYZW( index, x, y, z, w ) {

  		index = index * this.data.stride + this.offset;

  		if ( this.normalized ) {

  			x = normalize( x, this.array );
  			y = normalize( y, this.array );
  			z = normalize( z, this.array );
  			w = normalize( w, this.array );

  		}

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;
  		this.data.array[ index + 3 ] = w;

  		return this;

  	}

  	/**
  	 * Returns a new buffer attribute with copied values from this instance.
  	 *
  	 * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
  	 *
  	 * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
  	 * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
  	 */
  	clone( data ) {

  		if ( data === undefined ) {

  			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

  			const array = [];

  			for ( let i = 0; i < this.count; i ++ ) {

  				const index = i * this.data.stride + this.offset;

  				for ( let j = 0; j < this.itemSize; j ++ ) {

  					array.push( this.data.array[ index + j ] );

  				}

  			}

  			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

  		} else {

  			if ( data.interleavedBuffers === undefined ) {

  				data.interleavedBuffers = {};

  			}

  			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

  				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

  			}

  			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

  		}

  	}

  	/**
  	 * Serializes the buffer attribute into JSON.
  	 *
  	 * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
  	 *
  	 * @param {Object} [data] - An optional value holding meta information about the serialization.
  	 * @return {Object} A JSON object representing the serialized buffer attribute.
  	 */
  	toJSON( data ) {

  		if ( data === undefined ) {

  			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

  			const array = [];

  			for ( let i = 0; i < this.count; i ++ ) {

  				const index = i * this.data.stride + this.offset;

  				for ( let j = 0; j < this.itemSize; j ++ ) {

  					array.push( this.data.array[ index + j ] );

  				}

  			}

  			// de-interleave data and save it as an ordinary buffer attribute for now

  			return {
  				itemSize: this.itemSize,
  				type: this.array.constructor.name,
  				array: array,
  				normalized: this.normalized
  			};

  		} else {

  			// save as true interleaved attribute

  			if ( data.interleavedBuffers === undefined ) {

  				data.interleavedBuffers = {};

  			}

  			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

  				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

  			}

  			return {
  				isInterleavedBufferAttribute: true,
  				itemSize: this.itemSize,
  				data: this.data.uuid,
  				offset: this.offset,
  				normalized: this.normalized
  			};

  		}

  	}

  }

  const _basePosition = /*@__PURE__*/ new Vector3();

  const _skinIndex = /*@__PURE__*/ new Vector4();
  const _skinWeight = /*@__PURE__*/ new Vector4();

  const _vector3 = /*@__PURE__*/ new Vector3();
  const _matrix4 = /*@__PURE__*/ new Matrix4();
  const _vertex = /*@__PURE__*/ new Vector3();

  const _sphere$5 = /*@__PURE__*/ new Sphere();
  const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
  const _ray$2 = /*@__PURE__*/ new Ray();

  /**
   * A mesh that has a {@link Skeleton} that can then be used to animate the
   * vertices of the geometry with skinning/skeleton animation.
   *
   * Next to a valid skeleton, the skinned mesh requires skin indices and weights
   * as buffer attributes in its geometry. These attribute define which bones affect a single
   * vertex to a certain extend.
   *
   * Typically skinned meshes are not created manually but loaders like {@link GLTFLoader}
   * or {@link FBXLoader } import respective models.
   *
   * @augments Mesh
   */
  class SkinnedMesh extends Mesh {

  	/**
  	 * Constructs a new skinned mesh.
  	 *
  	 * @param {BufferGeometry} [geometry] - The mesh geometry.
  	 * @param {Material|Array<Material>} [material] - The mesh material.
  	 */
  	constructor( geometry, material ) {

  		super( geometry, material );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSkinnedMesh = true;

  		this.type = 'SkinnedMesh';

  		/**
  		 * `AttachedBindMode` means the skinned mesh shares the same world space as the skeleton.
  		 * This is not true when using `DetachedBindMode` which is useful when sharing a skeleton
  		 * across multiple skinned meshes.
  		 *
  		 * @type {(AttachedBindMode|DetachedBindMode)}
  		 * @default AttachedBindMode
  		 */
  		this.bindMode = AttachedBindMode;

  		/**
  		 * The base matrix that is used for the bound bone transforms.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.bindMatrix = new Matrix4();

  		/**
  		 * The base matrix that is used for resetting the bound bone transforms.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.bindMatrixInverse = new Matrix4();

  		/**
  		 * The bounding box of the skinned mesh. Can be computed via {@link SkinnedMesh#computeBoundingBox}.
  		 *
  		 * @type {?Box3}
  		 * @default null
  		 */
  		this.boundingBox = null;

  		/**
  		 * The bounding sphere of the skinned mesh. Can be computed via {@link SkinnedMesh#computeBoundingSphere}.
  		 *
  		 * @type {?Sphere}
  		 * @default null
  		 */
  		this.boundingSphere = null;

  	}

  	/**
  	 * Computes the bounding box of the skinned mesh, and updates {@link SkinnedMesh#boundingBox}.
  	 * The bounding box is not automatically computed by the engine; this method must be called by your app.
  	 * If the skinned mesh is animated, the bounding box should be recomputed per frame in order to reflect
  	 * the current animation state.
  	 */
  	computeBoundingBox() {

  		const geometry = this.geometry;

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		this.boundingBox.makeEmpty();

  		const positionAttribute = geometry.getAttribute( 'position' );

  		for ( let i = 0; i < positionAttribute.count; i ++ ) {

  			this.getVertexPosition( i, _vertex );
  			this.boundingBox.expandByPoint( _vertex );

  		}

  	}

  	/**
  	 * Computes the bounding sphere of the skinned mesh, and updates {@link SkinnedMesh#boundingSphere}.
  	 * The bounding sphere is automatically computed by the engine once when it is needed, e.g., for ray casting
  	 * and view frustum culling. If the skinned mesh is animated, the bounding sphere should be recomputed
  	 * per frame in order to reflect the current animation state.
  	 */
  	computeBoundingSphere() {

  		const geometry = this.geometry;

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere();

  		}

  		this.boundingSphere.makeEmpty();

  		const positionAttribute = geometry.getAttribute( 'position' );

  		for ( let i = 0; i < positionAttribute.count; i ++ ) {

  			this.getVertexPosition( i, _vertex );
  			this.boundingSphere.expandByPoint( _vertex );

  		}

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.bindMode = source.bindMode;
  		this.bindMatrix.copy( source.bindMatrix );
  		this.bindMatrixInverse.copy( source.bindMatrixInverse );

  		this.skeleton = source.skeleton;

  		if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
  		if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

  		return this;

  	}

  	raycast( raycaster, intersects ) {

  		const material = this.material;
  		const matrixWorld = this.matrixWorld;

  		if ( material === undefined ) return;

  		// test with bounding sphere in world space

  		if ( this.boundingSphere === null ) this.computeBoundingSphere();

  		_sphere$5.copy( this.boundingSphere );
  		_sphere$5.applyMatrix4( matrixWorld );

  		if ( raycaster.ray.intersectsSphere( _sphere$5 ) === false ) return;

  		// convert ray to local space of skinned mesh

  		_inverseMatrix$2.copy( matrixWorld ).invert();
  		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

  		// test with bounding box in local space

  		if ( this.boundingBox !== null ) {

  			if ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;

  		}

  		// test for intersections with geometry

  		this._computeIntersections( raycaster, intersects, _ray$2 );

  	}

  	getVertexPosition( index, target ) {

  		super.getVertexPosition( index, target );

  		this.applyBoneTransform( index, target );

  		return target;

  	}

  	/**
  	 * Binds the given skeleton to the skinned mesh.
  	 *
  	 * @param {Skeleton} skeleton - The skeleton to bind.
  	 * @param {Matrix4} [bindMatrix] - The bind matrix. If no bind matrix is provided,
  	 * the skinned mesh's world matrix will be used instead.
  	 */
  	bind( skeleton, bindMatrix ) {

  		this.skeleton = skeleton;

  		if ( bindMatrix === undefined ) {

  			this.updateMatrixWorld( true );

  			this.skeleton.calculateInverses();

  			bindMatrix = this.matrixWorld;

  		}

  		this.bindMatrix.copy( bindMatrix );
  		this.bindMatrixInverse.copy( bindMatrix ).invert();

  	}

  	/**
  	 * This method sets the skinned mesh in the rest pose).
  	 */
  	pose() {

  		this.skeleton.pose();

  	}

  	/**
  	 * Normalizes the skin weights which are defined as a buffer attribute
  	 * in the skinned mesh's geometry.
  	 */
  	normalizeSkinWeights() {

  		const vector = new Vector4();

  		const skinWeight = this.geometry.attributes.skinWeight;

  		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

  			vector.fromBufferAttribute( skinWeight, i );

  			const scale = 1.0 / vector.manhattanLength();

  			if ( scale !== Infinity ) {

  				vector.multiplyScalar( scale );

  			} else {

  				vector.set( 1, 0, 0, 0 ); // do something reasonable

  			}

  			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

  		}

  	}

  	updateMatrixWorld( force ) {

  		super.updateMatrixWorld( force );

  		if ( this.bindMode === AttachedBindMode ) {

  			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

  		} else if ( this.bindMode === DetachedBindMode ) {

  			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

  		} else {

  			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

  		}

  	}

  	/**
  	 * Applies the bone transform associated with the given index to the given
  	 * vertex position. Returns the updated vector.
  	 *
  	 * @param {number} index - The vertex index.
  	 * @param {Vector3} target - The target object that is used to store the method's result.
  	 * the skinned mesh's world matrix will be used instead.
  	 * @return {Vector3} The updated vertex position.
  	 */
  	applyBoneTransform( index, target ) {

  		const skeleton = this.skeleton;
  		const geometry = this.geometry;

  		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
  		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

  		_basePosition.copy( target ).applyMatrix4( this.bindMatrix );

  		target.set( 0, 0, 0 );

  		for ( let i = 0; i < 4; i ++ ) {

  			const weight = _skinWeight.getComponent( i );

  			if ( weight !== 0 ) {

  				const boneIndex = _skinIndex.getComponent( i );

  				_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

  				target.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );

  			}

  		}

  		return target.applyMatrix4( this.bindMatrixInverse );

  	}

  }

  /**
   * A bone which is part of a {@link Skeleton}. The skeleton in turn is used by
   * the {@link SkinnedMesh}.
   *
   * ```js
   * const root = new THREE.Bone();
   * const child = new THREE.Bone();
   *
   * root.add( child );
   * child.position.y = 5;
   * ```
   *
   * @augments Object3D
   */
  class Bone extends Object3D {

  	/**
  	 * Constructs a new bone.
  	 */
  	constructor() {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isBone = true;

  		this.type = 'Bone';

  	}

  }

  /**
   * Creates a texture directly from raw buffer data.
   *
   * The interpretation of the data depends on type and format: If the type is
   * `UnsignedByteType`, a `Uint8Array` will be useful for addressing the
   * texel data. If the format is `RGBAFormat`, data needs four values for
   * one texel; Red, Green, Blue and Alpha (typically the opacity).
   *
   * @augments Texture
   */
  class DataTexture extends Texture {

  	/**
  	 * Constructs a new data texture.
  	 *
  	 * @param {?TypedArray} [data=null] - The buffer data.
  	 * @param {number} [width=1] - The width of the texture.
  	 * @param {number} [height=1] - The height of the texture.
  	 * @param {number} [format=RGBAFormat] - The texture format.
  	 * @param {number} [type=UnsignedByteType] - The texture type.
  	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
  	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
  	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
  	 * @param {number} [magFilter=NearestFilter] - The mag filter value.
  	 * @param {number} [minFilter=NearestFilter] - The min filter value.
  	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
  	 * @param {string} [colorSpace=NoColorSpace] - The color space.
  	 */
  	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {

  		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isDataTexture = true;

  		/**
  		 * The image definition of a data texture.
  		 *
  		 * @type {{data:TypedArray,width:number,height:number}}
  		 */
  		this.image = { data: data, width: width, height: height };

  		/**
  		 * Whether to generate mipmaps (if possible) for a texture.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.generateMipmaps = false;

  		/**
  		 * If set to `true`, the texture is flipped along the vertical axis when
  		 * uploaded to the GPU.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flipY = false;

  		/**
  		 * Specifies the alignment requirements for the start of each pixel row in memory.
  		 *
  		 * Overwritten and set to `1` by default.
  		 *
  		 * @type {boolean}
  		 * @default 1
  		 */
  		this.unpackAlignment = 1;

  	}

  }

  const _offsetMatrix = /*@__PURE__*/ new Matrix4();
  const _identityMatrix$1 = /*@__PURE__*/ new Matrix4();

  /**
   * Class for representing the armatures in `three.js`. The skeleton
   * is defined by a hierarchy of bones.
   *
   * ```js
   * const bones = [];
   *
   * const shoulder = new THREE.Bone();
   * const elbow = new THREE.Bone();
   * const hand = new THREE.Bone();
   *
   * shoulder.add( elbow );
   * elbow.add( hand );
   *
   * bones.push( shoulder , elbow, hand);
   *
   * shoulder.position.y = -5;
   * elbow.position.y = 0;
   * hand.position.y = 5;
   *
   * const armSkeleton = new THREE.Skeleton( bones );
   * ```
   */
  class Skeleton {

  	/**
  	 * Constructs a new skeleton.
  	 *
  	 * @param {Array<Bone>} [bones] - An array of bones.
  	 * @param {Array<Matrix4>} [boneInverses] - An array of bone inverse matrices.
  	 * If not provided, these matrices will be computed automatically via {@link Skeleton#calculateInverses}.
  	 */
  	constructor( bones = [], boneInverses = [] ) {

  		this.uuid = generateUUID();

  		/**
  		 * An array of bones defining the skeleton.
  		 *
  		 * @type {Array<Bone>}
  		 */
  		this.bones = bones.slice( 0 );

  		/**
  		 * An array of bone inverse matrices.
  		 *
  		 * @type {Array<Matrix4>}
  		 */
  		this.boneInverses = boneInverses;

  		/**
  		 * An array buffer holding the bone data.
  		 * Input data for {@link Skeleton#boneTexture}.
  		 *
  		 * @type {?Float32Array}
  		 * @default null
  		 */
  		this.boneMatrices = null;

  		/**
  		 * A texture holding the bone data for use
  		 * in the vertex shader.
  		 *
  		 * @type {?DataTexture}
  		 * @default null
  		 */
  		this.boneTexture = null;

  		this.init();

  	}

  	/**
  	 * Initializes the skeleton. This method gets automatically called by the constructor
  	 * but depending on how the skeleton is created it might be necessary to call this method
  	 * manually.
  	 */
  	init() {

  		const bones = this.bones;
  		const boneInverses = this.boneInverses;

  		this.boneMatrices = new Float32Array( bones.length * 16 );

  		// calculate inverse bone matrices if necessary

  		if ( boneInverses.length === 0 ) {

  			this.calculateInverses();

  		} else {

  			// handle special case

  			if ( bones.length !== boneInverses.length ) {

  				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

  				this.boneInverses = [];

  				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  					this.boneInverses.push( new Matrix4() );

  				}

  			}

  		}

  	}

  	/**
  	 * Computes the bone inverse matrices. This method resets {@link Skeleton#boneInverses}
  	 * and fills it with new matrices.
  	 */
  	calculateInverses() {

  		this.boneInverses.length = 0;

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const inverse = new Matrix4();

  			if ( this.bones[ i ] ) {

  				inverse.copy( this.bones[ i ].matrixWorld ).invert();

  			}

  			this.boneInverses.push( inverse );

  		}

  	}

  	/**
  	 * Resets the skeleton to the base pose.
  	 */
  	pose() {

  		// recover the bind-time world matrices

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const bone = this.bones[ i ];

  			if ( bone ) {

  				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

  			}

  		}

  		// compute the local matrices, positions, rotations and scales

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const bone = this.bones[ i ];

  			if ( bone ) {

  				if ( bone.parent && bone.parent.isBone ) {

  					bone.matrix.copy( bone.parent.matrixWorld ).invert();
  					bone.matrix.multiply( bone.matrixWorld );

  				} else {

  					bone.matrix.copy( bone.matrixWorld );

  				}

  				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

  			}

  		}

  	}

  	/**
  	 * Resets the skeleton to the base pose.
  	 */
  	update() {

  		const bones = this.bones;
  		const boneInverses = this.boneInverses;
  		const boneMatrices = this.boneMatrices;
  		const boneTexture = this.boneTexture;

  		// flatten bone matrices to array

  		for ( let i = 0, il = bones.length; i < il; i ++ ) {

  			// compute the offset between the current and the original transform

  			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix$1;

  			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
  			_offsetMatrix.toArray( boneMatrices, i * 16 );

  		}

  		if ( boneTexture !== null ) {

  			boneTexture.needsUpdate = true;

  		}

  	}

  	/**
  	 * Returns a new skeleton with copied values from this instance.
  	 *
  	 * @return {Skeleton} A clone of this instance.
  	 */
  	clone() {

  		return new Skeleton( this.bones, this.boneInverses );

  	}

  	/**
  	 * Computes a data texture for passing bone data to the vertex shader.
  	 *
  	 * @return {Skeleton} A reference of this instance.
  	 */
  	computeBoneTexture() {

  		// layout (1 matrix = 4 pixels)
  		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
  		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
  		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
  		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
  		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

  		let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
  		size = Math.ceil( size / 4 ) * 4;
  		size = Math.max( size, 4 );

  		const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
  		boneMatrices.set( this.boneMatrices ); // copy current values

  		const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
  		boneTexture.needsUpdate = true;

  		this.boneMatrices = boneMatrices;
  		this.boneTexture = boneTexture;

  		return this;

  	}

  	/**
  	 * Searches through the skeleton's bone array and returns the first with a
  	 * matching name.
  	 *
  	 * @param {string} name - The name of the bone.
  	 * @return {Bone|undefined} The found bone. `undefined` if no bone has been found.
  	 */
  	getBoneByName( name ) {

  		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

  			const bone = this.bones[ i ];

  			if ( bone.name === name ) {

  				return bone;

  			}

  		}

  		return undefined;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 */
  	dispose( ) {

  		if ( this.boneTexture !== null ) {

  			this.boneTexture.dispose();

  			this.boneTexture = null;

  		}

  	}

  	/**
  	 * Setups the skeleton by the given JSON and bones.
  	 *
  	 * @param {Object} json - The skeleton as serialized JSON.
  	 * @param {Object<string, Bone>} bones - An array of bones.
  	 * @return {Skeleton} A reference of this instance.
  	 */
  	fromJSON( json, bones ) {

  		this.uuid = json.uuid;

  		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

  			const uuid = json.bones[ i ];
  			let bone = bones[ uuid ];

  			if ( bone === undefined ) {

  				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
  				bone = new Bone();

  			}

  			this.bones.push( bone );
  			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

  		}

  		this.init();

  		return this;

  	}

  	/**
  	 * Serializes the skeleton into JSON.
  	 *
  	 * @return {Object} A JSON object representing the serialized skeleton.
  	 * @see {@link ObjectLoader#parse}
  	 */
  	toJSON() {

  		const data = {
  			metadata: {
  				version: 4.7,
  				type: 'Skeleton',
  				generator: 'Skeleton.toJSON'
  			},
  			bones: [],
  			boneInverses: []
  		};

  		data.uuid = this.uuid;

  		const bones = this.bones;
  		const boneInverses = this.boneInverses;

  		for ( let i = 0, l = bones.length; i < l; i ++ ) {

  			const bone = bones[ i ];
  			data.bones.push( bone.uuid );

  			const boneInverse = boneInverses[ i ];
  			data.boneInverses.push( boneInverse.toArray() );

  		}

  		return data;

  	}

  }

  /**
   * An instanced version of a buffer attribute.
   *
   * @augments BufferAttribute
   */
  class InstancedBufferAttribute extends BufferAttribute {

  	/**
  	 * Constructs a new instanced buffer attribute.
  	 *
  	 * @param {TypedArray} array - The array holding the attribute data.
  	 * @param {number} itemSize - The item size.
  	 * @param {boolean} [normalized=false] - Whether the data are normalized or not.
  	 * @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
  	 */
  	constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

  		super( array, itemSize, normalized );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isInstancedBufferAttribute = true;

  		/**
  		 * Defines how often a value of this buffer attribute should be repeated. A
  		 * value of one means that each value of the instanced attribute is used for
  		 * a single instance. A value of two means that each value is used for two
  		 * consecutive instances (and so on).
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.meshPerAttribute = meshPerAttribute;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  	toJSON() {

  		const data = super.toJSON();

  		data.meshPerAttribute = this.meshPerAttribute;

  		data.isInstancedBufferAttribute = true;

  		return data;

  	}

  }

  const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
  const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

  const _instanceIntersects = [];

  const _box3 = /*@__PURE__*/ new Box3();
  const _identity = /*@__PURE__*/ new Matrix4();
  const _mesh$1 = /*@__PURE__*/ new Mesh();
  const _sphere$4 = /*@__PURE__*/ new Sphere();

  /**
   * A special version of a mesh with instanced rendering support. Use
   * this class if you have to render a large number of objects with the same
   * geometry and material(s) but with different world transformations. The usage
   * of 'InstancedMesh' will help you to reduce the number of draw calls and thus
   * improve the overall rendering performance in your application.
   *
   * @augments Mesh
   */
  class InstancedMesh extends Mesh {

  	/**
  	 * Constructs a new instanced mesh.
  	 *
  	 * @param {BufferGeometry} [geometry] - The mesh geometry.
  	 * @param {Material|Array<Material>} [material] - The mesh material.
  	 * @param {number} count - The number of instances.
  	 */
  	constructor( geometry, material, count ) {

  		super( geometry, material );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isInstancedMesh = true;

  		/**
  		 * Represents the local transformation of all instances. You have to set its
  		 * {@link BufferAttribute#needsUpdate} flag to true if you modify instanced data
  		 * via {@link InstancedMesh#setMatrixAt}.
  		 *
  		 * @type {InstancedBufferAttribute}
  		 */
  		this.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );

  		/**
  		 * Represents the color of all instances. You have to set its
  		 * {@link BufferAttribute#needsUpdate} flag to true if you modify instanced data
  		 * via {@link InstancedMesh#setColorAt}.
  		 *
  		 * @type {?InstancedBufferAttribute}
  		 * @default null
  		 */
  		this.instanceColor = null;

  		/**
  		 * Represents the morph target weights of all instances. You have to set its
  		 * {@link Texture#needsUpdate} flag to true if you modify instanced data
  		 * via {@link InstancedMesh#setMorphAt}.
  		 *
  		 * @type {?DataTexture}
  		 * @default null
  		 */
  		this.morphTexture = null;

  		/**
  		 * The number of instances.
  		 *
  		 * @type {number}
  		 */
  		this.count = count;

  		/**
  		 * The bounding box of the instanced mesh. Can be computed via {@link InstancedMesh#computeBoundingBox}.
  		 *
  		 * @type {?Box3}
  		 * @default null
  		 */
  		this.boundingBox = null;

  		/**
  		 * The bounding sphere of the instanced mesh. Can be computed via {@link InstancedMesh#computeBoundingSphere}.
  		 *
  		 * @type {?Sphere}
  		 * @default null
  		 */
  		this.boundingSphere = null;

  		for ( let i = 0; i < count; i ++ ) {

  			this.setMatrixAt( i, _identity );

  		}

  	}

  	/**
  	 * Computes the bounding box of the instanced mesh, and updates {@link InstancedMesh#boundingBox}.
  	 * The bounding box is not automatically computed by the engine; this method must be called by your app.
  	 * You may need to recompute the bounding box if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
  	 */
  	computeBoundingBox() {

  		const geometry = this.geometry;
  		const count = this.count;

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		if ( geometry.boundingBox === null ) {

  			geometry.computeBoundingBox();

  		}

  		this.boundingBox.makeEmpty();

  		for ( let i = 0; i < count; i ++ ) {

  			this.getMatrixAt( i, _instanceLocalMatrix );

  			_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );

  			this.boundingBox.union( _box3 );

  		}

  	}

  	/**
  	 * Computes the bounding sphere of the instanced mesh, and updates {@link InstancedMesh#boundingSphere}
  	 * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
  	 * You may need to recompute the bounding sphere if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
  	 */
  	computeBoundingSphere() {

  		const geometry = this.geometry;
  		const count = this.count;

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere();

  		}

  		if ( geometry.boundingSphere === null ) {

  			geometry.computeBoundingSphere();

  		}

  		this.boundingSphere.makeEmpty();

  		for ( let i = 0; i < count; i ++ ) {

  			this.getMatrixAt( i, _instanceLocalMatrix );

  			_sphere$4.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );

  			this.boundingSphere.union( _sphere$4 );

  		}

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.instanceMatrix.copy( source.instanceMatrix );

  		if ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();
  		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

  		this.count = source.count;

  		if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
  		if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

  		return this;

  	}

  	/**
  	 * Gets the color of the defined instance.
  	 *
  	 * @param {number} index - The instance index.
  	 * @param {Color} color - The target object that is used to store the method's result.
  	 */
  	getColorAt( index, color ) {

  		color.fromArray( this.instanceColor.array, index * 3 );

  	}

  	/**
  	 * Gets the local transformation matrix of the defined instance.
  	 *
  	 * @param {number} index - The instance index.
  	 * @param {Matrix4} matrix - The target object that is used to store the method's result.
  	 */
  	getMatrixAt( index, matrix ) {

  		matrix.fromArray( this.instanceMatrix.array, index * 16 );

  	}

  	/**
  	 * Gets the morph target weights of the defined instance.
  	 *
  	 * @param {number} index - The instance index.
  	 * @param {Mesh} object - The target object that is used to store the method's result.
  	 */
  	getMorphAt( index, object ) {

  		const objectInfluences = object.morphTargetInfluences;

  		const array = this.morphTexture.source.data.data;

  		const len = objectInfluences.length + 1; // All influences + the baseInfluenceSum

  		const dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning

  		for ( let i = 0; i < objectInfluences.length; i ++ ) {

  			objectInfluences[ i ] = array[ dataIndex + i ];

  		}

  	}

  	raycast( raycaster, intersects ) {

  		const matrixWorld = this.matrixWorld;
  		const raycastTimes = this.count;

  		_mesh$1.geometry = this.geometry;
  		_mesh$1.material = this.material;

  		if ( _mesh$1.material === undefined ) return;

  		// test with bounding sphere first

  		if ( this.boundingSphere === null ) this.computeBoundingSphere();

  		_sphere$4.copy( this.boundingSphere );
  		_sphere$4.applyMatrix4( matrixWorld );

  		if ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;

  		// now test each instance

  		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

  			// calculate the world matrix for each instance

  			this.getMatrixAt( instanceId, _instanceLocalMatrix );

  			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

  			// the mesh represents this single instance

  			_mesh$1.matrixWorld = _instanceWorldMatrix;

  			_mesh$1.raycast( raycaster, _instanceIntersects );

  			// process the result of raycast

  			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

  				const intersect = _instanceIntersects[ i ];
  				intersect.instanceId = instanceId;
  				intersect.object = this;
  				intersects.push( intersect );

  			}

  			_instanceIntersects.length = 0;

  		}

  	}

  	/**
  	 * Sets the given color to the defined instance. Make sure you set the `needsUpdate` flag of
  	 * {@link InstancedMesh#instanceColor} to `true` after updating all the colors.
  	 *
  	 * @param {number} index - The instance index.
  	 * @param {Color} color - The instance color.
  	 */
  	setColorAt( index, color ) {

  		if ( this.instanceColor === null ) {

  			this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ).fill( 1 ), 3 );

  		}

  		color.toArray( this.instanceColor.array, index * 3 );

  	}

  	/**
  	 * Sets the given local transformation matrix to the defined instance. Make sure you set the `needsUpdate` flag of
  	 * {@link InstancedMesh#instanceMatrix} to `true` after updating all the colors.
  	 *
  	 * @param {number} index - The instance index.
  	 * @param {Matrix4} matrix - The local transformation.
  	 */
  	setMatrixAt( index, matrix ) {

  		matrix.toArray( this.instanceMatrix.array, index * 16 );

  	}

  	/**
  	 * Sets the morph target weights to the defined instance. Make sure you set the `needsUpdate` flag of
  	 * {@link InstancedMesh#morphTexture} to `true` after updating all the influences.
  	 *
  	 * @param {number} index - The instance index.
  	 * @param {Mesh} object -  A mesh which `morphTargetInfluences` property containing the morph target weights
  	 * of a single instance.
  	 */
  	setMorphAt( index, object ) {

  		const objectInfluences = object.morphTargetInfluences;

  		const len = objectInfluences.length + 1; // morphBaseInfluence + all influences

  		if ( this.morphTexture === null ) {

  			this.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );

  		}

  		const array = this.morphTexture.source.data.data;

  		let morphInfluencesSum = 0;

  		for ( let i = 0; i < objectInfluences.length; i ++ ) {

  			morphInfluencesSum += objectInfluences[ i ];

  		}

  		const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

  		const dataIndex = len * index;

  		array[ dataIndex ] = morphBaseInfluence;

  		array.set( objectInfluences, dataIndex + 1 );

  	}

  	updateMorphTargets() {

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 */
  	dispose() {

  		this.dispatchEvent( { type: 'dispose' } );

  		if ( this.morphTexture !== null ) {

  			this.morphTexture.dispose();
  			this.morphTexture = null;

  		}

  	}

  }

  const _vector1 = /*@__PURE__*/ new Vector3();
  const _vector2 = /*@__PURE__*/ new Vector3();
  const _normalMatrix = /*@__PURE__*/ new Matrix3();

  /**
   * A two dimensional surface that extends infinitely in 3D space, represented
   * in [Hessian normal form]{@link http://mathworld.wolfram.com/HessianNormalForm.html}
   * by a unit length normal vector and a constant.
   */
  class Plane {

  	/**
  	 * Constructs a new plane.
  	 *
  	 * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
  	 * @param {number} [constant=0] - The signed distance from the origin to the plane.
  	 */
  	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPlane = true;

  		/**
  		 * A unit length vector defining the normal of the plane.
  		 *
  		 * @type {Vector3}
  		 */
  		this.normal = normal;

  		/**
  		 * The signed distance from the origin to the plane.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.constant = constant;

  	}

  	/**
  	 * Sets the plane components by copying the given values.
  	 *
  	 * @param {Vector3} normal - The normal.
  	 * @param {number} constant - The constant.
  	 * @return {Plane} A reference to this plane.
  	 */
  	set( normal, constant ) {

  		this.normal.copy( normal );
  		this.constant = constant;

  		return this;

  	}

  	/**
  	 * Sets the plane components by defining `x`, `y`, `z` as the
  	 * plane normal and `w` as the constant.
  	 *
  	 * @param {number} x - The value for the normal's x component.
  	 * @param {number} y - The value for the normal's y component.
  	 * @param {number} z - The value for the normal's z component.
  	 * @param {number} w - The constant value.
  	 * @return {Plane} A reference to this plane.
  	 */
  	setComponents( x, y, z, w ) {

  		this.normal.set( x, y, z );
  		this.constant = w;

  		return this;

  	}

  	/**
  	 * Sets the plane from the given normal and coplanar point (that is a point
  	 * that lies onto the plane).
  	 *
  	 * @param {Vector3} normal - The normal.
  	 * @param {Vector3} point - A coplanar point.
  	 * @return {Plane} A reference to this plane.
  	 */
  	setFromNormalAndCoplanarPoint( normal, point ) {

  		this.normal.copy( normal );
  		this.constant = - point.dot( this.normal );

  		return this;

  	}

  	/**
  	 * Sets the plane from three coplanar points. The winding order is
  	 * assumed to be counter-clockwise, and determines the direction of
  	 * the plane normal.
  	 *
  	 * @param {Vector3} a - The first coplanar point.
  	 * @param {Vector3} b - The second coplanar point.
  	 * @param {Vector3} c - The third coplanar point.
  	 * @return {Plane} A reference to this plane.
  	 */
  	setFromCoplanarPoints( a, b, c ) {

  		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

  		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

  		this.setFromNormalAndCoplanarPoint( normal, a );

  		return this;

  	}

  	/**
  	 * Copies the values of the given plane to this instance.
  	 *
  	 * @param {Plane} plane - The plane to copy.
  	 * @return {Plane} A reference to this plane.
  	 */
  	copy( plane ) {

  		this.normal.copy( plane.normal );
  		this.constant = plane.constant;

  		return this;

  	}

  	/**
  	 * Normalizes the plane normal and adjusts the constant accordingly.
  	 *
  	 * @return {Plane} A reference to this plane.
  	 */
  	normalize() {

  		// Note: will lead to a divide by zero if the plane is invalid.

  		const inverseNormalLength = 1.0 / this.normal.length();
  		this.normal.multiplyScalar( inverseNormalLength );
  		this.constant *= inverseNormalLength;

  		return this;

  	}

  	/**
  	 * Negates both the plane normal and the constant.
  	 *
  	 * @return {Plane} A reference to this plane.
  	 */
  	negate() {

  		this.constant *= -1;
  		this.normal.negate();

  		return this;

  	}

  	/**
  	 * Returns the signed distance from the given point to this plane.
  	 *
  	 * @param {Vector3} point - The point to compute the distance for.
  	 * @return {number} The signed distance.
  	 */
  	distanceToPoint( point ) {

  		return this.normal.dot( point ) + this.constant;

  	}

  	/**
  	 * Returns the signed distance from the given sphere to this plane.
  	 *
  	 * @param {Sphere} sphere - The sphere to compute the distance for.
  	 * @return {number} The signed distance.
  	 */
  	distanceToSphere( sphere ) {

  		return this.distanceToPoint( sphere.center ) - sphere.radius;

  	}

  	/**
  	 * Projects a the given point onto the plane.
  	 *
  	 * @param {Vector3} point - The point to project.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The projected point on the plane.
  	 */
  	projectPoint( point, target ) {

  		return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

  	}

  	/**
  	 * Returns the intersection point of the passed line and the plane. Returns
  	 * `null` if the line does not intersect. Returns the line's starting point if
  	 * the line is coplanar with the plane.
  	 *
  	 * @param {Line3} line - The line to compute the intersection for.
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {?Vector3} The intersection point.
  	 */
  	intersectLine( line, target ) {

  		const direction = line.delta( _vector1 );

  		const denominator = this.normal.dot( direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( this.distanceToPoint( line.start ) === 0 ) {

  				return target.copy( line.start );

  			}

  			// Unsure if this is the correct method to handle this case.
  			return null;

  		}

  		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

  		if ( t < 0 || t > 1 ) {

  			return null;

  		}

  		return target.copy( line.start ).addScaledVector( direction, t );

  	}

  	/**
  	 * Returns `true` if the given line segment intersects with (passes through) the plane.
  	 *
  	 * @param {Line3} line - The line to test.
  	 * @return {boolean} Whether the given line segment intersects with the plane or not.
  	 */
  	intersectsLine( line ) {

  		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

  		const startSign = this.distanceToPoint( line.start );
  		const endSign = this.distanceToPoint( line.end );

  		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  	}

  	/**
  	 * Returns `true` if the given bounding box intersects with the plane.
  	 *
  	 * @param {Box3} box - The bounding box to test.
  	 * @return {boolean} Whether the given bounding box intersects with the plane or not.
  	 */
  	intersectsBox( box ) {

  		return box.intersectsPlane( this );

  	}

  	/**
  	 * Returns `true` if the given bounding sphere intersects with the plane.
  	 *
  	 * @param {Sphere} sphere - The bounding sphere to test.
  	 * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
  	 */
  	intersectsSphere( sphere ) {

  		return sphere.intersectsPlane( this );

  	}

  	/**
  	 * Returns a coplanar vector to the plane, by calculating the
  	 * projection of the normal at the origin onto the plane.
  	 *
  	 * @param {Vector3} target - The target vector that is used to store the method's result.
  	 * @return {Vector3} The coplanar point.
  	 */
  	coplanarPoint( target ) {

  		return target.copy( this.normal ).multiplyScalar( - this.constant );

  	}

  	/**
  	 * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
  	 *
  	 * The optional normal matrix can be pre-computed like so:
  	 * ```js
  	 * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
  	 * ```
  	 *
  	 * @param {Matrix4} matrix - The transformation matrix.
  	 * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
  	 * @return {Plane} A reference to this plane.
  	 */
  	applyMatrix4( matrix, optionalNormalMatrix ) {

  		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

  		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

  		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

  		this.constant = - referencePoint.dot( normal );

  		return this;

  	}

  	/**
  	 * Translates the plane by the distance defined by the given offset vector.
  	 * Note that this only affects the plane constant and will not affect the normal vector.
  	 *
  	 * @param {Vector3} offset - The offset vector.
  	 * @return {Plane} A reference to this plane.
  	 */
  	translate( offset ) {

  		this.constant -= offset.dot( this.normal );

  		return this;

  	}

  	/**
  	 * Returns `true` if this plane is equal with the given one.
  	 *
  	 * @param {Plane} plane - The plane to test for equality.
  	 * @return {boolean} Whether this plane is equal with the given one.
  	 */
  	equals( plane ) {

  		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  	}

  	/**
  	 * Returns a new plane with copied values from this instance.
  	 *
  	 * @return {Plane} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  const _sphere$3 = /*@__PURE__*/ new Sphere();
  const _defaultSpriteCenter = /*@__PURE__*/ new Vector2( 0.5, 0.5 );
  const _vector$6 = /*@__PURE__*/ new Vector3();

  /**
   * Frustums are used to determine what is inside the camera's field of view.
   * They help speed up the rendering process - objects which lie outside a camera's
   * frustum can safely be excluded from rendering.
   *
   * This class is mainly intended for use internally by a renderer.
   */
  class Frustum {

  	/**
  	 * Constructs a new frustum.
  	 *
  	 * @param {Plane} [p0] - The first plane that encloses the frustum.
  	 * @param {Plane} [p1] - The second plane that encloses the frustum.
  	 * @param {Plane} [p2] - The third plane that encloses the frustum.
  	 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
  	 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
  	 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
  	 */
  	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

  		/**
  		 * This array holds the planes that enclose the frustum.
  		 *
  		 * @type {Array<Plane>}
  		 */
  		this.planes = [ p0, p1, p2, p3, p4, p5 ];

  	}

  	/**
  	 * Sets the frustum planes by copying the given planes.
  	 *
  	 * @param {Plane} [p0] - The first plane that encloses the frustum.
  	 * @param {Plane} [p1] - The second plane that encloses the frustum.
  	 * @param {Plane} [p2] - The third plane that encloses the frustum.
  	 * @param {Plane} [p3] - The fourth plane that encloses the frustum.
  	 * @param {Plane} [p4] - The fifth plane that encloses the frustum.
  	 * @param {Plane} [p5] - The sixth plane that encloses the frustum.
  	 * @return {Frustum} A reference to this frustum.
  	 */
  	set( p0, p1, p2, p3, p4, p5 ) {

  		const planes = this.planes;

  		planes[ 0 ].copy( p0 );
  		planes[ 1 ].copy( p1 );
  		planes[ 2 ].copy( p2 );
  		planes[ 3 ].copy( p3 );
  		planes[ 4 ].copy( p4 );
  		planes[ 5 ].copy( p5 );

  		return this;

  	}

  	/**
  	 * Copies the values of the given frustum to this instance.
  	 *
  	 * @param {Frustum} frustum - The frustum to copy.
  	 * @return {Frustum} A reference to this frustum.
  	 */
  	copy( frustum ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			planes[ i ].copy( frustum.planes[ i ] );

  		}

  		return this;

  	}

  	/**
  	 * Sets the frustum planes from the given projection matrix.
  	 *
  	 * @param {Matrix4} m - The projection matrix.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
  	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
  	 * @return {Frustum} A reference to this frustum.
  	 */
  	setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false ) {

  		const planes = this.planes;
  		const me = m.elements;
  		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
  		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
  		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
  		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

  		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
  		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
  		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
  		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();

  		if ( reversedDepth ) {

  			planes[ 4 ].setComponents( me2, me6, me10, me14 ).normalize(); // far
  			planes[ 5 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize(); // near

  		} else {

  			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize(); // far

  			if ( coordinateSystem === WebGLCoordinateSystem ) {

  				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize(); // near

  			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

  				planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize(); // near

  			} else {

  				throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

  			}

  		}

  		return this;

  	}

  	/**
  	 * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
  	 *
  	 * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
  	 *
  	 * @param {Object3D} object - The 3D object to test.
  	 * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
  	 */
  	intersectsObject( object ) {

  		if ( object.boundingSphere !== undefined ) {

  			if ( object.boundingSphere === null ) object.computeBoundingSphere();

  			_sphere$3.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

  		} else {

  			const geometry = object.geometry;

  			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  			_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

  		}

  		return this.intersectsSphere( _sphere$3 );

  	}

  	/**
  	 * Returns `true` if the given sprite is intersecting this frustum.
  	 *
  	 * @param {Sprite} sprite - The sprite to test.
  	 * @return {boolean} Whether the sprite is intersecting this frustum or not.
  	 */
  	intersectsSprite( sprite ) {

  		_sphere$3.center.set( 0, 0, 0 );

  		const offset = _defaultSpriteCenter.distanceTo( sprite.center );

  		_sphere$3.radius = 0.7071067811865476 + offset;
  		_sphere$3.applyMatrix4( sprite.matrixWorld );

  		return this.intersectsSphere( _sphere$3 );

  	}

  	/**
  	 * Returns `true` if the given bounding sphere is intersecting this frustum.
  	 *
  	 * @param {Sphere} sphere - The bounding sphere to test.
  	 * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
  	 */
  	intersectsSphere( sphere ) {

  		const planes = this.planes;
  		const center = sphere.center;
  		const negRadius = - sphere.radius;

  		for ( let i = 0; i < 6; i ++ ) {

  			const distance = planes[ i ].distanceToPoint( center );

  			if ( distance < negRadius ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	/**
  	 * Returns `true` if the given bounding box is intersecting this frustum.
  	 *
  	 * @param {Box3} box - The bounding box to test.
  	 * @return {boolean} Whether the bounding box is intersecting this frustum or not.
  	 */
  	intersectsBox( box ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			const plane = planes[ i ];

  			// corner at max distance

  			_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
  			_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
  			_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;

  			if ( plane.distanceToPoint( _vector$6 ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	/**
  	 * Returns `true` if the given point lies within the frustum.
  	 *
  	 * @param {Vector3} point - The point to test.
  	 * @return {boolean} Whether the point lies within this frustum or not.
  	 */
  	containsPoint( point ) {

  		const planes = this.planes;

  		for ( let i = 0; i < 6; i ++ ) {

  			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	/**
  	 * Returns a new frustum with copied values from this instance.
  	 *
  	 * @return {Frustum} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  /**
   * A material for rendering line primitives.
   *
   * Materials define the appearance of renderable 3D objects.
   *
   * ```js
   * const material = new THREE.LineBasicMaterial( { color: 0xffffff } );
   * ```
   *
   * @augments Material
   */
  class LineBasicMaterial extends Material {

  	/**
  	 * Constructs a new line basic material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLineBasicMaterial = true;

  		this.type = 'LineBasicMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff );

  		/**
  		 * Sets the color of the lines using data from a texture. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * Controls line thickness or lines.
  		 *
  		 * Can only be used with {@link SVGRenderer}. WebGL and WebGPU
  		 * ignore this setting and always render line primitives with a
  		 * width of one pixel.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.linewidth = 1;

  		/**
  		 * Defines appearance of line ends.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('butt'|'round'|'square')}
  		 * @default 'round'
  		 */
  		this.linecap = 'round';

  		/**
  		 * Defines appearance of line joints.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.linejoin = 'round';

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.linewidth = source.linewidth;
  		this.linecap = source.linecap;
  		this.linejoin = source.linejoin;

  		this.fog = source.fog;

  		return this;

  	}

  }

  const _vStart = /*@__PURE__*/ new Vector3();
  const _vEnd = /*@__PURE__*/ new Vector3();

  const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
  const _ray$1 = /*@__PURE__*/ new Ray();
  const _sphere$1 = /*@__PURE__*/ new Sphere();

  const _intersectPointOnRay = /*@__PURE__*/ new Vector3();
  const _intersectPointOnSegment = /*@__PURE__*/ new Vector3();

  /**
   * A continuous line. The line are rendered by connecting consecutive
   * vertices with straight lines.
   *
   * ```js
   * const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
   *
   * const points = [];
   * points.push( new THREE.Vector3( - 10, 0, 0 ) );
   * points.push( new THREE.Vector3( 0, 10, 0 ) );
   * points.push( new THREE.Vector3( 10, 0, 0 ) );
   *
   * const geometry = new THREE.BufferGeometry().setFromPoints( points );
   *
   * const line = new THREE.Line( geometry, material );
   * scene.add( line );
   * ```
   *
   * @augments Object3D
   */
  class Line extends Object3D {

  	/**
  	 * Constructs a new line.
  	 *
  	 * @param {BufferGeometry} [geometry] - The line geometry.
  	 * @param {Material|Array<Material>} [material] - The line material.
  	 */
  	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLine = true;

  		this.type = 'Line';

  		/**
  		 * The line geometry.
  		 *
  		 * @type {BufferGeometry}
  		 */
  		this.geometry = geometry;

  		/**
  		 * The line material.
  		 *
  		 * @type {Material|Array<Material>}
  		 * @default LineBasicMaterial
  		 */
  		this.material = material;

  		/**
  		 * A dictionary representing the morph targets in the geometry. The key is the
  		 * morph targets name, the value its attribute index. This member is `undefined`
  		 * by default and only set when morph targets are detected in the geometry.
  		 *
  		 * @type {Object<String,number>|undefined}
  		 * @default undefined
  		 */
  		this.morphTargetDictionary = undefined;

  		/**
  		 * An array of weights typically in the range `[0,1]` that specify how much of the morph
  		 * is applied. This member is `undefined` by default and only set when morph targets are
  		 * detected in the geometry.
  		 *
  		 * @type {Array<number>|undefined}
  		 * @default undefined
  		 */
  		this.morphTargetInfluences = undefined;

  		this.updateMorphTargets();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
  		this.geometry = source.geometry;

  		return this;

  	}

  	/**
  	 * Computes an array of distance values which are necessary for rendering dashed lines.
  	 * For each vertex in the geometry, the method calculates the cumulative length from the
  	 * current point to the very beginning of the line.
  	 *
  	 * @return {Line} A reference to this line.
  	 */
  	computeLineDistances() {

  		const geometry = this.geometry;

  		// we assume non-indexed geometry

  		if ( geometry.index === null ) {

  			const positionAttribute = geometry.attributes.position;
  			const lineDistances = [ 0 ];

  			for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

  				_vStart.fromBufferAttribute( positionAttribute, i - 1 );
  				_vEnd.fromBufferAttribute( positionAttribute, i );

  				lineDistances[ i ] = lineDistances[ i - 1 ];
  				lineDistances[ i ] += _vStart.distanceTo( _vEnd );

  			}

  			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

  		} else {

  			console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

  		}

  		return this;

  	}

  	/**
  	 * Computes intersection points between a casted ray and this line.
  	 *
  	 * @param {Raycaster} raycaster - The raycaster.
  	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
  	 */
  	raycast( raycaster, intersects ) {

  		const geometry = this.geometry;
  		const matrixWorld = this.matrixWorld;
  		const threshold = raycaster.params.Line.threshold;
  		const drawRange = geometry.drawRange;

  		// Checking boundingSphere distance to ray

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere$1.copy( geometry.boundingSphere );
  		_sphere$1.applyMatrix4( matrixWorld );
  		_sphere$1.radius += threshold;

  		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

  		//

  		_inverseMatrix$1.copy( matrixWorld ).invert();
  		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

  		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  		const localThresholdSq = localThreshold * localThreshold;

  		const step = this.isLineSegments ? 2 : 1;

  		const index = geometry.index;
  		const attributes = geometry.attributes;
  		const positionAttribute = attributes.position;

  		if ( index !== null ) {

  			const start = Math.max( 0, drawRange.start );
  			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  			for ( let i = start, l = end - 1; i < l; i += step ) {

  				const a = index.getX( i );
  				const b = index.getX( i + 1 );

  				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b, i );

  				if ( intersect ) {

  					intersects.push( intersect );

  				}

  			}

  			if ( this.isLineLoop ) {

  				const a = index.getX( end - 1 );
  				const b = index.getX( start );

  				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b, end - 1 );

  				if ( intersect ) {

  					intersects.push( intersect );

  				}

  			}

  		} else {

  			const start = Math.max( 0, drawRange.start );
  			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

  			for ( let i = start, l = end - 1; i < l; i += step ) {

  				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, i, i + 1, i );

  				if ( intersect ) {

  					intersects.push( intersect );

  				}

  			}

  			if ( this.isLineLoop ) {

  				const intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, end - 1, start, end - 1 );

  				if ( intersect ) {

  					intersects.push( intersect );

  				}

  			}

  		}

  	}

  	/**
  	 * Sets the values of {@link Line#morphTargetDictionary} and {@link Line#morphTargetInfluences}
  	 * to make sure existing morph targets can influence this 3D object.
  	 */
  	updateMorphTargets() {

  		const geometry = this.geometry;

  		const morphAttributes = geometry.morphAttributes;
  		const keys = Object.keys( morphAttributes );

  		if ( keys.length > 0 ) {

  			const morphAttribute = morphAttributes[ keys[ 0 ] ];

  			if ( morphAttribute !== undefined ) {

  				this.morphTargetInfluences = [];
  				this.morphTargetDictionary = {};

  				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  					const name = morphAttribute[ m ].name || String( m );

  					this.morphTargetInfluences.push( 0 );
  					this.morphTargetDictionary[ name ] = m;

  				}

  			}

  		}

  	}

  }

  function checkIntersection( object, raycaster, ray, thresholdSq, a, b, i ) {

  	const positionAttribute = object.geometry.attributes.position;

  	_vStart.fromBufferAttribute( positionAttribute, a );
  	_vEnd.fromBufferAttribute( positionAttribute, b );

  	const distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );

  	if ( distSq > thresholdSq ) return;

  	_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation

  	const distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );

  	if ( distance < raycaster.near || distance > raycaster.far ) return;

  	return {

  		distance: distance,
  		// What do we want? intersection point on the ray or on the segment??
  		// point: raycaster.ray.at( distance ),
  		point: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),
  		index: i,
  		face: null,
  		faceIndex: null,
  		barycoord: null,
  		object: object

  	};

  }

  const _start = /*@__PURE__*/ new Vector3();
  const _end = /*@__PURE__*/ new Vector3();

  /**
   * A series of lines drawn between pairs of vertices.
   *
   * @augments Line
   */
  class LineSegments extends Line {

  	/**
  	 * Constructs a new line segments.
  	 *
  	 * @param {BufferGeometry} [geometry] - The line geometry.
  	 * @param {Material|Array<Material>} [material] - The line material.
  	 */
  	constructor( geometry, material ) {

  		super( geometry, material );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLineSegments = true;

  		this.type = 'LineSegments';

  	}

  	computeLineDistances() {

  		const geometry = this.geometry;

  		// we assume non-indexed geometry

  		if ( geometry.index === null ) {

  			const positionAttribute = geometry.attributes.position;
  			const lineDistances = [];

  			for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

  				_start.fromBufferAttribute( positionAttribute, i );
  				_end.fromBufferAttribute( positionAttribute, i + 1 );

  				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
  				lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

  			}

  			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

  		} else {

  			console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

  		}

  		return this;

  	}

  }

  /**
   * A continuous line. This is nearly the same as {@link Line} the only difference
   * is that the last vertex is connected with the first vertex in order to close
   * the line to form a loop.
   *
   * @augments Line
   */
  class LineLoop extends Line {

  	/**
  	 * Constructs a new line loop.
  	 *
  	 * @param {BufferGeometry} [geometry] - The line geometry.
  	 * @param {Material|Array<Material>} [material] - The line material.
  	 */
  	constructor( geometry, material ) {

  		super( geometry, material );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLineLoop = true;

  		this.type = 'LineLoop';

  	}

  }

  /**
   * A material for rendering point primitives.
   *
   * Materials define the appearance of renderable 3D objects.
   *
   * ```js
   * const vertices = [];
   *
   * for ( let i = 0; i < 10000; i ++ ) {
   * 	const x = THREE.MathUtils.randFloatSpread( 2000 );
   * 	const y = THREE.MathUtils.randFloatSpread( 2000 );
   * 	const z = THREE.MathUtils.randFloatSpread( 2000 );
   *
   * 	vertices.push( x, y, z );
   * }
   *
   * const geometry = new THREE.BufferGeometry();
   * geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
   * const material = new THREE.PointsMaterial( { color: 0x888888 } );
   * const points = new THREE.Points( geometry, material );
   * scene.add( points );
   * ```
   *
   * @augments Material
   */
  class PointsMaterial extends Material {

  	/**
  	 * Constructs a new points material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPointsMaterial = true;

  		this.type = 'PointsMaterial';

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff );

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * Defines the size of the points in pixels.
  		 *
  		 * Might be capped if the value exceeds hardware dependent parameters like [gl.ALIASED_POINT_SIZE_RANGE]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getParamete}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.size = 1;

  		/**
  		 * Specifies whether size of individual points is attenuated by the camera depth (perspective camera only).
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.sizeAttenuation = true;

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.size = source.size;
  		this.sizeAttenuation = source.sizeAttenuation;

  		this.fog = source.fog;

  		return this;

  	}

  }

  const _inverseMatrix = /*@__PURE__*/ new Matrix4();
  const _ray$4 = /*@__PURE__*/ new Ray();
  const _sphere = /*@__PURE__*/ new Sphere();
  const _position$2 = /*@__PURE__*/ new Vector3();

  /**
   * A class for displaying points or point clouds.
   *
   * @augments Object3D
   */
  class Points extends Object3D {

  	/**
  	 * Constructs a new point cloud.
  	 *
  	 * @param {BufferGeometry} [geometry] - The points geometry.
  	 * @param {Material|Array<Material>} [material] - The points material.
  	 */
  	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPoints = true;

  		this.type = 'Points';

  		/**
  		 * The points geometry.
  		 *
  		 * @type {BufferGeometry}
  		 */
  		this.geometry = geometry;

  		/**
  		 * The line material.
  		 *
  		 * @type {Material|Array<Material>}
  		 * @default PointsMaterial
  		 */
  		this.material = material;

  		/**
  		 * A dictionary representing the morph targets in the geometry. The key is the
  		 * morph targets name, the value its attribute index. This member is `undefined`
  		 * by default and only set when morph targets are detected in the geometry.
  		 *
  		 * @type {Object<String,number>|undefined}
  		 * @default undefined
  		 */
  		this.morphTargetDictionary = undefined;

  		/**
  		 * An array of weights typically in the range `[0,1]` that specify how much of the morph
  		 * is applied. This member is `undefined` by default and only set when morph targets are
  		 * detected in the geometry.
  		 *
  		 * @type {Array<number>|undefined}
  		 * @default undefined
  		 */
  		this.morphTargetInfluences = undefined;

  		this.updateMorphTargets();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.material = Array.isArray( source.material ) ? source.material.slice() : source.material;
  		this.geometry = source.geometry;

  		return this;

  	}

  	/**
  	 * Computes intersection points between a casted ray and this point cloud.
  	 *
  	 * @param {Raycaster} raycaster - The raycaster.
  	 * @param {Array<Object>} intersects - The target array that holds the intersection points.
  	 */
  	raycast( raycaster, intersects ) {

  		const geometry = this.geometry;
  		const matrixWorld = this.matrixWorld;
  		const threshold = raycaster.params.Points.threshold;
  		const drawRange = geometry.drawRange;

  		// Checking boundingSphere distance to ray

  		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  		_sphere.copy( geometry.boundingSphere );
  		_sphere.applyMatrix4( matrixWorld );
  		_sphere.radius += threshold;

  		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

  		//

  		_inverseMatrix.copy( matrixWorld ).invert();
  		_ray$4.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

  		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  		const localThresholdSq = localThreshold * localThreshold;

  		const index = geometry.index;
  		const attributes = geometry.attributes;
  		const positionAttribute = attributes.position;

  		if ( index !== null ) {

  			const start = Math.max( 0, drawRange.start );
  			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  			for ( let i = start, il = end; i < il; i ++ ) {

  				const a = index.getX( i );

  				_position$2.fromBufferAttribute( positionAttribute, a );

  				testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

  			}

  		} else {

  			const start = Math.max( 0, drawRange.start );
  			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

  			for ( let i = start, l = end; i < l; i ++ ) {

  				_position$2.fromBufferAttribute( positionAttribute, i );

  				testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

  			}

  		}

  	}

  	/**
  	 * Sets the values of {@link Points#morphTargetDictionary} and {@link Points#morphTargetInfluences}
  	 * to make sure existing morph targets can influence this 3D object.
  	 */
  	updateMorphTargets() {

  		const geometry = this.geometry;

  		const morphAttributes = geometry.morphAttributes;
  		const keys = Object.keys( morphAttributes );

  		if ( keys.length > 0 ) {

  			const morphAttribute = morphAttributes[ keys[ 0 ] ];

  			if ( morphAttribute !== undefined ) {

  				this.morphTargetInfluences = [];
  				this.morphTargetDictionary = {};

  				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  					const name = morphAttribute[ m ].name || String( m );

  					this.morphTargetInfluences.push( 0 );
  					this.morphTargetDictionary[ name ] = m;

  				}

  			}

  		}

  	}

  }

  function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

  	const rayPointDistanceSq = _ray$4.distanceSqToPoint( point );

  	if ( rayPointDistanceSq < localThresholdSq ) {

  		const intersectPoint = new Vector3();

  		_ray$4.closestPointToPoint( point, intersectPoint );
  		intersectPoint.applyMatrix4( matrixWorld );

  		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

  		if ( distance < raycaster.near || distance > raycaster.far ) return;

  		intersects.push( {

  			distance: distance,
  			distanceToRay: Math.sqrt( rayPointDistanceSq ),
  			point: intersectPoint,
  			index: index,
  			face: null,
  			faceIndex: null,
  			barycoord: null,
  			object: object

  		} );

  	}

  }

  /**
   * This class can be used to automatically save the depth information of a
   * rendering into a texture.
   *
   * @augments Texture
   */
  class DepthTexture extends Texture {

  	/**
  	 * Constructs a new depth texture.
  	 *
  	 * @param {number} width - The width of the texture.
  	 * @param {number} height - The height of the texture.
  	 * @param {number} [type=UnsignedIntType] - The texture type.
  	 * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
  	 * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
  	 * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
  	 * @param {number} [magFilter=LinearFilter] - The mag filter value.
  	 * @param {number} [minFilter=LinearFilter] - The min filter value.
  	 * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
  	 * @param {number} [format=DepthFormat] - The texture format.
  	 * @param {number} [depth=1] - The depth of the texture.
  	 */
  	constructor( width, height, type = UnsignedIntType, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, format = DepthFormat, depth = 1 ) {

  		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

  			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

  		}

  		const image = { width: width, height: height, depth: depth };

  		super( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isDepthTexture = true;

  		/**
  		 * If set to `true`, the texture is flipped along the vertical axis when
  		 * uploaded to the GPU.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flipY = false;

  		/**
  		 * Whether to generate mipmaps (if possible) for a texture.
  		 *
  		 * Overwritten and set to `false` by default.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.generateMipmaps = false;

  		/**
  		 * Code corresponding to the depth compare function.
  		 *
  		 * @type {?(NeverCompare|LessCompare|EqualCompare|LessEqualCompare|GreaterCompare|NotEqualCompare|GreaterEqualCompare|AlwaysCompare)}
  		 * @default null
  		 */
  		this.compareFunction = null;

  	}


  	copy( source ) {

  		super.copy( source );

  		this.source = new Source( Object.assign( {}, source.image ) ); // see #30540
  		this.compareFunction = source.compareFunction;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

  		return data;

  	}

  }

  /**
   * Represents a texture created externally with the same renderer context.
   *
   * This may be a texture from a protected media stream, device camera feed,
   * or other data feeds like a depth sensor.
   *
   * Note that this class is only supported in {@link WebGLRenderer}, and in
   * the {@link WebGPURenderer} WebGPU backend.
   *
   * @augments Texture
   */
  class ExternalTexture extends Texture {

  	/**
  	 * Creates a new raw texture.
  	 *
  	 * @param {?(WebGLTexture|GPUTexture)} [sourceTexture=null] - The external texture.
  	 */
  	constructor( sourceTexture = null ) {

  		super();

  		/**
  		 * The external source texture.
  		 *
  		 * @type {?(WebGLTexture|GPUTexture)}
  		 * @default null
  		 */
  		this.sourceTexture = sourceTexture;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isExternalTexture = true;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.sourceTexture = source.sourceTexture;

  		return this;

  	}

  }

  /**
   * A geometry class for representing a plane.
   *
   * ```js
   * const geometry = new THREE.PlaneGeometry( 1, 1 );
   * const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
   * const plane = new THREE.Mesh( geometry, material );
   * scene.add( plane );
   * ```
   *
   * @augments BufferGeometry
   */
  class PlaneGeometry extends BufferGeometry {

  	/**
  	 * Constructs a new plane geometry.
  	 *
  	 * @param {number} [width=1] - The width along the X axis.
  	 * @param {number} [height=1] - The height along the Y axis
  	 * @param {number} [widthSegments=1] - The number of segments along the X axis.
  	 * @param {number} [heightSegments=1] - The number of segments along the Y axis.
  	 */
  	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

  		super();

  		this.type = 'PlaneGeometry';

  		/**
  		 * Holds the constructor parameters that have been
  		 * used to generate the geometry. Any modification
  		 * after instantiation does not change the geometry.
  		 *
  		 * @type {Object}
  		 */
  		this.parameters = {
  			width: width,
  			height: height,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments
  		};

  		const width_half = width / 2;
  		const height_half = height / 2;

  		const gridX = Math.floor( widthSegments );
  		const gridY = Math.floor( heightSegments );

  		const gridX1 = gridX + 1;
  		const gridY1 = gridY + 1;

  		const segment_width = width / gridX;
  		const segment_height = height / gridY;

  		//

  		const indices = [];
  		const vertices = [];
  		const normals = [];
  		const uvs = [];

  		for ( let iy = 0; iy < gridY1; iy ++ ) {

  			const y = iy * segment_height - height_half;

  			for ( let ix = 0; ix < gridX1; ix ++ ) {

  				const x = ix * segment_width - width_half;

  				vertices.push( x, - y, 0 );

  				normals.push( 0, 0, 1 );

  				uvs.push( ix / gridX );
  				uvs.push( 1 - ( iy / gridY ) );

  			}

  		}

  		for ( let iy = 0; iy < gridY; iy ++ ) {

  			for ( let ix = 0; ix < gridX; ix ++ ) {

  				const a = ix + gridX1 * iy;
  				const b = ix + gridX1 * ( iy + 1 );
  				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
  				const d = ( ix + 1 ) + gridX1 * iy;

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		this.setIndex( indices );
  		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.parameters = Object.assign( {}, source.parameters );

  		return this;

  	}

  	/**
  	 * Factory method for creating an instance of this class from the given
  	 * JSON object.
  	 *
  	 * @param {Object} data - A JSON object representing the serialized geometry.
  	 * @return {PlaneGeometry} A new instance.
  	 */
  	static fromJSON( data ) {

  		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

  	}

  }

  /**
   * A standard physically based material, using Metallic-Roughness workflow.
   *
   * Physically based rendering (PBR) has recently become the standard in many
   * 3D applications, such as [Unity]{@link https://blogs.unity3d.com/2014/10/29/physically-based-shading-in-unity-5-a-primer/},
   * [Unreal]{@link https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/PhysicallyBased/} and
   * [3D Studio Max]{@link http://area.autodesk.com/blogs/the-3ds-max-blog/what039s-new-for-rendering-in-3ds-max-2017}.
   *
   * This approach differs from older approaches in that instead of using
   * approximations for the way in which light interacts with a surface, a
   * physically correct model is used. The idea is that, instead of tweaking
   * materials to look good under specific lighting, a material can be created
   * that will react 'correctly' under all lighting scenarios.
   *
   * In practice this gives a more accurate and realistic looking result than
   * the {@link MeshLambertMaterial} or {@link MeshPhongMaterial}, at the cost of
   * being somewhat more computationally expensive. `MeshStandardMaterial` uses per-fragment
   * shading.
   *
   * Note that for best results you should always specify an environment map when using this material.
   *
   * For a non-technical introduction to the concept of PBR and how to set up a
   * PBR material, check out these articles by the people at [marmoset]{@link https://www.marmoset.co}:
   *
   * - [Basic Theory of Physically Based Rendering]{@link https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/}
   * - [Physically Based Rendering and You Can Too]{@link https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/}
   *
   * Technical details of the approach used in three.js (and most other PBR systems) can be found is this
   * [paper from Disney]{@link https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf}
   * (pdf), by Brent Burley.
   *
   * @augments Material
   */
  class MeshStandardMaterial extends Material {

  	/**
  	 * Constructs a new mesh standard material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshStandardMaterial = true;

  		this.type = 'MeshStandardMaterial';

  		this.defines = { 'STANDARD': '' };

  		/**
  		 * Color of the material.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.color = new Color( 0xffffff ); // diffuse

  		/**
  		 * How rough the material appears. `0.0` means a smooth mirror reflection, `1.0`
  		 * means fully diffuse. If `roughnessMap` is also provided,
  		 * both values are multiplied.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.roughness = 1.0;

  		/**
  		 * How much the material is like a metal. Non-metallic materials such as wood
  		 * or stone use `0.0`, metallic use `1.0`, with nothing (usually) in between.
  		 * A value between `0.0` and `1.0` could be used for a rusty metal look.
  		 * If `metalnessMap` is also provided, both values are multiplied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.metalness = 0.0;

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}. The texture map
  		 * color is modulated by the diffuse `color`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The light map. Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.lightMap = null;

  		/**
  		 * Intensity of the baked light.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.lightMapIntensity = 1.0;

  		/**
  		 * The red channel of this texture is used as the ambient occlusion map.
  		 * Requires a second set of UVs.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.aoMap = null;

  		/**
  		 * Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
  		 * disables ambient occlusion. Where intensity is `1` and the AO map's
  		 * red channel is also `1`, ambient light is fully occluded on a surface.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.aoMapIntensity = 1.0;

  		/**
  		 * Emissive (light) color of the material, essentially a solid color
  		 * unaffected by other lighting.
  		 *
  		 * @type {Color}
  		 * @default (0,0,0)
  		 */
  		this.emissive = new Color( 0x000000 );

  		/**
  		 * Intensity of the emissive light. Modulates the emissive color.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.emissiveIntensity = 1.0;

  		/**
  		 * Set emissive (glow) map. The emissive map color is modulated by the
  		 * emissive color and the emissive intensity. If you have an emissive map,
  		 * be sure to set the emissive color to something other than black.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.emissiveMap = null;

  		/**
  		 * The texture to create a bump map. The black and white values map to the
  		 * perceived depth in relation to the lights. Bump doesn't actually affect
  		 * the geometry of the object, only the lighting. If a normal map is defined
  		 * this will be ignored.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.bumpMap = null;

  		/**
  		 * How much the bump map affects the material. Typical range is `[0,1]`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.bumpScale = 1;

  		/**
  		 * The texture to create a normal map. The RGB values affect the surface
  		 * normal for each pixel fragment and change the way the color is lit. Normal
  		 * maps do not change the actual shape of the surface, only the lighting. In
  		 * case the material has a normal map authored using the left handed
  		 * convention, the `y` component of `normalScale` should be negated to compensate
  		 * for the different handedness.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.normalMap = null;

  		/**
  		 * The type of normal map.
  		 *
  		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
  		 * @default TangentSpaceNormalMap
  		 */
  		this.normalMapType = TangentSpaceNormalMap;

  		/**
  		 * How much the normal map affects the material. Typical value range is `[0,1]`.
  		 *
  		 * @type {Vector2}
  		 * @default (1,1)
  		 */
  		this.normalScale = new Vector2( 1, 1 );

  		/**
  		 * The displacement map affects the position of the mesh's vertices. Unlike
  		 * other maps which only affect the light and shade of the material the
  		 * displaced vertices can cast shadows, block other objects, and otherwise
  		 * act as real geometry. The displacement texture is an image where the value
  		 * of each pixel (white being the highest) is mapped against, and
  		 * repositions, the vertices of the mesh.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.displacementMap = null;

  		/**
  		 * How much the displacement map affects the mesh (where black is no
  		 * displacement, and white is maximum displacement). Without a displacement
  		 * map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementScale = 1;

  		/**
  		 * The offset of the displacement map's values on the mesh's vertices.
  		 * The bias is added to the scaled sample of the displacement map.
  		 * Without a displacement map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementBias = 0;

  		/**
  		 * The green channel of this texture is used to alter the roughness of the
  		 * material.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.roughnessMap = null;

  		/**
  		 * The blue channel of this texture is used to alter the metalness of the
  		 * material.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.metalnessMap = null;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * The environment map. To ensure a physically correct rendering, environment maps
  		 * are internally pre-processed with {@link PMREMGenerator}.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.envMap = null;

  		/**
  		 * The rotation of the environment map in radians.
  		 *
  		 * @type {Euler}
  		 * @default (0,0,0)
  		 */
  		this.envMapRotation = new Euler();

  		/**
  		 * Scales the effect of the environment map by multiplying its color.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.envMapIntensity = 1.0;

  		/**
  		 * Renders the geometry as a wireframe.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.wireframe = false;

  		/**
  		 * Controls the thickness of the wireframe.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.wireframeLinewidth = 1;

  		/**
  		 * Defines appearance of wireframe ends.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinecap = 'round';

  		/**
  		 * Defines appearance of wireframe joints.
  		 *
  		 * Can only be used with {@link SVGRenderer}.
  		 *
  		 * @type {('round'|'bevel'|'miter')}
  		 * @default 'round'
  		 */
  		this.wireframeLinejoin = 'round';

  		/**
  		 * Whether the material is rendered with flat shading or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.flatShading = false;

  		/**
  		 * Whether the material is affected by fog or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.fog = true;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.defines = { 'STANDARD': '' };

  		this.color.copy( source.color );
  		this.roughness = source.roughness;
  		this.metalness = source.metalness;

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.roughnessMap = source.roughnessMap;

  		this.metalnessMap = source.metalnessMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapRotation.copy( source.envMapRotation );
  		this.envMapIntensity = source.envMapIntensity;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.flatShading = source.flatShading;

  		this.fog = source.fog;

  		return this;

  	}

  }

  /**
   * An extension of the {@link MeshStandardMaterial}, providing more advanced
   * physically-based rendering properties:
   *
   * - Anisotropy: Ability to represent the anisotropic property of materials
   * as observable with brushed metals.
   * - Clearcoat: Some materials  like car paints, carbon fiber, and wet surfaces  require
   * a clear, reflective layer on top of another layer that may be irregular or rough.
   * Clearcoat approximates this effect, without the need for a separate transparent surface.
   * - Iridescence: Allows to render the effect where hue varies  depending on the viewing
   * angle and illumination angle. This can be seen on soap bubbles, oil films, or on the
   * wings of many insects.
   * - Physically-based transparency: One limitation of {@link Material#opacity} is that highly
   * transparent materials are less reflective. Physically-based transmission provides a more
   * realistic option for thin, transparent surfaces like glass.
   * - Advanced reflectivity: More flexible reflectivity for non-metallic materials.
   * - Sheen: Can be used for representing cloth and fabric materials.
   *
   * As a result of these complex shading features, `MeshPhysicalMaterial` has a
   * higher performance cost, per pixel, than other three.js materials. Most
   * effects are disabled by default, and add cost as they are enabled. For
   * best results, always specify an environment map when using this material.
   *
   * @augments MeshStandardMaterial
   */
  class MeshPhysicalMaterial extends MeshStandardMaterial {

  	/**
  	 * Constructs a new mesh physical material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshPhysicalMaterial = true;

  		this.defines = {

  			'STANDARD': '',
  			'PHYSICAL': ''

  		};

  		this.type = 'MeshPhysicalMaterial';

  		/**
  		 * The rotation of the anisotropy in tangent, bitangent space, measured in radians
  		 * counter-clockwise from the tangent. When `anisotropyMap` is present, this
  		 * property provides additional rotation to the vectors in the texture.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.anisotropyRotation = 0;

  		/**
  		 * Red and green channels represent the anisotropy direction in `[-1, 1]` tangent,
  		 * bitangent space, to be rotated by `anisotropyRotation`. The blue channel
  		 * contains strength as `[0, 1]` to be multiplied by `anisotropy`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.anisotropyMap = null;

  		/**
  		 * The red channel of this texture is multiplied against `clearcoat`,
  		 * for per-pixel control over a coating's intensity.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.clearcoatMap = null;

  		/**
  		 * Roughness of the clear coat layer, from `0.0` to `1.0`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.clearcoatRoughness = 0.0;

  		/**
  		 * The green channel of this texture is multiplied against
  		 * `clearcoatRoughness`, for per-pixel control over a coating's roughness.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.clearcoatRoughnessMap = null;

  		/**
  		 * How much `clearcoatNormalMap` affects the clear coat layer, from
  		 * `(0,0)` to `(1,1)`.
  		 *
  		 * @type {Vector2}
  		 * @default (1,1)
  		 */
  		this.clearcoatNormalScale = new Vector2( 1, 1 );

  		/**
  		 * Can be used to enable independent normals for the clear coat layer.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.clearcoatNormalMap = null;

  		/**
  		 * Index-of-refraction for non-metallic materials, from `1.0` to `2.333`.
  		 *
  		 * @type {number}
  		 * @default 1.5
  		 */
  		this.ior = 1.5;

  		/**
  		 * Degree of reflectivity, from `0.0` to `1.0`. Default is `0.5`, which
  		 * corresponds to an index-of-refraction of `1.5`.
  		 *
  		 * This models the reflectivity of non-metallic materials. It has no effect
  		 * when `metalness` is `1.0`
  		 *
  		 * @name MeshPhysicalMaterial#reflectivity
  		 * @type {number}
  		 * @default 0.5
  		 */
  		Object.defineProperty( this, 'reflectivity', {
  			get: function () {

  				return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

  			},
  			set: function ( reflectivity ) {

  				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

  			}
  		} );

  		/**
  		 * The red channel of this texture is multiplied against `iridescence`, for per-pixel
  		 * control over iridescence.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.iridescenceMap = null;

  		/**
  		 * Strength of the iridescence RGB color shift effect, represented by an index-of-refraction.
  		 * Between `1.0` to `2.333`.
  		 *
  		 * @type {number}
  		 * @default 1.3
  		 */
  		this.iridescenceIOR = 1.3;

  		/**
  		 *Array of exactly 2 elements, specifying minimum and maximum thickness of the iridescence layer.
  		 Thickness of iridescence layer has an equivalent effect of the one `thickness` has on `ior`.
  		 *
  		 * @type {Array<number,number>}
  		 * @default [100,400]
  		 */
  		this.iridescenceThicknessRange = [ 100, 400 ];

  		/**
  		 * A texture that defines the thickness of the iridescence layer, stored in the green channel.
  		 * Minimum and maximum values of thickness are defined by `iridescenceThicknessRange` array:
  		 * - `0.0` in the green channel will result in thickness equal to first element of the array.
  		 * - `1.0` in the green channel will result in thickness equal to second element of the array.
  		 * - Values in-between will linearly interpolate between the elements of the array.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.iridescenceThicknessMap = null;

  		/**
  		 * The sheen tint.
  		 *
  		 * @type {Color}
  		 * @default (0,0,0)
  		 */
  		this.sheenColor = new Color( 0x000000 );

  		/**
  		 * The RGB channels of this texture are multiplied against  `sheenColor`, for per-pixel control
  		 * over sheen tint.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.sheenColorMap = null;

  		/**
  		 * Roughness of the sheen layer, from `0.0` to `1.0`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.sheenRoughness = 1.0;

  		/**
  		 * The alpha channel of this texture is multiplied against `sheenRoughness`, for per-pixel control
  		 * over sheen roughness.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.sheenRoughnessMap = null;

  		/**
  		 * The red channel of this texture is multiplied against `transmission`, for per-pixel control over
  		 * optical transparency.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.transmissionMap = null;

  		/**
  		 * The thickness of the volume beneath the surface. The value is given in the
  		 * coordinate space of the mesh. If the value is `0` the material is
  		 * thin-walled. Otherwise the material is a volume boundary.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.thickness = 0;

  		/**
  		 * A texture that defines the thickness, stored in the green channel. This will
  		 * be multiplied by `thickness`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.thicknessMap = null;

  		/**
  		 * Density of the medium given as the average distance that light travels in
  		 * the medium before interacting with a particle. The value is given in world
  		 * space units, and must be greater than zero.
  		 *
  		 * @type {number}
  		 * @default Infinity
  		 */
  		this.attenuationDistance = Infinity;

  		/**
  		 * The color that white light turns into due to absorption when reaching the
  		 * attenuation distance.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.attenuationColor = new Color( 1, 1, 1 );

  		/**
  		 * A float that scales the amount of specular reflection for non-metals only.
  		 * When set to zero, the model is effectively Lambertian. From `0.0` to `1.0`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.specularIntensity = 1.0;

  		/**
  		 * The alpha channel of this texture is multiplied against `specularIntensity`,
  		 * for per-pixel control over specular intensity.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.specularIntensityMap = null;

  		/**
  		 * Tints the specular reflection at normal incidence for non-metals only.
  		 *
  		 * @type {Color}
  		 * @default (1,1,1)
  		 */
  		this.specularColor = new Color( 1, 1, 1 );

  		/**
  		 * The RGB channels of this texture are multiplied against `specularColor`,
  		 * for per-pixel control over specular color.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.specularColorMap = null;

  		this._anisotropy = 0;
  		this._clearcoat = 0;
  		this._dispersion = 0;
  		this._iridescence = 0;
  		this._sheen = 0.0;
  		this._transmission = 0;

  		this.setValues( parameters );

  	}

  	/**
  	 * The anisotropy strength.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get anisotropy() {

  		return this._anisotropy;

  	}

  	set anisotropy( value ) {

  		if ( this._anisotropy > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._anisotropy = value;

  	}

  	/**
  	 * Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
  	 * clear coat related properties to enable multilayer materials that have a
  	 * thin translucent layer over the base layer.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get clearcoat() {

  		return this._clearcoat;

  	}

  	set clearcoat( value ) {

  		if ( this._clearcoat > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._clearcoat = value;

  	}
  	/**
  	 * The intensity of the iridescence layer, simulating RGB color shift based on the angle between
  	 * the surface and the viewer, from `0.0` to `1.0`.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get iridescence() {

  		return this._iridescence;

  	}

  	set iridescence( value ) {

  		if ( this._iridescence > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._iridescence = value;

  	}

  	/**
  	 * Defines the strength of the angular separation of colors (chromatic aberration) transmitting
  	 * through a relatively clear volume. Any value zero or larger is valid, the typical range of
  	 * realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get dispersion() {

  		return this._dispersion;

  	}

  	set dispersion( value ) {

  		if ( this._dispersion > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._dispersion = value;

  	}

  	/**
  	 * The intensity of the sheen layer, from `0.0` to `1.0`.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get sheen() {

  		return this._sheen;

  	}

  	set sheen( value ) {

  		if ( this._sheen > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._sheen = value;

  	}

  	/**
  	 * Degree of transmission (or optical transparency), from `0.0` to `1.0`.
  	 *
  	 * Thin, transparent or semitransparent, plastic or glass materials remain
  	 * largely reflective even if they are fully transmissive. The transmission
  	 * property can be used to model these materials.
  	 *
  	 * When transmission is non-zero, `opacity` should be  set to `1`.
  	 *
  	 * @type {number}
  	 * @default 0
  	 */
  	get transmission() {

  		return this._transmission;

  	}

  	set transmission( value ) {

  		if ( this._transmission > 0 !== value > 0 ) {

  			this.version ++;

  		}

  		this._transmission = value;

  	}

  	copy( source ) {

  		super.copy( source );

  		this.defines = {

  			'STANDARD': '',
  			'PHYSICAL': ''

  		};

  		this.anisotropy = source.anisotropy;
  		this.anisotropyRotation = source.anisotropyRotation;
  		this.anisotropyMap = source.anisotropyMap;

  		this.clearcoat = source.clearcoat;
  		this.clearcoatMap = source.clearcoatMap;
  		this.clearcoatRoughness = source.clearcoatRoughness;
  		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  		this.clearcoatNormalMap = source.clearcoatNormalMap;
  		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

  		this.dispersion = source.dispersion;
  		this.ior = source.ior;

  		this.iridescence = source.iridescence;
  		this.iridescenceMap = source.iridescenceMap;
  		this.iridescenceIOR = source.iridescenceIOR;
  		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
  		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

  		this.sheen = source.sheen;
  		this.sheenColor.copy( source.sheenColor );
  		this.sheenColorMap = source.sheenColorMap;
  		this.sheenRoughness = source.sheenRoughness;
  		this.sheenRoughnessMap = source.sheenRoughnessMap;

  		this.transmission = source.transmission;
  		this.transmissionMap = source.transmissionMap;

  		this.thickness = source.thickness;
  		this.thicknessMap = source.thicknessMap;
  		this.attenuationDistance = source.attenuationDistance;
  		this.attenuationColor.copy( source.attenuationColor );

  		this.specularIntensity = source.specularIntensity;
  		this.specularIntensityMap = source.specularIntensityMap;
  		this.specularColor.copy( source.specularColor );
  		this.specularColorMap = source.specularColorMap;

  		return this;

  	}

  }

  /**
   * A material for drawing geometry by depth. Depth is based off of the camera
   * near and far plane. White is nearest, black is farthest.
   *
   * @augments Material
   */
  class MeshDepthMaterial extends Material {

  	/**
  	 * Constructs a new mesh depth material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshDepthMaterial = true;

  		this.type = 'MeshDepthMaterial';

  		/**
  		 * Type for depth packing.
  		 *
  		 * @type {(BasicDepthPacking|RGBADepthPacking|RGBDepthPacking|RGDepthPacking)}
  		 * @default BasicDepthPacking
  		 */
  		this.depthPacking = BasicDepthPacking;

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * The displacement map affects the position of the mesh's vertices. Unlike
  		 * other maps which only affect the light and shade of the material the
  		 * displaced vertices can cast shadows, block other objects, and otherwise
  		 * act as real geometry. The displacement texture is an image where the value
  		 * of each pixel (white being the highest) is mapped against, and
  		 * repositions, the vertices of the mesh.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.displacementMap = null;

  		/**
  		 * How much the displacement map affects the mesh (where black is no
  		 * displacement, and white is maximum displacement). Without a displacement
  		 * map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementScale = 1;

  		/**
  		 * The offset of the displacement map's values on the mesh's vertices.
  		 * The bias is added to the scaled sample of the displacement map.
  		 * Without a displacement map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementBias = 0;

  		/**
  		 * Renders the geometry as a wireframe.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.wireframe = false;

  		/**
  		 * Controls the thickness of the wireframe.
  		 *
  		 * WebGL and WebGPU ignore this property and always render
  		 * 1 pixel wide lines.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.wireframeLinewidth = 1;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.depthPacking = source.depthPacking;

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		return this;

  	}

  }

  /**
   * A material used internally for implementing shadow mapping with
   * point lights.
   *
   * Can also be used to customize the shadow casting of an object by assigning
   * an instance of `MeshDistanceMaterial` to {@link Object3D#customDistanceMaterial}.
   * The following examples demonstrates this approach in order to ensure
   * transparent parts of objects do not cast shadows.
   *
   * @augments Material
   */
  class MeshDistanceMaterial extends Material {

  	/**
  	 * Constructs a new mesh distance material.
  	 *
  	 * @param {Object} [parameters] - An object with one or more properties
  	 * defining the material's appearance. Any property of the material
  	 * (including any property from inherited materials) can be passed
  	 * in here. Color values can be passed any type of value accepted
  	 * by {@link Color#set}.
  	 */
  	constructor( parameters ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isMeshDistanceMaterial = true;

  		this.type = 'MeshDistanceMaterial';

  		/**
  		 * The color map. May optionally include an alpha channel, typically combined
  		 * with {@link Material#transparent} or {@link Material#alphaTest}.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The alpha map is a grayscale texture that controls the opacity across the
  		 * surface (black: fully transparent; white: fully opaque).
  		 *
  		 * Only the color of the texture is used, ignoring the alpha channel if one
  		 * exists. For RGB and RGBA textures, the renderer will use the green channel
  		 * when sampling this texture due to the extra bit of precision provided for
  		 * green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
  		 * luminance/alpha textures will also still work as expected.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.alphaMap = null;

  		/**
  		 * The displacement map affects the position of the mesh's vertices. Unlike
  		 * other maps which only affect the light and shade of the material the
  		 * displaced vertices can cast shadows, block other objects, and otherwise
  		 * act as real geometry. The displacement texture is an image where the value
  		 * of each pixel (white being the highest) is mapped against, and
  		 * repositions, the vertices of the mesh.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.displacementMap = null;

  		/**
  		 * How much the displacement map affects the mesh (where black is no
  		 * displacement, and white is maximum displacement). Without a displacement
  		 * map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementScale = 1;

  		/**
  		 * The offset of the displacement map's values on the mesh's vertices.
  		 * The bias is added to the scaled sample of the displacement map.
  		 * Without a displacement map set, this value is not applied.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.displacementBias = 0;

  		this.setValues( parameters );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		return this;

  	}

  }

  /**
   * Converts an array to a specific type.
   *
   * @param {TypedArray|Array} array - The array to convert.
   * @param {TypedArray.constructor} type - The constructor of a typed array that defines the new type.
   * @return {TypedArray} The converted array.
   */
  function convertArray( array, type ) {

  	if ( ! array || array.constructor === type ) return array;

  	if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

  		return new type( array ); // create typed array

  	}

  	return Array.prototype.slice.call( array ); // create Array

  }

  /**
   * Returns `true` if the given object is a typed array.
   *
   * @param {any} object - The object to check.
   * @return {boolean} Whether the given object is a typed array.
   */
  function isTypedArray( object ) {

  	return ArrayBuffer.isView( object ) && ! ( object instanceof DataView );

  }

  /**
   * Returns an array by which times and values can be sorted.
   *
   * @param {Array<number>} times - The keyframe time values.
   * @return {Array<number>} The array.
   */
  function getKeyframeOrder( times ) {

  	function compareTime( i, j ) {

  		return times[ i ] - times[ j ];

  	}

  	const n = times.length;
  	const result = new Array( n );
  	for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

  	result.sort( compareTime );

  	return result;

  }

  /**
   * Sorts the given array by the previously computed order via `getKeyframeOrder()`.
   *
   * @param {Array<number>} values - The values to sort.
   * @param {number} stride - The stride.
   * @param {Array<number>} order - The sort order.
   * @return {Array<number>} The sorted values.
   */
  function sortedArray( values, stride, order ) {

  	const nValues = values.length;
  	const result = new values.constructor( nValues );

  	for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

  		const srcOffset = order[ i ] * stride;

  		for ( let j = 0; j !== stride; ++ j ) {

  			result[ dstOffset ++ ] = values[ srcOffset + j ];

  		}

  	}

  	return result;

  }

  /**
   * Used for parsing AOS keyframe formats.
   *
   * @param {Array<number>} jsonKeys - A list of JSON keyframes.
   * @param {Array<number>} times - This array will be filled with keyframe times by this function.
   * @param {Array<number>} values - This array will be filled with keyframe values by this function.
   * @param {string} valuePropertyName - The name of the property to use.
   */
  function flattenJSON( jsonKeys, times, values, valuePropertyName ) {

  	let i = 1, key = jsonKeys[ 0 ];

  	while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

  		key = jsonKeys[ i ++ ];

  	}

  	if ( key === undefined ) return; // no data

  	let value = key[ valuePropertyName ];
  	if ( value === undefined ) return; // no data

  	if ( Array.isArray( value ) ) {

  		do {

  			value = key[ valuePropertyName ];

  			if ( value !== undefined ) {

  				times.push( key.time );
  				values.push( ...value ); // push all elements

  			}

  			key = jsonKeys[ i ++ ];

  		} while ( key !== undefined );

  	} else if ( value.toArray !== undefined ) {

  		// ...assume THREE.Math-ish

  		do {

  			value = key[ valuePropertyName ];

  			if ( value !== undefined ) {

  				times.push( key.time );
  				value.toArray( values, values.length );

  			}

  			key = jsonKeys[ i ++ ];

  		} while ( key !== undefined );

  	} else {

  		// otherwise push as-is

  		do {

  			value = key[ valuePropertyName ];

  			if ( value !== undefined ) {

  				times.push( key.time );
  				values.push( value );

  			}

  			key = jsonKeys[ i ++ ];

  		} while ( key !== undefined );

  	}

  }

  /**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References: {@link http://www.oodesign.com/template-method-pattern.html}
   *
   * @abstract
   */
  class Interpolant {

  	/**
  	 * Constructs a new interpolant.
  	 *
  	 * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
  	 * @param {TypedArray} sampleValues - The sample values.
  	 * @param {number} sampleSize - The sample size
  	 * @param {TypedArray} [resultBuffer] - The result buffer.
  	 */
  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		/**
  		 * The parameter positions.
  		 *
  		 * @type {TypedArray}
  		 */
  		this.parameterPositions = parameterPositions;

  		/**
  		 * A cache index.
  		 *
  		 * @private
  		 * @type {number}
  		 * @default 0
  		 */
  		this._cachedIndex = 0;

  		/**
  		 * The result buffer.
  		 *
  		 * @type {TypedArray}
  		 */
  		this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor( sampleSize );

  		/**
  		 * The sample values.
  		 *
  		 * @type {TypedArray}
  		 */
  		this.sampleValues = sampleValues;

  		/**
  		 * The value size.
  		 *
  		 * @type {TypedArray}
  		 */
  		this.valueSize = sampleSize;

  		/**
  		 * The interpolation settings.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.settings = null;

  		/**
  		 * The default settings object.
  		 *
  		 * @type {Object}
  		 */
  		this.DefaultSettings_ = {};

  	}

  	/**
  	 * Evaluate the interpolant at position `t`.
  	 *
  	 * @param {number} t - The interpolation factor.
  	 * @return {TypedArray} The result buffer.
  	 */
  	evaluate( t ) {

  		const pp = this.parameterPositions;
  		let i1 = this._cachedIndex,
  			t1 = pp[ i1 ],
  			t0 = pp[ i1 - 1 ];

  		validate_interval: {

  			seek: {

  				let right;

  				linear_scan: {

  					//- See http://jsperf.com/comparison-to-undefined/3
  					//- slower code:
  					//-
  					//- 				if ( t >= t1 || t1 === undefined ) {
  					forward_scan: if ( ! ( t < t1 ) ) {

  						for ( let giveUpAt = i1 + 2; ; ) {

  							if ( t1 === undefined ) {

  								if ( t < t0 ) break forward_scan;

  								// after end

  								i1 = pp.length;
  								this._cachedIndex = i1;
  								return this.copySampleValue_( i1 - 1 );

  							}

  							if ( i1 === giveUpAt ) break; // this loop

  							t0 = t1;
  							t1 = pp[ ++ i1 ];

  							if ( t < t1 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the right side of the index
  						right = pp.length;
  						break linear_scan;

  					}

  					//- slower code:
  					//-					if ( t < t0 || t0 === undefined ) {
  					if ( ! ( t >= t0 ) ) {

  						// looping?

  						const t1global = pp[ 1 ];

  						if ( t < t1global ) {

  							i1 = 2; // + 1, using the scan for the details
  							t0 = t1global;

  						}

  						// linear reverse scan

  						for ( let giveUpAt = i1 - 2; ; ) {

  							if ( t0 === undefined ) {

  								// before start

  								this._cachedIndex = 0;
  								return this.copySampleValue_( 0 );

  							}

  							if ( i1 === giveUpAt ) break; // this loop

  							t1 = t0;
  							t0 = pp[ -- i1 - 1 ];

  							if ( t >= t0 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the left side of the index
  						right = i1;
  						i1 = 0;
  						break linear_scan;

  					}

  					// the interval is valid

  					break validate_interval;

  				} // linear scan

  				// binary search

  				while ( i1 < right ) {

  					const mid = ( i1 + right ) >>> 1;

  					if ( t < pp[ mid ] ) {

  						right = mid;

  					} else {

  						i1 = mid + 1;

  					}

  				}

  				t1 = pp[ i1 ];
  				t0 = pp[ i1 - 1 ];

  				// check boundary cases, again

  				if ( t0 === undefined ) {

  					this._cachedIndex = 0;
  					return this.copySampleValue_( 0 );

  				}

  				if ( t1 === undefined ) {

  					i1 = pp.length;
  					this._cachedIndex = i1;
  					return this.copySampleValue_( i1 - 1 );

  				}

  			} // seek

  			this._cachedIndex = i1;

  			this.intervalChanged_( i1, t0, t1 );

  		} // validate_interval

  		return this.interpolate_( i1, t0, t, t1 );

  	}

  	/**
  	 * Returns the interpolation settings.
  	 *
  	 * @return {Object} The interpolation settings.
  	 */
  	getSettings_() {

  		return this.settings || this.DefaultSettings_;

  	}

  	/**
  	 * Copies a sample value to the result buffer.
  	 *
  	 * @param {number} index - An index into the sample value buffer.
  	 * @return {TypedArray} The result buffer.
  	 */
  	copySampleValue_( index ) {

  		// copies a sample value to the result buffer

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,
  			offset = index * stride;

  		for ( let i = 0; i !== stride; ++ i ) {

  			result[ i ] = values[ offset + i ];

  		}

  		return result;

  	}

  	/**
  	 * Copies a sample value to the result buffer.
  	 *
  	 * @abstract
  	 * @param {number} i1 - An index into the sample value buffer.
  	 * @param {number} t0 - The previous interpolation factor.
  	 * @param {number} t - The current interpolation factor.
  	 * @param {number} t1 - The next interpolation factor.
  	 * @return {TypedArray} The result buffer.
  	 */
  	interpolate_( /* i1, t0, t, t1 */ ) {

  		throw new Error( 'call to abstract method' );
  		// implementations shall return this.resultBuffer

  	}

  	/**
  	 * Optional method that is executed when the interval has changed.
  	 *
  	 * @param {number} i1 - An index into the sample value buffer.
  	 * @param {number} t0 - The previous interpolation factor.
  	 * @param {number} t - The current interpolation factor.
  	 */
  	intervalChanged_( /* i1, t0, t1 */ ) {

  		// empty

  	}

  }

  /**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   *
   * @augments Interpolant
   */
  class CubicInterpolant extends Interpolant {

  	/**
  	 * Constructs a new cubic interpolant.
  	 *
  	 * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
  	 * @param {TypedArray} sampleValues - The sample values.
  	 * @param {number} sampleSize - The sample size
  	 * @param {TypedArray} [resultBuffer] - The result buffer.
  	 */
  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  		this._weightPrev = -0;
  		this._offsetPrev = -0;
  		this._weightNext = -0;
  		this._offsetNext = -0;

  		this.DefaultSettings_ = {

  			endingStart: ZeroCurvatureEnding,
  			endingEnd: ZeroCurvatureEnding

  		};

  	}

  	intervalChanged_( i1, t0, t1 ) {

  		const pp = this.parameterPositions;
  		let iPrev = i1 - 2,
  			iNext = i1 + 1,

  			tPrev = pp[ iPrev ],
  			tNext = pp[ iNext ];

  		if ( tPrev === undefined ) {

  			switch ( this.getSettings_().endingStart ) {

  				case ZeroSlopeEnding:

  					// f'(t0) = 0
  					iPrev = i1;
  					tPrev = 2 * t0 - t1;

  					break;

  				case WrapAroundEnding:

  					// use the other end of the curve
  					iPrev = pp.length - 2;
  					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(t0) = 0 a.k.a. Natural Spline
  					iPrev = i1;
  					tPrev = t1;

  			}

  		}

  		if ( tNext === undefined ) {

  			switch ( this.getSettings_().endingEnd ) {

  				case ZeroSlopeEnding:

  					// f'(tN) = 0
  					iNext = i1;
  					tNext = 2 * t1 - t0;

  					break;

  				case WrapAroundEnding:

  					// use the other end of the curve
  					iNext = 1;
  					tNext = t1 + pp[ 1 ] - pp[ 0 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(tN) = 0, a.k.a. Natural Spline
  					iNext = i1 - 1;
  					tNext = t0;

  			}

  		}

  		const halfDt = ( t1 - t0 ) * 0.5,
  			stride = this.valueSize;

  		this._weightPrev = halfDt / ( t0 - tPrev );
  		this._weightNext = halfDt / ( tNext - t1 );
  		this._offsetPrev = iPrev * stride;
  		this._offsetNext = iNext * stride;

  	}

  	interpolate_( i1, t0, t, t1 ) {

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			o1 = i1 * stride,		o0 = o1 - stride,
  			oP = this._offsetPrev, 	oN = this._offsetNext,
  			wP = this._weightPrev,	wN = this._weightNext,

  			p = ( t - t0 ) / ( t1 - t0 ),
  			pp = p * p,
  			ppp = pp * p;

  		// evaluate polynomials

  		const sP = - wP * ppp + 2 * wP * pp - wP * p;
  		const s0 = ( 1 + wP ) * ppp + ( -1.5 - 2 * wP ) * pp + ( -0.5 + wP ) * p + 1;
  		const s1 = ( -1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
  		const sN = wN * ppp - wN * pp;

  		// combine data linearly

  		for ( let i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					sP * values[ oP + i ] +
  					s0 * values[ o0 + i ] +
  					s1 * values[ o1 + i ] +
  					sN * values[ oN + i ];

  		}

  		return result;

  	}

  }

  /**
   * A basic linear interpolant.
   *
   * @augments Interpolant
   */
  class LinearInterpolant extends Interpolant {

  	/**
  	 * Constructs a new linear interpolant.
  	 *
  	 * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
  	 * @param {TypedArray} sampleValues - The sample values.
  	 * @param {number} sampleSize - The sample size
  	 * @param {TypedArray} [resultBuffer] - The result buffer.
  	 */
  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	interpolate_( i1, t0, t, t1 ) {

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			offset1 = i1 * stride,
  			offset0 = offset1 - stride,

  			weight1 = ( t - t0 ) / ( t1 - t0 ),
  			weight0 = 1 - weight1;

  		for ( let i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					values[ offset0 + i ] * weight0 +
  					values[ offset1 + i ] * weight1;

  		}

  		return result;

  	}

  }

  /**
   * Interpolant that evaluates to the sample value at the position preceding
   * the parameter.
   *
   * @augments Interpolant
   */
  class DiscreteInterpolant extends Interpolant {

  	/**
  	 * Constructs a new discrete interpolant.
  	 *
  	 * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
  	 * @param {TypedArray} sampleValues - The sample values.
  	 * @param {number} sampleSize - The sample size
  	 * @param {TypedArray} [resultBuffer] - The result buffer.
  	 */
  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	interpolate_( i1 /*, t0, t, t1 */ ) {

  		return this.copySampleValue_( i1 - 1 );

  	}

  }

  /**
   * Represents s a timed sequence of keyframes, which are composed of lists of
   * times and related values, and which are used to animate a specific property
   * of an object.
   */
  class KeyframeTrack {

  	/**
  	 * Constructs a new keyframe track.
  	 *
  	 * @param {string} name - The keyframe track's name.
  	 * @param {Array<number>} times - A list of keyframe times.
  	 * @param {Array<number|string|boolean>} values - A list of keyframe values.
  	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
  	 */
  	constructor( name, times, values, interpolation ) {

  		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
  		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

  		/**
  		 * The track's name can refer to morph targets or bones or
  		 * possibly other values within an animated object. See {@link PropertyBinding#parseTrackName}
  		 * for the forms of strings that can be parsed for property binding.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 * The keyframe times.
  		 *
  		 * @type {Float32Array}
  		 */
  		this.times = convertArray( times, this.TimeBufferType );

  		/**
  		 * The keyframe values.
  		 *
  		 * @type {Float32Array}
  		 */
  		this.values = convertArray( values, this.ValueBufferType );

  		this.setInterpolation( interpolation || this.DefaultInterpolation );

  	}

  	/**
  	 * Converts the keyframe track to JSON.
  	 *
  	 * @static
  	 * @param {KeyframeTrack} track - The keyframe track to serialize.
  	 * @return {Object} The serialized keyframe track as JSON.
  	 */
  	static toJSON( track ) {

  		const trackType = track.constructor;

  		let json;

  		// derived classes can define a static toJSON method
  		if ( trackType.toJSON !== this.toJSON ) {

  			json = trackType.toJSON( track );

  		} else {

  			// by default, we assume the data can be serialized as-is
  			json = {

  				'name': track.name,
  				'times': convertArray( track.times, Array ),
  				'values': convertArray( track.values, Array )

  			};

  			const interpolation = track.getInterpolation();

  			if ( interpolation !== track.DefaultInterpolation ) {

  				json.interpolation = interpolation;

  			}

  		}

  		json.type = track.ValueTypeName; // mandatory

  		return json;

  	}

  	/**
  	 * Factory method for creating a new discrete interpolant.
  	 *
  	 * @static
  	 * @param {TypedArray} [result] - The result buffer.
  	 * @return {DiscreteInterpolant} The new interpolant.
  	 */
  	InterpolantFactoryMethodDiscrete( result ) {

  		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  	/**
  	 * Factory method for creating a new linear interpolant.
  	 *
  	 * @static
  	 * @param {TypedArray} [result] - The result buffer.
  	 * @return {LinearInterpolant} The new interpolant.
  	 */
  	InterpolantFactoryMethodLinear( result ) {

  		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  	/**
  	 * Factory method for creating a new smooth interpolant.
  	 *
  	 * @static
  	 * @param {TypedArray} [result] - The result buffer.
  	 * @return {CubicInterpolant} The new interpolant.
  	 */
  	InterpolantFactoryMethodSmooth( result ) {

  		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  	/**
  	 * Defines the interpolation factor method for this keyframe track.
  	 *
  	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} interpolation - The interpolation type.
  	 * @return {KeyframeTrack} A reference to this keyframe track.
  	 */
  	setInterpolation( interpolation ) {

  		let factoryMethod;

  		switch ( interpolation ) {

  			case InterpolateDiscrete:

  				factoryMethod = this.InterpolantFactoryMethodDiscrete;

  				break;

  			case InterpolateLinear:

  				factoryMethod = this.InterpolantFactoryMethodLinear;

  				break;

  			case InterpolateSmooth:

  				factoryMethod = this.InterpolantFactoryMethodSmooth;

  				break;

  		}

  		if ( factoryMethod === undefined ) {

  			const message = 'unsupported interpolation for ' +
  				this.ValueTypeName + ' keyframe track named ' + this.name;

  			if ( this.createInterpolant === undefined ) {

  				// fall back to default, unless the default itself is messed up
  				if ( interpolation !== this.DefaultInterpolation ) {

  					this.setInterpolation( this.DefaultInterpolation );

  				} else {

  					throw new Error( message ); // fatal, in this case

  				}

  			}

  			console.warn( 'THREE.KeyframeTrack:', message );
  			return this;

  		}

  		this.createInterpolant = factoryMethod;

  		return this;

  	}

  	/**
  	 * Returns the current interpolation type.
  	 *
  	 * @return {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} The interpolation type.
  	 */
  	getInterpolation() {

  		switch ( this.createInterpolant ) {

  			case this.InterpolantFactoryMethodDiscrete:

  				return InterpolateDiscrete;

  			case this.InterpolantFactoryMethodLinear:

  				return InterpolateLinear;

  			case this.InterpolantFactoryMethodSmooth:

  				return InterpolateSmooth;

  		}

  	}

  	/**
  	 * Returns the value size.
  	 *
  	 * @return {number} The value size.
  	 */
  	getValueSize() {

  		return this.values.length / this.times.length;

  	}

  	/**
  	 * Moves all keyframes either forward or backward in time.
  	 *
  	 * @param {number} timeOffset - The offset to move the time values.
  	 * @return {KeyframeTrack} A reference to this keyframe track.
  	 */
  	shift( timeOffset ) {

  		if ( timeOffset !== 0.0 ) {

  			const times = this.times;

  			for ( let i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] += timeOffset;

  			}

  		}

  		return this;

  	}

  	/**
  	 * Scale all keyframe times by a factor (useful for frame - seconds conversions).
  	 *
  	 * @param {number} timeScale - The time scale.
  	 * @return {KeyframeTrack} A reference to this keyframe track.
  	 */
  	scale( timeScale ) {

  		if ( timeScale !== 1.0 ) {

  			const times = this.times;

  			for ( let i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] *= timeScale;

  			}

  		}

  		return this;

  	}

  	/**
  	 * Removes keyframes before and after animation without changing any values within the defined time range.
  	 *
  	 * Note: The method does not shift around keys to the start of the track time, because for interpolated
  	 * keys this will change their values
  	 *
  	 * @param {number} startTime - The start time.
  	 * @param {number} endTime - The end time.
  	 * @return {KeyframeTrack} A reference to this keyframe track.
  	 */
  	trim( startTime, endTime ) {

  		const times = this.times,
  			nKeys = times.length;

  		let from = 0,
  			to = nKeys - 1;

  		while ( from !== nKeys && times[ from ] < startTime ) {

  			++ from;

  		}

  		while ( to !== -1 && times[ to ] > endTime ) {

  			-- to;

  		}

  		++ to; // inclusive -> exclusive bound

  		if ( from !== 0 || to !== nKeys ) {

  			// empty tracks are forbidden, so keep at least one keyframe
  			if ( from >= to ) {

  				to = Math.max( to, 1 );
  				from = to - 1;

  			}

  			const stride = this.getValueSize();
  			this.times = times.slice( from, to );
  			this.values = this.values.slice( from * stride, to * stride );

  		}

  		return this;

  	}

  	/**
  	 * Performs minimal validation on the keyframe track. Returns `true` if the values
  	 * are valid.
  	 *
  	 * @return {boolean} Whether the keyframes are valid or not.
  	 */
  	validate() {

  		let valid = true;

  		const valueSize = this.getValueSize();
  		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

  			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
  			valid = false;

  		}

  		const times = this.times,
  			values = this.values,

  			nKeys = times.length;

  		if ( nKeys === 0 ) {

  			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
  			valid = false;

  		}

  		let prevTime = null;

  		for ( let i = 0; i !== nKeys; i ++ ) {

  			const currTime = times[ i ];

  			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

  				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
  				valid = false;
  				break;

  			}

  			if ( prevTime !== null && prevTime > currTime ) {

  				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
  				valid = false;
  				break;

  			}

  			prevTime = currTime;

  		}

  		if ( values !== undefined ) {

  			if ( isTypedArray( values ) ) {

  				for ( let i = 0, n = values.length; i !== n; ++ i ) {

  					const value = values[ i ];

  					if ( isNaN( value ) ) {

  						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
  						valid = false;
  						break;

  					}

  				}

  			}

  		}

  		return valid;

  	}

  	/**
  	 * Optimizes this keyframe track by removing equivalent sequential keys (which are
  	 * common in morph target sequences).
  	 *
  	 * @return {AnimationClip} A reference to this animation clip.
  	 */
  	optimize() {

  		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)

  		// times or values may be shared with other tracks, so overwriting is unsafe
  		const times = this.times.slice(),
  			values = this.values.slice(),
  			stride = this.getValueSize(),

  			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

  			lastIndex = times.length - 1;

  		let writeIndex = 1;

  		for ( let i = 1; i < lastIndex; ++ i ) {

  			let keep = false;

  			const time = times[ i ];
  			const timeNext = times[ i + 1 ];

  			// remove adjacent keyframes scheduled at the same time

  			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

  				if ( ! smoothInterpolation ) {

  					// remove unnecessary keyframes same as their neighbors

  					const offset = i * stride,
  						offsetP = offset - stride,
  						offsetN = offset + stride;

  					for ( let j = 0; j !== stride; ++ j ) {

  						const value = values[ offset + j ];

  						if ( value !== values[ offsetP + j ] ||
  							value !== values[ offsetN + j ] ) {

  							keep = true;
  							break;

  						}

  					}

  				} else {

  					keep = true;

  				}

  			}

  			// in-place compaction

  			if ( keep ) {

  				if ( i !== writeIndex ) {

  					times[ writeIndex ] = times[ i ];

  					const readOffset = i * stride,
  						writeOffset = writeIndex * stride;

  					for ( let j = 0; j !== stride; ++ j ) {

  						values[ writeOffset + j ] = values[ readOffset + j ];

  					}

  				}

  				++ writeIndex;

  			}

  		}

  		// flush last keyframe (compaction looks ahead)

  		if ( lastIndex > 0 ) {

  			times[ writeIndex ] = times[ lastIndex ];

  			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

  				values[ writeOffset + j ] = values[ readOffset + j ];

  			}

  			++ writeIndex;

  		}

  		if ( writeIndex !== times.length ) {

  			this.times = times.slice( 0, writeIndex );
  			this.values = values.slice( 0, writeIndex * stride );

  		} else {

  			this.times = times;
  			this.values = values;

  		}

  		return this;

  	}

  	/**
  	 * Returns a new keyframe track with copied values from this instance.
  	 *
  	 * @return {KeyframeTrack} A clone of this instance.
  	 */
  	clone() {

  		const times = this.times.slice();
  		const values = this.values.slice();

  		const TypedKeyframeTrack = this.constructor;
  		const track = new TypedKeyframeTrack( this.name, times, values );

  		// Interpolant argument to constructor is not saved, so copy the factory method directly.
  		track.createInterpolant = this.createInterpolant;

  		return track;

  	}

  }

  /**
   * The value type name.
   *
   * @type {String}
   * @default ''
   */
  KeyframeTrack.prototype.ValueTypeName = '';

  /**
   * The time buffer type of this keyframe track.
   *
   * @type {TypedArray|Array}
   * @default Float32Array.constructor
   */
  KeyframeTrack.prototype.TimeBufferType = Float32Array;

  /**
   * The value buffer type of this keyframe track.
   *
   * @type {TypedArray|Array}
   * @default Float32Array.constructor
   */
  KeyframeTrack.prototype.ValueBufferType = Float32Array;

  /**
   * The default interpolation type of this keyframe track.
   *
   * @type {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)}
   * @default InterpolateLinear
   */
  KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

  /**
   * A track for boolean keyframe values.
   *
   * @augments KeyframeTrack
   */
  class BooleanKeyframeTrack extends KeyframeTrack {

  	/**
  	 * Constructs a new boolean keyframe track.
  	 *
  	 * This keyframe track type has no `interpolation` parameter because the
  	 * interpolation is always discrete.
  	 *
  	 * @param {string} name - The keyframe track's name.
  	 * @param {Array<number>} times - A list of keyframe times.
  	 * @param {Array<boolean>} values - A list of keyframe values.
  	 */
  	constructor( name, times, values ) {

  		super( name, times, values );

  	}

  }

  /**
   * The value type name.
   *
   * @type {String}
   * @default 'bool'
   */
  BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';

  /**
   * The value buffer type of this keyframe track.
   *
   * @type {TypedArray|Array}
   * @default Array.constructor
   */
  BooleanKeyframeTrack.prototype.ValueBufferType = Array;

  /**
   * The default interpolation type of this keyframe track.
   *
   * @type {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)}
   * @default InterpolateDiscrete
   */
  BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A track for color keyframe values.
   *
   * @augments KeyframeTrack
   */
  class ColorKeyframeTrack extends KeyframeTrack {

  	/**
  	 * Constructs a new color keyframe track.
  	 *
  	 * @param {string} name - The keyframe track's name.
  	 * @param {Array<number>} times - A list of keyframe times.
  	 * @param {Array<number>} values - A list of keyframe values.
  	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
  	 */
  	constructor( name, times, values, interpolation ) {

  		super( name, times, values, interpolation );

  	}

  }

  /**
   * The value type name.
   *
   * @type {String}
   * @default 'color'
   */
  ColorKeyframeTrack.prototype.ValueTypeName = 'color';

  /**
   * A track for numeric keyframe values.
   *
   * @augments KeyframeTrack
   */
  class NumberKeyframeTrack extends KeyframeTrack {

  	/**
  	 * Constructs a new number keyframe track.
  	 *
  	 * @param {string} name - The keyframe track's name.
  	 * @param {Array<number>} times - A list of keyframe times.
  	 * @param {Array<number>} values - A list of keyframe values.
  	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
  	 */
  	constructor( name, times, values, interpolation ) {

  		super( name, times, values, interpolation );

  	}

  }

  /**
   * The value type name.
   *
   * @type {String}
   * @default 'number'
   */
  NumberKeyframeTrack.prototype.ValueTypeName = 'number';

  /**
   * Spherical linear unit quaternion interpolant.
   *
   * @augments Interpolant
   */
  class QuaternionLinearInterpolant extends Interpolant {

  	/**
  	 * Constructs a new SLERP interpolant.
  	 *
  	 * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
  	 * @param {TypedArray} sampleValues - The sample values.
  	 * @param {number} sampleSize - The sample size
  	 * @param {TypedArray} [resultBuffer] - The result buffer.
  	 */
  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	interpolate_( i1, t0, t, t1 ) {

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			alpha = ( t - t0 ) / ( t1 - t0 );

  		let offset = i1 * stride;

  		for ( let end = offset + stride; offset !== end; offset += 4 ) {

  			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

  		}

  		return result;

  	}

  }

  /**
   * A track for Quaternion keyframe values.
   *
   * @augments KeyframeTrack
   */
  class QuaternionKeyframeTrack extends KeyframeTrack {

  	/**
  	 * Constructs a new Quaternion keyframe track.
  	 *
  	 * @param {string} name - The keyframe track's name.
  	 * @param {Array<number>} times - A list of keyframe times.
  	 * @param {Array<number>} values - A list of keyframe values.
  	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
  	 */
  	constructor( name, times, values, interpolation ) {

  		super( name, times, values, interpolation );

  	}

  	/**
  	 * Overwritten so the method returns Quaternion based interpolant.
  	 *
  	 * @static
  	 * @param {TypedArray} [result] - The result buffer.
  	 * @return {QuaternionLinearInterpolant} The new interpolant.
  	 */
  	InterpolantFactoryMethodLinear( result ) {

  		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

  	}

  }

  /**
   * The value type name.
   *
   * @type {String}
   * @default 'quaternion'
   */
  QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited;
  QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A track for string keyframe values.
   *
   * @augments KeyframeTrack
   */
  class StringKeyframeTrack extends KeyframeTrack {

  	/**
  	 * Constructs a new string keyframe track.
  	 *
  	 * This keyframe track type has no `interpolation` parameter because the
  	 * interpolation is always discrete.
  	 *
  	 * @param {string} name - The keyframe track's name.
  	 * @param {Array<number>} times - A list of keyframe times.
  	 * @param {Array<string>} values - A list of keyframe values.
  	 */
  	constructor( name, times, values ) {

  		super( name, times, values );

  	}

  }

  /**
   * The value type name.
   *
   * @type {String}
   * @default 'string'
   */
  StringKeyframeTrack.prototype.ValueTypeName = 'string';

  /**
   * The value buffer type of this keyframe track.
   *
   * @type {TypedArray|Array}
   * @default Array.constructor
   */
  StringKeyframeTrack.prototype.ValueBufferType = Array;

  /**
   * The default interpolation type of this keyframe track.
   *
   * @type {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)}
   * @default InterpolateDiscrete
   */
  StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A track for vector keyframe values.
   *
   * @augments KeyframeTrack
   */
  class VectorKeyframeTrack extends KeyframeTrack {

  	/**
  	 * Constructs a new vector keyframe track.
  	 *
  	 * @param {string} name - The keyframe track's name.
  	 * @param {Array<number>} times - A list of keyframe times.
  	 * @param {Array<number>} values - A list of keyframe values.
  	 * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
  	 */
  	constructor( name, times, values, interpolation ) {

  		super( name, times, values, interpolation );

  	}

  }

  /**
   * The value type name.
   *
   * @type {String}
   * @default 'vector'
   */
  VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

  /**
   * A reusable set of keyframe tracks which represent an animation.
   */
  class AnimationClip {

  	/**
  	 * Constructs a new animation clip.
  	 *
  	 * Note: Instead of instantiating an AnimationClip directly with the constructor, you can
  	 * use the static interface of this class for creating clips. In most cases though, animation clips
  	 * will automatically be created by loaders when importing animated 3D assets.
  	 *
  	 * @param {string} [name=''] - The clip's name.
  	 * @param {number} [duration=-1] - The clip's duration in seconds. If a negative value is passed,
  	 * the duration will be calculated from the passed keyframes.
  	 * @param {Array<KeyframeTrack>} tracks - An array of keyframe tracks.
  	 * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode=NormalAnimationBlendMode] - Defines how the animation
  	 * is blended/combined when two or more animations are simultaneously played.
  	 */
  	constructor( name = '', duration = -1, tracks = [], blendMode = NormalAnimationBlendMode ) {

  		/**
  		 * The clip's name.
  		 *
  		 * @type {string}
  		 */
  		this.name = name;

  		/**
  		 *  An array of keyframe tracks.
  		 *
  		 * @type {Array<KeyframeTrack>}
  		 */
  		this.tracks = tracks;

  		/**
  		 * The clip's duration in seconds.
  		 *
  		 * @type {number}
  		 */
  		this.duration = duration;

  		/**
  		 * Defines how the animation is blended/combined when two or more animations
  		 * are simultaneously played.
  		 *
  		 * @type {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)}
  		 */
  		this.blendMode = blendMode;

  		/**
  		 * The UUID of the animation clip.
  		 *
  		 * @type {string}
  		 * @readonly
  		 */
  		this.uuid = generateUUID();

  		/**
  		 * An object that can be used to store custom data about the animation clip.
  		 * It should not hold references to functions as these will not be cloned.
  		 *
  		 * @type {Object}
  		 */
  		this.userData = {};

  		// this means it should figure out its duration by scanning the tracks
  		if ( this.duration < 0 ) {

  			this.resetDuration();

  		}

  	}

  	/**
  	 * Factory method for creating an animation clip from the given JSON.
  	 *
  	 * @static
  	 * @param {Object} json - The serialized animation clip.
  	 * @return {AnimationClip} The new animation clip.
  	 */
  	static parse( json ) {

  		const tracks = [],
  			jsonTracks = json.tracks,
  			frameTime = 1.0 / ( json.fps || 1.0 );

  		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

  			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

  		}

  		const clip = new this( json.name, json.duration, tracks, json.blendMode );
  		clip.uuid = json.uuid;

  		clip.userData = JSON.parse( json.userData || '{}' );

  		return clip;

  	}

  	/**
  	 * Serializes the given animation clip into JSON.
  	 *
  	 * @static
  	 * @param {AnimationClip} clip - The animation clip to serialize.
  	 * @return {Object} The JSON object.
  	 */
  	static toJSON( clip ) {

  		const tracks = [],
  			clipTracks = clip.tracks;

  		const json = {

  			'name': clip.name,
  			'duration': clip.duration,
  			'tracks': tracks,
  			'uuid': clip.uuid,
  			'blendMode': clip.blendMode,
  			'userData': JSON.stringify( clip.userData ),

  		};

  		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

  			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

  		}

  		return json;

  	}

  	/**
  	 * Returns a new animation clip from the passed morph targets array of a
  	 * geometry, taking a name and the number of frames per second.
  	 *
  	 * Note: The fps parameter is required, but the animation speed can be
  	 * overridden via {@link AnimationAction#setDuration}.
  	 *
  	 * @static
  	 * @param {string} name - The name of the animation clip.
  	 * @param {Array<Object>} morphTargetSequence - A sequence of morph targets.
  	 * @param {number} fps - The Frames-Per-Second value.
  	 * @param {boolean} noLoop - Whether the clip should be no loop or not.
  	 * @return {AnimationClip} The new animation clip.
  	 */
  	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

  		const numMorphTargets = morphTargetSequence.length;
  		const tracks = [];

  		for ( let i = 0; i < numMorphTargets; i ++ ) {

  			let times = [];
  			let values = [];

  			times.push(
  				( i + numMorphTargets - 1 ) % numMorphTargets,
  				i,
  				( i + 1 ) % numMorphTargets );

  			values.push( 0, 1, 0 );

  			const order = getKeyframeOrder( times );
  			times = sortedArray( times, 1, order );
  			values = sortedArray( values, 1, order );

  			// if there is a key at the first frame, duplicate it as the
  			// last frame as well for perfect loop.
  			if ( ! noLoop && times[ 0 ] === 0 ) {

  				times.push( numMorphTargets );
  				values.push( values[ 0 ] );

  			}

  			tracks.push(
  				new NumberKeyframeTrack(
  					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
  					times, values
  				).scale( 1.0 / fps ) );

  		}

  		return new this( name, -1, tracks );

  	}

  	/**
  	 * Searches for an animation clip by name, taking as its first parameter
  	 * either an array of clips, or a mesh or geometry that contains an
  	 * array named "animations" property.
  	 *
  	 * @static
  	 * @param {(Array<AnimationClip>|Object3D)} objectOrClipArray - The array or object to search through.
  	 * @param {string} name - The name to search for.
  	 * @return {?AnimationClip} The found animation clip. Returns `null` if no clip has been found.
  	 */
  	static findByName( objectOrClipArray, name ) {

  		let clipArray = objectOrClipArray;

  		if ( ! Array.isArray( objectOrClipArray ) ) {

  			const o = objectOrClipArray;
  			clipArray = o.geometry && o.geometry.animations || o.animations;

  		}

  		for ( let i = 0; i < clipArray.length; i ++ ) {

  			if ( clipArray[ i ].name === name ) {

  				return clipArray[ i ];

  			}

  		}

  		return null;

  	}

  	/**
  	 * Returns an array of new AnimationClips created from the morph target
  	 * sequences of a geometry, trying to sort morph target names into
  	 * animation-group-based patterns like "Walk_001, Walk_002, Run_001, Run_002...".
  	 *
  	 * See {@link MD2Loader#parse} as an example for how the method should be used.
  	 *
  	 * @static
  	 * @param {Array<Object>} morphTargets - A sequence of morph targets.
  	 * @param {number} fps - The Frames-Per-Second value.
  	 * @param {boolean} noLoop - Whether the clip should be no loop or not.
  	 * @return {Array<AnimationClip>} An array of new animation clips.
  	 */
  	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

  		const animationToMorphTargets = {};

  		// tested with https://regex101.com/ on trick sequences
  		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
  		const pattern = /^([\w-]*?)([\d]+)$/;

  		// sort morph target names into animation groups based
  		// patterns like Walk_001, Walk_002, Run_001, Run_002
  		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

  			const morphTarget = morphTargets[ i ];
  			const parts = morphTarget.name.match( pattern );

  			if ( parts && parts.length > 1 ) {

  				const name = parts[ 1 ];

  				let animationMorphTargets = animationToMorphTargets[ name ];

  				if ( ! animationMorphTargets ) {

  					animationToMorphTargets[ name ] = animationMorphTargets = [];

  				}

  				animationMorphTargets.push( morphTarget );

  			}

  		}

  		const clips = [];

  		for ( const name in animationToMorphTargets ) {

  			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

  		}

  		return clips;

  	}

  	/**
  	 * Parses the `animation.hierarchy` format and returns a new animation clip.
  	 *
  	 * @static
  	 * @deprecated since r175.
  	 * @param {Object} animation - A serialized animation clip as JSON.
  	 * @param {Array<Bones>} bones - An array of bones.
  	 * @return {?AnimationClip} The new animation clip.
  	 */
  	static parseAnimation( animation, bones ) {

  		console.warn( 'THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185' );

  		if ( ! animation ) {

  			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
  			return null;

  		}

  		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

  			// only return track if there are actually keys.
  			if ( animationKeys.length !== 0 ) {

  				const times = [];
  				const values = [];

  				flattenJSON( animationKeys, times, values, propertyName );

  				// empty keys are filtered out, so check again
  				if ( times.length !== 0 ) {

  					destTracks.push( new trackType( trackName, times, values ) );

  				}

  			}

  		};

  		const tracks = [];

  		const clipName = animation.name || 'default';
  		const fps = animation.fps || 30;
  		const blendMode = animation.blendMode;

  		// automatic length determination in AnimationClip.
  		let duration = animation.length || -1;

  		const hierarchyTracks = animation.hierarchy || [];

  		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

  			const animationKeys = hierarchyTracks[ h ].keys;

  			// skip empty tracks
  			if ( ! animationKeys || animationKeys.length === 0 ) continue;

  			// process morph targets
  			if ( animationKeys[ 0 ].morphTargets ) {

  				// figure out all morph targets used in this track
  				const morphTargetNames = {};

  				let k;

  				for ( k = 0; k < animationKeys.length; k ++ ) {

  					if ( animationKeys[ k ].morphTargets ) {

  						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

  							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = -1;

  						}

  					}

  				}

  				// create a track for each morph target with all zero
  				// morphTargetInfluences except for the keys in which
  				// the morphTarget is named.
  				for ( const morphTargetName in morphTargetNames ) {

  					const times = [];
  					const values = [];

  					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

  						const animationKey = animationKeys[ k ];

  						times.push( animationKey.time );
  						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

  					}

  					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

  				}

  				duration = morphTargetNames.length * fps;

  			} else {

  				// ...assume skeletal animation

  				const boneName = '.bones[' + bones[ h ].name + ']';

  				addNonemptyTrack(
  					VectorKeyframeTrack, boneName + '.position',
  					animationKeys, 'pos', tracks );

  				addNonemptyTrack(
  					QuaternionKeyframeTrack, boneName + '.quaternion',
  					animationKeys, 'rot', tracks );

  				addNonemptyTrack(
  					VectorKeyframeTrack, boneName + '.scale',
  					animationKeys, 'scl', tracks );

  			}

  		}

  		if ( tracks.length === 0 ) {

  			return null;

  		}

  		const clip = new this( clipName, duration, tracks, blendMode );

  		return clip;

  	}

  	/**
  	 * Sets the duration of this clip to the duration of its longest keyframe track.
  	 *
  	 * @return {AnimationClip} A reference to this animation clip.
  	 */
  	resetDuration() {

  		const tracks = this.tracks;
  		let duration = 0;

  		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

  			const track = this.tracks[ i ];

  			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

  		}

  		this.duration = duration;

  		return this;

  	}

  	/**
  	 * Trims all tracks to the clip's duration.
  	 *
  	 * @return {AnimationClip} A reference to this animation clip.
  	 */
  	trim() {

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			this.tracks[ i ].trim( 0, this.duration );

  		}

  		return this;

  	}

  	/**
  	 * Performs minimal validation on each track in the clip. Returns `true` if all
  	 * tracks are valid.
  	 *
  	 * @return {boolean} Whether the clip's keyframes are valid or not.
  	 */
  	validate() {

  		let valid = true;

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			valid = valid && this.tracks[ i ].validate();

  		}

  		return valid;

  	}

  	/**
  	 * Optimizes each track by removing equivalent sequential keys (which are
  	 * common in morph target sequences).
  	 *
  	 * @return {AnimationClip} A reference to this animation clip.
  	 */
  	optimize() {

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			this.tracks[ i ].optimize();

  		}

  		return this;

  	}

  	/**
  	 * Returns a new animation clip with copied values from this instance.
  	 *
  	 * @return {AnimationClip} A clone of this instance.
  	 */
  	clone() {

  		const tracks = [];

  		for ( let i = 0; i < this.tracks.length; i ++ ) {

  			tracks.push( this.tracks[ i ].clone() );

  		}

  		const clip = new this.constructor( this.name, this.duration, tracks, this.blendMode );

  		clip.userData = JSON.parse( JSON.stringify( this.userData ) );

  		return clip;

  	}

  	/**
  	 * Serializes this animation clip into JSON.
  	 *
  	 * @return {Object} The JSON object.
  	 */
  	toJSON() {

  		return this.constructor.toJSON( this );

  	}

  }

  function getTrackTypeForValueTypeName( typeName ) {

  	switch ( typeName.toLowerCase() ) {

  		case 'scalar':
  		case 'double':
  		case 'float':
  		case 'number':
  		case 'integer':

  			return NumberKeyframeTrack;

  		case 'vector':
  		case 'vector2':
  		case 'vector3':
  		case 'vector4':

  			return VectorKeyframeTrack;

  		case 'color':

  			return ColorKeyframeTrack;

  		case 'quaternion':

  			return QuaternionKeyframeTrack;

  		case 'bool':
  		case 'boolean':

  			return BooleanKeyframeTrack;

  		case 'string':

  			return StringKeyframeTrack;

  	}

  	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

  }

  function parseKeyframeTrack( json ) {

  	if ( json.type === undefined ) {

  		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

  	}

  	const trackType = getTrackTypeForValueTypeName( json.type );

  	if ( json.times === undefined ) {

  		const times = [], values = [];

  		flattenJSON( json.keys, times, values, 'value' );

  		json.times = times;
  		json.values = values;

  	}

  	// derived classes can define a static parse method
  	if ( trackType.parse !== undefined ) {

  		return trackType.parse( json );

  	} else {

  		// by default, we assume a constructor compatible with the base
  		return new trackType( json.name, json.times, json.values, json.interpolation );

  	}

  }

  /**
   * @class
   * @classdesc A simple caching system, used internally by {@link FileLoader}.
   * To enable caching across all loaders that use {@link FileLoader}, add `THREE.Cache.enabled = true.` once in your app.
   * @hideconstructor
   */
  const Cache = {

  	/**
  	 * Whether caching is enabled or not.
  	 *
  	 * @static
  	 * @type {boolean}
  	 * @default false
  	 */
  	enabled: false,

  	/**
  	 * A dictionary that holds cached files.
  	 *
  	 * @static
  	 * @type {Object<string,Object>}
  	 */
  	files: {},

  	/**
  	 * Adds a cache entry with a key to reference the file. If this key already
  	 * holds a file, it is overwritten.
  	 *
  	 * @static
  	 * @param {string} key - The key to reference the cached file.
  	 * @param {Object} file -  The file to be cached.
  	 */
  	add: function ( key, file ) {

  		if ( this.enabled === false ) return;

  		// console.log( 'THREE.Cache', 'Adding key:', key );

  		this.files[ key ] = file;

  	},

  	/**
  	 * Gets the cached value for the given key.
  	 *
  	 * @static
  	 * @param {string} key - The key to reference the cached file.
  	 * @return {Object|undefined} The cached file. If the key does not exist `undefined` is returned.
  	 */
  	get: function ( key ) {

  		if ( this.enabled === false ) return;

  		// console.log( 'THREE.Cache', 'Checking key:', key );

  		return this.files[ key ];

  	},

  	/**
  	 * Removes the cached file associated with the given key.
  	 *
  	 * @static
  	 * @param {string} key - The key to reference the cached file.
  	 */
  	remove: function ( key ) {

  		delete this.files[ key ];

  	},

  	/**
  	 * Remove all values from the cache.
  	 *
  	 * @static
  	 */
  	clear: function () {

  		this.files = {};

  	}

  };

  /**
   * Handles and keeps track of loaded and pending data. A default global
   * instance of this class is created and used by loaders if not supplied
   * manually.
   *
   * In general that should be sufficient, however there are times when it can
   * be useful to have separate loaders - for example if you want to show
   * separate loading bars for objects and textures.
   *
   * ```js
   * const manager = new THREE.LoadingManager();
   * manager.onLoad = () => console.log( 'Loading complete!' );
   *
   * const loader1 = new OBJLoader( manager );
   * const loader2 = new ColladaLoader( manager );
   * ```
   */
  class LoadingManager {

  	/**
  	 * Constructs a new loading manager.
  	 *
  	 * @param {Function} [onLoad] - Executes when all items have been loaded.
  	 * @param {Function} [onProgress] - Executes when single items have been loaded.
  	 * @param {Function} [onError] - Executes when an error occurs.
  	 */
  	constructor( onLoad, onProgress, onError ) {

  		const scope = this;

  		let isLoading = false;
  		let itemsLoaded = 0;
  		let itemsTotal = 0;
  		let urlModifier = undefined;
  		const handlers = [];

  		// Refer to #5689 for the reason why we don't set .onStart
  		// in the constructor

  		/**
  		 * Executes when an item starts loading.
  		 *
  		 * @type {Function|undefined}
  		 * @default undefined
  		 */
  		this.onStart = undefined;

  		/**
  		 * Executes when all items have been loaded.
  		 *
  		 * @type {Function|undefined}
  		 * @default undefined
  		 */
  		this.onLoad = onLoad;

  		/**
  		 * Executes when single items have been loaded.
  		 *
  		 * @type {Function|undefined}
  		 * @default undefined
  		 */
  		this.onProgress = onProgress;

  		/**
  		 * Executes when an error occurs.
  		 *
  		 * @type {Function|undefined}
  		 * @default undefined
  		 */
  		this.onError = onError;

  		/**
  		 * Used for aborting ongoing requests in loaders using this manager.
  		 *
  		 * @type {AbortController}
  		 */
  		this.abortController = new AbortController();

  		/**
  		 * This should be called by any loader using the manager when the loader
  		 * starts loading an item.
  		 *
  		 * @param {string} url - The URL to load.
  		 */
  		this.itemStart = function ( url ) {

  			itemsTotal ++;

  			if ( isLoading === false ) {

  				if ( scope.onStart !== undefined ) {

  					scope.onStart( url, itemsLoaded, itemsTotal );

  				}

  			}

  			isLoading = true;

  		};

  		/**
  		 * This should be called by any loader using the manager when the loader
  		 * ended loading an item.
  		 *
  		 * @param {string} url - The URL of the loaded item.
  		 */
  		this.itemEnd = function ( url ) {

  			itemsLoaded ++;

  			if ( scope.onProgress !== undefined ) {

  				scope.onProgress( url, itemsLoaded, itemsTotal );

  			}

  			if ( itemsLoaded === itemsTotal ) {

  				isLoading = false;

  				if ( scope.onLoad !== undefined ) {

  					scope.onLoad();

  				}

  			}

  		};

  		/**
  		 * This should be called by any loader using the manager when the loader
  		 * encounters an error when loading an item.
  		 *
  		 * @param {string} url - The URL of the item that produces an error.
  		 */
  		this.itemError = function ( url ) {

  			if ( scope.onError !== undefined ) {

  				scope.onError( url );

  			}

  		};

  		/**
  		 * Given a URL, uses the URL modifier callback (if any) and returns a
  		 * resolved URL. If no URL modifier is set, returns the original URL.
  		 *
  		 * @param {string} url - The URL to load.
  		 * @return {string} The resolved URL.
  		 */
  		this.resolveURL = function ( url ) {

  			if ( urlModifier ) {

  				return urlModifier( url );

  			}

  			return url;

  		};

  		/**
  		 * If provided, the callback will be passed each resource URL before a
  		 * request is sent. The callback may return the original URL, or a new URL to
  		 * override loading behavior. This behavior can be used to load assets from
  		 * .ZIP files, drag-and-drop APIs, and Data URIs.
  		 *
  		 * ```js
  		 * const blobs = {'fish.gltf': blob1, 'diffuse.png': blob2, 'normal.png': blob3};
  		 *
  		 * const manager = new THREE.LoadingManager();
  		 *
  		 * // Initialize loading manager with URL callback.
  		 * const objectURLs = [];
  		 * manager.setURLModifier( ( url ) => {
  		 *
  		 * 	url = URL.createObjectURL( blobs[ url ] );
  		 * 	objectURLs.push( url );
  		 * 	return url;
  		 *
  		 * } );
  		 *
  		 * // Load as usual, then revoke the blob URLs.
  		 * const loader = new GLTFLoader( manager );
  		 * loader.load( 'fish.gltf', (gltf) => {
  		 *
  		 * 	scene.add( gltf.scene );
  		 * 	objectURLs.forEach( ( url ) => URL.revokeObjectURL( url ) );
  		 *
  		 * } );
  		 * ```
  		 *
  		 * @param {function(string):string} transform - URL modifier callback. Called with an URL and must return a resolved URL.
  		 * @return {LoadingManager} A reference to this loading manager.
  		 */
  		this.setURLModifier = function ( transform ) {

  			urlModifier = transform;

  			return this;

  		};

  		/**
  		 * Registers a loader with the given regular expression. Can be used to
  		 * define what loader should be used in order to load specific files. A
  		 * typical use case is to overwrite the default loader for textures.
  		 *
  		 * ```js
  		 * // add handler for TGA textures
  		 * manager.addHandler( /\.tga$/i, new TGALoader() );
  		 * ```
  		 *
  		 * @param {string} regex - A regular expression.
  		 * @param {Loader} loader - A loader that should handle matched cases.
  		 * @return {LoadingManager} A reference to this loading manager.
  		 */
  		this.addHandler = function ( regex, loader ) {

  			handlers.push( regex, loader );

  			return this;

  		};

  		/**
  		 * Removes the loader for the given regular expression.
  		 *
  		 * @param {string} regex - A regular expression.
  		 * @return {LoadingManager} A reference to this loading manager.
  		 */
  		this.removeHandler = function ( regex ) {

  			const index = handlers.indexOf( regex );

  			if ( index !== -1 ) {

  				handlers.splice( index, 2 );

  			}

  			return this;

  		};

  		/**
  		 * Can be used to retrieve the registered loader for the given file path.
  		 *
  		 * @param {string} file - The file path.
  		 * @return {?Loader} The registered loader. Returns `null` if no loader was found.
  		 */
  		this.getHandler = function ( file ) {

  			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

  				const regex = handlers[ i ];
  				const loader = handlers[ i + 1 ];

  				if ( regex.global ) regex.lastIndex = 0; // see #17920

  				if ( regex.test( file ) ) {

  					return loader;

  				}

  			}

  			return null;

  		};

  		/**
  		 * Can be used to abort ongoing loading requests in loaders using this manager.
  		 * The abort only works if the loaders implement {@link Loader#abort} and `AbortSignal.any()`
  		 * is supported in the browser.
  		 *
  		 * @return {LoadingManager} A reference to this loading manager.
  		 */
  		this.abort = function () {

  			this.abortController.abort();
  			this.abortController = new AbortController();

  			return this;

  		};

  	}

  }

  /**
   * The global default loading manager.
   *
   * @constant
   * @type {LoadingManager}
   */
  const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

  /**
   * Abstract base class for loaders.
   *
   * @abstract
   */
  class Loader {

  	/**
  	 * Constructs a new loader.
  	 *
  	 * @param {LoadingManager} [manager] - The loading manager.
  	 */
  	constructor( manager ) {

  		/**
  		 * The loading manager.
  		 *
  		 * @type {LoadingManager}
  		 * @default DefaultLoadingManager
  		 */
  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  		/**
  		 * The crossOrigin string to implement CORS for loading the url from a
  		 * different domain that allows CORS.
  		 *
  		 * @type {string}
  		 * @default 'anonymous'
  		 */
  		this.crossOrigin = 'anonymous';

  		/**
  		 * Whether the XMLHttpRequest uses credentials.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.withCredentials = false;

  		/**
  		 * The base path from which the asset will be loaded.
  		 *
  		 * @type {string}
  		 */
  		this.path = '';

  		/**
  		 * The base path from which additional resources like textures will be loaded.
  		 *
  		 * @type {string}
  		 */
  		this.resourcePath = '';

  		/**
  		 * The [request header]{@link https://developer.mozilla.org/en-US/docs/Glossary/Request_header}
  		 * used in HTTP request.
  		 *
  		 * @type {Object<string, any>}
  		 */
  		this.requestHeader = {};

  	}

  	/**
  	 * This method needs to be implemented by all concrete loaders. It holds the
  	 * logic for loading assets from the backend.
  	 *
  	 * @abstract
  	 * @param {string} url - The path/URL of the file to be loaded.
  	 * @param {Function} onLoad - Executed when the loading process has been finished.
  	 * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
  	 * @param {onErrorCallback} [onError] - Executed when errors occur.
  	 */
  	load( /* url, onLoad, onProgress, onError */ ) {}

  	/**
  	 * A async version of {@link Loader#load}.
  	 *
  	 * @param {string} url - The path/URL of the file to be loaded.
  	 * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
  	 * @return {Promise} A Promise that resolves when the asset has been loaded.
  	 */
  	loadAsync( url, onProgress ) {

  		const scope = this;

  		return new Promise( function ( resolve, reject ) {

  			scope.load( url, resolve, onProgress, reject );

  		} );

  	}

  	/**
  	 * This method needs to be implemented by all concrete loaders. It holds the
  	 * logic for parsing the asset into three.js entities.
  	 *
  	 * @abstract
  	 * @param {any} data - The data to parse.
  	 */
  	parse( /* data */ ) {}

  	/**
  	 * Sets the `crossOrigin` String to implement CORS for loading the URL
  	 * from a different domain that allows CORS.
  	 *
  	 * @param {string} crossOrigin - The `crossOrigin` value.
  	 * @return {Loader} A reference to this instance.
  	 */
  	setCrossOrigin( crossOrigin ) {

  		this.crossOrigin = crossOrigin;
  		return this;

  	}

  	/**
  	 * Whether the XMLHttpRequest uses credentials such as cookies, authorization
  	 * headers or TLS client certificates, see [XMLHttpRequest.withCredentials]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials}.
  	 *
  	 * Note: This setting has no effect if you are loading files locally or from the same domain.
  	 *
  	 * @param {boolean} value - The `withCredentials` value.
  	 * @return {Loader} A reference to this instance.
  	 */
  	setWithCredentials( value ) {

  		this.withCredentials = value;
  		return this;

  	}

  	/**
  	 * Sets the base path for the asset.
  	 *
  	 * @param {string} path - The base path.
  	 * @return {Loader} A reference to this instance.
  	 */
  	setPath( path ) {

  		this.path = path;
  		return this;

  	}

  	/**
  	 * Sets the base path for dependent resources like textures.
  	 *
  	 * @param {string} resourcePath - The resource path.
  	 * @return {Loader} A reference to this instance.
  	 */
  	setResourcePath( resourcePath ) {

  		this.resourcePath = resourcePath;
  		return this;

  	}

  	/**
  	 * Sets the given request header.
  	 *
  	 * @param {Object} requestHeader - A [request header]{@link https://developer.mozilla.org/en-US/docs/Glossary/Request_header}
  	 * for configuring the HTTP request.
  	 * @return {Loader} A reference to this instance.
  	 */
  	setRequestHeader( requestHeader ) {

  		this.requestHeader = requestHeader;
  		return this;

  	}

  	/**
  	 * This method can be implemented in loaders for aborting ongoing requests.
  	 *
  	 * @abstract
  	 * @return {Loader} A reference to this instance.
  	 */
  	abort() {

  		return this;

  	}

  }

  /**
   * Callback for onProgress in loaders.
   *
   * @callback onProgressCallback
   * @param {ProgressEvent} event - An instance of `ProgressEvent` that represents the current loading status.
   */

  /**
   * Callback for onError in loaders.
   *
   * @callback onErrorCallback
   * @param {Error} error - The error which occurred during the loading process.
   */

  /**
   * The default material name that is used by loaders
   * when creating materials for loaded 3D objects.
   *
   * Note: Not all loaders might honor this setting.
   *
   * @static
   * @type {string}
   * @default '__DEFAULT'
   */
  Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';

  const loading = {};

  class HttpError extends Error {

  	constructor( message, response ) {

  		super( message );
  		this.response = response;

  	}

  }

  /**
   * A low level class for loading resources with the Fetch API, used internally by
   * most loaders. It can also be used directly to load any file type that does
   * not have a loader.
   *
   * This loader supports caching. If you want to use it, add `THREE.Cache.enabled = true;`
   * once to your application.
   *
   * ```js
   * const loader = new THREE.FileLoader();
   * const data = await loader.loadAsync( 'example.txt' );
   * ```
   *
   * @augments Loader
   */
  class FileLoader extends Loader {

  	/**
  	 * Constructs a new file loader.
  	 *
  	 * @param {LoadingManager} [manager] - The loading manager.
  	 */
  	constructor( manager ) {

  		super( manager );

  		/**
  		 * The expected mime type. Valid values can be found
  		 * [here]{@link hhttps://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#mimetype}
  		 *
  		 * @type {string}
  		 */
  		this.mimeType = '';

  		/**
  		 * The expected response type.
  		 *
  		 * @type {('arraybuffer'|'blob'|'document'|'json'|'')}
  		 * @default ''
  		 */
  		this.responseType = '';

  		/**
  		 * Used for aborting requests.
  		 *
  		 * @private
  		 * @type {AbortController}
  		 */
  		this._abortController = new AbortController();

  	}

  	/**
  	 * Starts loading from the given URL and pass the loaded response to the `onLoad()` callback.
  	 *
  	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
  	 * @param {function(any)} onLoad - Executed when the loading process has been finished.
  	 * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
  	 * @param {onErrorCallback} [onError] - Executed when errors occur.
  	 * @return {any|undefined} The cached resource if available.
  	 */
  	load( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) url = '';

  		if ( this.path !== undefined ) url = this.path + url;

  		url = this.manager.resolveURL( url );

  		const cached = Cache.get( `file:${url}` );

  		if ( cached !== undefined ) {

  			this.manager.itemStart( url );

  			setTimeout( () => {

  				if ( onLoad ) onLoad( cached );

  				this.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		// Check if request is duplicate

  		if ( loading[ url ] !== undefined ) {

  			loading[ url ].push( {

  				onLoad: onLoad,
  				onProgress: onProgress,
  				onError: onError

  			} );

  			return;

  		}

  		// Initialise array for duplicate requests
  		loading[ url ] = [];

  		loading[ url ].push( {
  			onLoad: onLoad,
  			onProgress: onProgress,
  			onError: onError,
  		} );

  		// create request
  		const req = new Request( url, {
  			headers: new Headers( this.requestHeader ),
  			credentials: this.withCredentials ? 'include' : 'same-origin',
  			signal: ( typeof AbortSignal.any === 'function' ) ? AbortSignal.any( [ this._abortController.signal, this.manager.abortController.signal ] ) : this._abortController.signal
  		} );

  		// record states ( avoid data race )
  		const mimeType = this.mimeType;
  		const responseType = this.responseType;

  		// start the fetch
  		fetch( req )
  			.then( response => {

  				if ( response.status === 200 || response.status === 0 ) {

  					// Some browsers return HTTP Status 0 when using non-http protocol
  					// e.g. 'file://' or 'data://'. Handle as success.

  					if ( response.status === 0 ) {

  						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

  					}

  					// Workaround: Checking if response.body === undefined for Alipay browser #23548

  					if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

  						return response;

  					}

  					const callbacks = loading[ url ];
  					const reader = response.body.getReader();

  					// Nginx needs X-File-Size check
  					// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
  					const contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );
  					const total = contentLength ? parseInt( contentLength ) : 0;
  					const lengthComputable = total !== 0;
  					let loaded = 0;

  					// periodically read data into the new stream tracking while download progress
  					const stream = new ReadableStream( {
  						start( controller ) {

  							readData();

  							function readData() {

  								reader.read().then( ( { done, value } ) => {

  									if ( done ) {

  										controller.close();

  									} else {

  										loaded += value.byteLength;

  										const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
  										for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

  											const callback = callbacks[ i ];
  											if ( callback.onProgress ) callback.onProgress( event );

  										}

  										controller.enqueue( value );
  										readData();

  									}

  								}, ( e ) => {

  									controller.error( e );

  								} );

  							}

  						}

  					} );

  					return new Response( stream );

  				} else {

  					throw new HttpError( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response );

  				}

  			} )
  			.then( response => {

  				switch ( responseType ) {

  					case 'arraybuffer':

  						return response.arrayBuffer();

  					case 'blob':

  						return response.blob();

  					case 'document':

  						return response.text()
  							.then( text => {

  								const parser = new DOMParser();
  								return parser.parseFromString( text, mimeType );

  							} );

  					case 'json':

  						return response.json();

  					default:

  						if ( mimeType === '' ) {

  							return response.text();

  						} else {

  							// sniff encoding
  							const re = /charset="?([^;"\s]*)"?/i;
  							const exec = re.exec( mimeType );
  							const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
  							const decoder = new TextDecoder( label );
  							return response.arrayBuffer().then( ab => decoder.decode( ab ) );

  						}

  				}

  			} )
  			.then( data => {

  				// Add to cache only on HTTP success, so that we do not cache
  				// error response bodies as proper responses to requests.
  				Cache.add( `file:${url}`, data );

  				const callbacks = loading[ url ];
  				delete loading[ url ];

  				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

  					const callback = callbacks[ i ];
  					if ( callback.onLoad ) callback.onLoad( data );

  				}

  			} )
  			.catch( err => {

  				// Abort errors and other errors are handled the same

  				const callbacks = loading[ url ];

  				if ( callbacks === undefined ) {

  					// When onLoad was called and url was deleted in `loading`
  					this.manager.itemError( url );
  					throw err;

  				}

  				delete loading[ url ];

  				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

  					const callback = callbacks[ i ];
  					if ( callback.onError ) callback.onError( err );

  				}

  				this.manager.itemError( url );

  			} )
  			.finally( () => {

  				this.manager.itemEnd( url );

  			} );

  		this.manager.itemStart( url );

  	}

  	/**
  	 * Sets the expected response type.
  	 *
  	 * @param {('arraybuffer'|'blob'|'document'|'json'|'')} value - The response type.
  	 * @return {FileLoader} A reference to this file loader.
  	 */
  	setResponseType( value ) {

  		this.responseType = value;
  		return this;

  	}

  	/**
  	 * Sets the expected mime type of the loaded file.
  	 *
  	 * @param {string} value - The mime type.
  	 * @return {FileLoader} A reference to this file loader.
  	 */
  	setMimeType( value ) {

  		this.mimeType = value;
  		return this;

  	}

  	/**
  	 * Aborts ongoing fetch requests.
  	 *
  	 * @return {FileLoader} A reference to this instance.
  	 */
  	abort() {

  		this._abortController.abort();
  		this._abortController = new AbortController();

  		return this;

  	}

  }

  const _loading = new WeakMap();

  /**
   * A loader for loading images. The class loads images with the HTML `Image` API.
   *
   * ```js
   * const loader = new THREE.ImageLoader();
   * const image = await loader.loadAsync( 'image.png' );
   * ```
   * Please note that `ImageLoader` has dropped support for progress
   * events in `r84`. For an `ImageLoader` that supports progress events, see
   * [this thread]{@link https://github.com/mrdoob/three.js/issues/10439#issuecomment-275785639}.
   *
   * @augments Loader
   */
  class ImageLoader extends Loader {

  	/**
  	 * Constructs a new image loader.
  	 *
  	 * @param {LoadingManager} [manager] - The loading manager.
  	 */
  	constructor( manager ) {

  		super( manager );

  	}

  	/**
  	 * Starts loading from the given URL and passes the loaded image
  	 * to the `onLoad()` callback. The method also returns a new `Image` object which can
  	 * directly be used for texture creation. If you do it this way, the texture
  	 * may pop up in your scene once the respective loading process is finished.
  	 *
  	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
  	 * @param {function(Image)} onLoad - Executed when the loading process has been finished.
  	 * @param {onProgressCallback} onProgress - Unsupported in this loader.
  	 * @param {onErrorCallback} onError - Executed when errors occur.
  	 * @return {Image} The image.
  	 */
  	load( url, onLoad, onProgress, onError ) {

  		if ( this.path !== undefined ) url = this.path + url;

  		url = this.manager.resolveURL( url );

  		const scope = this;

  		const cached = Cache.get( `image:${url}` );

  		if ( cached !== undefined ) {

  			if ( cached.complete === true ) {

  				scope.manager.itemStart( url );

  				setTimeout( function () {

  					if ( onLoad ) onLoad( cached );

  					scope.manager.itemEnd( url );

  				}, 0 );

  			} else {

  				let arr = _loading.get( cached );

  				if ( arr === undefined ) {

  					arr = [];
  					_loading.set( cached, arr );

  				}

  				arr.push( { onLoad, onError } );

  			}

  			return cached;

  		}

  		const image = createElementNS( 'img' );

  		function onImageLoad() {

  			removeEventListeners();

  			if ( onLoad ) onLoad( this );

  			//

  			const callbacks = _loading.get( this ) || [];

  			for ( let i = 0; i < callbacks.length; i ++ ) {

  				const callback = callbacks[ i ];
  				if ( callback.onLoad ) callback.onLoad( this );

  			}

  			_loading.delete( this );

  			scope.manager.itemEnd( url );

  		}

  		function onImageError( event ) {

  			removeEventListeners();

  			if ( onError ) onError( event );

  			Cache.remove( `image:${url}` );

  			//

  			const callbacks = _loading.get( this ) || [];

  			for ( let i = 0; i < callbacks.length; i ++ ) {

  				const callback = callbacks[ i ];
  				if ( callback.onError ) callback.onError( event );

  			}

  			_loading.delete( this );


  			scope.manager.itemError( url );
  			scope.manager.itemEnd( url );

  		}

  		function removeEventListeners() {

  			image.removeEventListener( 'load', onImageLoad, false );
  			image.removeEventListener( 'error', onImageError, false );

  		}

  		image.addEventListener( 'load', onImageLoad, false );
  		image.addEventListener( 'error', onImageError, false );

  		if ( url.slice( 0, 5 ) !== 'data:' ) {

  			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

  		}

  		Cache.add( `image:${url}`, image );
  		scope.manager.itemStart( url );

  		image.src = url;

  		return image;

  	}

  }

  /**
   * Class for loading textures. Images are internally
   * loaded via {@link ImageLoader}.
   *
   * ```js
   * const loader = new THREE.TextureLoader();
   * const texture = await loader.loadAsync( 'textures/land_ocean_ice_cloud_2048.jpg' );
   *
   * const material = new THREE.MeshBasicMaterial( { map:texture } );
   * ```
   * Please note that `TextureLoader` has dropped support for progress
   * events in `r84`. For a `TextureLoader` that supports progress events, see
   * [this thread]{@link https://github.com/mrdoob/three.js/issues/10439#issuecomment-293260145}.
   *
   * @augments Loader
   */
  class TextureLoader extends Loader {

  	/**
  	 * Constructs a new texture loader.
  	 *
  	 * @param {LoadingManager} [manager] - The loading manager.
  	 */
  	constructor( manager ) {

  		super( manager );

  	}

  	/**
  	 * Starts loading from the given URL and pass the fully loaded texture
  	 * to the `onLoad()` callback. The method also returns a new texture object which can
  	 * directly be used for material creation. If you do it this way, the texture
  	 * may pop up in your scene once the respective loading process is finished.
  	 *
  	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
  	 * @param {function(Texture)} onLoad - Executed when the loading process has been finished.
  	 * @param {onProgressCallback} onProgress - Unsupported in this loader.
  	 * @param {onErrorCallback} onError - Executed when errors occur.
  	 * @return {Texture} The texture.
  	 */
  	load( url, onLoad, onProgress, onError ) {

  		const texture = new Texture();

  		const loader = new ImageLoader( this.manager );
  		loader.setCrossOrigin( this.crossOrigin );
  		loader.setPath( this.path );

  		loader.load( url, function ( image ) {

  			texture.image = image;
  			texture.needsUpdate = true;

  			if ( onLoad !== undefined ) {

  				onLoad( texture );

  			}

  		}, onProgress, onError );

  		return texture;

  	}

  }

  /**
   * Abstract base class for lights - all other light types inherit the
   * properties and methods described here.
   *
   * @abstract
   * @augments Object3D
   */
  class Light extends Object3D {

  	/**
  	 * Constructs a new light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity.
  	 */
  	constructor( color, intensity = 1 ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isLight = true;

  		this.type = 'Light';

  		/**
  		 * The light's color.
  		 *
  		 * @type {Color}
  		 */
  		this.color = new Color( color );

  		/**
  		 * The light's intensity.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.intensity = intensity;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 */
  	dispose() {

  		// Empty here in base class; some subclasses override.

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.color.copy( source.color );
  		this.intensity = source.intensity;

  		return this;

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.color = this.color.getHex();
  		data.object.intensity = this.intensity;

  		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

  		if ( this.distance !== undefined ) data.object.distance = this.distance;
  		if ( this.angle !== undefined ) data.object.angle = this.angle;
  		if ( this.decay !== undefined ) data.object.decay = this.decay;
  		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

  		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
  		if ( this.target !== undefined ) data.object.target = this.target.uuid;

  		return data;

  	}

  }

  const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
  const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
  const _lookTarget$1 = /*@__PURE__*/ new Vector3();

  /**
   * Abstract base class for light shadow classes. These classes
   * represent the shadow configuration for different light types.
   *
   * @abstract
   */
  class LightShadow {

  	/**
  	 * Constructs a new light shadow.
  	 *
  	 * @param {Camera} camera - The light's view of the world.
  	 */
  	constructor( camera ) {

  		/**
  		 * The light's view of the world.
  		 *
  		 * @type {Camera}
  		 */
  		this.camera = camera;

  		/**
  		 * The intensity of the shadow. The default is `1`.
  		 * Valid values are in the range `[0, 1]`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.intensity = 1;

  		/**
  		 * Shadow map bias, how much to add or subtract from the normalized depth
  		 * when deciding whether a surface is in shadow.
  		 *
  		 * The default is `0`. Very tiny adjustments here (in the order of `0.0001`)
  		 * may help reduce artifacts in shadows.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.bias = 0;

  		/**
  		 * Defines how much the position used to query the shadow map is offset along
  		 * the object normal. The default is `0`. Increasing this value can be used to
  		 * reduce shadow acne especially in large scenes where light shines onto
  		 * geometry at a shallow angle. The cost is that shadows may appear distorted.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.normalBias = 0;

  		/**
  		 * Setting this to values greater than 1 will blur the edges of the shadow.
  		 * High values will cause unwanted banding effects in the shadows - a greater
  		 * map size will allow for a higher value to be used here before these effects
  		 * become visible.
  		 *
  		 * The property has no effect when the shadow map type is `PCFSoftShadowMap` and
  		 * and it is recommended to increase softness by decreasing the shadow map size instead.
  		 *
  		 * The property has no effect when the shadow map type is `BasicShadowMap`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.radius = 1;

  		/**
  		 * The amount of samples to use when blurring a VSM shadow map.
  		 *
  		 * @type {number}
  		 * @default 8
  		 */
  		this.blurSamples = 8;

  		/**
  		 * Defines the width and height of the shadow map. Higher values give better quality
  		 * shadows at the cost of computation time. Values must be powers of two.
  		 *
  		 * @type {Vector2}
  		 * @default (512,512)
  		 */
  		this.mapSize = new Vector2( 512, 512 );

  		/**
  		 * The type of shadow texture. The default is `UnsignedByteType`.
  		 *
  		 * @type {number}
  		 * @default UnsignedByteType
  		 */
  		this.mapType = UnsignedByteType;

  		/**
  		 * The depth map generated using the internal camera; a location beyond a
  		 * pixel's depth is in shadow. Computed internally during rendering.
  		 *
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * The distribution map generated using the internal camera; an occlusion is
  		 * calculated based on the distribution of depths. Computed internally during
  		 * rendering.
  		 *
  		 * @type {?RenderTarget}
  		 * @default null
  		 */
  		this.mapPass = null;

  		/**
  		 * Model to shadow camera space, to compute location and depth in shadow map.
  		 * This is computed internally during rendering.
  		 *
  		 * @type {Matrix4}
  		 */
  		this.matrix = new Matrix4();

  		/**
  		 * Enables automatic updates of the light's shadow. If you do not require dynamic
  		 * lighting / shadows, you may set this to `false`.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoUpdate = true;

  		/**
  		 * When set to `true`, shadow maps will be updated in the next `render` call.
  		 * If you have set {@link LightShadow#autoUpdate} to `false`, you will need to
  		 * set this property to `true` and then make a render call to update the light's shadow.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.needsUpdate = false;

  		this._frustum = new Frustum();
  		this._frameExtents = new Vector2( 1, 1 );

  		this._viewportCount = 1;

  		this._viewports = [

  			new Vector4( 0, 0, 1, 1 )

  		];

  	}

  	/**
  	 * Used internally by the renderer to get the number of viewports that need
  	 * to be rendered for this shadow.
  	 *
  	 * @return {number} The viewport count.
  	 */
  	getViewportCount() {

  		return this._viewportCount;

  	}

  	/**
  	 * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
  	 *
  	 * @return {Frustum} The shadow camera frustum.
  	 */
  	getFrustum() {

  		return this._frustum;

  	}

  	/**
  	 * Update the matrices for the camera and shadow, used internally by the renderer.
  	 *
  	 * @param {Light} light - The light for which the shadow is being rendered.
  	 */
  	updateMatrices( light ) {

  		const shadowCamera = this.camera;
  		const shadowMatrix = this.matrix;

  		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
  		shadowCamera.position.copy( _lightPositionWorld$1 );

  		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
  		shadowCamera.lookAt( _lookTarget$1 );
  		shadowCamera.updateMatrixWorld();

  		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
  		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1, shadowCamera.coordinateSystem, shadowCamera.reversedDepth );

  		if ( shadowCamera.reversedDepth ) {

  			shadowMatrix.set(
  				0.5, 0.0, 0.0, 0.5,
  				0.0, 0.5, 0.0, 0.5,
  				0.0, 0.0, 1.0, 0.0,
  				0.0, 0.0, 0.0, 1.0
  			);

  		} else {

  			shadowMatrix.set(
  				0.5, 0.0, 0.0, 0.5,
  				0.0, 0.5, 0.0, 0.5,
  				0.0, 0.0, 0.5, 0.5,
  				0.0, 0.0, 0.0, 1.0
  			);

  		}

  		shadowMatrix.multiply( _projScreenMatrix$1 );

  	}

  	/**
  	 * Returns a viewport definition for the given viewport index.
  	 *
  	 * @param {number} viewportIndex - The viewport index.
  	 * @return {Vector4} The viewport.
  	 */
  	getViewport( viewportIndex ) {

  		return this._viewports[ viewportIndex ];

  	}

  	/**
  	 * Returns the frame extends.
  	 *
  	 * @return {Vector2} The frame extends.
  	 */
  	getFrameExtents() {

  		return this._frameExtents;

  	}

  	/**
  	 * Frees the GPU-related resources allocated by this instance. Call this
  	 * method whenever this instance is no longer used in your app.
  	 */
  	dispose() {

  		if ( this.map ) {

  			this.map.dispose();

  		}

  		if ( this.mapPass ) {

  			this.mapPass.dispose();

  		}

  	}

  	/**
  	 * Copies the values of the given light shadow instance to this instance.
  	 *
  	 * @param {LightShadow} source - The light shadow to copy.
  	 * @return {LightShadow} A reference to this light shadow instance.
  	 */
  	copy( source ) {

  		this.camera = source.camera.clone();

  		this.intensity = source.intensity;

  		this.bias = source.bias;
  		this.radius = source.radius;

  		this.autoUpdate = source.autoUpdate;
  		this.needsUpdate = source.needsUpdate;
  		this.normalBias = source.normalBias;
  		this.blurSamples = source.blurSamples;

  		this.mapSize.copy( source.mapSize );

  		return this;

  	}

  	/**
  	 * Returns a new light shadow instance with copied values from this instance.
  	 *
  	 * @return {LightShadow} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  	/**
  	 * Serializes the light shadow into JSON.
  	 *
  	 * @return {Object} A JSON object representing the serialized light shadow.
  	 * @see {@link ObjectLoader#parse}
  	 */
  	toJSON() {

  		const object = {};

  		if ( this.intensity !== 1 ) object.intensity = this.intensity;
  		if ( this.bias !== 0 ) object.bias = this.bias;
  		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
  		if ( this.radius !== 1 ) object.radius = this.radius;
  		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

  		object.camera = this.camera.toJSON( false ).object;
  		delete object.camera.matrix;

  		return object;

  	}

  }

  /**
   * Represents the shadow configuration of directional lights.
   *
   * @augments LightShadow
   */
  class SpotLightShadow extends LightShadow {

  	/**
  	 * Constructs a new spot light shadow.
  	 */
  	constructor() {

  		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSpotLightShadow = true;

  		/**
  		 * Used to focus the shadow camera. The camera's field of view is set as a
  		 * percentage of the spotlight's field-of-view. Range is `[0, 1]`.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.focus = 1;

  		/**
  		 * Texture aspect ratio.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.aspect = 1;

  	}

  	updateMatrices( light ) {

  		const camera = this.camera;

  		const fov = RAD2DEG * 2 * light.angle * this.focus;
  		const aspect = ( this.mapSize.width / this.mapSize.height ) * this.aspect;
  		const far = light.distance || camera.far;

  		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

  			camera.fov = fov;
  			camera.aspect = aspect;
  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  		super.updateMatrices( light );

  	}

  	copy( source ) {

  		super.copy( source );

  		this.focus = source.focus;

  		return this;

  	}

  }

  /**
   * This light gets emitted from a single point in one direction, along a cone
   * that increases in size the further from the light it gets.
   *
   * This light can cast shadows - see the {@link SpotLightShadow} for details.
   *
   * ```js
   * // white spotlight shining from the side, modulated by a texture
   * const spotLight = new THREE.SpotLight( 0xffffff );
   * spotLight.position.set( 100, 1000, 100 );
   * spotLight.map = new THREE.TextureLoader().load( url );
   *
   * spotLight.castShadow = true;
   * spotLight.shadow.mapSize.width = 1024;
   * spotLight.shadow.mapSize.height = 1024;
   * spotLight.shadow.camera.near = 500;
   * spotLight.shadow.camera.far = 4000;
   * spotLight.shadow.camera.fov = 30;s
   * ```
   *
   * @augments Light
   */
  class SpotLight extends Light {

  	/**
  	 * Constructs a new spot light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
  	 * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
  	 * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
  	 * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
  	 * @param {number} [decay=2] - The amount the light dims along the distance of the light.
  	 */
  	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {

  		super( color, intensity );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isSpotLight = true;

  		this.type = 'SpotLight';

  		this.position.copy( Object3D.DEFAULT_UP );
  		this.updateMatrix();

  		/**
  		 * The spot light points from its position to the
  		 * target's position.
  		 *
  		 * For the target's position to be changed to anything other
  		 * than the default, it must be added to the scene.
  		 *
  		 * It is also possible to set the target to be another 3D object
  		 * in the scene. The light will now track the target object.
  		 *
  		 * @type {Object3D}
  		 */
  		this.target = new Object3D();

  		/**
  		 * Maximum range of the light. `0` means no limit.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.distance = distance;

  		/**
  		 * Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
  		 *
  		 * @type {number}
  		 * @default Math.PI/3
  		 */
  		this.angle = angle;

  		/**
  		 * Percent of the spotlight cone that is attenuated due to penumbra.
  		 * Value range is `[0,1]`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.penumbra = penumbra;

  		/**
  		 * The amount the light dims along the distance of the light. In context of
  		 * physically-correct rendering the default value should not be changed.
  		 *
  		 * @type {number}
  		 * @default 2
  		 */
  		this.decay = decay;

  		/**
  		 * A texture used to modulate the color of the light. The spot light
  		 * color is mixed with the RGB value of this texture, with a ratio
  		 * corresponding to its alpha value. The cookie-like masking effect is
  		 * reproduced using pixel values (0, 0, 0, 1-cookie_value).
  		 *
  		 * *Warning*: This property is disabled if {@link Object3D#castShadow} is set to `false`.
  		 *
  		 * @type {?Texture}
  		 * @default null
  		 */
  		this.map = null;

  		/**
  		 * This property holds the light's shadow configuration.
  		 *
  		 * @type {SpotLightShadow}
  		 */
  		this.shadow = new SpotLightShadow();

  	}

  	/**
  	 * The light's power. Power is the luminous power of the light measured in lumens (lm).
  	 *  Changing the power will also change the light's intensity.
  	 *
  	 * @type {number}
  	 */
  	get power() {

  		// compute the light's luminous power (in lumens) from its intensity (in candela)
  		// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
  		return this.intensity * Math.PI;

  	}

  	set power( power ) {

  		// set the light's intensity (in candela) from the desired luminous power (in lumens)
  		this.intensity = power / Math.PI;

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.distance = source.distance;
  		this.angle = source.angle;
  		this.penumbra = source.penumbra;
  		this.decay = source.decay;

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
  const _lightPositionWorld = /*@__PURE__*/ new Vector3();
  const _lookTarget = /*@__PURE__*/ new Vector3();

  /**
   * Represents the shadow configuration of point lights.
   *
   * @augments LightShadow
   */
  class PointLightShadow extends LightShadow {

  	/**
  	 * Constructs a new point light shadow.
  	 */
  	constructor() {

  		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPointLightShadow = true;

  		this._frameExtents = new Vector2( 4, 2 );

  		this._viewportCount = 6;

  		this._viewports = [
  			// These viewports map a cube-map onto a 2D texture with the
  			// following orientation:
  			//
  			//  xzXZ
  			//   y Y
  			//
  			// X - Positive x direction
  			// x - Negative x direction
  			// Y - Positive y direction
  			// y - Negative y direction
  			// Z - Positive z direction
  			// z - Negative z direction

  			// positive X
  			new Vector4( 2, 1, 1, 1 ),
  			// negative X
  			new Vector4( 0, 1, 1, 1 ),
  			// positive Z
  			new Vector4( 3, 1, 1, 1 ),
  			// negative Z
  			new Vector4( 1, 1, 1, 1 ),
  			// positive Y
  			new Vector4( 3, 0, 1, 1 ),
  			// negative Y
  			new Vector4( 1, 0, 1, 1 )
  		];

  		this._cubeDirections = [
  			new Vector3( 1, 0, 0 ), new Vector3( -1, 0, 0 ), new Vector3( 0, 0, 1 ),
  			new Vector3( 0, 0, -1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, -1, 0 )
  		];

  		this._cubeUps = [
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, -1 )
  		];

  	}

  	/**
  	 * Update the matrices for the camera and shadow, used internally by the renderer.
  	 *
  	 * @param {Light} light - The light for which the shadow is being rendered.
  	 * @param {number} [viewportIndex=0] - The viewport index.
  	 */
  	updateMatrices( light, viewportIndex = 0 ) {

  		const camera = this.camera;
  		const shadowMatrix = this.matrix;

  		const far = light.distance || camera.far;

  		if ( far !== camera.far ) {

  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
  		camera.position.copy( _lightPositionWorld );

  		_lookTarget.copy( camera.position );
  		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
  		camera.up.copy( this._cubeUps[ viewportIndex ] );
  		camera.lookAt( _lookTarget );
  		camera.updateMatrixWorld();

  		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

  		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  		this._frustum.setFromProjectionMatrix( _projScreenMatrix, camera.coordinateSystem, camera.reversedDepth );

  	}

  }

  /**
   * A light that gets emitted from a single point in all directions. A common
   * use case for this is to replicate the light emitted from a bare
   * lightbulb.
   *
   * This light can cast shadows - see the {@link PointLightShadow} for details.
   *
   * ```js
   * const light = new THREE.PointLight( 0xff0000, 1, 100 );
   * light.position.set( 50, 50, 50 );
   * scene.add( light );
   * ```
   *
   * @augments Light
   */
  class PointLight extends Light {

  	/**
  	 * Constructs a new point light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
  	 * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
  	 * @param {number} [decay=2] - The amount the light dims along the distance of the light.
  	 */
  	constructor( color, intensity, distance = 0, decay = 2 ) {

  		super( color, intensity );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isPointLight = true;

  		this.type = 'PointLight';

  		/**
  		 * When distance is zero, light will attenuate according to inverse-square
  		 * law to infinite distance. When distance is non-zero, light will attenuate
  		 * according to inverse-square law until near the distance cutoff, where it
  		 * will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not
  		 * physically correct.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.distance = distance;

  		/**
  		 * The amount the light dims along the distance of the light. In context of
  		 * physically-correct rendering the default value should not be changed.
  		 *
  		 * @type {number}
  		 * @default 2
  		 */
  		this.decay = decay;

  		/**
  		 * This property holds the light's shadow configuration.
  		 *
  		 * @type {PointLightShadow}
  		 */
  		this.shadow = new PointLightShadow();

  	}

  	/**
  	 * The light's power. Power is the luminous power of the light measured in lumens (lm).
  	 * Changing the power will also change the light's intensity.
  	 *
  	 * @type {number}
  	 */
  	get power() {

  		// compute the light's luminous power (in lumens) from its intensity (in candela)
  		// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
  		return this.intensity * 4 * Math.PI;

  	}

  	set power( power ) {

  		// set the light's intensity (in candela) from the desired luminous power (in lumens)
  		this.intensity = power / ( 4 * Math.PI );

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.distance = source.distance;
  		this.decay = source.decay;

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  /**
   * Camera that uses [orthographic projection]{@link https://en.wikipedia.org/wiki/Orthographic_projection}.
   *
   * In this projection mode, an object's size in the rendered image stays
   * constant regardless of its distance from the camera. This can be useful
   * for rendering 2D scenes and UI elements, amongst other things.
   *
   * ```js
   * const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
   * scene.add( camera );
   * ```
   *
   * @augments Camera
   */
  class OrthographicCamera extends Camera {

  	/**
  	 * Constructs a new orthographic camera.
  	 *
  	 * @param {number} [left=-1] - The left plane of the camera's frustum.
  	 * @param {number} [right=1] - The right plane of the camera's frustum.
  	 * @param {number} [top=1] - The top plane of the camera's frustum.
  	 * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
  	 * @param {number} [near=0.1] - The camera's near plane.
  	 * @param {number} [far=2000] - The camera's far plane.
  	 */
  	constructor( left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000 ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isOrthographicCamera = true;

  		this.type = 'OrthographicCamera';

  		/**
  		 * The zoom factor of the camera.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.zoom = 1;

  		/**
  		 * Represents the frustum window specification. This property should not be edited
  		 * directly but via {@link PerspectiveCamera#setViewOffset} and {@link PerspectiveCamera#clearViewOffset}.
  		 *
  		 * @type {?Object}
  		 * @default null
  		 */
  		this.view = null;

  		/**
  		 * The left plane of the camera's frustum.
  		 *
  		 * @type {number}
  		 * @default -1
  		 */
  		this.left = left;

  		/**
  		 * The right plane of the camera's frustum.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.right = right;

  		/**
  		 * The top plane of the camera's frustum.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.top = top;

  		/**
  		 * The bottom plane of the camera's frustum.
  		 *
  		 * @type {number}
  		 * @default -1
  		 */
  		this.bottom = bottom;

  		/**
  		 * The camera's near plane. The valid range is greater than `0`
  		 * and less than the current value of {@link OrthographicCamera#far}.
  		 *
  		 * Note that, unlike for the {@link PerspectiveCamera}, `0` is a
  		 * valid value for an orthographic camera's near plane.
  		 *
  		 * @type {number}
  		 * @default 0.1
  		 */
  		this.near = near;

  		/**
  		 * The camera's far plane. Must be greater than the
  		 * current value of {@link OrthographicCamera#near}.
  		 *
  		 * @type {number}
  		 * @default 2000
  		 */
  		this.far = far;

  		this.updateProjectionMatrix();

  	}

  	copy( source, recursive ) {

  		super.copy( source, recursive );

  		this.left = source.left;
  		this.right = source.right;
  		this.top = source.top;
  		this.bottom = source.bottom;
  		this.near = source.near;
  		this.far = source.far;

  		this.zoom = source.zoom;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		return this;

  	}

  	/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * @param {number} fullWidth - The full width of multiview setup.
  	 * @param {number} fullHeight - The full height of multiview setup.
  	 * @param {number} x - The horizontal offset of the subcamera.
  	 * @param {number} y - The vertical offset of the subcamera.
  	 * @param {number} width - The width of subcamera.
  	 * @param {number} height - The height of subcamera.
  	 * @see {@link PerspectiveCamera#setViewOffset}
  	 */
  	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Removes the view offset from the projection matrix.
  	 */
  	clearViewOffset() {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	}

  	/**
  	 * Updates the camera's projection matrix. Must be called after any change of
  	 * camera properties.
  	 */
  	updateProjectionMatrix() {

  		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
  		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  		const cx = ( this.right + this.left ) / 2;
  		const cy = ( this.top + this.bottom ) / 2;

  		let left = cx - dx;
  		let right = cx + dx;
  		let top = cy + dy;
  		let bottom = cy - dy;

  		if ( this.view !== null && this.view.enabled ) {

  			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
  			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

  			left += scaleW * this.view.offsetX;
  			right = left + scaleW * this.view.width;
  			top -= scaleH * this.view.offsetY;
  			bottom = top - scaleH * this.view.height;

  		}

  		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem, this.reversedDepth );

  		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

  	}

  	toJSON( meta ) {

  		const data = super.toJSON( meta );

  		data.object.zoom = this.zoom;
  		data.object.left = this.left;
  		data.object.right = this.right;
  		data.object.top = this.top;
  		data.object.bottom = this.bottom;
  		data.object.near = this.near;
  		data.object.far = this.far;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		return data;

  	}

  }

  /**
   * Represents the shadow configuration of directional lights.
   *
   * @augments LightShadow
   */
  class DirectionalLightShadow extends LightShadow {

  	/**
  	 * Constructs a new directional light shadow.
  	 */
  	constructor() {

  		super( new OrthographicCamera( -5, 5, 5, -5, 0.5, 500 ) );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isDirectionalLightShadow = true;

  	}

  }

  /**
   * A light that gets emitted in a specific direction. This light will behave
   * as though it is infinitely far away and the rays produced from it are all
   * parallel. The common use case for this is to simulate daylight; the sun is
   * far enough away that its position can be considered to be infinite, and
   * all light rays coming from it are parallel.
   *
   * A common point of confusion for directional lights is that setting the
   * rotation has no effect. This is because three.js's DirectionalLight is the
   * equivalent to what is often called a 'Target Direct Light' in other
   * applications.
   *
   * This means that its direction is calculated as pointing from the light's
   * {@link Object3D#position} to the {@link DirectionalLight#target} position
   * (as opposed to a 'Free Direct Light' that just has a rotation
   * component).
   *
   * This light can cast shadows - see the {@link DirectionalLightShadow} for details.
   *
   * ```js
   * // White directional light at half intensity shining from the top.
   * const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
   * scene.add( directionalLight );
   * ```
   *
   * @augments Light
   */
  class DirectionalLight extends Light {

  	/**
  	 * Constructs a new directional light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity.
  	 */
  	constructor( color, intensity ) {

  		super( color, intensity );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isDirectionalLight = true;

  		this.type = 'DirectionalLight';

  		this.position.copy( Object3D.DEFAULT_UP );
  		this.updateMatrix();

  		/**
  		 * The directional light points from its position to the
  		 * target's position.
  		 *
  		 * For the target's position to be changed to anything other
  		 * than the default, it must be added to the scene.
  		 *
  		 * It is also possible to set the target to be another 3D object
  		 * in the scene. The light will now track the target object.
  		 *
  		 * @type {Object3D}
  		 */
  		this.target = new Object3D();

  		/**
  		 * This property holds the light's shadow configuration.
  		 *
  		 * @type {DirectionalLightShadow}
  		 */
  		this.shadow = new DirectionalLightShadow();

  	}

  	dispose() {

  		this.shadow.dispose();

  	}

  	copy( source ) {

  		super.copy( source );

  		this.target = source.target.clone();
  		this.shadow = source.shadow.clone();

  		return this;

  	}

  }

  /**
   * This light globally illuminates all objects in the scene equally.
   *
   * It cannot be used to cast shadows as it does not have a direction.
   *
   * ```js
   * const light = new THREE.AmbientLight( 0x404040 ); // soft white light
   * scene.add( light );
   * ```
   *
   * @augments Light
   */
  class AmbientLight extends Light {

  	/**
  	 * Constructs a new ambient light.
  	 *
  	 * @param {(number|Color|string)} [color=0xffffff] - The light's color.
  	 * @param {number} [intensity=1] - The light's strength/intensity.
  	 */
  	constructor( color, intensity ) {

  		super( color, intensity );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isAmbientLight = true;

  		this.type = 'AmbientLight';

  	}

  }

  /**
   * A class with loader utility functions.
   */
  class LoaderUtils {

  	/**
  	 * Extracts the base URL from the given URL.
  	 *
  	 * @param {string} url -The URL to extract the base URL from.
  	 * @return {string} The extracted base URL.
  	 */
  	static extractUrlBase( url ) {

  		const index = url.lastIndexOf( '/' );

  		if ( index === -1 ) return './';

  		return url.slice( 0, index + 1 );

  	}

  	/**
  	 * Resolves relative URLs against the given path. Absolute paths, data urls,
  	 * and blob URLs will be returned as is. Invalid URLs will return an empty
  	 * string.
  	 *
  	 * @param {string} url -The URL to resolve.
  	 * @param {string} path - The base path for relative URLs to be resolved against.
  	 * @return {string} The resolved URL.
  	 */
  	static resolveURL( url, path ) {

  		// Invalid URL
  		if ( typeof url !== 'string' || url === '' ) return '';

  		// Host Relative URL
  		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

  			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

  		}

  		// Absolute URL http://,https://,//
  		if ( /^(https?:)?\/\//i.test( url ) ) return url;

  		// Data URI
  		if ( /^data:.*,.*$/i.test( url ) ) return url;

  		// Blob URL
  		if ( /^blob:.*$/i.test( url ) ) return url;

  		// Relative URL
  		return path + url;

  	}

  }

  const _errorMap = new WeakMap();

  /**
   * A loader for loading images as an [ImageBitmap]{@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap}.
   * An `ImageBitmap` provides an asynchronous and resource efficient pathway to prepare
   * textures for rendering.
   *
   * Note that {@link Texture#flipY} and {@link Texture#premultiplyAlpha} are ignored with image bitmaps.
   * They needs these configuration on bitmap creation unlike regular images need them on uploading to GPU.
   *
   * You need to set the equivalent options via {@link ImageBitmapLoader#setOptions} instead.
   *
   * Also note that unlike {@link FileLoader}, this loader avoids multiple concurrent requests to the same URL only if `Cache` is enabled.
   *
   * ```js
   * const loader = new THREE.ImageBitmapLoader();
   * loader.setOptions( { imageOrientation: 'flipY' } ); // set options if needed
   * const imageBitmap = await loader.loadAsync( 'image.png' );
   *
   * const texture = new THREE.Texture( imageBitmap );
   * texture.needsUpdate = true;
   * ```
   *
   * @augments Loader
   */
  class ImageBitmapLoader extends Loader {

  	/**
  	 * Constructs a new image bitmap loader.
  	 *
  	 * @param {LoadingManager} [manager] - The loading manager.
  	 */
  	constructor( manager ) {

  		super( manager );

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isImageBitmapLoader = true;

  		if ( typeof createImageBitmap === 'undefined' ) {

  			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

  		}

  		if ( typeof fetch === 'undefined' ) {

  			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

  		}

  		/**
  		 * Represents the loader options.
  		 *
  		 * @type {Object}
  		 * @default {premultiplyAlpha:'none'}
  		 */
  		this.options = { premultiplyAlpha: 'none' };

  		/**
  		 * Used for aborting requests.
  		 *
  		 * @private
  		 * @type {AbortController}
  		 */
  		this._abortController = new AbortController();

  	}

  	/**
  	 * Sets the given loader options. The structure of the object must match the `options` parameter of
  	 * [createImageBitmap]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/createImageBitmap}.
  	 *
  	 * @param {Object} options - The loader options to set.
  	 * @return {ImageBitmapLoader} A reference to this image bitmap loader.
  	 */
  	setOptions( options ) {

  		this.options = options;

  		return this;

  	}

  	/**
  	 * Starts loading from the given URL and pass the loaded image bitmap to the `onLoad()` callback.
  	 *
  	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
  	 * @param {function(ImageBitmap)} onLoad - Executed when the loading process has been finished.
  	 * @param {onProgressCallback} onProgress - Unsupported in this loader.
  	 * @param {onErrorCallback} onError - Executed when errors occur.
  	 * @return {ImageBitmap|undefined} The image bitmap.
  	 */
  	load( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) url = '';

  		if ( this.path !== undefined ) url = this.path + url;

  		url = this.manager.resolveURL( url );

  		const scope = this;

  		const cached = Cache.get( `image-bitmap:${url}` );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			// If cached is a promise, wait for it to resolve
  			if ( cached.then ) {

  				cached.then( imageBitmap => {

  					// check if there is an error for the cached promise

  					if ( _errorMap.has( cached ) === true ) {

  						if ( onError ) onError( _errorMap.get( cached ) );

  						scope.manager.itemError( url );
  						scope.manager.itemEnd( url );

  					} else {

  						if ( onLoad ) onLoad( imageBitmap );

  						scope.manager.itemEnd( url );

  						return imageBitmap;

  					}

  				} );

  				return;

  			}

  			// If cached is not a promise (i.e., it's already an imageBitmap)
  			setTimeout( function () {

  				if ( onLoad ) onLoad( cached );

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		const fetchOptions = {};
  		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
  		fetchOptions.headers = this.requestHeader;
  		fetchOptions.signal = ( typeof AbortSignal.any === 'function' ) ? AbortSignal.any( [ this._abortController.signal, this.manager.abortController.signal ] ) : this._abortController.signal;

  		const promise = fetch( url, fetchOptions ).then( function ( res ) {

  			return res.blob();

  		} ).then( function ( blob ) {

  			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

  		} ).then( function ( imageBitmap ) {

  			Cache.add( `image-bitmap:${url}`, imageBitmap );

  			if ( onLoad ) onLoad( imageBitmap );

  			scope.manager.itemEnd( url );

  			return imageBitmap;

  		} ).catch( function ( e ) {

  			if ( onError ) onError( e );

  			_errorMap.set( promise, e );

  			Cache.remove( `image-bitmap:${url}` );

  			scope.manager.itemError( url );
  			scope.manager.itemEnd( url );

  		} );

  		Cache.add( `image-bitmap:${url}`, promise );
  		scope.manager.itemStart( url );

  	}

  	/**
  	 * Aborts ongoing fetch requests.
  	 *
  	 * @return {ImageBitmapLoader} A reference to this instance.
  	 */
  	abort() {

  		this._abortController.abort();
  		this._abortController = new AbortController();

  		return this;

  	}

  }

  /**
   * This type of camera can be used in order to efficiently render a scene with a
   * predefined set of cameras. This is an important performance aspect for
   * rendering VR scenes.
   *
   * An instance of `ArrayCamera` always has an array of sub cameras. It's mandatory
   * to define for each sub camera the `viewport` property which determines the
   * part of the viewport that is rendered with this camera.
   *
   * @augments PerspectiveCamera
   */
  class ArrayCamera extends PerspectiveCamera {

  	/**
  	 * Constructs a new array camera.
  	 *
  	 * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
  	 */
  	constructor( array = [] ) {

  		super();

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isArrayCamera = true;

  		/**
  		 * Whether this camera is used with multiview rendering or not.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default false
  		 */
  		this.isMultiViewCamera = false;

  		/**
  		 * An array of perspective sub cameras.
  		 *
  		 * @type {Array<PerspectiveCamera>}
  		 */
  		this.cameras = array;

  	}

  }

  /**
   * Class for keeping track of time.
   */
  class Clock {

  	/**
  	 * Constructs a new clock.
  	 *
  	 * @param {boolean} [autoStart=true] - Whether to automatically start the clock when
  	 * `getDelta()` is called for the first time.
  	 */
  	constructor( autoStart = true ) {

  		/**
  		 * If set to `true`, the clock starts automatically when `getDelta()` is called
  		 * for the first time.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoStart = autoStart;

  		/**
  		 * Holds the time at which the clock's `start()` method was last called.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.startTime = 0;

  		/**
  		 * Holds the time at which the clock's `start()`, `getElapsedTime()` or
  		 * `getDelta()` methods were last called.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.oldTime = 0;

  		/**
  		 * Keeps track of the total time that the clock has been running.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.elapsedTime = 0;

  		/**
  		 * Whether the clock is running or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.running = false;

  	}

  	/**
  	 * Starts the clock. When `autoStart` is set to `true`, the method is automatically
  	 * called by the class.
  	 */
  	start() {

  		this.startTime = performance.now();

  		this.oldTime = this.startTime;
  		this.elapsedTime = 0;
  		this.running = true;

  	}

  	/**
  	 * Stops the clock.
  	 */
  	stop() {

  		this.getElapsedTime();
  		this.running = false;
  		this.autoStart = false;

  	}

  	/**
  	 * Returns the elapsed time in seconds.
  	 *
  	 * @return {number} The elapsed time.
  	 */
  	getElapsedTime() {

  		this.getDelta();
  		return this.elapsedTime;

  	}

  	/**
  	 * Returns the delta time in seconds.
  	 *
  	 * @return {number} The delta time.
  	 */
  	getDelta() {

  		let diff = 0;

  		if ( this.autoStart && ! this.running ) {

  			this.start();
  			return 0;

  		}

  		if ( this.running ) {

  			const newTime = performance.now();

  			diff = ( newTime - this.oldTime ) / 1000;
  			this.oldTime = newTime;

  			this.elapsedTime += diff;

  		}

  		return diff;

  	}

  }

  // Characters [].:/ are reserved for track binding syntax.
  const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
  const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

  // Attempts to allow node names from any language. ES5's `\w` regexp matches
  // only latin characters, and the unicode \p{L} is not yet supported. So
  // instead, we exclude reserved characters and match everything else.
  const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
  const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

  // Parent directories, delimited by '/' or ':'. Currently unused, but must
  // be matched to parse the rest of the track name.
  const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

  // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

  // Object on target node, and accessor. May not contain reserved
  // characters. Accessor may contain any character except closing bracket.
  const _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

  // Property and accessor. May not contain reserved characters. Accessor may
  // contain any non-bracket characters.
  const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

  const _trackRe = new RegExp( ''
  	+ '^'
  	+ _directoryRe
  	+ _nodeRe
  	+ _objectRe
  	+ _propertyRe
  	+ '$'
  );

  const _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];

  class Composite {

  	constructor( targetGroup, path, optionalParsedPath ) {

  		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

  		this._targetGroup = targetGroup;
  		this._bindings = targetGroup.subscribe_( path, parsedPath );

  	}

  	getValue( array, offset ) {

  		this.bind(); // bind all binding

  		const firstValidIndex = this._targetGroup.nCachedObjects_,
  			binding = this._bindings[ firstValidIndex ];

  		// and only call .getValue on the first
  		if ( binding !== undefined ) binding.getValue( array, offset );

  	}

  	setValue( array, offset ) {

  		const bindings = this._bindings;

  		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].setValue( array, offset );

  		}

  	}

  	bind() {

  		const bindings = this._bindings;

  		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].bind();

  		}

  	}

  	unbind() {

  		const bindings = this._bindings;

  		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].unbind();

  		}

  	}

  }

  // Note: This class uses a State pattern on a per-method basis:
  // 'bind' sets 'this.getValue' / 'setValue' and shadows the
  // prototype version of these methods with one that represents
  // the bound state. When the property is not found, the methods
  // become no-ops.


  /**
   * This holds a reference to a real property in the scene graph; used internally.
   */
  class PropertyBinding {

  	/**
  	 * Constructs a new property binding.
  	 *
  	 * @param {Object} rootNode - The root node.
  	 * @param {string} path - The path.
  	 * @param {?Object} [parsedPath] - The parsed path.
  	 */
  	constructor( rootNode, path, parsedPath ) {

  		/**
  		 * The object path to the animated property.
  		 *
  		 * @type {string}
  		 */
  		this.path = path;

  		/**
  		 * An object holding information about the path.
  		 *
  		 * @type {Object}
  		 */
  		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

  		/**
  		 * The object owns the animated property.
  		 *
  		 * @type {?Object}
  		 */
  		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );

  		/**
  		 * The root node.
  		 *
  		 * @type {Object3D|Skeleton}
  		 */
  		this.rootNode = rootNode;

  		// initial state of these methods that calls 'bind'
  		this.getValue = this._getValue_unbound;
  		this.setValue = this._setValue_unbound;

  	}


  	/**
  	 * Factory method for creating a property binding from the given parameters.
  	 *
  	 * @static
  	 * @param {Object} root - The root node.
  	 * @param {string} path - The path.
  	 * @param {?Object} [parsedPath] - The parsed path.
  	 * @return {PropertyBinding|Composite} The created property binding or composite.
  	 */
  	static create( root, path, parsedPath ) {

  		if ( ! ( root && root.isAnimationObjectGroup ) ) {

  			return new PropertyBinding( root, path, parsedPath );

  		} else {

  			return new PropertyBinding.Composite( root, path, parsedPath );

  		}

  	}

  	/**
  	 * Replaces spaces with underscores and removes unsupported characters from
  	 * node names, to ensure compatibility with parseTrackName().
  	 *
  	 * @param {string} name - Node name to be sanitized.
  	 * @return {string} The sanitized node name.
  	 */
  	static sanitizeNodeName( name ) {

  		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

  	}

  	/**
  	 * Parses the given track name (an object path to an animated property) and
  	 * returns an object with information about the path. Matches strings in the following forms:
  	 *
  	 * - nodeName.property
  	 * - nodeName.property[accessor]
  	 * - nodeName.material.property[accessor]
  	 * - uuid.property[accessor]
  	 * - uuid.objectName[objectIndex].propertyName[propertyIndex]
  	 * - parentName/nodeName.property
  	 * - parentName/parentName/nodeName.property[index]
  	 * - .bone[Armature.DEF_cog].position
  	 * - scene:helium_balloon_model:helium_balloon_model.position
  	 *
  	 * @static
  	 * @param {string} trackName - The track name to parse.
  	 * @return {Object} The parsed track name as an object.
  	 */
  	static parseTrackName( trackName ) {

  		const matches = _trackRe.exec( trackName );

  		if ( matches === null ) {

  			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

  		}

  		const results = {
  			// directoryName: matches[ 1 ], // (tschw) currently unused
  			nodeName: matches[ 2 ],
  			objectName: matches[ 3 ],
  			objectIndex: matches[ 4 ],
  			propertyName: matches[ 5 ], // required
  			propertyIndex: matches[ 6 ]
  		};

  		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

  		if ( lastDot !== undefined && lastDot !== -1 ) {

  			const objectName = results.nodeName.substring( lastDot + 1 );

  			// Object names must be checked against an allowlist. Otherwise, there
  			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
  			// 'bar' could be the objectName, or part of a nodeName (which can
  			// include '.' characters).
  			if ( _supportedObjectNames.indexOf( objectName ) !== -1 ) {

  				results.nodeName = results.nodeName.substring( 0, lastDot );
  				results.objectName = objectName;

  			}

  		}

  		if ( results.propertyName === null || results.propertyName.length === 0 ) {

  			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

  		}

  		return results;

  	}

  	/**
  	 * Searches for a node in the hierarchy of the given root object by the given
  	 * node name.
  	 *
  	 * @static
  	 * @param {Object} root - The root object.
  	 * @param {string|number} nodeName - The name of the node.
  	 * @return {?Object} The found node. Returns `null` if no object was found.
  	 */
  	static findNode( root, nodeName ) {

  		if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

  			return root;

  		}

  		// search into skeleton bones.
  		if ( root.skeleton ) {

  			const bone = root.skeleton.getBoneByName( nodeName );

  			if ( bone !== undefined ) {

  				return bone;

  			}

  		}

  		// search into node subtree.
  		if ( root.children ) {

  			const searchNodeSubtree = function ( children ) {

  				for ( let i = 0; i < children.length; i ++ ) {

  					const childNode = children[ i ];

  					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

  						return childNode;

  					}

  					const result = searchNodeSubtree( childNode.children );

  					if ( result ) return result;

  				}

  				return null;

  			};

  			const subTreeNode = searchNodeSubtree( root.children );

  			if ( subTreeNode ) {

  				return subTreeNode;

  			}

  		}

  		return null;

  	}

  	// these are used to "bind" a nonexistent property
  	_getValue_unavailable() {}
  	_setValue_unavailable() {}

  	// Getters

  	_getValue_direct( buffer, offset ) {

  		buffer[ offset ] = this.targetObject[ this.propertyName ];

  	}

  	_getValue_array( buffer, offset ) {

  		const source = this.resolvedProperty;

  		for ( let i = 0, n = source.length; i !== n; ++ i ) {

  			buffer[ offset ++ ] = source[ i ];

  		}

  	}

  	_getValue_arrayElement( buffer, offset ) {

  		buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

  	}

  	_getValue_toArray( buffer, offset ) {

  		this.resolvedProperty.toArray( buffer, offset );

  	}

  	// Direct

  	_setValue_direct( buffer, offset ) {

  		this.targetObject[ this.propertyName ] = buffer[ offset ];

  	}

  	_setValue_direct_setNeedsUpdate( buffer, offset ) {

  		this.targetObject[ this.propertyName ] = buffer[ offset ];
  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		this.targetObject[ this.propertyName ] = buffer[ offset ];
  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	// EntireArray

  	_setValue_array( buffer, offset ) {

  		const dest = this.resolvedProperty;

  		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

  			dest[ i ] = buffer[ offset ++ ];

  		}

  	}

  	_setValue_array_setNeedsUpdate( buffer, offset ) {

  		const dest = this.resolvedProperty;

  		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

  			dest[ i ] = buffer[ offset ++ ];

  		}

  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		const dest = this.resolvedProperty;

  		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

  			dest[ i ] = buffer[ offset ++ ];

  		}

  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	// ArrayElement

  	_setValue_arrayElement( buffer, offset ) {

  		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

  	}

  	_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	// HasToFromArray

  	_setValue_fromArray( buffer, offset ) {

  		this.resolvedProperty.fromArray( buffer, offset );

  	}

  	_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty.fromArray( buffer, offset );
  		this.targetObject.needsUpdate = true;

  	}

  	_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

  		this.resolvedProperty.fromArray( buffer, offset );
  		this.targetObject.matrixWorldNeedsUpdate = true;

  	}

  	_getValue_unbound( targetArray, offset ) {

  		this.bind();
  		this.getValue( targetArray, offset );

  	}

  	_setValue_unbound( sourceArray, offset ) {

  		this.bind();
  		this.setValue( sourceArray, offset );

  	}

  	/**
  	 * Creates a getter / setter pair for the property tracked by this binding.
  	 */
  	bind() {

  		let targetObject = this.node;
  		const parsedPath = this.parsedPath;

  		const objectName = parsedPath.objectName;
  		const propertyName = parsedPath.propertyName;
  		let propertyIndex = parsedPath.propertyIndex;

  		if ( ! targetObject ) {

  			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );

  			this.node = targetObject;

  		}

  		// set fail state so we can just 'return' on error
  		this.getValue = this._getValue_unavailable;
  		this.setValue = this._setValue_unavailable;

  		// ensure there is a value node
  		if ( ! targetObject ) {

  			console.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );
  			return;

  		}

  		if ( objectName ) {

  			let objectIndex = parsedPath.objectIndex;

  			// special cases were we need to reach deeper into the hierarchy to get the face materials....
  			switch ( objectName ) {

  				case 'materials':

  					if ( ! targetObject.material ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
  						return;

  					}

  					if ( ! targetObject.material.materials ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
  						return;

  					}

  					targetObject = targetObject.material.materials;

  					break;

  				case 'bones':

  					if ( ! targetObject.skeleton ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
  						return;

  					}

  					// potential future optimization: skip this if propertyIndex is already an integer
  					// and convert the integer string to a true integer.

  					targetObject = targetObject.skeleton.bones;

  					// support resolving morphTarget names into indices.
  					for ( let i = 0; i < targetObject.length; i ++ ) {

  						if ( targetObject[ i ].name === objectIndex ) {

  							objectIndex = i;
  							break;

  						}

  					}

  					break;

  				case 'map':

  					if ( 'map' in targetObject ) {

  						targetObject = targetObject.map;
  						break;

  					}

  					if ( ! targetObject.material ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
  						return;

  					}

  					if ( ! targetObject.material.map ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );
  						return;

  					}

  					targetObject = targetObject.material.map;
  					break;

  				default:

  					if ( targetObject[ objectName ] === undefined ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
  						return;

  					}

  					targetObject = targetObject[ objectName ];

  			}


  			if ( objectIndex !== undefined ) {

  				if ( targetObject[ objectIndex ] === undefined ) {

  					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
  					return;

  				}

  				targetObject = targetObject[ objectIndex ];

  			}

  		}

  		// resolve property
  		const nodeProperty = targetObject[ propertyName ];

  		if ( nodeProperty === undefined ) {

  			const nodeName = parsedPath.nodeName;

  			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
  				'.' + propertyName + ' but it wasn\'t found.', targetObject );
  			return;

  		}

  		// determine versioning scheme
  		let versioning = this.Versioning.None;

  		this.targetObject = targetObject;

  		if ( targetObject.isMaterial === true ) {

  			versioning = this.Versioning.NeedsUpdate;

  		} else if ( targetObject.isObject3D === true ) {

  			versioning = this.Versioning.MatrixWorldNeedsUpdate;

  		}

  		// determine how the property gets bound
  		let bindingType = this.BindingType.Direct;

  		if ( propertyIndex !== undefined ) {

  			// access a sub element of the property array (only primitives are supported right now)

  			if ( propertyName === 'morphTargetInfluences' ) {

  				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

  				// support resolving morphTarget names into indices.
  				if ( ! targetObject.geometry ) {

  					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
  					return;

  				}

  				if ( ! targetObject.geometry.morphAttributes ) {

  					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
  					return;

  				}

  				if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

  					propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

  				}

  			}

  			bindingType = this.BindingType.ArrayElement;

  			this.resolvedProperty = nodeProperty;
  			this.propertyIndex = propertyIndex;

  		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

  			// must use copy for Object3D.Euler/Quaternion

  			bindingType = this.BindingType.HasFromToArray;

  			this.resolvedProperty = nodeProperty;

  		} else if ( Array.isArray( nodeProperty ) ) {

  			bindingType = this.BindingType.EntireArray;

  			this.resolvedProperty = nodeProperty;

  		} else {

  			this.propertyName = propertyName;

  		}

  		// select getter / setter
  		this.getValue = this.GetterByBindingType[ bindingType ];
  		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

  	}

  	/**
  	 * Unbinds the property.
  	 */
  	unbind() {

  		this.node = null;

  		// back to the prototype version of getValue / setValue
  		// note: avoiding to mutate the shape of 'this' via 'delete'
  		this.getValue = this._getValue_unbound;
  		this.setValue = this._setValue_unbound;

  	}

  }

  PropertyBinding.Composite = Composite;

  PropertyBinding.prototype.BindingType = {
  	Direct: 0,
  	EntireArray: 1,
  	ArrayElement: 2,
  	HasFromToArray: 3
  };

  PropertyBinding.prototype.Versioning = {
  	None: 0,
  	NeedsUpdate: 1,
  	MatrixWorldNeedsUpdate: 2
  };

  PropertyBinding.prototype.GetterByBindingType = [

  	PropertyBinding.prototype._getValue_direct,
  	PropertyBinding.prototype._getValue_array,
  	PropertyBinding.prototype._getValue_arrayElement,
  	PropertyBinding.prototype._getValue_toArray,

  ];

  PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

  	[
  		// Direct
  		PropertyBinding.prototype._setValue_direct,
  		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

  	], [

  		// EntireArray

  		PropertyBinding.prototype._setValue_array,
  		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

  	], [

  		// ArrayElement
  		PropertyBinding.prototype._setValue_arrayElement,
  		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

  	], [

  		// HasToFromArray
  		PropertyBinding.prototype._setValue_fromArray,
  		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
  		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

  	]

  ];

  /**
   * This class can be used to represent points in 3D space as
   * [Spherical coordinates]{@link https://en.wikipedia.org/wiki/Spherical_coordinate_system}.
   */
  class Spherical {

  	/**
  	 * Constructs a new spherical.
  	 *
  	 * @param {number} [radius=1] - The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
  	 * @param {number} [phi=0] - The polar angle in radians from the y (up) axis.
  	 * @param {number} [theta=0] - The equator/azimuthal angle in radians around the y (up) axis.
  	 */
  	constructor( radius = 1, phi = 0, theta = 0 ) {

  		/**
  		 * The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.radius = radius;

  		/**
  		 * The polar angle in radians from the y (up) axis.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.phi = phi;

  		/**
  		 * The equator/azimuthal angle in radians around the y (up) axis.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.theta = theta;

  	}

  	/**
  	 * Sets the spherical components by copying the given values.
  	 *
  	 * @param {number} radius - The radius.
  	 * @param {number} phi - The polar angle.
  	 * @param {number} theta - The azimuthal angle.
  	 * @return {Spherical} A reference to this spherical.
  	 */
  	set( radius, phi, theta ) {

  		this.radius = radius;
  		this.phi = phi;
  		this.theta = theta;

  		return this;

  	}

  	/**
  	 * Copies the values of the given spherical to this instance.
  	 *
  	 * @param {Spherical} other - The spherical to copy.
  	 * @return {Spherical} A reference to this spherical.
  	 */
  	copy( other ) {

  		this.radius = other.radius;
  		this.phi = other.phi;
  		this.theta = other.theta;

  		return this;

  	}

  	/**
  	 * Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
  	 * `0.000001`.
  	 *
  	 * @return {Spherical} A reference to this spherical.
  	 */
  	makeSafe() {

  		const EPS = 0.000001;
  		this.phi = clamp( this.phi, EPS, Math.PI - EPS );

  		return this;

  	}

  	/**
  	 * Sets the spherical components from the given vector which is assumed to hold
  	 * Cartesian coordinates.
  	 *
  	 * @param {Vector3} v - The vector to set.
  	 * @return {Spherical} A reference to this spherical.
  	 */
  	setFromVector3( v ) {

  		return this.setFromCartesianCoords( v.x, v.y, v.z );

  	}

  	/**
  	 * Sets the spherical components from the given Cartesian coordinates.
  	 *
  	 * @param {number} x - The x value.
  	 * @param {number} y - The y value.
  	 * @param {number} z - The z value.
  	 * @return {Spherical} A reference to this spherical.
  	 */
  	setFromCartesianCoords( x, y, z ) {

  		this.radius = Math.sqrt( x * x + y * y + z * z );

  		if ( this.radius === 0 ) {

  			this.theta = 0;
  			this.phi = 0;

  		} else {

  			this.theta = Math.atan2( x, z );
  			this.phi = Math.acos( clamp( y / this.radius, -1, 1 ) );

  		}

  		return this;

  	}

  	/**
  	 * Returns a new spherical with copied values from this instance.
  	 *
  	 * @return {Spherical} A clone of this instance.
  	 */
  	clone() {

  		return new this.constructor().copy( this );

  	}

  }

  /**
   * Abstract base class for controls.
   *
   * @abstract
   * @augments EventDispatcher
   */
  class Controls extends EventDispatcher {

  	/**
  	 * Constructs a new controls instance.
  	 *
  	 * @param {Object3D} object - The object that is managed by the controls.
  	 * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
  	 */
  	constructor( object, domElement = null ) {

  		super();

  		/**
  		 * The object that is managed by the controls.
  		 *
  		 * @type {Object3D}
  		 */
  		this.object = object;

  		/**
  		 * The HTML element used for event listeners.
  		 *
  		 * @type {?HTMLDOMElement}
  		 * @default null
  		 */
  		this.domElement = domElement;

  		/**
  		 * Whether the controls responds to user input or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.enabled = true;

  		/**
  		 * The internal state of the controls.
  		 *
  		 * @type {number}
  		 * @default -1
  		 */
  		this.state = -1;

  		/**
  		 * This object defines the keyboard input of the controls.
  		 *
  		 * @type {Object}
  		 */
  		this.keys = {};

  		/**
  		 * This object defines what type of actions are assigned to the available mouse buttons.
  		 * It depends on the control implementation what kind of mouse buttons and actions are supported.
  		 *
  		 * @type {{LEFT: ?number, MIDDLE: ?number, RIGHT: ?number}}
  		 */
  		this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };

  		/**
  		 * This object defines what type of actions are assigned to what kind of touch interaction.
  		 * It depends on the control implementation what kind of touch interaction and actions are supported.
  		 *
  		 * @type {{ONE: ?number, TWO: ?number}}
  		 */
  		this.touches = { ONE: null, TWO: null };

  	}

  	/**
  	 * Connects the controls to the DOM. This method has so called "side effects" since
  	 * it adds the module's event listeners to the DOM.
  	 *
  	 * @param {HTMLDOMElement} element - The DOM element to connect to.
  	 */
  	connect( element ) {

  		if ( element === undefined ) {

  			console.warn( 'THREE.Controls: connect() now requires an element.' ); // @deprecated, the warning can be removed with r185
  			return;

  		}

  		if ( this.domElement !== null ) this.disconnect();

  		this.domElement = element;

  	}

  	/**
  	 * Disconnects the controls from the DOM.
  	 */
  	disconnect() {}

  	/**
  	 * Call this method if you no longer want use to the controls. It frees all internal
  	 * resources and removes all event listeners.
  	 */
  	dispose() {}

  	/**
  	 * Controls should implement this method if they have to update their internal state
  	 * per simulation step.
  	 *
  	 * @param {number} [delta] - The time delta in seconds.
  	 */
  	update( /* delta */ ) {}

  }

  /**
   * Determines how many bytes must be used to represent the texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} format - The texture's format.
   * @param {number} type - The texture's type.
   * @return {number} The byte length.
   */
  function getByteLength( width, height, format, type ) {

  	const typeByteLength = getTextureTypeByteLength( type );

  	switch ( format ) {

  		// https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
  		case AlphaFormat:
  			return width * height;
  		case RedFormat:
  			return ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RedIntegerFormat:
  			return ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RGFormat:
  			return ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RGIntegerFormat:
  			return ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RGBFormat:
  			return ( ( width * height * 3 ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RGBAFormat:
  			return ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;
  		case RGBAIntegerFormat:
  			return ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;

  		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
  		case RGB_S3TC_DXT1_Format:
  		case RGBA_S3TC_DXT1_Format:
  			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;
  		case RGBA_S3TC_DXT3_Format:
  		case RGBA_S3TC_DXT5_Format:
  			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;

  		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
  		case RGB_PVRTC_2BPPV1_Format:
  		case RGBA_PVRTC_2BPPV1_Format:
  			return ( Math.max( width, 16 ) * Math.max( height, 8 ) ) / 4;
  		case RGB_PVRTC_4BPPV1_Format:
  		case RGBA_PVRTC_4BPPV1_Format:
  			return ( Math.max( width, 8 ) * Math.max( height, 8 ) ) / 2;

  		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
  		case RGB_ETC1_Format:
  		case RGB_ETC2_Format:
  			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;
  		case RGBA_ETC2_EAC_Format:
  			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;

  		// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
  		case RGBA_ASTC_4x4_Format:
  			return Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;
  		case RGBA_ASTC_5x4_Format:
  			return Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 3 ) / 4 ) * 16;
  		case RGBA_ASTC_5x5_Format:
  			return Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
  		case RGBA_ASTC_6x5_Format:
  			return Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
  		case RGBA_ASTC_6x6_Format:
  			return Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
  		case RGBA_ASTC_8x5_Format:
  			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
  		case RGBA_ASTC_8x6_Format:
  			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
  		case RGBA_ASTC_8x8_Format:
  			return Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 7 ) / 8 ) * 16;
  		case RGBA_ASTC_10x5_Format:
  			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 4 ) / 5 ) * 16;
  		case RGBA_ASTC_10x6_Format:
  			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 5 ) / 6 ) * 16;
  		case RGBA_ASTC_10x8_Format:
  			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 7 ) / 8 ) * 16;
  		case RGBA_ASTC_10x10_Format:
  			return Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 9 ) / 10 ) * 16;
  		case RGBA_ASTC_12x10_Format:
  			return Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 9 ) / 10 ) * 16;
  		case RGBA_ASTC_12x12_Format:
  			return Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 11 ) / 12 ) * 16;

  		// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
  		case RGBA_BPTC_Format:
  		case RGB_BPTC_SIGNED_Format:
  		case RGB_BPTC_UNSIGNED_Format:
  			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;

  		// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
  		case RED_RGTC1_Format:
  		case SIGNED_RED_RGTC1_Format:
  			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 8;
  		case RED_GREEN_RGTC2_Format:
  		case SIGNED_RED_GREEN_RGTC2_Format:
  			return Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;

  	}

  	throw new Error(
  		`Unable to determine texture byte length for ${format} format.`,
  	);

  }

  function getTextureTypeByteLength( type ) {

  	switch ( type ) {

  		case UnsignedByteType:
  		case ByteType:
  			return { byteLength: 1, components: 1 };
  		case UnsignedShortType:
  		case ShortType:
  		case HalfFloatType:
  			return { byteLength: 2, components: 1 };
  		case UnsignedShort4444Type:
  		case UnsignedShort5551Type:
  			return { byteLength: 2, components: 4 };
  		case UnsignedIntType:
  		case IntType:
  		case FloatType:
  			return { byteLength: 4, components: 1 };
  		case UnsignedInt5999Type:
  		case UnsignedInt101111Type:
  			return { byteLength: 4, components: 3 };

  	}

  	throw new Error( `Unknown texture type ${type}.` );

  }

  if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
  		revision: REVISION,
  	} } ) );

  }

  if ( typeof window !== 'undefined' ) {

  	if ( window.__THREE__ ) {

  		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

  	} else {

  		window.__THREE__ = REVISION;

  	}

  }

  /**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   */

  function WebGLAnimation() {

  	let context = null;
  	let isAnimating = false;
  	let animationLoop = null;
  	let requestId = null;

  	function onAnimationFrame( time, frame ) {

  		animationLoop( time, frame );

  		requestId = context.requestAnimationFrame( onAnimationFrame );

  	}

  	return {

  		start: function () {

  			if ( isAnimating === true ) return;
  			if ( animationLoop === null ) return;

  			requestId = context.requestAnimationFrame( onAnimationFrame );

  			isAnimating = true;

  		},

  		stop: function () {

  			context.cancelAnimationFrame( requestId );

  			isAnimating = false;

  		},

  		setAnimationLoop: function ( callback ) {

  			animationLoop = callback;

  		},

  		setContext: function ( value ) {

  			context = value;

  		}

  	};

  }

  function WebGLAttributes( gl ) {

  	const buffers = new WeakMap();

  	function createBuffer( attribute, bufferType ) {

  		const array = attribute.array;
  		const usage = attribute.usage;
  		const size = array.byteLength;

  		const buffer = gl.createBuffer();

  		gl.bindBuffer( bufferType, buffer );
  		gl.bufferData( bufferType, array, usage );

  		attribute.onUploadCallback();

  		let type;

  		if ( array instanceof Float32Array ) {

  			type = gl.FLOAT;

  		} else if ( typeof Float16Array !== 'undefined' && array instanceof Float16Array ) {

  			type = gl.HALF_FLOAT;

  		} else if ( array instanceof Uint16Array ) {

  			if ( attribute.isFloat16BufferAttribute ) {

  				type = gl.HALF_FLOAT;

  			} else {

  				type = gl.UNSIGNED_SHORT;

  			}

  		} else if ( array instanceof Int16Array ) {

  			type = gl.SHORT;

  		} else if ( array instanceof Uint32Array ) {

  			type = gl.UNSIGNED_INT;

  		} else if ( array instanceof Int32Array ) {

  			type = gl.INT;

  		} else if ( array instanceof Int8Array ) {

  			type = gl.BYTE;

  		} else if ( array instanceof Uint8Array ) {

  			type = gl.UNSIGNED_BYTE;

  		} else if ( array instanceof Uint8ClampedArray ) {

  			type = gl.UNSIGNED_BYTE;

  		} else {

  			throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

  		}

  		return {
  			buffer: buffer,
  			type: type,
  			bytesPerElement: array.BYTES_PER_ELEMENT,
  			version: attribute.version,
  			size: size
  		};

  	}

  	function updateBuffer( buffer, attribute, bufferType ) {

  		const array = attribute.array;
  		const updateRanges = attribute.updateRanges;

  		gl.bindBuffer( bufferType, buffer );

  		if ( updateRanges.length === 0 ) {

  			// Not using update ranges
  			gl.bufferSubData( bufferType, 0, array );

  		} else {

  			// Before applying update ranges, we merge any adjacent / overlapping
  			// ranges to reduce load on `gl.bufferSubData`. Empirically, this has led
  			// to performance improvements for applications which make heavy use of
  			// update ranges. Likely due to GPU command overhead.
  			//
  			// Note that to reduce garbage collection between frames, we merge the
  			// update ranges in-place. This is safe because this method will clear the
  			// update ranges once updated.

  			updateRanges.sort( ( a, b ) => a.start - b.start );

  			// To merge the update ranges in-place, we work from left to right in the
  			// existing updateRanges array, merging ranges. This may result in a final
  			// array which is smaller than the original. This index tracks the last
  			// index representing a merged range, any data after this index can be
  			// trimmed once the merge algorithm is completed.
  			let mergeIndex = 0;

  			for ( let i = 1; i < updateRanges.length; i ++ ) {

  				const previousRange = updateRanges[ mergeIndex ];
  				const range = updateRanges[ i ];

  				// We add one here to merge adjacent ranges. This is safe because ranges
  				// operate over positive integers.
  				if ( range.start <= previousRange.start + previousRange.count + 1 ) {

  					previousRange.count = Math.max(
  						previousRange.count,
  						range.start + range.count - previousRange.start
  					);

  				} else {

  					++ mergeIndex;
  					updateRanges[ mergeIndex ] = range;

  				}

  			}

  			// Trim the array to only contain the merged ranges.
  			updateRanges.length = mergeIndex + 1;

  			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

  				const range = updateRanges[ i ];

  				gl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,
  					array, range.start, range.count );

  			}

  			attribute.clearUpdateRanges();

  		}

  		attribute.onUploadCallback();

  	}

  	//

  	function get( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		return buffers.get( attribute );

  	}

  	function remove( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		const data = buffers.get( attribute );

  		if ( data ) {

  			gl.deleteBuffer( data.buffer );

  			buffers.delete( attribute );

  		}

  	}

  	function update( attribute, bufferType ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		if ( attribute.isGLBufferAttribute ) {

  			const cached = buffers.get( attribute );

  			if ( ! cached || cached.version < attribute.version ) {

  				buffers.set( attribute, {
  					buffer: attribute.buffer,
  					type: attribute.type,
  					bytesPerElement: attribute.elementSize,
  					version: attribute.version
  				} );

  			}

  			return;

  		}

  		const data = buffers.get( attribute );

  		if ( data === undefined ) {

  			buffers.set( attribute, createBuffer( attribute, bufferType ) );

  		} else if ( data.version < attribute.version ) {

  			if ( data.size !== attribute.array.byteLength ) {

  				throw new Error( 'THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.' );

  			}

  			updateBuffer( data.buffer, attribute, bufferType );

  			data.version = attribute.version;

  		}

  	}

  	return {

  		get: get,
  		remove: remove,
  		update: update

  	};

  }

  var alphahash_fragment = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";

  var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";

  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";

  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

  var alphatest_fragment = "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif";

  var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

  var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

  var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

  var batching_pars_vertex = "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif";

  var batching_vertex = "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";

  var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";

  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

  var bsdfs = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";

  var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif";

  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

  var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

  var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

  var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif";

  var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif";

  var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";

  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";

  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

  var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

  var colorspace_pars_fragment = "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

  var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

  var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

  var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

  var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

  var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

  var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";

  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

  var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";

  var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";

  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

  var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";

  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";

  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";

  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";

  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

  var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";

  var logdepthbuf_fragment = "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

  var logdepthbuf_pars_fragment = "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

  var logdepthbuf_pars_vertex = "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

  var logdepthbuf_vertex = "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";

  var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

  var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

  var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

  var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif";

  var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";

  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif";

  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";

  var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;";

  var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

  var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

  var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

  var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";

  var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif";

  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";

  var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";

  var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

  var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";

  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

  var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

  var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

  var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\tfloat depth = unpackRGBAToDepth( texture2D( depths, uv ) );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\treturn step( depth, compare );\n\t\t#else\n\t\t\treturn step( compare, depth );\n\t\t#endif\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow( sampler2D shadow, vec2 uv, float compare ) {\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\tfloat hard_shadow = step( distribution.x, compare );\n\t\t#else\n\t\t\tfloat hard_shadow = step( compare, distribution.x );\n\t\t#endif\n\t\tif ( hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif";

  var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

  var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";

  var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

  var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

  var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";

  var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

  var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

  var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";

  var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";

  var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

  var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

  var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";

  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

  const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

  const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

  const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

  const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

  const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

  const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

  const vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

  const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\tfloat fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];\n\t#else\n\t\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;\n\t#endif\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}";

  const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

  const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

  const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

  const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

  const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

  const vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

  const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

  const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

  const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

  const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

  const vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

  const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

  const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

  const ShaderChunk = {
  	alphahash_fragment: alphahash_fragment,
  	alphahash_pars_fragment: alphahash_pars_fragment,
  	alphamap_fragment: alphamap_fragment,
  	alphamap_pars_fragment: alphamap_pars_fragment,
  	alphatest_fragment: alphatest_fragment,
  	alphatest_pars_fragment: alphatest_pars_fragment,
  	aomap_fragment: aomap_fragment,
  	aomap_pars_fragment: aomap_pars_fragment,
  	batching_pars_vertex: batching_pars_vertex,
  	batching_vertex: batching_vertex,
  	begin_vertex: begin_vertex,
  	beginnormal_vertex: beginnormal_vertex,
  	bsdfs: bsdfs,
  	iridescence_fragment: iridescence_fragment,
  	bumpmap_pars_fragment: bumpmap_pars_fragment,
  	clipping_planes_fragment: clipping_planes_fragment,
  	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  	clipping_planes_vertex: clipping_planes_vertex,
  	color_fragment: color_fragment,
  	color_pars_fragment: color_pars_fragment,
  	color_pars_vertex: color_pars_vertex,
  	color_vertex: color_vertex,
  	common: common,
  	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  	defaultnormal_vertex: defaultnormal_vertex,
  	displacementmap_pars_vertex: displacementmap_pars_vertex,
  	displacementmap_vertex: displacementmap_vertex,
  	emissivemap_fragment: emissivemap_fragment,
  	emissivemap_pars_fragment: emissivemap_pars_fragment,
  	colorspace_fragment: colorspace_fragment,
  	colorspace_pars_fragment: colorspace_pars_fragment,
  	envmap_fragment: envmap_fragment,
  	envmap_common_pars_fragment: envmap_common_pars_fragment,
  	envmap_pars_fragment: envmap_pars_fragment,
  	envmap_pars_vertex: envmap_pars_vertex,
  	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  	envmap_vertex: envmap_vertex,
  	fog_vertex: fog_vertex,
  	fog_pars_vertex: fog_pars_vertex,
  	fog_fragment: fog_fragment,
  	fog_pars_fragment: fog_pars_fragment,
  	gradientmap_pars_fragment: gradientmap_pars_fragment,
  	lightmap_pars_fragment: lightmap_pars_fragment,
  	lights_lambert_fragment: lights_lambert_fragment,
  	lights_lambert_pars_fragment: lights_lambert_pars_fragment,
  	lights_pars_begin: lights_pars_begin,
  	lights_toon_fragment: lights_toon_fragment,
  	lights_toon_pars_fragment: lights_toon_pars_fragment,
  	lights_phong_fragment: lights_phong_fragment,
  	lights_phong_pars_fragment: lights_phong_pars_fragment,
  	lights_physical_fragment: lights_physical_fragment,
  	lights_physical_pars_fragment: lights_physical_pars_fragment,
  	lights_fragment_begin: lights_fragment_begin,
  	lights_fragment_maps: lights_fragment_maps,
  	lights_fragment_end: lights_fragment_end,
  	logdepthbuf_fragment: logdepthbuf_fragment,
  	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  	logdepthbuf_vertex: logdepthbuf_vertex,
  	map_fragment: map_fragment,
  	map_pars_fragment: map_pars_fragment,
  	map_particle_fragment: map_particle_fragment,
  	map_particle_pars_fragment: map_particle_pars_fragment,
  	metalnessmap_fragment: metalnessmap_fragment,
  	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  	morphinstance_vertex: morphinstance_vertex,
  	morphcolor_vertex: morphcolor_vertex,
  	morphnormal_vertex: morphnormal_vertex,
  	morphtarget_pars_vertex: morphtarget_pars_vertex,
  	morphtarget_vertex: morphtarget_vertex,
  	normal_fragment_begin: normal_fragment_begin,
  	normal_fragment_maps: normal_fragment_maps,
  	normal_pars_fragment: normal_pars_fragment,
  	normal_pars_vertex: normal_pars_vertex,
  	normal_vertex: normal_vertex,
  	normalmap_pars_fragment: normalmap_pars_fragment,
  	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
  	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
  	clearcoat_pars_fragment: clearcoat_pars_fragment,
  	iridescence_pars_fragment: iridescence_pars_fragment,
  	opaque_fragment: opaque_fragment,
  	packing: packing,
  	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  	project_vertex: project_vertex,
  	dithering_fragment: dithering_fragment,
  	dithering_pars_fragment: dithering_pars_fragment,
  	roughnessmap_fragment: roughnessmap_fragment,
  	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  	shadowmap_pars_fragment: shadowmap_pars_fragment,
  	shadowmap_pars_vertex: shadowmap_pars_vertex,
  	shadowmap_vertex: shadowmap_vertex,
  	shadowmask_pars_fragment: shadowmask_pars_fragment,
  	skinbase_vertex: skinbase_vertex,
  	skinning_pars_vertex: skinning_pars_vertex,
  	skinning_vertex: skinning_vertex,
  	skinnormal_vertex: skinnormal_vertex,
  	specularmap_fragment: specularmap_fragment,
  	specularmap_pars_fragment: specularmap_pars_fragment,
  	tonemapping_fragment: tonemapping_fragment,
  	tonemapping_pars_fragment: tonemapping_pars_fragment,
  	transmission_fragment: transmission_fragment,
  	transmission_pars_fragment: transmission_pars_fragment,
  	uv_pars_fragment: uv_pars_fragment,
  	uv_pars_vertex: uv_pars_vertex,
  	uv_vertex: uv_vertex,
  	worldpos_vertex: worldpos_vertex,

  	background_vert: vertex$h,
  	background_frag: fragment$h,
  	backgroundCube_vert: vertex$g,
  	backgroundCube_frag: fragment$g,
  	cube_vert: vertex$f,
  	cube_frag: fragment$f,
  	depth_vert: vertex$e,
  	depth_frag: fragment$e,
  	distanceRGBA_vert: vertex$d,
  	distanceRGBA_frag: fragment$d,
  	equirect_vert: vertex$c,
  	equirect_frag: fragment$c,
  	linedashed_vert: vertex$b,
  	linedashed_frag: fragment$b,
  	meshbasic_vert: vertex$a,
  	meshbasic_frag: fragment$a,
  	meshlambert_vert: vertex$9,
  	meshlambert_frag: fragment$9,
  	meshmatcap_vert: vertex$8,
  	meshmatcap_frag: fragment$8,
  	meshnormal_vert: vertex$7,
  	meshnormal_frag: fragment$7,
  	meshphong_vert: vertex$6,
  	meshphong_frag: fragment$6,
  	meshphysical_vert: vertex$5,
  	meshphysical_frag: fragment$5,
  	meshtoon_vert: vertex$4,
  	meshtoon_frag: fragment$4,
  	points_vert: vertex$3,
  	points_frag: fragment$3,
  	shadow_vert: vertex$2,
  	shadow_frag: fragment$2,
  	sprite_vert: vertex$1,
  	sprite_frag: fragment$1
  };

  // Uniforms library for shared webgl shaders
  const UniformsLib = {

  	common: {

  		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
  		opacity: { value: 1.0 },

  		map: { value: null },
  		mapTransform: { value: /*@__PURE__*/ new Matrix3() },

  		alphaMap: { value: null },
  		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },

  		alphaTest: { value: 0 }

  	},

  	specularmap: {

  		specularMap: { value: null },
  		specularMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	envmap: {

  		envMap: { value: null },
  		envMapRotation: { value: /*@__PURE__*/ new Matrix3() },
  		flipEnvMap: { value: -1 },
  		reflectivity: { value: 1.0 }, // basic, lambert, phong
  		ior: { value: 1.5 }, // physical
  		refractionRatio: { value: 0.98 }, // basic, lambert, phong

  	},

  	aomap: {

  		aoMap: { value: null },
  		aoMapIntensity: { value: 1 },
  		aoMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	lightmap: {

  		lightMap: { value: null },
  		lightMapIntensity: { value: 1 },
  		lightMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	bumpmap: {

  		bumpMap: { value: null },
  		bumpMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		bumpScale: { value: 1 }

  	},

  	normalmap: {

  		normalMap: { value: null },
  		normalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

  	},

  	displacementmap: {

  		displacementMap: { value: null },
  		displacementMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		displacementScale: { value: 1 },
  		displacementBias: { value: 0 }

  	},

  	emissivemap: {

  		emissiveMap: { value: null },
  		emissiveMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	metalnessmap: {

  		metalnessMap: { value: null },
  		metalnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	roughnessmap: {

  		roughnessMap: { value: null },
  		roughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	gradientmap: {

  		gradientMap: { value: null }

  	},

  	fog: {

  		fogDensity: { value: 0.00025 },
  		fogNear: { value: 1 },
  		fogFar: { value: 2000 },
  		fogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }

  	},

  	lights: {

  		ambientLightColor: { value: [] },

  		lightProbe: { value: [] },

  		directionalLights: { value: [], properties: {
  			direction: {},
  			color: {}
  		} },

  		directionalLightShadows: { value: [], properties: {
  			shadowIntensity: 1,
  			shadowBias: {},
  			shadowNormalBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		directionalShadowMap: { value: [] },
  		directionalShadowMatrix: { value: [] },

  		spotLights: { value: [], properties: {
  			color: {},
  			position: {},
  			direction: {},
  			distance: {},
  			coneCos: {},
  			penumbraCos: {},
  			decay: {}
  		} },

  		spotLightShadows: { value: [], properties: {
  			shadowIntensity: 1,
  			shadowBias: {},
  			shadowNormalBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		spotLightMap: { value: [] },
  		spotShadowMap: { value: [] },
  		spotLightMatrix: { value: [] },

  		pointLights: { value: [], properties: {
  			color: {},
  			position: {},
  			decay: {},
  			distance: {}
  		} },

  		pointLightShadows: { value: [], properties: {
  			shadowIntensity: 1,
  			shadowBias: {},
  			shadowNormalBias: {},
  			shadowRadius: {},
  			shadowMapSize: {},
  			shadowCameraNear: {},
  			shadowCameraFar: {}
  		} },

  		pointShadowMap: { value: [] },
  		pointShadowMatrix: { value: [] },

  		hemisphereLights: { value: [], properties: {
  			direction: {},
  			skyColor: {},
  			groundColor: {}
  		} },

  		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
  		rectAreaLights: { value: [], properties: {
  			color: {},
  			position: {},
  			width: {},
  			height: {}
  		} },

  		ltc_1: { value: null },
  		ltc_2: { value: null }

  	},

  	points: {

  		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
  		opacity: { value: 1.0 },
  		size: { value: 1.0 },
  		scale: { value: 1.0 },
  		map: { value: null },
  		alphaMap: { value: null },
  		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		alphaTest: { value: 0 },
  		uvTransform: { value: /*@__PURE__*/ new Matrix3() }

  	},

  	sprite: {

  		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
  		opacity: { value: 1.0 },
  		center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
  		rotation: { value: 0.0 },
  		map: { value: null },
  		mapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		alphaMap: { value: null },
  		alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		alphaTest: { value: 0 }

  	}

  };

  const ShaderLib = {

  	basic: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.meshbasic_vert,
  		fragmentShader: ShaderChunk.meshbasic_frag

  	},

  	lambert: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshlambert_vert,
  		fragmentShader: ShaderChunk.meshlambert_frag

  	},

  	phong: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
  				specular: { value: /*@__PURE__*/ new Color( 0x111111 ) },
  				shininess: { value: 30 }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshphong_vert,
  		fragmentShader: ShaderChunk.meshphong_frag

  	},

  	standard: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.roughnessmap,
  			UniformsLib.metalnessmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
  				roughness: { value: 1.0 },
  				metalness: { value: 0.0 },
  				envMapIntensity: { value: 1 }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshphysical_vert,
  		fragmentShader: ShaderChunk.meshphysical_frag

  	},

  	toon: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.gradientmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshtoon_vert,
  		fragmentShader: ShaderChunk.meshtoon_frag

  	},

  	matcap: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.fog,
  			{
  				matcap: { value: null }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshmatcap_vert,
  		fragmentShader: ShaderChunk.meshmatcap_frag

  	},

  	points: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.points,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.points_vert,
  		fragmentShader: ShaderChunk.points_frag

  	},

  	dashed: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.fog,
  			{
  				scale: { value: 1 },
  				dashSize: { value: 1 },
  				totalSize: { value: 2 }
  			}
  		] ),

  		vertexShader: ShaderChunk.linedashed_vert,
  		fragmentShader: ShaderChunk.linedashed_frag

  	},

  	depth: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.displacementmap
  		] ),

  		vertexShader: ShaderChunk.depth_vert,
  		fragmentShader: ShaderChunk.depth_frag

  	},

  	normal: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			{
  				opacity: { value: 1.0 }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshnormal_vert,
  		fragmentShader: ShaderChunk.meshnormal_frag

  	},

  	sprite: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.sprite,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.sprite_vert,
  		fragmentShader: ShaderChunk.sprite_frag

  	},

  	background: {

  		uniforms: {
  			uvTransform: { value: /*@__PURE__*/ new Matrix3() },
  			t2D: { value: null },
  			backgroundIntensity: { value: 1 }
  		},

  		vertexShader: ShaderChunk.background_vert,
  		fragmentShader: ShaderChunk.background_frag

  	},

  	backgroundCube: {

  		uniforms: {
  			envMap: { value: null },
  			flipEnvMap: { value: -1 },
  			backgroundBlurriness: { value: 0 },
  			backgroundIntensity: { value: 1 },
  			backgroundRotation: { value: /*@__PURE__*/ new Matrix3() }
  		},

  		vertexShader: ShaderChunk.backgroundCube_vert,
  		fragmentShader: ShaderChunk.backgroundCube_frag

  	},

  	cube: {

  		uniforms: {
  			tCube: { value: null },
  			tFlip: { value: -1 },
  			opacity: { value: 1.0 }
  		},

  		vertexShader: ShaderChunk.cube_vert,
  		fragmentShader: ShaderChunk.cube_frag

  	},

  	equirect: {

  		uniforms: {
  			tEquirect: { value: null },
  		},

  		vertexShader: ShaderChunk.equirect_vert,
  		fragmentShader: ShaderChunk.equirect_frag

  	},

  	distanceRGBA: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.displacementmap,
  			{
  				referencePosition: { value: /*@__PURE__*/ new Vector3() },
  				nearDistance: { value: 1 },
  				farDistance: { value: 1000 }
  			}
  		] ),

  		vertexShader: ShaderChunk.distanceRGBA_vert,
  		fragmentShader: ShaderChunk.distanceRGBA_frag

  	},

  	shadow: {

  		uniforms: /*@__PURE__*/ mergeUniforms( [
  			UniformsLib.lights,
  			UniformsLib.fog,
  			{
  				color: { value: /*@__PURE__*/ new Color( 0x00000 ) },
  				opacity: { value: 1.0 }
  			},
  		] ),

  		vertexShader: ShaderChunk.shadow_vert,
  		fragmentShader: ShaderChunk.shadow_frag

  	}

  };

  ShaderLib.physical = {

  	uniforms: /*@__PURE__*/ mergeUniforms( [
  		ShaderLib.standard.uniforms,
  		{
  			clearcoat: { value: 0 },
  			clearcoatMap: { value: null },
  			clearcoatMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			clearcoatNormalMap: { value: null },
  			clearcoatNormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
  			clearcoatRoughness: { value: 0 },
  			clearcoatRoughnessMap: { value: null },
  			clearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			dispersion: { value: 0 },
  			iridescence: { value: 0 },
  			iridescenceMap: { value: null },
  			iridescenceMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			iridescenceIOR: { value: 1.3 },
  			iridescenceThicknessMinimum: { value: 100 },
  			iridescenceThicknessMaximum: { value: 400 },
  			iridescenceThicknessMap: { value: null },
  			iridescenceThicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			sheen: { value: 0 },
  			sheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
  			sheenColorMap: { value: null },
  			sheenColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			sheenRoughness: { value: 1 },
  			sheenRoughnessMap: { value: null },
  			sheenRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			transmission: { value: 0 },
  			transmissionMap: { value: null },
  			transmissionMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
  			transmissionSamplerMap: { value: null },
  			thickness: { value: 0 },
  			thicknessMap: { value: null },
  			thicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			attenuationDistance: { value: 0 },
  			attenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
  			specularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },
  			specularColorMap: { value: null },
  			specularColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			specularIntensity: { value: 1 },
  			specularIntensityMap: { value: null },
  			specularIntensityMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  			anisotropyVector: { value: /*@__PURE__*/ new Vector2() },
  			anisotropyMap: { value: null },
  			anisotropyMapTransform: { value: /*@__PURE__*/ new Matrix3() },
  		}
  	] ),

  	vertexShader: ShaderChunk.meshphysical_vert,
  	fragmentShader: ShaderChunk.meshphysical_frag

  };

  const _rgb = { r: 0, b: 0, g: 0 };
  const _e1$1 = /*@__PURE__*/ new Euler();
  const _m1$1 = /*@__PURE__*/ new Matrix4();

  function WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {

  	const clearColor = new Color( 0x000000 );
  	let clearAlpha = alpha === true ? 0 : 1;

  	let planeMesh;
  	let boxMesh;

  	let currentBackground = null;
  	let currentBackgroundVersion = 0;
  	let currentTonemapping = null;

  	function getBackground( scene ) {

  		let background = scene.isScene === true ? scene.background : null;

  		if ( background && background.isTexture ) {

  			const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
  			background = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );

  		}

  		return background;

  	}

  	function render( scene ) {

  		let forceClear = false;
  		const background = getBackground( scene );

  		if ( background === null ) {

  			setClear( clearColor, clearAlpha );

  		} else if ( background && background.isColor ) {

  			setClear( background, 1 );
  			forceClear = true;

  		}

  		const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();

  		if ( environmentBlendMode === 'additive' ) {

  			state.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );

  		} else if ( environmentBlendMode === 'alpha-blend' ) {

  			state.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );

  		}

  		if ( renderer.autoClear || forceClear ) {

  			// buffers might not be writable which is required to ensure a correct clear

  			state.buffers.depth.setTest( true );
  			state.buffers.depth.setMask( true );
  			state.buffers.color.setMask( true );

  			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

  		}

  	}

  	function addToRenderList( renderList, scene ) {

  		const background = getBackground( scene );

  		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

  			if ( boxMesh === undefined ) {

  				boxMesh = new Mesh(
  					new BoxGeometry( 1, 1, 1 ),
  					new ShaderMaterial( {
  						name: 'BackgroundCubeMaterial',
  						uniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),
  						vertexShader: ShaderLib.backgroundCube.vertexShader,
  						fragmentShader: ShaderLib.backgroundCube.fragmentShader,
  						side: BackSide,
  						depthTest: false,
  						depthWrite: false,
  						fog: false,
  						allowOverride: false
  					} )
  				);

  				boxMesh.geometry.deleteAttribute( 'normal' );
  				boxMesh.geometry.deleteAttribute( 'uv' );

  				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

  					this.matrixWorld.copyPosition( camera.matrixWorld );

  				};

  				// add "envMap" material property so the renderer can evaluate it like for built-in materials
  				Object.defineProperty( boxMesh.material, 'envMap', {

  					get: function () {

  						return this.uniforms.envMap.value;

  					}

  				} );

  				objects.update( boxMesh );

  			}

  			_e1$1.copy( scene.backgroundRotation );

  			// accommodate left-handed frame
  			_e1$1.x *= -1; _e1$1.y *= -1; _e1$1.z *= -1;

  			if ( background.isCubeTexture && background.isRenderTargetTexture === false ) {

  				// environment maps which are not cube render targets or PMREMs follow a different convention
  				_e1$1.y *= -1;
  				_e1$1.z *= -1;

  			}

  			boxMesh.material.uniforms.envMap.value = background;
  			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? -1 : 1;
  			boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
  			boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
  			boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4( _m1$1.makeRotationFromEuler( _e1$1 ) );
  			boxMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

  			if ( currentBackground !== background ||
  				currentBackgroundVersion !== background.version ||
  				currentTonemapping !== renderer.toneMapping ) {

  				boxMesh.material.needsUpdate = true;

  				currentBackground = background;
  				currentBackgroundVersion = background.version;
  				currentTonemapping = renderer.toneMapping;

  			}

  			boxMesh.layers.enableAll();

  			// push to the pre-sorted opaque render list
  			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

  		} else if ( background && background.isTexture ) {

  			if ( planeMesh === undefined ) {

  				planeMesh = new Mesh(
  					new PlaneGeometry( 2, 2 ),
  					new ShaderMaterial( {
  						name: 'BackgroundMaterial',
  						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
  						vertexShader: ShaderLib.background.vertexShader,
  						fragmentShader: ShaderLib.background.fragmentShader,
  						side: FrontSide,
  						depthTest: false,
  						depthWrite: false,
  						fog: false,
  						allowOverride: false
  					} )
  				);

  				planeMesh.geometry.deleteAttribute( 'normal' );

  				// add "map" material property so the renderer can evaluate it like for built-in materials
  				Object.defineProperty( planeMesh.material, 'map', {

  					get: function () {

  						return this.uniforms.t2D.value;

  					}

  				} );

  				objects.update( planeMesh );

  			}

  			planeMesh.material.uniforms.t2D.value = background;
  			planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
  			planeMesh.material.toneMapped = ColorManagement.getTransfer( background.colorSpace ) !== SRGBTransfer;

  			if ( background.matrixAutoUpdate === true ) {

  				background.updateMatrix();

  			}

  			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

  			if ( currentBackground !== background ||
  				currentBackgroundVersion !== background.version ||
  				currentTonemapping !== renderer.toneMapping ) {

  				planeMesh.material.needsUpdate = true;

  				currentBackground = background;
  				currentBackgroundVersion = background.version;
  				currentTonemapping = renderer.toneMapping;

  			}

  			planeMesh.layers.enableAll();

  			// push to the pre-sorted opaque render list
  			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

  		}

  	}

  	function setClear( color, alpha ) {

  		color.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );

  		state.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );

  	}

  	function dispose() {

  		if ( boxMesh !== undefined ) {

  			boxMesh.geometry.dispose();
  			boxMesh.material.dispose();

  			boxMesh = undefined;

  		}

  		if ( planeMesh !== undefined ) {

  			planeMesh.geometry.dispose();
  			planeMesh.material.dispose();

  			planeMesh = undefined;

  		}

  	}

  	return {

  		getClearColor: function () {

  			return clearColor;

  		},
  		setClearColor: function ( color, alpha = 1 ) {

  			clearColor.set( color );
  			clearAlpha = alpha;
  			setClear( clearColor, clearAlpha );

  		},
  		getClearAlpha: function () {

  			return clearAlpha;

  		},
  		setClearAlpha: function ( alpha ) {

  			clearAlpha = alpha;
  			setClear( clearColor, clearAlpha );

  		},
  		render: render,
  		addToRenderList: addToRenderList,
  		dispose: dispose

  	};

  }

  function WebGLBindingStates( gl, attributes ) {

  	const maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );

  	const bindingStates = {};

  	const defaultState = createBindingState( null );
  	let currentState = defaultState;
  	let forceUpdate = false;

  	function setup( object, material, program, geometry, index ) {

  		let updateBuffers = false;

  		const state = getBindingState( geometry, program, material );

  		if ( currentState !== state ) {

  			currentState = state;
  			bindVertexArrayObject( currentState.object );

  		}

  		updateBuffers = needsUpdate( object, geometry, program, index );

  		if ( updateBuffers ) saveCache( object, geometry, program, index );

  		if ( index !== null ) {

  			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

  		}

  		if ( updateBuffers || forceUpdate ) {

  			forceUpdate = false;

  			setupVertexAttributes( object, material, program, geometry );

  			if ( index !== null ) {

  				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

  			}

  		}

  	}

  	function createVertexArrayObject() {

  		return gl.createVertexArray();

  	}

  	function bindVertexArrayObject( vao ) {

  		return gl.bindVertexArray( vao );

  	}

  	function deleteVertexArrayObject( vao ) {

  		return gl.deleteVertexArray( vao );

  	}

  	function getBindingState( geometry, program, material ) {

  		const wireframe = ( material.wireframe === true );

  		let programMap = bindingStates[ geometry.id ];

  		if ( programMap === undefined ) {

  			programMap = {};
  			bindingStates[ geometry.id ] = programMap;

  		}

  		let stateMap = programMap[ program.id ];

  		if ( stateMap === undefined ) {

  			stateMap = {};
  			programMap[ program.id ] = stateMap;

  		}

  		let state = stateMap[ wireframe ];

  		if ( state === undefined ) {

  			state = createBindingState( createVertexArrayObject() );
  			stateMap[ wireframe ] = state;

  		}

  		return state;

  	}

  	function createBindingState( vao ) {

  		const newAttributes = [];
  		const enabledAttributes = [];
  		const attributeDivisors = [];

  		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

  			newAttributes[ i ] = 0;
  			enabledAttributes[ i ] = 0;
  			attributeDivisors[ i ] = 0;

  		}

  		return {

  			// for backward compatibility on non-VAO support browser
  			geometry: null,
  			program: null,
  			wireframe: false,

  			newAttributes: newAttributes,
  			enabledAttributes: enabledAttributes,
  			attributeDivisors: attributeDivisors,
  			object: vao,
  			attributes: {},
  			index: null

  		};

  	}

  	function needsUpdate( object, geometry, program, index ) {

  		const cachedAttributes = currentState.attributes;
  		const geometryAttributes = geometry.attributes;

  		let attributesNum = 0;

  		const programAttributes = program.getAttributes();

  		for ( const name in programAttributes ) {

  			const programAttribute = programAttributes[ name ];

  			if ( programAttribute.location >= 0 ) {

  				const cachedAttribute = cachedAttributes[ name ];
  				let geometryAttribute = geometryAttributes[ name ];

  				if ( geometryAttribute === undefined ) {

  					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
  					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

  				}

  				if ( cachedAttribute === undefined ) return true;

  				if ( cachedAttribute.attribute !== geometryAttribute ) return true;

  				if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

  				attributesNum ++;

  			}

  		}

  		if ( currentState.attributesNum !== attributesNum ) return true;

  		if ( currentState.index !== index ) return true;

  		return false;

  	}

  	function saveCache( object, geometry, program, index ) {

  		const cache = {};
  		const attributes = geometry.attributes;
  		let attributesNum = 0;

  		const programAttributes = program.getAttributes();

  		for ( const name in programAttributes ) {

  			const programAttribute = programAttributes[ name ];

  			if ( programAttribute.location >= 0 ) {

  				let attribute = attributes[ name ];

  				if ( attribute === undefined ) {

  					if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
  					if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

  				}

  				const data = {};
  				data.attribute = attribute;

  				if ( attribute && attribute.data ) {

  					data.data = attribute.data;

  				}

  				cache[ name ] = data;

  				attributesNum ++;

  			}

  		}

  		currentState.attributes = cache;
  		currentState.attributesNum = attributesNum;

  		currentState.index = index;

  	}

  	function initAttributes() {

  		const newAttributes = currentState.newAttributes;

  		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

  			newAttributes[ i ] = 0;

  		}

  	}

  	function enableAttribute( attribute ) {

  		enableAttributeAndDivisor( attribute, 0 );

  	}

  	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

  		const newAttributes = currentState.newAttributes;
  		const enabledAttributes = currentState.enabledAttributes;
  		const attributeDivisors = currentState.attributeDivisors;

  		newAttributes[ attribute ] = 1;

  		if ( enabledAttributes[ attribute ] === 0 ) {

  			gl.enableVertexAttribArray( attribute );
  			enabledAttributes[ attribute ] = 1;

  		}

  		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

  			gl.vertexAttribDivisor( attribute, meshPerAttribute );
  			attributeDivisors[ attribute ] = meshPerAttribute;

  		}

  	}

  	function disableUnusedAttributes() {

  		const newAttributes = currentState.newAttributes;
  		const enabledAttributes = currentState.enabledAttributes;

  		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

  			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

  				gl.disableVertexAttribArray( i );
  				enabledAttributes[ i ] = 0;

  			}

  		}

  	}

  	function vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {

  		if ( integer === true ) {

  			gl.vertexAttribIPointer( index, size, type, stride, offset );

  		} else {

  			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

  		}

  	}

  	function setupVertexAttributes( object, material, program, geometry ) {

  		initAttributes();

  		const geometryAttributes = geometry.attributes;

  		const programAttributes = program.getAttributes();

  		const materialDefaultAttributeValues = material.defaultAttributeValues;

  		for ( const name in programAttributes ) {

  			const programAttribute = programAttributes[ name ];

  			if ( programAttribute.location >= 0 ) {

  				let geometryAttribute = geometryAttributes[ name ];

  				if ( geometryAttribute === undefined ) {

  					if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
  					if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

  				}

  				if ( geometryAttribute !== undefined ) {

  					const normalized = geometryAttribute.normalized;
  					const size = geometryAttribute.itemSize;

  					const attribute = attributes.get( geometryAttribute );

  					// TODO Attribute may not be available on context restore

  					if ( attribute === undefined ) continue;

  					const buffer = attribute.buffer;
  					const type = attribute.type;
  					const bytesPerElement = attribute.bytesPerElement;

  					// check for integer attributes

  					const integer = ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType );

  					if ( geometryAttribute.isInterleavedBufferAttribute ) {

  						const data = geometryAttribute.data;
  						const stride = data.stride;
  						const offset = geometryAttribute.offset;

  						if ( data.isInstancedInterleavedBuffer ) {

  							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  								enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

  							}

  							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

  								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

  							}

  						} else {

  							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  								enableAttribute( programAttribute.location + i );

  							}

  						}

  						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

  						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  							vertexAttribPointer(
  								programAttribute.location + i,
  								size / programAttribute.locationSize,
  								type,
  								normalized,
  								stride * bytesPerElement,
  								( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,
  								integer
  							);

  						}

  					} else {

  						if ( geometryAttribute.isInstancedBufferAttribute ) {

  							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  								enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

  							}

  							if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

  								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

  							}

  						} else {

  							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  								enableAttribute( programAttribute.location + i );

  							}

  						}

  						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

  						for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

  							vertexAttribPointer(
  								programAttribute.location + i,
  								size / programAttribute.locationSize,
  								type,
  								normalized,
  								size * bytesPerElement,
  								( size / programAttribute.locationSize ) * i * bytesPerElement,
  								integer
  							);

  						}

  					}

  				} else if ( materialDefaultAttributeValues !== undefined ) {

  					const value = materialDefaultAttributeValues[ name ];

  					if ( value !== undefined ) {

  						switch ( value.length ) {

  							case 2:
  								gl.vertexAttrib2fv( programAttribute.location, value );
  								break;

  							case 3:
  								gl.vertexAttrib3fv( programAttribute.location, value );
  								break;

  							case 4:
  								gl.vertexAttrib4fv( programAttribute.location, value );
  								break;

  							default:
  								gl.vertexAttrib1fv( programAttribute.location, value );

  						}

  					}

  				}

  			}

  		}

  		disableUnusedAttributes();

  	}

  	function dispose() {

  		reset();

  		for ( const geometryId in bindingStates ) {

  			const programMap = bindingStates[ geometryId ];

  			for ( const programId in programMap ) {

  				const stateMap = programMap[ programId ];

  				for ( const wireframe in stateMap ) {

  					deleteVertexArrayObject( stateMap[ wireframe ].object );

  					delete stateMap[ wireframe ];

  				}

  				delete programMap[ programId ];

  			}

  			delete bindingStates[ geometryId ];

  		}

  	}

  	function releaseStatesOfGeometry( geometry ) {

  		if ( bindingStates[ geometry.id ] === undefined ) return;

  		const programMap = bindingStates[ geometry.id ];

  		for ( const programId in programMap ) {

  			const stateMap = programMap[ programId ];

  			for ( const wireframe in stateMap ) {

  				deleteVertexArrayObject( stateMap[ wireframe ].object );

  				delete stateMap[ wireframe ];

  			}

  			delete programMap[ programId ];

  		}

  		delete bindingStates[ geometry.id ];

  	}

  	function releaseStatesOfProgram( program ) {

  		for ( const geometryId in bindingStates ) {

  			const programMap = bindingStates[ geometryId ];

  			if ( programMap[ program.id ] === undefined ) continue;

  			const stateMap = programMap[ program.id ];

  			for ( const wireframe in stateMap ) {

  				deleteVertexArrayObject( stateMap[ wireframe ].object );

  				delete stateMap[ wireframe ];

  			}

  			delete programMap[ program.id ];

  		}

  	}

  	function reset() {

  		resetDefaultState();
  		forceUpdate = true;

  		if ( currentState === defaultState ) return;

  		currentState = defaultState;
  		bindVertexArrayObject( currentState.object );

  	}

  	// for backward-compatibility

  	function resetDefaultState() {

  		defaultState.geometry = null;
  		defaultState.program = null;
  		defaultState.wireframe = false;

  	}

  	return {

  		setup: setup,
  		reset: reset,
  		resetDefaultState: resetDefaultState,
  		dispose: dispose,
  		releaseStatesOfGeometry: releaseStatesOfGeometry,
  		releaseStatesOfProgram: releaseStatesOfProgram,

  		initAttributes: initAttributes,
  		enableAttribute: enableAttribute,
  		disableUnusedAttributes: disableUnusedAttributes

  	};

  }

  function WebGLBufferRenderer( gl, extensions, info ) {

  	let mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	function render( start, count ) {

  		gl.drawArrays( mode, start, count );

  		info.update( count, mode, 1 );

  	}

  	function renderInstances( start, count, primcount ) {

  		if ( primcount === 0 ) return;

  		gl.drawArraysInstanced( mode, start, count, primcount );

  		info.update( count, mode, primcount );

  	}

  	function renderMultiDraw( starts, counts, drawCount ) {

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );
  		extension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );

  		let elementCount = 0;
  		for ( let i = 0; i < drawCount; i ++ ) {

  			elementCount += counts[ i ];

  		}

  		info.update( elementCount, mode, 1 );

  	}

  	function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );

  		if ( extension === null ) {

  			for ( let i = 0; i < starts.length; i ++ ) {

  				renderInstances( starts[ i ], counts[ i ], primcount[ i ] );

  			}

  		} else {

  			extension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );

  			let elementCount = 0;
  			for ( let i = 0; i < drawCount; i ++ ) {

  				elementCount += counts[ i ] * primcount[ i ];

  			}

  			info.update( elementCount, mode, 1 );

  		}

  	}

  	//

  	this.setMode = setMode;
  	this.render = render;
  	this.renderInstances = renderInstances;
  	this.renderMultiDraw = renderMultiDraw;
  	this.renderMultiDrawInstances = renderMultiDrawInstances;

  }

  function WebGLCapabilities( gl, extensions, parameters, utils ) {

  	let maxAnisotropy;

  	function getMaxAnisotropy() {

  		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

  		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

  			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

  		} else {

  			maxAnisotropy = 0;

  		}

  		return maxAnisotropy;

  	}

  	function textureFormatReadable( textureFormat ) {

  		if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

  			return false;

  		}

  		return true;

  	}

  	function textureTypeReadable( textureType ) {

  		const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) );

  		if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)
  			textureType !== FloatType && ! halfFloatSupportedByExt ) {

  			return false;

  		}

  		return true;

  	}

  	function getMaxPrecision( precision ) {

  		if ( precision === 'highp' ) {

  			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
  				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

  				return 'highp';

  			}

  			precision = 'mediump';

  		}

  		if ( precision === 'mediump' ) {

  			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
  				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

  				return 'mediump';

  			}

  		}

  		return 'lowp';

  	}

  	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  	const maxPrecision = getMaxPrecision( precision );

  	if ( maxPrecision !== precision ) {

  		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
  		precision = maxPrecision;

  	}

  	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  	const reversedDepthBuffer = parameters.reversedDepthBuffer === true && extensions.has( 'EXT_clip_control' );

  	const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
  	const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
  	const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
  	const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

  	const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
  	const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
  	const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
  	const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

  	const vertexTextures = maxVertexTextures > 0;

  	const maxSamples = gl.getParameter( gl.MAX_SAMPLES );

  	return {

  		isWebGL2: true, // keeping this for backwards compatibility

  		getMaxAnisotropy: getMaxAnisotropy,
  		getMaxPrecision: getMaxPrecision,

  		textureFormatReadable: textureFormatReadable,
  		textureTypeReadable: textureTypeReadable,

  		precision: precision,
  		logarithmicDepthBuffer: logarithmicDepthBuffer,
  		reversedDepthBuffer: reversedDepthBuffer,

  		maxTextures: maxTextures,
  		maxVertexTextures: maxVertexTextures,
  		maxTextureSize: maxTextureSize,
  		maxCubemapSize: maxCubemapSize,

  		maxAttributes: maxAttributes,
  		maxVertexUniforms: maxVertexUniforms,
  		maxVaryings: maxVaryings,
  		maxFragmentUniforms: maxFragmentUniforms,

  		vertexTextures: vertexTextures,

  		maxSamples: maxSamples

  	};

  }

  function WebGLClipping( properties ) {

  	const scope = this;

  	let globalState = null,
  		numGlobalPlanes = 0,
  		localClippingEnabled = false,
  		renderingShadows = false;

  	const plane = new Plane(),
  		viewNormalMatrix = new Matrix3(),

  		uniform = { value: null, needsUpdate: false };

  	this.uniform = uniform;
  	this.numPlanes = 0;
  	this.numIntersection = 0;

  	this.init = function ( planes, enableLocalClipping ) {

  		const enabled =
  			planes.length !== 0 ||
  			enableLocalClipping ||
  			// enable state of previous frame - the clipping code has to
  			// run another frame in order to reset the state:
  			numGlobalPlanes !== 0 ||
  			localClippingEnabled;

  		localClippingEnabled = enableLocalClipping;

  		numGlobalPlanes = planes.length;

  		return enabled;

  	};

  	this.beginShadows = function () {

  		renderingShadows = true;
  		projectPlanes( null );

  	};

  	this.endShadows = function () {

  		renderingShadows = false;

  	};

  	this.setGlobalState = function ( planes, camera ) {

  		globalState = projectPlanes( planes, camera, 0 );

  	};

  	this.setState = function ( material, camera, useCache ) {

  		const planes = material.clippingPlanes,
  			clipIntersection = material.clipIntersection,
  			clipShadows = material.clipShadows;

  		const materialProperties = properties.get( material );

  		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

  			// there's no local clipping

  			if ( renderingShadows ) {

  				// there's no global clipping

  				projectPlanes( null );

  			} else {

  				resetGlobalState();

  			}

  		} else {

  			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
  				lGlobal = nGlobal * 4;

  			let dstArray = materialProperties.clippingState || null;

  			uniform.value = dstArray; // ensure unique state

  			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

  			for ( let i = 0; i !== lGlobal; ++ i ) {

  				dstArray[ i ] = globalState[ i ];

  			}

  			materialProperties.clippingState = dstArray;
  			this.numIntersection = clipIntersection ? this.numPlanes : 0;
  			this.numPlanes += nGlobal;

  		}


  	};

  	function resetGlobalState() {

  		if ( uniform.value !== globalState ) {

  			uniform.value = globalState;
  			uniform.needsUpdate = numGlobalPlanes > 0;

  		}

  		scope.numPlanes = numGlobalPlanes;
  		scope.numIntersection = 0;

  	}

  	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

  		const nPlanes = planes !== null ? planes.length : 0;
  		let dstArray = null;

  		if ( nPlanes !== 0 ) {

  			dstArray = uniform.value;

  			if ( skipTransform !== true || dstArray === null ) {

  				const flatSize = dstOffset + nPlanes * 4,
  					viewMatrix = camera.matrixWorldInverse;

  				viewNormalMatrix.getNormalMatrix( viewMatrix );

  				if ( dstArray === null || dstArray.length < flatSize ) {

  					dstArray = new Float32Array( flatSize );

  				}

  				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

  					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

  					plane.normal.toArray( dstArray, i4 );
  					dstArray[ i4 + 3 ] = plane.constant;

  				}

  			}

  			uniform.value = dstArray;
  			uniform.needsUpdate = true;

  		}

  		scope.numPlanes = nPlanes;
  		scope.numIntersection = 0;

  		return dstArray;

  	}

  }

  function WebGLCubeMaps( renderer ) {

  	let cubemaps = new WeakMap();

  	function mapTextureMapping( texture, mapping ) {

  		if ( mapping === EquirectangularReflectionMapping ) {

  			texture.mapping = CubeReflectionMapping;

  		} else if ( mapping === EquirectangularRefractionMapping ) {

  			texture.mapping = CubeRefractionMapping;

  		}

  		return texture;

  	}

  	function get( texture ) {

  		if ( texture && texture.isTexture ) {

  			const mapping = texture.mapping;

  			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

  				if ( cubemaps.has( texture ) ) {

  					const cubemap = cubemaps.get( texture ).texture;
  					return mapTextureMapping( cubemap, texture.mapping );

  				} else {

  					const image = texture.image;

  					if ( image && image.height > 0 ) {

  						const renderTarget = new WebGLCubeRenderTarget( image.height );
  						renderTarget.fromEquirectangularTexture( renderer, texture );
  						cubemaps.set( texture, renderTarget );

  						texture.addEventListener( 'dispose', onTextureDispose );

  						return mapTextureMapping( renderTarget.texture, texture.mapping );

  					} else {

  						// image not yet ready. try the conversion next frame

  						return null;

  					}

  				}

  			}

  		}

  		return texture;

  	}

  	function onTextureDispose( event ) {

  		const texture = event.target;

  		texture.removeEventListener( 'dispose', onTextureDispose );

  		const cubemap = cubemaps.get( texture );

  		if ( cubemap !== undefined ) {

  			cubemaps.delete( texture );
  			cubemap.dispose();

  		}

  	}

  	function dispose() {

  		cubemaps = new WeakMap();

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  const LOD_MIN = 4;

  // The standard deviations (radians) associated with the extra mips. These are
  // chosen to approximate a Trowbridge-Reitz distribution function times the
  // geometric shadowing function. These sigma values squared must match the
  // variance #defines in cube_uv_reflection_fragment.glsl.js.
  const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

  // The maximum length of the blur for loop. Smaller sigmas will use fewer
  // samples and exit early, but not recompile the shader.
  const MAX_SAMPLES = 20;

  const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
  const _clearColor = /*@__PURE__*/ new Color();
  let _oldTarget = null;
  let _oldActiveCubeFace = 0;
  let _oldActiveMipmapLevel = 0;
  let _oldXrEnabled = false;

  // Golden Ratio
  const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
  const INV_PHI = 1 / PHI;

  // Vertices of a dodecahedron (except the opposites, which represent the
  // same axis), used as axis directions evenly spread on a sphere.
  const _axisDirections = [
  	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),
  	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
  	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
  	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
  	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
  	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
  	/*@__PURE__*/ new Vector3( -1, 1, -1 ),
  	/*@__PURE__*/ new Vector3( 1, 1, -1 ),
  	/*@__PURE__*/ new Vector3( -1, 1, 1 ),
  	/*@__PURE__*/ new Vector3( 1, 1, 1 ) ];

  const _origin = /*@__PURE__*/ new Vector3();

  /**
   * This class generates a Prefiltered, Mipmapped Radiance Environment Map
   * (PMREM) from a cubeMap environment texture. This allows different levels of
   * blur to be quickly accessed based on material roughness. It is packed into a
   * special CubeUV format that allows us to perform custom interpolation so that
   * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
   * chain, it only goes down to the LOD_MIN level (above), and then creates extra
   * even more filtered 'mips' at the same LOD_MIN resolution, associated with
   * higher roughness levels. In this way we maintain resolution to smoothly
   * interpolate diffuse lighting while limiting sampling computation.
   *
   * Paper: Fast, Accurate Image-Based Lighting:
   * {@link https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view}
  */
  class PMREMGenerator {

  	/**
  	 * Constructs a new PMREM generator.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 */
  	constructor( renderer ) {

  		this._renderer = renderer;
  		this._pingPongRenderTarget = null;

  		this._lodMax = 0;
  		this._cubeSize = 0;
  		this._lodPlanes = [];
  		this._sizeLods = [];
  		this._sigmas = [];

  		this._blurMaterial = null;
  		this._cubemapMaterial = null;
  		this._equirectMaterial = null;

  		this._compileMaterial( this._blurMaterial );

  	}

  	/**
  	 * Generates a PMREM from a supplied Scene, which can be faster than using an
  	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
  	 * in radians to be applied to the scene before PMREM generation. Optional near
  	 * and far planes ensure the scene is rendered in its entirety.
  	 *
  	 * @param {Scene} scene - The scene to be captured.
  	 * @param {number} [sigma=0] - The blur radius in radians.
  	 * @param {number} [near=0.1] - The near plane distance.
  	 * @param {number} [far=100] - The far plane distance.
  	 * @param {Object} [options={}] - The configuration options.
  	 * @param {number} [options.size=256] - The texture size of the PMREM.
  	 * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
  	 * @return {WebGLRenderTarget} The resulting PMREM.
  	 */
  	fromScene( scene, sigma = 0, near = 0.1, far = 100, options = {} ) {

  		const {
  			size = 256,
  			position = _origin,
  		} = options;

  		_oldTarget = this._renderer.getRenderTarget();
  		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
  		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
  		_oldXrEnabled = this._renderer.xr.enabled;

  		this._renderer.xr.enabled = false;

  		this._setSize( size );

  		const cubeUVRenderTarget = this._allocateTargets();
  		cubeUVRenderTarget.depthBuffer = true;

  		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position );

  		if ( sigma > 0 ) {

  			this._blur( cubeUVRenderTarget, 0, 0, sigma );

  		}

  		this._applyPMREM( cubeUVRenderTarget );
  		this._cleanup( cubeUVRenderTarget );

  		return cubeUVRenderTarget;

  	}

  	/**
  	 * Generates a PMREM from an equirectangular texture, which can be either LDR
  	 * or HDR. The ideal input image size is 1k (1024 x 512),
  	 * as this matches best with the 256 x 256 cubemap output.
  	 *
  	 * @param {Texture} equirectangular - The equirectangular texture to be converted.
  	 * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
  	 * @return {WebGLRenderTarget} The resulting PMREM.
  	 */
  	fromEquirectangular( equirectangular, renderTarget = null ) {

  		return this._fromTexture( equirectangular, renderTarget );

  	}

  	/**
  	 * Generates a PMREM from an cubemap texture, which can be either LDR
  	 * or HDR. The ideal input cube size is 256 x 256,
  	 * as this matches best with the 256 x 256 cubemap output.
  	 *
  	 * @param {Texture} cubemap - The cubemap texture to be converted.
  	 * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
  	 * @return {WebGLRenderTarget} The resulting PMREM.
  	 */
  	fromCubemap( cubemap, renderTarget = null ) {

  		return this._fromTexture( cubemap, renderTarget );

  	}

  	/**
  	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */
  	compileCubemapShader() {

  		if ( this._cubemapMaterial === null ) {

  			this._cubemapMaterial = _getCubemapMaterial();
  			this._compileMaterial( this._cubemapMaterial );

  		}

  	}

  	/**
  	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
  	 * your texture's network fetch for increased concurrency.
  	 */
  	compileEquirectangularShader() {

  		if ( this._equirectMaterial === null ) {

  			this._equirectMaterial = _getEquirectMaterial();
  			this._compileMaterial( this._equirectMaterial );

  		}

  	}

  	/**
  	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
  	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
  	 * one of them will cause any others to also become unusable.
  	 */
  	dispose() {

  		this._dispose();

  		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
  		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

  	}

  	// private interface

  	_setSize( cubeSize ) {

  		this._lodMax = Math.floor( Math.log2( cubeSize ) );
  		this._cubeSize = Math.pow( 2, this._lodMax );

  	}

  	_dispose() {

  		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

  		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

  		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

  			this._lodPlanes[ i ].dispose();

  		}

  	}

  	_cleanup( outputTarget ) {

  		this._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );
  		this._renderer.xr.enabled = _oldXrEnabled;

  		outputTarget.scissorTest = false;
  		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

  	}

  	_fromTexture( texture, renderTarget ) {

  		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

  			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

  		} else { // Equirectangular

  			this._setSize( texture.image.width / 4 );

  		}

  		_oldTarget = this._renderer.getRenderTarget();
  		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
  		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
  		_oldXrEnabled = this._renderer.xr.enabled;

  		this._renderer.xr.enabled = false;

  		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
  		this._textureToCubeUV( texture, cubeUVRenderTarget );
  		this._applyPMREM( cubeUVRenderTarget );
  		this._cleanup( cubeUVRenderTarget );

  		return cubeUVRenderTarget;

  	}

  	_allocateTargets() {

  		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
  		const height = 4 * this._cubeSize;

  		const params = {
  			magFilter: LinearFilter,
  			minFilter: LinearFilter,
  			generateMipmaps: false,
  			type: HalfFloatType,
  			format: RGBAFormat,
  			colorSpace: LinearSRGBColorSpace,
  			depthBuffer: false
  		};

  		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

  		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

  			if ( this._pingPongRenderTarget !== null ) {

  				this._dispose();

  			}

  			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

  			const { _lodMax } = this;
  			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

  			this._blurMaterial = _getBlurShader( _lodMax, width, height );

  		}

  		return cubeUVRenderTarget;

  	}

  	_compileMaterial( material ) {

  		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
  		this._renderer.compile( tmpMesh, _flatCamera );

  	}

  	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position ) {

  		const fov = 90;
  		const aspect = 1;
  		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
  		const upSign = [ 1, -1, 1, 1, 1, 1 ];
  		const forwardSign = [ 1, 1, 1, -1, -1, -1 ];
  		const renderer = this._renderer;

  		const originalAutoClear = renderer.autoClear;
  		const toneMapping = renderer.toneMapping;
  		renderer.getClearColor( _clearColor );

  		renderer.toneMapping = NoToneMapping;
  		renderer.autoClear = false;

  		// https://github.com/mrdoob/three.js/issues/31413#issuecomment-3095966812
  		const reversedDepthBuffer = renderer.state.buffers.depth.getReversed();

  		if ( reversedDepthBuffer ) {

  			renderer.setRenderTarget( cubeUVRenderTarget );
  			renderer.clearDepth();
  			renderer.setRenderTarget( null );

  		}

  		const backgroundMaterial = new MeshBasicMaterial( {
  			name: 'PMREM.Background',
  			side: BackSide,
  			depthWrite: false,
  			depthTest: false,
  		} );

  		const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

  		let useSolidColor = false;
  		const background = scene.background;

  		if ( background ) {

  			if ( background.isColor ) {

  				backgroundMaterial.color.copy( background );
  				scene.background = null;
  				useSolidColor = true;

  			}

  		} else {

  			backgroundMaterial.color.copy( _clearColor );
  			useSolidColor = true;

  		}

  		for ( let i = 0; i < 6; i ++ ) {

  			const col = i % 3;

  			if ( col === 0 ) {

  				cubeCamera.up.set( 0, upSign[ i ], 0 );
  				cubeCamera.position.set( position.x, position.y, position.z );
  				cubeCamera.lookAt( position.x + forwardSign[ i ], position.y, position.z );

  			} else if ( col === 1 ) {

  				cubeCamera.up.set( 0, 0, upSign[ i ] );
  				cubeCamera.position.set( position.x, position.y, position.z );
  				cubeCamera.lookAt( position.x, position.y + forwardSign[ i ], position.z );


  			} else {

  				cubeCamera.up.set( 0, upSign[ i ], 0 );
  				cubeCamera.position.set( position.x, position.y, position.z );
  				cubeCamera.lookAt( position.x, position.y, position.z + forwardSign[ i ] );

  			}

  			const size = this._cubeSize;

  			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

  			renderer.setRenderTarget( cubeUVRenderTarget );

  			if ( useSolidColor ) {

  				renderer.render( backgroundBox, cubeCamera );

  			}

  			renderer.render( scene, cubeCamera );

  		}

  		backgroundBox.geometry.dispose();
  		backgroundBox.material.dispose();

  		renderer.toneMapping = toneMapping;
  		renderer.autoClear = originalAutoClear;
  		scene.background = background;

  	}

  	_textureToCubeUV( texture, cubeUVRenderTarget ) {

  		const renderer = this._renderer;

  		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

  		if ( isCubeTexture ) {

  			if ( this._cubemapMaterial === null ) {

  				this._cubemapMaterial = _getCubemapMaterial();

  			}

  			this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? -1 : 1;

  		} else {

  			if ( this._equirectMaterial === null ) {

  				this._equirectMaterial = _getEquirectMaterial();

  			}

  		}

  		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
  		const mesh = new Mesh( this._lodPlanes[ 0 ], material );

  		const uniforms = material.uniforms;

  		uniforms[ 'envMap' ].value = texture;

  		const size = this._cubeSize;

  		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

  		renderer.setRenderTarget( cubeUVRenderTarget );
  		renderer.render( mesh, _flatCamera );

  	}

  	_applyPMREM( cubeUVRenderTarget ) {

  		const renderer = this._renderer;
  		const autoClear = renderer.autoClear;
  		renderer.autoClear = false;
  		const n = this._lodPlanes.length;

  		for ( let i = 1; i < n; i ++ ) {

  			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

  			const poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];

  			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

  		}

  		renderer.autoClear = autoClear;

  	}

  	/**
  	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
  	 * vertically and horizontally, but this breaks down on a cube. Here we apply
  	 * the blur latitudinally (around the poles), and then longitudinally (towards
  	 * the poles) to approximate the orthogonally-separable blur. It is least
  	 * accurate at the poles, but still does a decent job.
  	 *
  	 * @private
  	 * @param {WebGLRenderTarget} cubeUVRenderTarget
  	 * @param {number} lodIn
  	 * @param {number} lodOut
  	 * @param {number} sigma
  	 * @param {Vector3} [poleAxis]
  	 */
  	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

  		const pingPongRenderTarget = this._pingPongRenderTarget;

  		this._halfBlur(
  			cubeUVRenderTarget,
  			pingPongRenderTarget,
  			lodIn,
  			lodOut,
  			sigma,
  			'latitudinal',
  			poleAxis );

  		this._halfBlur(
  			pingPongRenderTarget,
  			cubeUVRenderTarget,
  			lodOut,
  			lodOut,
  			sigma,
  			'longitudinal',
  			poleAxis );

  	}

  	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

  		const renderer = this._renderer;
  		const blurMaterial = this._blurMaterial;

  		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

  			console.error(
  				'blur direction must be either latitudinal or longitudinal!' );

  		}

  		// Number of standard deviations at which to cut off the discrete approximation.
  		const STANDARD_DEVIATIONS = 3;

  		const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
  		const blurUniforms = blurMaterial.uniforms;

  		const pixels = this._sizeLods[ lodIn ] - 1;
  		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
  		const sigmaPixels = sigmaRadians / radiansPerPixel;
  		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

  		if ( samples > MAX_SAMPLES ) {

  			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

  		}

  		const weights = [];
  		let sum = 0;

  		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

  			const x = i / sigmaPixels;
  			const weight = Math.exp( - x * x / 2 );
  			weights.push( weight );

  			if ( i === 0 ) {

  				sum += weight;

  			} else if ( i < samples ) {

  				sum += 2 * weight;

  			}

  		}

  		for ( let i = 0; i < weights.length; i ++ ) {

  			weights[ i ] = weights[ i ] / sum;

  		}

  		blurUniforms[ 'envMap' ].value = targetIn.texture;
  		blurUniforms[ 'samples' ].value = samples;
  		blurUniforms[ 'weights' ].value = weights;
  		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

  		if ( poleAxis ) {

  			blurUniforms[ 'poleAxis' ].value = poleAxis;

  		}

  		const { _lodMax } = this;
  		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
  		blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

  		const outputSize = this._sizeLods[ lodOut ];
  		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
  		const y = 4 * ( this._cubeSize - outputSize );

  		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
  		renderer.setRenderTarget( targetOut );
  		renderer.render( blurMesh, _flatCamera );

  	}

  }



  function _createPlanes( lodMax ) {

  	const lodPlanes = [];
  	const sizeLods = [];
  	const sigmas = [];

  	let lod = lodMax;

  	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

  	for ( let i = 0; i < totalLods; i ++ ) {

  		const sizeLod = Math.pow( 2, lod );
  		sizeLods.push( sizeLod );
  		let sigma = 1.0 / sizeLod;

  		if ( i > lodMax - LOD_MIN ) {

  			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

  		} else if ( i === 0 ) {

  			sigma = 0;

  		}

  		sigmas.push( sigma );

  		const texelSize = 1.0 / ( sizeLod - 2 );
  		const min = - texelSize;
  		const max = 1 + texelSize;
  		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

  		const cubeFaces = 6;
  		const vertices = 6;
  		const positionSize = 3;
  		const uvSize = 2;
  		const faceIndexSize = 1;

  		const position = new Float32Array( positionSize * vertices * cubeFaces );
  		const uv = new Float32Array( uvSize * vertices * cubeFaces );
  		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

  		for ( let face = 0; face < cubeFaces; face ++ ) {

  			const x = ( face % 3 ) * 2 / 3 - 1;
  			const y = face > 2 ? 0 : -1;
  			const coordinates = [
  				x, y, 0,
  				x + 2 / 3, y, 0,
  				x + 2 / 3, y + 1, 0,
  				x, y, 0,
  				x + 2 / 3, y + 1, 0,
  				x, y + 1, 0
  			];
  			position.set( coordinates, positionSize * vertices * face );
  			uv.set( uv1, uvSize * vertices * face );
  			const fill = [ face, face, face, face, face, face ];
  			faceIndex.set( fill, faceIndexSize * vertices * face );

  		}

  		const planes = new BufferGeometry();
  		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
  		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
  		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
  		lodPlanes.push( planes );

  		if ( lod > LOD_MIN ) {

  			lod --;

  		}

  	}

  	return { lodPlanes, sizeLods, sigmas };

  }

  function _createRenderTarget( width, height, params ) {

  	const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
  	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
  	cubeUVRenderTarget.scissorTest = true;
  	return cubeUVRenderTarget;

  }

  function _setViewport( target, x, y, width, height ) {

  	target.viewport.set( x, y, width, height );
  	target.scissor.set( x, y, width, height );

  }

  function _getBlurShader( lodMax, width, height ) {

  	const weights = new Float32Array( MAX_SAMPLES );
  	const poleAxis = new Vector3( 0, 1, 0 );
  	const shaderMaterial = new ShaderMaterial( {

  		name: 'SphericalGaussianBlur',

  		defines: {
  			'n': MAX_SAMPLES,
  			'CUBEUV_TEXEL_WIDTH': 1.0 / width,
  			'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
  			'CUBEUV_MAX_MIP': `${lodMax}.0`,
  		},

  		uniforms: {
  			'envMap': { value: null },
  			'samples': { value: 1 },
  			'weights': { value: weights },
  			'latitudinal': { value: false },
  			'dTheta': { value: 0 },
  			'mipInt': { value: 0 },
  			'poleAxis': { value: poleAxis }
  		},

  		vertexShader: _getCommonVertexShader(),

  		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

  		blending: NoBlending,
  		depthTest: false,
  		depthWrite: false

  	} );

  	return shaderMaterial;

  }

  function _getEquirectMaterial() {

  	return new ShaderMaterial( {

  		name: 'EquirectangularToCubeUV',

  		uniforms: {
  			'envMap': { value: null }
  		},

  		vertexShader: _getCommonVertexShader(),

  		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

  		blending: NoBlending,
  		depthTest: false,
  		depthWrite: false

  	} );

  }

  function _getCubemapMaterial() {

  	return new ShaderMaterial( {

  		name: 'CubemapToCubeUV',

  		uniforms: {
  			'envMap': { value: null },
  			'flipEnvMap': { value: -1 }
  		},

  		vertexShader: _getCommonVertexShader(),

  		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

  		blending: NoBlending,
  		depthTest: false,
  		depthWrite: false

  	} );

  }

  function _getCommonVertexShader() {

  	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

  }

  function WebGLCubeUVMaps( renderer ) {

  	let cubeUVmaps = new WeakMap();

  	let pmremGenerator = null;

  	function get( texture ) {

  		if ( texture && texture.isTexture ) {

  			const mapping = texture.mapping;

  			const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
  			const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

  			// equirect/cube map to cubeUV conversion

  			if ( isEquirectMap || isCubeMap ) {

  				let renderTarget = cubeUVmaps.get( texture );

  				const currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;

  				if ( texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion ) {

  					if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

  					renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
  					renderTarget.texture.pmremVersion = texture.pmremVersion;

  					cubeUVmaps.set( texture, renderTarget );

  					return renderTarget.texture;

  				} else {

  					if ( renderTarget !== undefined ) {

  						return renderTarget.texture;

  					} else {

  						const image = texture.image;

  						if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

  							if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

  							renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
  							renderTarget.texture.pmremVersion = texture.pmremVersion;

  							cubeUVmaps.set( texture, renderTarget );

  							texture.addEventListener( 'dispose', onTextureDispose );

  							return renderTarget.texture;

  						} else {

  							// image not yet ready. try the conversion next frame

  							return null;

  						}

  					}

  				}

  			}

  		}

  		return texture;

  	}

  	function isCubeTextureComplete( image ) {

  		let count = 0;
  		const length = 6;

  		for ( let i = 0; i < length; i ++ ) {

  			if ( image[ i ] !== undefined ) count ++;

  		}

  		return count === length;


  	}

  	function onTextureDispose( event ) {

  		const texture = event.target;

  		texture.removeEventListener( 'dispose', onTextureDispose );

  		const cubemapUV = cubeUVmaps.get( texture );

  		if ( cubemapUV !== undefined ) {

  			cubeUVmaps.delete( texture );
  			cubemapUV.dispose();

  		}

  	}

  	function dispose() {

  		cubeUVmaps = new WeakMap();

  		if ( pmremGenerator !== null ) {

  			pmremGenerator.dispose();
  			pmremGenerator = null;

  		}

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  function WebGLExtensions( gl ) {

  	const extensions = {};

  	function getExtension( name ) {

  		if ( extensions[ name ] !== undefined ) {

  			return extensions[ name ];

  		}

  		let extension;

  		switch ( name ) {

  			case 'WEBGL_depth_texture':
  				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
  				break;

  			case 'EXT_texture_filter_anisotropic':
  				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
  				break;

  			case 'WEBGL_compressed_texture_s3tc':
  				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
  				break;

  			case 'WEBGL_compressed_texture_pvrtc':
  				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
  				break;

  			default:
  				extension = gl.getExtension( name );

  		}

  		extensions[ name ] = extension;

  		return extension;

  	}

  	return {

  		has: function ( name ) {

  			return getExtension( name ) !== null;

  		},

  		init: function () {

  			getExtension( 'EXT_color_buffer_float' );
  			getExtension( 'WEBGL_clip_cull_distance' );
  			getExtension( 'OES_texture_float_linear' );
  			getExtension( 'EXT_color_buffer_half_float' );
  			getExtension( 'WEBGL_multisampled_render_to_texture' );
  			getExtension( 'WEBGL_render_shared_exponent' );

  		},

  		get: function ( name ) {

  			const extension = getExtension( name );

  			if ( extension === null ) {

  				warnOnce( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

  			}

  			return extension;

  		}

  	};

  }

  function WebGLGeometries( gl, attributes, info, bindingStates ) {

  	const geometries = {};
  	const wireframeAttributes = new WeakMap();

  	function onGeometryDispose( event ) {

  		const geometry = event.target;

  		if ( geometry.index !== null ) {

  			attributes.remove( geometry.index );

  		}

  		for ( const name in geometry.attributes ) {

  			attributes.remove( geometry.attributes[ name ] );

  		}

  		geometry.removeEventListener( 'dispose', onGeometryDispose );

  		delete geometries[ geometry.id ];

  		const attribute = wireframeAttributes.get( geometry );

  		if ( attribute ) {

  			attributes.remove( attribute );
  			wireframeAttributes.delete( geometry );

  		}

  		bindingStates.releaseStatesOfGeometry( geometry );

  		if ( geometry.isInstancedBufferGeometry === true ) {

  			delete geometry._maxInstanceCount;

  		}

  		//

  		info.memory.geometries --;

  	}

  	function get( object, geometry ) {

  		if ( geometries[ geometry.id ] === true ) return geometry;

  		geometry.addEventListener( 'dispose', onGeometryDispose );

  		geometries[ geometry.id ] = true;

  		info.memory.geometries ++;

  		return geometry;

  	}

  	function update( geometry ) {

  		const geometryAttributes = geometry.attributes;

  		// Updating index buffer in VAO now. See WebGLBindingStates.

  		for ( const name in geometryAttributes ) {

  			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

  		}

  	}

  	function updateWireframeAttribute( geometry ) {

  		const indices = [];

  		const geometryIndex = geometry.index;
  		const geometryPosition = geometry.attributes.position;
  		let version = 0;

  		if ( geometryIndex !== null ) {

  			const array = geometryIndex.array;
  			version = geometryIndex.version;

  			for ( let i = 0, l = array.length; i < l; i += 3 ) {

  				const a = array[ i + 0 ];
  				const b = array[ i + 1 ];
  				const c = array[ i + 2 ];

  				indices.push( a, b, b, c, c, a );

  			}

  		} else if ( geometryPosition !== undefined ) {

  			const array = geometryPosition.array;
  			version = geometryPosition.version;

  			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

  				const a = i + 0;
  				const b = i + 1;
  				const c = i + 2;

  				indices.push( a, b, b, c, c, a );

  			}

  		} else {

  			return;

  		}

  		const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
  		attribute.version = version;

  		// Updating index buffer in VAO now. See WebGLBindingStates

  		//

  		const previousAttribute = wireframeAttributes.get( geometry );

  		if ( previousAttribute ) attributes.remove( previousAttribute );

  		//

  		wireframeAttributes.set( geometry, attribute );

  	}

  	function getWireframeAttribute( geometry ) {

  		const currentAttribute = wireframeAttributes.get( geometry );

  		if ( currentAttribute ) {

  			const geometryIndex = geometry.index;

  			if ( geometryIndex !== null ) {

  				// if the attribute is obsolete, create a new one

  				if ( currentAttribute.version < geometryIndex.version ) {

  					updateWireframeAttribute( geometry );

  				}

  			}

  		} else {

  			updateWireframeAttribute( geometry );

  		}

  		return wireframeAttributes.get( geometry );

  	}

  	return {

  		get: get,
  		update: update,

  		getWireframeAttribute: getWireframeAttribute

  	};

  }

  function WebGLIndexedBufferRenderer( gl, extensions, info ) {

  	let mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	let type, bytesPerElement;

  	function setIndex( value ) {

  		type = value.type;
  		bytesPerElement = value.bytesPerElement;

  	}

  	function render( start, count ) {

  		gl.drawElements( mode, count, type, start * bytesPerElement );

  		info.update( count, mode, 1 );

  	}

  	function renderInstances( start, count, primcount ) {

  		if ( primcount === 0 ) return;

  		gl.drawElementsInstanced( mode, count, type, start * bytesPerElement, primcount );

  		info.update( count, mode, primcount );

  	}

  	function renderMultiDraw( starts, counts, drawCount ) {

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );
  		extension.multiDrawElementsWEBGL( mode, counts, 0, type, starts, 0, drawCount );

  		let elementCount = 0;
  		for ( let i = 0; i < drawCount; i ++ ) {

  			elementCount += counts[ i ];

  		}

  		info.update( elementCount, mode, 1 );


  	}

  	function renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

  		if ( drawCount === 0 ) return;

  		const extension = extensions.get( 'WEBGL_multi_draw' );

  		if ( extension === null ) {

  			for ( let i = 0; i < starts.length; i ++ ) {

  				renderInstances( starts[ i ] / bytesPerElement, counts[ i ], primcount[ i ] );

  			}

  		} else {

  			extension.multiDrawElementsInstancedWEBGL( mode, counts, 0, type, starts, 0, primcount, 0, drawCount );

  			let elementCount = 0;
  			for ( let i = 0; i < drawCount; i ++ ) {

  				elementCount += counts[ i ] * primcount[ i ];

  			}

  			info.update( elementCount, mode, 1 );

  		}

  	}

  	//

  	this.setMode = setMode;
  	this.setIndex = setIndex;
  	this.render = render;
  	this.renderInstances = renderInstances;
  	this.renderMultiDraw = renderMultiDraw;
  	this.renderMultiDrawInstances = renderMultiDrawInstances;

  }

  function WebGLInfo( gl ) {

  	const memory = {
  		geometries: 0,
  		textures: 0
  	};

  	const render = {
  		frame: 0,
  		calls: 0,
  		triangles: 0,
  		points: 0,
  		lines: 0
  	};

  	function update( count, mode, instanceCount ) {

  		render.calls ++;

  		switch ( mode ) {

  			case gl.TRIANGLES:
  				render.triangles += instanceCount * ( count / 3 );
  				break;

  			case gl.LINES:
  				render.lines += instanceCount * ( count / 2 );
  				break;

  			case gl.LINE_STRIP:
  				render.lines += instanceCount * ( count - 1 );
  				break;

  			case gl.LINE_LOOP:
  				render.lines += instanceCount * count;
  				break;

  			case gl.POINTS:
  				render.points += instanceCount * count;
  				break;

  			default:
  				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
  				break;

  		}

  	}

  	function reset() {

  		render.calls = 0;
  		render.triangles = 0;
  		render.points = 0;
  		render.lines = 0;

  	}

  	return {
  		memory: memory,
  		render: render,
  		programs: null,
  		autoReset: true,
  		reset: reset,
  		update: update
  	};

  }

  function WebGLMorphtargets( gl, capabilities, textures ) {

  	const morphTextures = new WeakMap();
  	const morph = new Vector4();

  	function update( object, geometry, program ) {

  		const objectInfluences = object.morphTargetInfluences;

  		// the following encodes morph targets into an array of data textures. Each layer represents a single morph target.

  		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

  		let entry = morphTextures.get( geometry );

  		if ( entry === undefined || entry.count !== morphTargetsCount ) {

  			if ( entry !== undefined ) entry.texture.dispose();

  			const hasMorphPosition = geometry.morphAttributes.position !== undefined;
  			const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
  			const hasMorphColors = geometry.morphAttributes.color !== undefined;

  			const morphTargets = geometry.morphAttributes.position || [];
  			const morphNormals = geometry.morphAttributes.normal || [];
  			const morphColors = geometry.morphAttributes.color || [];

  			let vertexDataCount = 0;

  			if ( hasMorphPosition === true ) vertexDataCount = 1;
  			if ( hasMorphNormals === true ) vertexDataCount = 2;
  			if ( hasMorphColors === true ) vertexDataCount = 3;

  			let width = geometry.attributes.position.count * vertexDataCount;
  			let height = 1;

  			if ( width > capabilities.maxTextureSize ) {

  				height = Math.ceil( width / capabilities.maxTextureSize );
  				width = capabilities.maxTextureSize;

  			}

  			const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

  			const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
  			texture.type = FloatType;
  			texture.needsUpdate = true;

  			// fill buffer

  			const vertexDataStride = vertexDataCount * 4;

  			for ( let i = 0; i < morphTargetsCount; i ++ ) {

  				const morphTarget = morphTargets[ i ];
  				const morphNormal = morphNormals[ i ];
  				const morphColor = morphColors[ i ];

  				const offset = width * height * 4 * i;

  				for ( let j = 0; j < morphTarget.count; j ++ ) {

  					const stride = j * vertexDataStride;

  					if ( hasMorphPosition === true ) {

  						morph.fromBufferAttribute( morphTarget, j );

  						buffer[ offset + stride + 0 ] = morph.x;
  						buffer[ offset + stride + 1 ] = morph.y;
  						buffer[ offset + stride + 2 ] = morph.z;
  						buffer[ offset + stride + 3 ] = 0;

  					}

  					if ( hasMorphNormals === true ) {

  						morph.fromBufferAttribute( morphNormal, j );

  						buffer[ offset + stride + 4 ] = morph.x;
  						buffer[ offset + stride + 5 ] = morph.y;
  						buffer[ offset + stride + 6 ] = morph.z;
  						buffer[ offset + stride + 7 ] = 0;

  					}

  					if ( hasMorphColors === true ) {

  						morph.fromBufferAttribute( morphColor, j );

  						buffer[ offset + stride + 8 ] = morph.x;
  						buffer[ offset + stride + 9 ] = morph.y;
  						buffer[ offset + stride + 10 ] = morph.z;
  						buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

  					}

  				}

  			}

  			entry = {
  				count: morphTargetsCount,
  				texture: texture,
  				size: new Vector2( width, height )
  			};

  			morphTextures.set( geometry, entry );

  			function disposeTexture() {

  				texture.dispose();

  				morphTextures.delete( geometry );

  				geometry.removeEventListener( 'dispose', disposeTexture );

  			}

  			geometry.addEventListener( 'dispose', disposeTexture );

  		}

  		//
  		if ( object.isInstancedMesh === true && object.morphTexture !== null ) {

  			program.getUniforms().setValue( gl, 'morphTexture', object.morphTexture, textures );

  		} else {

  			let morphInfluencesSum = 0;

  			for ( let i = 0; i < objectInfluences.length; i ++ ) {

  				morphInfluencesSum += objectInfluences[ i ];

  			}

  			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;


  			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
  			program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

  		}

  		program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
  		program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );

  	}

  	return {

  		update: update

  	};

  }

  function WebGLObjects( gl, geometries, attributes, info ) {

  	let updateMap = new WeakMap();

  	function update( object ) {

  		const frame = info.render.frame;

  		const geometry = object.geometry;
  		const buffergeometry = geometries.get( object, geometry );

  		// Update once per frame

  		if ( updateMap.get( buffergeometry ) !== frame ) {

  			geometries.update( buffergeometry );

  			updateMap.set( buffergeometry, frame );

  		}

  		if ( object.isInstancedMesh ) {

  			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

  				object.addEventListener( 'dispose', onInstancedMeshDispose );

  			}

  			if ( updateMap.get( object ) !== frame ) {

  				attributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );

  				if ( object.instanceColor !== null ) {

  					attributes.update( object.instanceColor, gl.ARRAY_BUFFER );

  				}

  				updateMap.set( object, frame );

  			}

  		}

  		if ( object.isSkinnedMesh ) {

  			const skeleton = object.skeleton;

  			if ( updateMap.get( skeleton ) !== frame ) {

  				skeleton.update();

  				updateMap.set( skeleton, frame );

  			}

  		}

  		return buffergeometry;

  	}

  	function dispose() {

  		updateMap = new WeakMap();

  	}

  	function onInstancedMeshDispose( event ) {

  		const instancedMesh = event.target;

  		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

  		attributes.remove( instancedMesh.instanceMatrix );

  		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

  	}

  	return {

  		update: update,
  		dispose: dispose

  	};

  }

  /**
   * Uniforms of a program.
   * Those form a tree structure with a special top-level container for the root,
   * which you get by calling 'new WebGLUniforms( gl, program )'.
   *
   *
   * Properties of inner nodes including the top-level container:
   *
   * .seq - array of nested uniforms
   * .map - nested uniforms by name
   *
   *
   * Methods of all nodes except the top-level container:
   *
   * .setValue( gl, value, [textures] )
   *
   * 		uploads a uniform value(s)
   *  	the 'textures' parameter is needed for sampler uniforms
   *
   *
   * Static methods of the top-level container (textures factorizations):
   *
   * .upload( gl, seq, values, textures )
   *
   * 		sets uniforms in 'seq' to 'values[id].value'
   *
   * .seqWithValue( seq, values ) : filteredSeq
   *
   * 		filters 'seq' entries with corresponding entry in values
   *
   *
   * Methods of the top-level container (textures factorizations):
   *
   * .setValue( gl, name, value, textures )
   *
   * 		sets uniform with  name 'name' to 'value'
   *
   * .setOptional( gl, obj, prop )
   *
   * 		like .set for an optional property of the object
   *
   */


  const emptyTexture = /*@__PURE__*/ new Texture();

  const emptyShadowTexture = /*@__PURE__*/ new DepthTexture( 1, 1 );

  const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
  const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
  const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();

  // --- Utilities ---

  // Array Caches (provide typed arrays for temporary by size)

  const arrayCacheF32 = [];
  const arrayCacheI32 = [];

  // Float32Array caches used for uploading Matrix uniforms

  const mat4array = new Float32Array( 16 );
  const mat3array = new Float32Array( 9 );
  const mat2array = new Float32Array( 4 );

  // Flattening for arrays of vectors and matrices

  function flatten( array, nBlocks, blockSize ) {

  	const firstElem = array[ 0 ];

  	if ( firstElem <= 0 || firstElem > 0 ) return array;
  	// unoptimized: ! isNaN( firstElem )
  	// see http://jacksondunstan.com/articles/983

  	const n = nBlocks * blockSize;
  	let r = arrayCacheF32[ n ];

  	if ( r === undefined ) {

  		r = new Float32Array( n );
  		arrayCacheF32[ n ] = r;

  	}

  	if ( nBlocks !== 0 ) {

  		firstElem.toArray( r, 0 );

  		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

  			offset += blockSize;
  			array[ i ].toArray( r, offset );

  		}

  	}

  	return r;

  }

  function arraysEqual( a, b ) {

  	if ( a.length !== b.length ) return false;

  	for ( let i = 0, l = a.length; i < l; i ++ ) {

  		if ( a[ i ] !== b[ i ] ) return false;

  	}

  	return true;

  }

  function copyArray( a, b ) {

  	for ( let i = 0, l = b.length; i < l; i ++ ) {

  		a[ i ] = b[ i ];

  	}

  }

  // Texture unit allocation

  function allocTexUnits( textures, n ) {

  	let r = arrayCacheI32[ n ];

  	if ( r === undefined ) {

  		r = new Int32Array( n );
  		arrayCacheI32[ n ] = r;

  	}

  	for ( let i = 0; i !== n; ++ i ) {

  		r[ i ] = textures.allocateTextureUnit();

  	}

  	return r;

  }

  // --- Setters ---

  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.

  // Single scalar

  function setValueV1f( gl, v ) {

  	const cache = this.cache;

  	if ( cache[ 0 ] === v ) return;

  	gl.uniform1f( this.addr, v );

  	cache[ 0 ] = v;

  }

  // Single float vector (from flat array or THREE.VectorN)

  function setValueV2f( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

  			gl.uniform2f( this.addr, v.x, v.y );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform2fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV3f( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

  			gl.uniform3f( this.addr, v.x, v.y, v.z );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;

  		}

  	} else if ( v.r !== undefined ) {

  		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

  			gl.uniform3f( this.addr, v.r, v.g, v.b );

  			cache[ 0 ] = v.r;
  			cache[ 1 ] = v.g;
  			cache[ 2 ] = v.b;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform3fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV4f( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

  			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;
  			cache[ 3 ] = v.w;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform4fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  // Single matrix (from flat array or THREE.MatrixN)

  function setValueM2( gl, v ) {

  	const cache = this.cache;
  	const elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniformMatrix2fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) return;

  		mat2array.set( elements );

  		gl.uniformMatrix2fv( this.addr, false, mat2array );

  		copyArray( cache, elements );

  	}

  }

  function setValueM3( gl, v ) {

  	const cache = this.cache;
  	const elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniformMatrix3fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) return;

  		mat3array.set( elements );

  		gl.uniformMatrix3fv( this.addr, false, mat3array );

  		copyArray( cache, elements );

  	}

  }

  function setValueM4( gl, v ) {

  	const cache = this.cache;
  	const elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniformMatrix4fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) return;

  		mat4array.set( elements );

  		gl.uniformMatrix4fv( this.addr, false, mat4array );

  		copyArray( cache, elements );

  	}

  }

  // Single integer / boolean

  function setValueV1i( gl, v ) {

  	const cache = this.cache;

  	if ( cache[ 0 ] === v ) return;

  	gl.uniform1i( this.addr, v );

  	cache[ 0 ] = v;

  }

  // Single integer / boolean vector (from flat array or THREE.VectorN)

  function setValueV2i( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

  			gl.uniform2i( this.addr, v.x, v.y );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform2iv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV3i( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

  			gl.uniform3i( this.addr, v.x, v.y, v.z );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform3iv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV4i( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

  			gl.uniform4i( this.addr, v.x, v.y, v.z, v.w );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;
  			cache[ 3 ] = v.w;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform4iv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  // Single unsigned integer

  function setValueV1ui( gl, v ) {

  	const cache = this.cache;

  	if ( cache[ 0 ] === v ) return;

  	gl.uniform1ui( this.addr, v );

  	cache[ 0 ] = v;

  }

  // Single unsigned integer vector (from flat array or THREE.VectorN)

  function setValueV2ui( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

  			gl.uniform2ui( this.addr, v.x, v.y );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform2uiv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV3ui( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

  			gl.uniform3ui( this.addr, v.x, v.y, v.z );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform3uiv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValueV4ui( gl, v ) {

  	const cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

  			gl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;
  			cache[ 3 ] = v.w;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform4uiv( this.addr, v );

  		copyArray( cache, v );

  	}

  }


  // Single texture (2D / Cube)

  function setValueT1( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	let emptyTexture2D;

  	if ( this.type === gl.SAMPLER_2D_SHADOW ) {

  		emptyShadowTexture.compareFunction = LessEqualCompare; // #28670
  		emptyTexture2D = emptyShadowTexture;

  	} else {

  		emptyTexture2D = emptyTexture;

  	}

  	textures.setTexture2D( v || emptyTexture2D, unit );

  }

  function setValueT3D1( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	textures.setTexture3D( v || empty3dTexture, unit );

  }

  function setValueT6( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	textures.setTextureCube( v || emptyCubeTexture, unit );

  }

  function setValueT2DArray1( gl, v, textures ) {

  	const cache = this.cache;
  	const unit = textures.allocateTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	textures.setTexture2DArray( v || emptyArrayTexture, unit );

  }

  // Helper to pick the right setter for the singular case

  function getSingularSetter( type ) {

  	switch ( type ) {

  		case 0x1406: return setValueV1f; // FLOAT
  		case 0x8b50: return setValueV2f; // _VEC2
  		case 0x8b51: return setValueV3f; // _VEC3
  		case 0x8b52: return setValueV4f; // _VEC4

  		case 0x8b5a: return setValueM2; // _MAT2
  		case 0x8b5b: return setValueM3; // _MAT3
  		case 0x8b5c: return setValueM4; // _MAT4

  		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
  		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
  		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

  		case 0x1405: return setValueV1ui; // UINT
  		case 0x8dc6: return setValueV2ui; // _VEC2
  		case 0x8dc7: return setValueV3ui; // _VEC3
  		case 0x8dc8: return setValueV4ui; // _VEC4

  		case 0x8b5e: // SAMPLER_2D
  		case 0x8d66: // SAMPLER_EXTERNAL_OES
  		case 0x8dca: // INT_SAMPLER_2D
  		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
  		case 0x8b62: // SAMPLER_2D_SHADOW
  			return setValueT1;

  		case 0x8b5f: // SAMPLER_3D
  		case 0x8dcb: // INT_SAMPLER_3D
  		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
  			return setValueT3D1;

  		case 0x8b60: // SAMPLER_CUBE
  		case 0x8dcc: // INT_SAMPLER_CUBE
  		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
  		case 0x8dc5: // SAMPLER_CUBE_SHADOW
  			return setValueT6;

  		case 0x8dc1: // SAMPLER_2D_ARRAY
  		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
  		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
  		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
  			return setValueT2DArray1;

  	}

  }


  // Array of scalars

  function setValueV1fArray( gl, v ) {

  	gl.uniform1fv( this.addr, v );

  }

  // Array of vectors (from flat array or array of THREE.VectorN)

  function setValueV2fArray( gl, v ) {

  	const data = flatten( v, this.size, 2 );

  	gl.uniform2fv( this.addr, data );

  }

  function setValueV3fArray( gl, v ) {

  	const data = flatten( v, this.size, 3 );

  	gl.uniform3fv( this.addr, data );

  }

  function setValueV4fArray( gl, v ) {

  	const data = flatten( v, this.size, 4 );

  	gl.uniform4fv( this.addr, data );

  }

  // Array of matrices (from flat array or array of THREE.MatrixN)

  function setValueM2Array( gl, v ) {

  	const data = flatten( v, this.size, 4 );

  	gl.uniformMatrix2fv( this.addr, false, data );

  }

  function setValueM3Array( gl, v ) {

  	const data = flatten( v, this.size, 9 );

  	gl.uniformMatrix3fv( this.addr, false, data );

  }

  function setValueM4Array( gl, v ) {

  	const data = flatten( v, this.size, 16 );

  	gl.uniformMatrix4fv( this.addr, false, data );

  }

  // Array of integer / boolean

  function setValueV1iArray( gl, v ) {

  	gl.uniform1iv( this.addr, v );

  }

  // Array of integer / boolean vectors (from flat array)

  function setValueV2iArray( gl, v ) {

  	gl.uniform2iv( this.addr, v );

  }

  function setValueV3iArray( gl, v ) {

  	gl.uniform3iv( this.addr, v );

  }

  function setValueV4iArray( gl, v ) {

  	gl.uniform4iv( this.addr, v );

  }

  // Array of unsigned integer

  function setValueV1uiArray( gl, v ) {

  	gl.uniform1uiv( this.addr, v );

  }

  // Array of unsigned integer vectors (from flat array)

  function setValueV2uiArray( gl, v ) {

  	gl.uniform2uiv( this.addr, v );

  }

  function setValueV3uiArray( gl, v ) {

  	gl.uniform3uiv( this.addr, v );

  }

  function setValueV4uiArray( gl, v ) {

  	gl.uniform4uiv( this.addr, v );

  }


  // Array of textures (2D / 3D / Cube / 2DArray)

  function setValueT1Array( gl, v, textures ) {

  	const cache = this.cache;

  	const n = v.length;

  	const units = allocTexUnits( textures, n );

  	if ( ! arraysEqual( cache, units ) ) {

  		gl.uniform1iv( this.addr, units );

  		copyArray( cache, units );

  	}

  	for ( let i = 0; i !== n; ++ i ) {

  		textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

  	}

  }

  function setValueT3DArray( gl, v, textures ) {

  	const cache = this.cache;

  	const n = v.length;

  	const units = allocTexUnits( textures, n );

  	if ( ! arraysEqual( cache, units ) ) {

  		gl.uniform1iv( this.addr, units );

  		copyArray( cache, units );

  	}

  	for ( let i = 0; i !== n; ++ i ) {

  		textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

  	}

  }

  function setValueT6Array( gl, v, textures ) {

  	const cache = this.cache;

  	const n = v.length;

  	const units = allocTexUnits( textures, n );

  	if ( ! arraysEqual( cache, units ) ) {

  		gl.uniform1iv( this.addr, units );

  		copyArray( cache, units );

  	}

  	for ( let i = 0; i !== n; ++ i ) {

  		textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

  	}

  }

  function setValueT2DArrayArray( gl, v, textures ) {

  	const cache = this.cache;

  	const n = v.length;

  	const units = allocTexUnits( textures, n );

  	if ( ! arraysEqual( cache, units ) ) {

  		gl.uniform1iv( this.addr, units );

  		copyArray( cache, units );

  	}

  	for ( let i = 0; i !== n; ++ i ) {

  		textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

  	}

  }


  // Helper to pick the right setter for a pure (bottom-level) array

  function getPureArraySetter( type ) {

  	switch ( type ) {

  		case 0x1406: return setValueV1fArray; // FLOAT
  		case 0x8b50: return setValueV2fArray; // _VEC2
  		case 0x8b51: return setValueV3fArray; // _VEC3
  		case 0x8b52: return setValueV4fArray; // _VEC4

  		case 0x8b5a: return setValueM2Array; // _MAT2
  		case 0x8b5b: return setValueM3Array; // _MAT3
  		case 0x8b5c: return setValueM4Array; // _MAT4

  		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
  		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
  		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

  		case 0x1405: return setValueV1uiArray; // UINT
  		case 0x8dc6: return setValueV2uiArray; // _VEC2
  		case 0x8dc7: return setValueV3uiArray; // _VEC3
  		case 0x8dc8: return setValueV4uiArray; // _VEC4

  		case 0x8b5e: // SAMPLER_2D
  		case 0x8d66: // SAMPLER_EXTERNAL_OES
  		case 0x8dca: // INT_SAMPLER_2D
  		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
  		case 0x8b62: // SAMPLER_2D_SHADOW
  			return setValueT1Array;

  		case 0x8b5f: // SAMPLER_3D
  		case 0x8dcb: // INT_SAMPLER_3D
  		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
  			return setValueT3DArray;

  		case 0x8b60: // SAMPLER_CUBE
  		case 0x8dcc: // INT_SAMPLER_CUBE
  		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
  		case 0x8dc5: // SAMPLER_CUBE_SHADOW
  			return setValueT6Array;

  		case 0x8dc1: // SAMPLER_2D_ARRAY
  		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
  		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
  		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
  			return setValueT2DArrayArray;

  	}

  }

  // --- Uniform Classes ---

  class SingleUniform {

  	constructor( id, activeInfo, addr ) {

  		this.id = id;
  		this.addr = addr;
  		this.cache = [];
  		this.type = activeInfo.type;
  		this.setValue = getSingularSetter( activeInfo.type );

  		// this.path = activeInfo.name; // DEBUG

  	}

  }

  class PureArrayUniform {

  	constructor( id, activeInfo, addr ) {

  		this.id = id;
  		this.addr = addr;
  		this.cache = [];
  		this.type = activeInfo.type;
  		this.size = activeInfo.size;
  		this.setValue = getPureArraySetter( activeInfo.type );

  		// this.path = activeInfo.name; // DEBUG

  	}

  }

  class StructuredUniform {

  	constructor( id ) {

  		this.id = id;

  		this.seq = [];
  		this.map = {};

  	}

  	setValue( gl, value, textures ) {

  		const seq = this.seq;

  		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

  			const u = seq[ i ];
  			u.setValue( gl, value[ u.id ], textures );

  		}

  	}

  }

  // --- Top-level ---

  // Parser - builds up the property tree from the path strings

  const RePathPart = /(\w+)(\])?(\[|\.)?/g;

  // extracts
  // 	- the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.

  function addUniform( container, uniformObject ) {

  	container.seq.push( uniformObject );
  	container.map[ uniformObject.id ] = uniformObject;

  }

  function parseUniform( activeInfo, addr, container ) {

  	const path = activeInfo.name,
  		pathLength = path.length;

  	// reset RegExp object, because of the early exit of a previous run
  	RePathPart.lastIndex = 0;

  	while ( true ) {

  		const match = RePathPart.exec( path ),
  			matchEnd = RePathPart.lastIndex;

  		let id = match[ 1 ];
  		const idIsIndex = match[ 2 ] === ']',
  			subscript = match[ 3 ];

  		if ( idIsIndex ) id = id | 0; // convert to integer

  		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

  			// bare name or "pure" bottom-level array "[0]" suffix

  			addUniform( container, subscript === undefined ?
  				new SingleUniform( id, activeInfo, addr ) :
  				new PureArrayUniform( id, activeInfo, addr ) );

  			break;

  		} else {

  			// step into inner node / create it in case it doesn't exist

  			const map = container.map;
  			let next = map[ id ];

  			if ( next === undefined ) {

  				next = new StructuredUniform( id );
  				addUniform( container, next );

  			}

  			container = next;

  		}

  	}

  }

  // Root Container

  class WebGLUniforms {

  	constructor( gl, program ) {

  		this.seq = [];
  		this.map = {};

  		const n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

  		for ( let i = 0; i < n; ++ i ) {

  			const info = gl.getActiveUniform( program, i ),
  				addr = gl.getUniformLocation( program, info.name );

  			parseUniform( info, addr, this );

  		}

  	}

  	setValue( gl, name, value, textures ) {

  		const u = this.map[ name ];

  		if ( u !== undefined ) u.setValue( gl, value, textures );

  	}

  	setOptional( gl, object, name ) {

  		const v = object[ name ];

  		if ( v !== undefined ) this.setValue( gl, name, v );

  	}

  	static upload( gl, seq, values, textures ) {

  		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

  			const u = seq[ i ],
  				v = values[ u.id ];

  			if ( v.needsUpdate !== false ) {

  				// note: always updating when .needsUpdate is undefined
  				u.setValue( gl, v.value, textures );

  			}

  		}

  	}

  	static seqWithValue( seq, values ) {

  		const r = [];

  		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

  			const u = seq[ i ];
  			if ( u.id in values ) r.push( u );

  		}

  		return r;

  	}

  }

  function WebGLShader( gl, type, string ) {

  	const shader = gl.createShader( type );

  	gl.shaderSource( shader, string );
  	gl.compileShader( shader );

  	return shader;

  }

  // From https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
  const COMPLETION_STATUS_KHR = 0x91B1;

  let programIdCount = 0;

  function handleSource( string, errorLine ) {

  	const lines = string.split( '\n' );
  	const lines2 = [];

  	const from = Math.max( errorLine - 6, 0 );
  	const to = Math.min( errorLine + 6, lines.length );

  	for ( let i = from; i < to; i ++ ) {

  		const line = i + 1;
  		lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

  	}

  	return lines2.join( '\n' );

  }

  const _m0 = /*@__PURE__*/ new Matrix3();

  function getEncodingComponents( colorSpace ) {

  	ColorManagement._getMatrix( _m0, ColorManagement.workingColorSpace, colorSpace );

  	const encodingMatrix = `mat3( ${ _m0.elements.map( ( v ) => v.toFixed( 4 ) ) } )`;

  	switch ( ColorManagement.getTransfer( colorSpace ) ) {

  		case LinearTransfer:
  			return [ encodingMatrix, 'LinearTransferOETF' ];

  		case SRGBTransfer:
  			return [ encodingMatrix, 'sRGBTransferOETF' ];

  		default:
  			console.warn( 'THREE.WebGLProgram: Unsupported color space: ', colorSpace );
  			return [ encodingMatrix, 'LinearTransferOETF' ];

  	}

  }

  function getShaderErrors( gl, shader, type ) {

  	const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );

  	const shaderInfoLog = gl.getShaderInfoLog( shader ) || '';
  	const errors = shaderInfoLog.trim();

  	if ( status && errors === '' ) return '';

  	const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
  	if ( errorMatches ) {

  		// --enable-privileged-webgl-extension
  		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  		const errorLine = parseInt( errorMatches[ 1 ] );
  		return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

  	} else {

  		return errors;

  	}

  }

  function getTexelEncodingFunction( functionName, colorSpace ) {

  	const components = getEncodingComponents( colorSpace );

  	return [

  		`vec4 ${functionName}( vec4 value ) {`,

  		`	return ${components[ 1 ]}( vec4( value.rgb * ${components[ 0 ]}, value.a ) );`,

  		'}',

  	].join( '\n' );

  }

  function getToneMappingFunction( functionName, toneMapping ) {

  	let toneMappingName;

  	switch ( toneMapping ) {

  		case LinearToneMapping:
  			toneMappingName = 'Linear';
  			break;

  		case ReinhardToneMapping:
  			toneMappingName = 'Reinhard';
  			break;

  		case CineonToneMapping:
  			toneMappingName = 'Cineon';
  			break;

  		case ACESFilmicToneMapping:
  			toneMappingName = 'ACESFilmic';
  			break;

  		case AgXToneMapping:
  			toneMappingName = 'AgX';
  			break;

  		case NeutralToneMapping:
  			toneMappingName = 'Neutral';
  			break;

  		case CustomToneMapping:
  			toneMappingName = 'Custom';
  			break;

  		default:
  			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
  			toneMappingName = 'Linear';

  	}

  	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

  }

  const _v0 = /*@__PURE__*/ new Vector3();

  function getLuminanceFunction() {

  	ColorManagement.getLuminanceCoefficients( _v0 );

  	const r = _v0.x.toFixed( 4 );
  	const g = _v0.y.toFixed( 4 );
  	const b = _v0.z.toFixed( 4 );

  	return [

  		'float luminance( const in vec3 rgb ) {',

  		`	const vec3 weights = vec3( ${ r }, ${ g }, ${ b } );`,

  		'	return dot( weights, rgb );',

  		'}'

  	].join( '\n' );

  }

  function generateVertexExtensions( parameters ) {

  	const chunks = [
  		parameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
  		parameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
  	];

  	return chunks.filter( filterEmptyLine ).join( '\n' );

  }

  function generateDefines( defines ) {

  	const chunks = [];

  	for ( const name in defines ) {

  		const value = defines[ name ];

  		if ( value === false ) continue;

  		chunks.push( '#define ' + name + ' ' + value );

  	}

  	return chunks.join( '\n' );

  }

  function fetchAttributeLocations( gl, program ) {

  	const attributes = {};

  	const n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

  	for ( let i = 0; i < n; i ++ ) {

  		const info = gl.getActiveAttrib( program, i );
  		const name = info.name;

  		let locationSize = 1;
  		if ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;
  		if ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;
  		if ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;

  		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

  		attributes[ name ] = {
  			type: info.type,
  			location: gl.getAttribLocation( program, name ),
  			locationSize: locationSize
  		};

  	}

  	return attributes;

  }

  function filterEmptyLine( string ) {

  	return string !== '';

  }

  function replaceLightNums( string, parameters ) {

  	const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;

  	return string
  		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
  		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
  		.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )
  		.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )
  		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
  		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
  		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
  		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
  		.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )
  		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
  		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

  }

  function replaceClippingPlaneNums( string, parameters ) {

  	return string
  		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
  		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

  }

  // Resolve Includes

  const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

  function resolveIncludes( string ) {

  	return string.replace( includePattern, includeReplacer );

  }

  const shaderChunkMap = new Map();

  function includeReplacer( match, include ) {

  	let string = ShaderChunk[ include ];

  	if ( string === undefined ) {

  		const newInclude = shaderChunkMap.get( include );

  		if ( newInclude !== undefined ) {

  			string = ShaderChunk[ newInclude ];
  			console.warn( 'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude );

  		} else {

  			throw new Error( 'Can not resolve #include <' + include + '>' );

  		}

  	}

  	return resolveIncludes( string );

  }

  // Unroll Loops

  const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

  function unrollLoops( string ) {

  	return string.replace( unrollLoopPattern, loopReplacer );

  }

  function loopReplacer( match, start, end, snippet ) {

  	let string = '';

  	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

  		string += snippet
  			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
  			.replace( /UNROLLED_LOOP_INDEX/g, i );

  	}

  	return string;

  }

  //

  function generatePrecision( parameters ) {

  	let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;

  	if ( parameters.precision === 'highp' ) {

  		precisionstring += '\n#define HIGH_PRECISION';

  	} else if ( parameters.precision === 'mediump' ) {

  		precisionstring += '\n#define MEDIUM_PRECISION';

  	} else if ( parameters.precision === 'lowp' ) {

  		precisionstring += '\n#define LOW_PRECISION';

  	}

  	return precisionstring;

  }

  function generateShadowMapTypeDefine( parameters ) {

  	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  	if ( parameters.shadowMapType === PCFShadowMap ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

  	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

  	} else if ( parameters.shadowMapType === VSMShadowMap ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

  	}

  	return shadowMapTypeDefine;

  }

  function generateEnvMapTypeDefine( parameters ) {

  	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

  	if ( parameters.envMap ) {

  		switch ( parameters.envMapMode ) {

  			case CubeReflectionMapping:
  			case CubeRefractionMapping:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  				break;

  			case CubeUVReflectionMapping:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
  				break;

  		}

  	}

  	return envMapTypeDefine;

  }

  function generateEnvMapModeDefine( parameters ) {

  	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

  	if ( parameters.envMap ) {

  		switch ( parameters.envMapMode ) {

  			case CubeRefractionMapping:

  				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
  				break;

  		}

  	}

  	return envMapModeDefine;

  }

  function generateEnvMapBlendingDefine( parameters ) {

  	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

  	if ( parameters.envMap ) {

  		switch ( parameters.combine ) {

  			case MultiplyOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
  				break;

  			case MixOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
  				break;

  			case AddOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
  				break;

  		}

  	}

  	return envMapBlendingDefine;

  }

  function generateCubeUVSize( parameters ) {

  	const imageHeight = parameters.envMapCubeUVHeight;

  	if ( imageHeight === null ) return null;

  	const maxMip = Math.log2( imageHeight ) - 2;

  	const texelHeight = 1.0 / imageHeight;

  	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

  	return { texelWidth, texelHeight, maxMip };

  }

  function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

  	// TODO Send this event to Three.js DevTools
  	// console.log( 'WebGLProgram', cacheKey );

  	const gl = renderer.getContext();

  	const defines = parameters.defines;

  	let vertexShader = parameters.vertexShader;
  	let fragmentShader = parameters.fragmentShader;

  	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
  	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
  	const envMapModeDefine = generateEnvMapModeDefine( parameters );
  	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
  	const envMapCubeUVSize = generateCubeUVSize( parameters );

  	const customVertexExtensions = generateVertexExtensions( parameters );

  	const customDefines = generateDefines( defines );

  	const program = gl.createProgram();

  	let prefixVertex, prefixFragment;
  	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

  	if ( parameters.isRawShaderMaterial ) {

  		prefixVertex = [

  			'#define SHADER_TYPE ' + parameters.shaderType,
  			'#define SHADER_NAME ' + parameters.shaderName,

  			customDefines

  		].filter( filterEmptyLine ).join( '\n' );

  		if ( prefixVertex.length > 0 ) {

  			prefixVertex += '\n';

  		}

  		prefixFragment = [

  			'#define SHADER_TYPE ' + parameters.shaderType,
  			'#define SHADER_NAME ' + parameters.shaderName,

  			customDefines

  		].filter( filterEmptyLine ).join( '\n' );

  		if ( prefixFragment.length > 0 ) {

  			prefixFragment += '\n';

  		}

  	} else {

  		prefixVertex = [

  			generatePrecision( parameters ),

  			'#define SHADER_TYPE ' + parameters.shaderType,
  			'#define SHADER_NAME ' + parameters.shaderName,

  			customDefines,

  			parameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
  			parameters.batching ? '#define USE_BATCHING' : '',
  			parameters.batchingColor ? '#define USE_BATCHING_COLOR' : '',
  			parameters.instancing ? '#define USE_INSTANCING' : '',
  			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
  			parameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',

  			parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
  			parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

  			parameters.map ? '#define USE_MAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
  			parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
  			parameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

  			parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
  			parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

  			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
  			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
  			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

  			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
  			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
  			parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
  			parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

  			parameters.transmission ? '#define USE_TRANSMISSION' : '',
  			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
  			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

  			parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
  			parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

  			//

  			parameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',
  			parameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',
  			parameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',
  			parameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',
  			parameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',
  			parameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',
  			parameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',
  			parameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',

  			parameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',
  			parameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',

  			parameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',

  			parameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',
  			parameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',
  			parameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',

  			parameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',
  			parameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',

  			parameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',
  			parameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',

  			parameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',
  			parameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',
  			parameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',

  			parameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',
  			parameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',

  			//

  			parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
  			parameters.vertexColors ? '#define USE_COLOR' : '',
  			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
  			parameters.vertexUv1s ? '#define USE_UV1' : '',
  			parameters.vertexUv2s ? '#define USE_UV2' : '',
  			parameters.vertexUv3s ? '#define USE_UV3' : '',

  			parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.skinning ? '#define USE_SKINNING' : '',

  			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
  			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
  			( parameters.morphColors ) ? '#define USE_MORPHCOLORS' : '',
  			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
  			( parameters.morphTargetsCount > 0 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

  			parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGARITHMIC_DEPTH_BUFFER' : '',
  			parameters.reversedDepthBuffer ? '#define USE_REVERSED_DEPTH_BUFFER' : '',

  			'uniform mat4 modelMatrix;',
  			'uniform mat4 modelViewMatrix;',
  			'uniform mat4 projectionMatrix;',
  			'uniform mat4 viewMatrix;',
  			'uniform mat3 normalMatrix;',
  			'uniform vec3 cameraPosition;',
  			'uniform bool isOrthographic;',

  			'#ifdef USE_INSTANCING',

  			'	attribute mat4 instanceMatrix;',

  			'#endif',

  			'#ifdef USE_INSTANCING_COLOR',

  			'	attribute vec3 instanceColor;',

  			'#endif',

  			'#ifdef USE_INSTANCING_MORPH',

  			'	uniform sampler2D morphTexture;',

  			'#endif',

  			'attribute vec3 position;',
  			'attribute vec3 normal;',
  			'attribute vec2 uv;',

  			'#ifdef USE_UV1',

  			'	attribute vec2 uv1;',

  			'#endif',

  			'#ifdef USE_UV2',

  			'	attribute vec2 uv2;',

  			'#endif',

  			'#ifdef USE_UV3',

  			'	attribute vec2 uv3;',

  			'#endif',

  			'#ifdef USE_TANGENT',

  			'	attribute vec4 tangent;',

  			'#endif',

  			'#if defined( USE_COLOR_ALPHA )',

  			'	attribute vec4 color;',

  			'#elif defined( USE_COLOR )',

  			'	attribute vec3 color;',

  			'#endif',

  			'#ifdef USE_SKINNING',

  			'	attribute vec4 skinIndex;',
  			'	attribute vec4 skinWeight;',

  			'#endif',

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  		prefixFragment = [

  			generatePrecision( parameters ),

  			'#define SHADER_TYPE ' + parameters.shaderType,
  			'#define SHADER_NAME ' + parameters.shaderName,

  			customDefines,

  			parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
  			parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

  			parameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
  			parameters.map ? '#define USE_MAP' : '',
  			parameters.matcap ? '#define USE_MATCAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapTypeDefine : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
  			envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
  			envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
  			envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
  			parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

  			parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
  			parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

  			parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
  			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
  			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
  			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

  			parameters.dispersion ? '#define USE_DISPERSION' : '',

  			parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
  			parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
  			parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
  			parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
  			parameters.alphaTest ? '#define USE_ALPHATEST' : '',
  			parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

  			parameters.sheen ? '#define USE_SHEEN' : '',
  			parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
  			parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

  			parameters.transmission ? '#define USE_TRANSMISSION' : '',
  			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
  			parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

  			parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
  			parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? '#define USE_COLOR' : '',
  			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
  			parameters.vertexUv1s ? '#define USE_UV1' : '',
  			parameters.vertexUv2s ? '#define USE_UV2' : '',
  			parameters.vertexUv3s ? '#define USE_UV3' : '',

  			parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

  			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

  			parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',

  			parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
  			parameters.decodeVideoTextureEmissive ? '#define DECODE_VIDEO_TEXTURE_EMISSIVE' : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGARITHMIC_DEPTH_BUFFER' : '',
  			parameters.reversedDepthBuffer ? '#define USE_REVERSED_DEPTH_BUFFER' : '',

  			'uniform mat4 viewMatrix;',
  			'uniform vec3 cameraPosition;',
  			'uniform bool isOrthographic;',

  			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
  			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
  			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

  			parameters.dithering ? '#define DITHERING' : '',
  			parameters.opaque ? '#define OPAQUE' : '',

  			ShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
  			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),
  			getLuminanceFunction(),

  			parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  	}

  	vertexShader = resolveIncludes( vertexShader );
  	vertexShader = replaceLightNums( vertexShader, parameters );
  	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

  	fragmentShader = resolveIncludes( fragmentShader );
  	fragmentShader = replaceLightNums( fragmentShader, parameters );
  	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

  	vertexShader = unrollLoops( vertexShader );
  	fragmentShader = unrollLoops( fragmentShader );

  	if ( parameters.isRawShaderMaterial !== true ) {

  		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

  		versionString = '#version 300 es\n';

  		prefixVertex = [
  			customVertexExtensions,
  			'#define attribute in',
  			'#define varying out',
  			'#define texture2D texture'
  		].join( '\n' ) + '\n' + prefixVertex;

  		prefixFragment = [
  			'#define varying in',
  			( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
  			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
  			'#define gl_FragDepthEXT gl_FragDepth',
  			'#define texture2D texture',
  			'#define textureCube texture',
  			'#define texture2DProj textureProj',
  			'#define texture2DLodEXT textureLod',
  			'#define texture2DProjLodEXT textureProjLod',
  			'#define textureCubeLodEXT textureLod',
  			'#define texture2DGradEXT textureGrad',
  			'#define texture2DProjGradEXT textureProjGrad',
  			'#define textureCubeGradEXT textureGrad'
  		].join( '\n' ) + '\n' + prefixFragment;

  	}

  	const vertexGlsl = versionString + prefixVertex + vertexShader;
  	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

  	// console.log( '*VERTEX*', vertexGlsl );
  	// console.log( '*FRAGMENT*', fragmentGlsl );

  	const glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
  	const glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

  	gl.attachShader( program, glVertexShader );
  	gl.attachShader( program, glFragmentShader );

  	// Force a particular attribute to index 0.

  	if ( parameters.index0AttributeName !== undefined ) {

  		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

  	} else if ( parameters.morphTargets === true ) {

  		// programs with morphTargets displace position out of attribute 0
  		gl.bindAttribLocation( program, 0, 'position' );

  	}

  	gl.linkProgram( program );

  	function onFirstUse( self ) {

  		// check for link errors
  		if ( renderer.debug.checkShaderErrors ) {

  			const programInfoLog = gl.getProgramInfoLog( program ) || '';
  			const vertexShaderInfoLog = gl.getShaderInfoLog( glVertexShader ) || '';
  			const fragmentShaderInfoLog = gl.getShaderInfoLog( glFragmentShader ) || '';

  			const programLog = programInfoLog.trim();
  			const vertexLog = vertexShaderInfoLog.trim();
  			const fragmentLog = fragmentShaderInfoLog.trim();

  			let runnable = true;
  			let haveDiagnostics = true;

  			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

  				runnable = false;

  				if ( typeof renderer.debug.onShaderError === 'function' ) {

  					renderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );

  				} else {

  					// default error reporting

  					const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
  					const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

  					console.error(
  						'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
  						'VALIDATE_STATUS ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + '\n\n' +
  						'Material Name: ' + self.name + '\n' +
  						'Material Type: ' + self.type + '\n\n' +
  						'Program Info Log: ' + programLog + '\n' +
  						vertexErrors + '\n' +
  						fragmentErrors
  					);

  				}

  			} else if ( programLog !== '' ) {

  				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

  			} else if ( vertexLog === '' || fragmentLog === '' ) {

  				haveDiagnostics = false;

  			}

  			if ( haveDiagnostics ) {

  				self.diagnostics = {

  					runnable: runnable,

  					programLog: programLog,

  					vertexShader: {

  						log: vertexLog,
  						prefix: prefixVertex

  					},

  					fragmentShader: {

  						log: fragmentLog,
  						prefix: prefixFragment

  					}

  				};

  			}

  		}

  		// Clean up

  		// Crashes in iOS9 and iOS10. #18402
  		// gl.detachShader( program, glVertexShader );
  		// gl.detachShader( program, glFragmentShader );

  		gl.deleteShader( glVertexShader );
  		gl.deleteShader( glFragmentShader );

  		cachedUniforms = new WebGLUniforms( gl, program );
  		cachedAttributes = fetchAttributeLocations( gl, program );

  	}

  	// set up caching for uniform locations

  	let cachedUniforms;

  	this.getUniforms = function () {

  		if ( cachedUniforms === undefined ) {

  			// Populates cachedUniforms and cachedAttributes
  			onFirstUse( this );

  		}

  		return cachedUniforms;

  	};

  	// set up caching for attribute locations

  	let cachedAttributes;

  	this.getAttributes = function () {

  		if ( cachedAttributes === undefined ) {

  			// Populates cachedAttributes and cachedUniforms
  			onFirstUse( this );

  		}

  		return cachedAttributes;

  	};

  	// indicate when the program is ready to be used. if the KHR_parallel_shader_compile extension isn't supported,
  	// flag the program as ready immediately. It may cause a stall when it's first used.

  	let programReady = ( parameters.rendererExtensionParallelShaderCompile === false );

  	this.isReady = function () {

  		if ( programReady === false ) {

  			programReady = gl.getProgramParameter( program, COMPLETION_STATUS_KHR );

  		}

  		return programReady;

  	};

  	// free resource

  	this.destroy = function () {

  		bindingStates.releaseStatesOfProgram( this );

  		gl.deleteProgram( program );
  		this.program = undefined;

  	};

  	//

  	this.type = parameters.shaderType;
  	this.name = parameters.shaderName;
  	this.id = programIdCount ++;
  	this.cacheKey = cacheKey;
  	this.usedTimes = 1;
  	this.program = program;
  	this.vertexShader = glVertexShader;
  	this.fragmentShader = glFragmentShader;

  	return this;

  }

  let _id = 0;

  class WebGLShaderCache {

  	constructor() {

  		this.shaderCache = new Map();
  		this.materialCache = new Map();

  	}

  	update( material ) {

  		const vertexShader = material.vertexShader;
  		const fragmentShader = material.fragmentShader;

  		const vertexShaderStage = this._getShaderStage( vertexShader );
  		const fragmentShaderStage = this._getShaderStage( fragmentShader );

  		const materialShaders = this._getShaderCacheForMaterial( material );

  		if ( materialShaders.has( vertexShaderStage ) === false ) {

  			materialShaders.add( vertexShaderStage );
  			vertexShaderStage.usedTimes ++;

  		}

  		if ( materialShaders.has( fragmentShaderStage ) === false ) {

  			materialShaders.add( fragmentShaderStage );
  			fragmentShaderStage.usedTimes ++;

  		}

  		return this;

  	}

  	remove( material ) {

  		const materialShaders = this.materialCache.get( material );

  		for ( const shaderStage of materialShaders ) {

  			shaderStage.usedTimes --;

  			if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

  		}

  		this.materialCache.delete( material );

  		return this;

  	}

  	getVertexShaderID( material ) {

  		return this._getShaderStage( material.vertexShader ).id;

  	}

  	getFragmentShaderID( material ) {

  		return this._getShaderStage( material.fragmentShader ).id;

  	}

  	dispose() {

  		this.shaderCache.clear();
  		this.materialCache.clear();

  	}

  	_getShaderCacheForMaterial( material ) {

  		const cache = this.materialCache;
  		let set = cache.get( material );

  		if ( set === undefined ) {

  			set = new Set();
  			cache.set( material, set );

  		}

  		return set;

  	}

  	_getShaderStage( code ) {

  		const cache = this.shaderCache;
  		let stage = cache.get( code );

  		if ( stage === undefined ) {

  			stage = new WebGLShaderStage( code );
  			cache.set( code, stage );

  		}

  		return stage;

  	}

  }

  class WebGLShaderStage {

  	constructor( code ) {

  		this.id = _id ++;

  		this.code = code;
  		this.usedTimes = 0;

  	}

  }

  function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

  	const _programLayers = new Layers();
  	const _customShaders = new WebGLShaderCache();
  	const _activeChannels = new Set();
  	const programs = [];

  	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  	const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;

  	let precision = capabilities.precision;

  	const shaderIDs = {
  		MeshDepthMaterial: 'depth',
  		MeshDistanceMaterial: 'distanceRGBA',
  		MeshNormalMaterial: 'normal',
  		MeshBasicMaterial: 'basic',
  		MeshLambertMaterial: 'lambert',
  		MeshPhongMaterial: 'phong',
  		MeshToonMaterial: 'toon',
  		MeshStandardMaterial: 'physical',
  		MeshPhysicalMaterial: 'physical',
  		MeshMatcapMaterial: 'matcap',
  		LineBasicMaterial: 'basic',
  		LineDashedMaterial: 'dashed',
  		PointsMaterial: 'points',
  		ShadowMaterial: 'shadow',
  		SpriteMaterial: 'sprite'
  	};

  	function getChannel( value ) {

  		_activeChannels.add( value );

  		if ( value === 0 ) return 'uv';

  		return `uv${ value }`;

  	}

  	function getParameters( material, lights, shadows, scene, object ) {

  		const fog = scene.fog;
  		const geometry = object.geometry;
  		const environment = material.isMeshStandardMaterial ? scene.environment : null;

  		const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
  		const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

  		const shaderID = shaderIDs[ material.type ];

  		// heuristics to create shader parameters according to lights in the scene
  		// (not to blow over maxLights budget)

  		if ( material.precision !== null ) {

  			precision = capabilities.getMaxPrecision( material.precision );

  			if ( precision !== material.precision ) {

  				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

  			}

  		}

  		//

  		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

  		let morphTextureStride = 0;

  		if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
  		if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
  		if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

  		//

  		let vertexShader, fragmentShader;
  		let customVertexShaderID, customFragmentShaderID;

  		if ( shaderID ) {

  			const shader = ShaderLib[ shaderID ];

  			vertexShader = shader.vertexShader;
  			fragmentShader = shader.fragmentShader;

  		} else {

  			vertexShader = material.vertexShader;
  			fragmentShader = material.fragmentShader;

  			_customShaders.update( material );

  			customVertexShaderID = _customShaders.getVertexShaderID( material );
  			customFragmentShaderID = _customShaders.getFragmentShaderID( material );

  		}

  		const currentRenderTarget = renderer.getRenderTarget();
  		const reversedDepthBuffer = renderer.state.buffers.depth.getReversed();

  		const IS_INSTANCEDMESH = object.isInstancedMesh === true;
  		const IS_BATCHEDMESH = object.isBatchedMesh === true;

  		const HAS_MAP = !! material.map;
  		const HAS_MATCAP = !! material.matcap;
  		const HAS_ENVMAP = !! envMap;
  		const HAS_AOMAP = !! material.aoMap;
  		const HAS_LIGHTMAP = !! material.lightMap;
  		const HAS_BUMPMAP = !! material.bumpMap;
  		const HAS_NORMALMAP = !! material.normalMap;
  		const HAS_DISPLACEMENTMAP = !! material.displacementMap;
  		const HAS_EMISSIVEMAP = !! material.emissiveMap;

  		const HAS_METALNESSMAP = !! material.metalnessMap;
  		const HAS_ROUGHNESSMAP = !! material.roughnessMap;

  		const HAS_ANISOTROPY = material.anisotropy > 0;
  		const HAS_CLEARCOAT = material.clearcoat > 0;
  		const HAS_DISPERSION = material.dispersion > 0;
  		const HAS_IRIDESCENCE = material.iridescence > 0;
  		const HAS_SHEEN = material.sheen > 0;
  		const HAS_TRANSMISSION = material.transmission > 0;

  		const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;

  		const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;
  		const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;
  		const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;

  		const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;
  		const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;

  		const HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;
  		const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;

  		const HAS_SPECULARMAP = !! material.specularMap;
  		const HAS_SPECULAR_COLORMAP = !! material.specularColorMap;
  		const HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;

  		const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;
  		const HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;

  		const HAS_GRADIENTMAP = !! material.gradientMap;

  		const HAS_ALPHAMAP = !! material.alphaMap;

  		const HAS_ALPHATEST = material.alphaTest > 0;

  		const HAS_ALPHAHASH = !! material.alphaHash;

  		const HAS_EXTENSIONS = !! material.extensions;

  		let toneMapping = NoToneMapping;

  		if ( material.toneMapped ) {

  			if ( currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true ) {

  				toneMapping = renderer.toneMapping;

  			}

  		}

  		const parameters = {

  			shaderID: shaderID,
  			shaderType: material.type,
  			shaderName: material.name,

  			vertexShader: vertexShader,
  			fragmentShader: fragmentShader,
  			defines: material.defines,

  			customVertexShaderID: customVertexShaderID,
  			customFragmentShaderID: customFragmentShaderID,

  			isRawShaderMaterial: material.isRawShaderMaterial === true,
  			glslVersion: material.glslVersion,

  			precision: precision,

  			batching: IS_BATCHEDMESH,
  			batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
  			instancing: IS_INSTANCEDMESH,
  			instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
  			instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,

  			supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
  			outputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace ),
  			alphaToCoverage: !! material.alphaToCoverage,

  			map: HAS_MAP,
  			matcap: HAS_MATCAP,
  			envMap: HAS_ENVMAP,
  			envMapMode: HAS_ENVMAP && envMap.mapping,
  			envMapCubeUVHeight: envMapCubeUVHeight,
  			aoMap: HAS_AOMAP,
  			lightMap: HAS_LIGHTMAP,
  			bumpMap: HAS_BUMPMAP,
  			normalMap: HAS_NORMALMAP,
  			displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
  			emissiveMap: HAS_EMISSIVEMAP,

  			normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
  			normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,

  			metalnessMap: HAS_METALNESSMAP,
  			roughnessMap: HAS_ROUGHNESSMAP,

  			anisotropy: HAS_ANISOTROPY,
  			anisotropyMap: HAS_ANISOTROPYMAP,

  			clearcoat: HAS_CLEARCOAT,
  			clearcoatMap: HAS_CLEARCOATMAP,
  			clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
  			clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,

  			dispersion: HAS_DISPERSION,

  			iridescence: HAS_IRIDESCENCE,
  			iridescenceMap: HAS_IRIDESCENCEMAP,
  			iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,

  			sheen: HAS_SHEEN,
  			sheenColorMap: HAS_SHEEN_COLORMAP,
  			sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,

  			specularMap: HAS_SPECULARMAP,
  			specularColorMap: HAS_SPECULAR_COLORMAP,
  			specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,

  			transmission: HAS_TRANSMISSION,
  			transmissionMap: HAS_TRANSMISSIONMAP,
  			thicknessMap: HAS_THICKNESSMAP,

  			gradientMap: HAS_GRADIENTMAP,

  			opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,

  			alphaMap: HAS_ALPHAMAP,
  			alphaTest: HAS_ALPHATEST,
  			alphaHash: HAS_ALPHAHASH,

  			combine: material.combine,

  			//

  			mapUv: HAS_MAP && getChannel( material.map.channel ),
  			aoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),
  			lightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),
  			bumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),
  			normalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),
  			displacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),
  			emissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),

  			metalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),
  			roughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),

  			anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),

  			clearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),
  			clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),
  			clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),

  			iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),
  			iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),

  			sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),
  			sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),

  			specularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),
  			specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),
  			specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),

  			transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),
  			thicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),

  			alphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),

  			//

  			vertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),
  			vertexColors: material.vertexColors,
  			vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,

  			pointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),

  			fog: !! fog,
  			useFog: material.fog === true,
  			fogExp2: ( !! fog && fog.isFogExp2 ),

  			flatShading: ( material.flatShading === true && material.wireframe === false ),

  			sizeAttenuation: material.sizeAttenuation === true,
  			logarithmicDepthBuffer: logarithmicDepthBuffer,
  			reversedDepthBuffer: reversedDepthBuffer,

  			skinning: object.isSkinnedMesh === true,

  			morphTargets: geometry.morphAttributes.position !== undefined,
  			morphNormals: geometry.morphAttributes.normal !== undefined,
  			morphColors: geometry.morphAttributes.color !== undefined,
  			morphTargetsCount: morphTargetsCount,
  			morphTextureStride: morphTextureStride,

  			numDirLights: lights.directional.length,
  			numPointLights: lights.point.length,
  			numSpotLights: lights.spot.length,
  			numSpotLightMaps: lights.spotLightMap.length,
  			numRectAreaLights: lights.rectArea.length,
  			numHemiLights: lights.hemi.length,

  			numDirLightShadows: lights.directionalShadowMap.length,
  			numPointLightShadows: lights.pointShadowMap.length,
  			numSpotLightShadows: lights.spotShadowMap.length,
  			numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,

  			numLightProbes: lights.numLightProbes,

  			numClippingPlanes: clipping.numPlanes,
  			numClipIntersection: clipping.numIntersection,

  			dithering: material.dithering,

  			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
  			shadowMapType: renderer.shadowMap.type,

  			toneMapping: toneMapping,

  			decodeVideoTexture: HAS_MAP && ( material.map.isVideoTexture === true ) && ( ColorManagement.getTransfer( material.map.colorSpace ) === SRGBTransfer ),
  			decodeVideoTextureEmissive: HAS_EMISSIVEMAP && ( material.emissiveMap.isVideoTexture === true ) && ( ColorManagement.getTransfer( material.emissiveMap.colorSpace ) === SRGBTransfer ),

  			premultipliedAlpha: material.premultipliedAlpha,

  			doubleSided: material.side === DoubleSide,
  			flipSided: material.side === BackSide,

  			useDepthPacking: material.depthPacking >= 0,
  			depthPacking: material.depthPacking || 0,

  			index0AttributeName: material.index0AttributeName,

  			extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has( 'WEBGL_clip_cull_distance' ),
  			extensionMultiDraw: ( HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH ) && extensions.has( 'WEBGL_multi_draw' ),

  			rendererExtensionParallelShaderCompile: extensions.has( 'KHR_parallel_shader_compile' ),

  			customProgramCacheKey: material.customProgramCacheKey()

  		};

  		// the usage of getChannel() determines the active texture channels for this shader

  		parameters.vertexUv1s = _activeChannels.has( 1 );
  		parameters.vertexUv2s = _activeChannels.has( 2 );
  		parameters.vertexUv3s = _activeChannels.has( 3 );

  		_activeChannels.clear();

  		return parameters;

  	}

  	function getProgramCacheKey( parameters ) {

  		const array = [];

  		if ( parameters.shaderID ) {

  			array.push( parameters.shaderID );

  		} else {

  			array.push( parameters.customVertexShaderID );
  			array.push( parameters.customFragmentShaderID );

  		}

  		if ( parameters.defines !== undefined ) {

  			for ( const name in parameters.defines ) {

  				array.push( name );
  				array.push( parameters.defines[ name ] );

  			}

  		}

  		if ( parameters.isRawShaderMaterial === false ) {

  			getProgramCacheKeyParameters( array, parameters );
  			getProgramCacheKeyBooleans( array, parameters );
  			array.push( renderer.outputColorSpace );

  		}

  		array.push( parameters.customProgramCacheKey );

  		return array.join();

  	}

  	function getProgramCacheKeyParameters( array, parameters ) {

  		array.push( parameters.precision );
  		array.push( parameters.outputColorSpace );
  		array.push( parameters.envMapMode );
  		array.push( parameters.envMapCubeUVHeight );
  		array.push( parameters.mapUv );
  		array.push( parameters.alphaMapUv );
  		array.push( parameters.lightMapUv );
  		array.push( parameters.aoMapUv );
  		array.push( parameters.bumpMapUv );
  		array.push( parameters.normalMapUv );
  		array.push( parameters.displacementMapUv );
  		array.push( parameters.emissiveMapUv );
  		array.push( parameters.metalnessMapUv );
  		array.push( parameters.roughnessMapUv );
  		array.push( parameters.anisotropyMapUv );
  		array.push( parameters.clearcoatMapUv );
  		array.push( parameters.clearcoatNormalMapUv );
  		array.push( parameters.clearcoatRoughnessMapUv );
  		array.push( parameters.iridescenceMapUv );
  		array.push( parameters.iridescenceThicknessMapUv );
  		array.push( parameters.sheenColorMapUv );
  		array.push( parameters.sheenRoughnessMapUv );
  		array.push( parameters.specularMapUv );
  		array.push( parameters.specularColorMapUv );
  		array.push( parameters.specularIntensityMapUv );
  		array.push( parameters.transmissionMapUv );
  		array.push( parameters.thicknessMapUv );
  		array.push( parameters.combine );
  		array.push( parameters.fogExp2 );
  		array.push( parameters.sizeAttenuation );
  		array.push( parameters.morphTargetsCount );
  		array.push( parameters.morphAttributeCount );
  		array.push( parameters.numDirLights );
  		array.push( parameters.numPointLights );
  		array.push( parameters.numSpotLights );
  		array.push( parameters.numSpotLightMaps );
  		array.push( parameters.numHemiLights );
  		array.push( parameters.numRectAreaLights );
  		array.push( parameters.numDirLightShadows );
  		array.push( parameters.numPointLightShadows );
  		array.push( parameters.numSpotLightShadows );
  		array.push( parameters.numSpotLightShadowsWithMaps );
  		array.push( parameters.numLightProbes );
  		array.push( parameters.shadowMapType );
  		array.push( parameters.toneMapping );
  		array.push( parameters.numClippingPlanes );
  		array.push( parameters.numClipIntersection );
  		array.push( parameters.depthPacking );

  	}

  	function getProgramCacheKeyBooleans( array, parameters ) {

  		_programLayers.disableAll();

  		if ( parameters.supportsVertexTextures )
  			_programLayers.enable( 0 );
  		if ( parameters.instancing )
  			_programLayers.enable( 1 );
  		if ( parameters.instancingColor )
  			_programLayers.enable( 2 );
  		if ( parameters.instancingMorph )
  			_programLayers.enable( 3 );
  		if ( parameters.matcap )
  			_programLayers.enable( 4 );
  		if ( parameters.envMap )
  			_programLayers.enable( 5 );
  		if ( parameters.normalMapObjectSpace )
  			_programLayers.enable( 6 );
  		if ( parameters.normalMapTangentSpace )
  			_programLayers.enable( 7 );
  		if ( parameters.clearcoat )
  			_programLayers.enable( 8 );
  		if ( parameters.iridescence )
  			_programLayers.enable( 9 );
  		if ( parameters.alphaTest )
  			_programLayers.enable( 10 );
  		if ( parameters.vertexColors )
  			_programLayers.enable( 11 );
  		if ( parameters.vertexAlphas )
  			_programLayers.enable( 12 );
  		if ( parameters.vertexUv1s )
  			_programLayers.enable( 13 );
  		if ( parameters.vertexUv2s )
  			_programLayers.enable( 14 );
  		if ( parameters.vertexUv3s )
  			_programLayers.enable( 15 );
  		if ( parameters.vertexTangents )
  			_programLayers.enable( 16 );
  		if ( parameters.anisotropy )
  			_programLayers.enable( 17 );
  		if ( parameters.alphaHash )
  			_programLayers.enable( 18 );
  		if ( parameters.batching )
  			_programLayers.enable( 19 );
  		if ( parameters.dispersion )
  			_programLayers.enable( 20 );
  		if ( parameters.batchingColor )
  			_programLayers.enable( 21 );
  		if ( parameters.gradientMap )
  			_programLayers.enable( 22 );

  		array.push( _programLayers.mask );
  		_programLayers.disableAll();

  		if ( parameters.fog )
  			_programLayers.enable( 0 );
  		if ( parameters.useFog )
  			_programLayers.enable( 1 );
  		if ( parameters.flatShading )
  			_programLayers.enable( 2 );
  		if ( parameters.logarithmicDepthBuffer )
  			_programLayers.enable( 3 );
  		if ( parameters.reversedDepthBuffer )
  			_programLayers.enable( 4 );
  		if ( parameters.skinning )
  			_programLayers.enable( 5 );
  		if ( parameters.morphTargets )
  			_programLayers.enable( 6 );
  		if ( parameters.morphNormals )
  			_programLayers.enable( 7 );
  		if ( parameters.morphColors )
  			_programLayers.enable( 8 );
  		if ( parameters.premultipliedAlpha )
  			_programLayers.enable( 9 );
  		if ( parameters.shadowMapEnabled )
  			_programLayers.enable( 10 );
  		if ( parameters.doubleSided )
  			_programLayers.enable( 11 );
  		if ( parameters.flipSided )
  			_programLayers.enable( 12 );
  		if ( parameters.useDepthPacking )
  			_programLayers.enable( 13 );
  		if ( parameters.dithering )
  			_programLayers.enable( 14 );
  		if ( parameters.transmission )
  			_programLayers.enable( 15 );
  		if ( parameters.sheen )
  			_programLayers.enable( 16 );
  		if ( parameters.opaque )
  			_programLayers.enable( 17 );
  		if ( parameters.pointsUvs )
  			_programLayers.enable( 18 );
  		if ( parameters.decodeVideoTexture )
  			_programLayers.enable( 19 );
  		if ( parameters.decodeVideoTextureEmissive )
  			_programLayers.enable( 20 );
  		if ( parameters.alphaToCoverage )
  			_programLayers.enable( 21 );

  		array.push( _programLayers.mask );

  	}

  	function getUniforms( material ) {

  		const shaderID = shaderIDs[ material.type ];
  		let uniforms;

  		if ( shaderID ) {

  			const shader = ShaderLib[ shaderID ];
  			uniforms = UniformsUtils.clone( shader.uniforms );

  		} else {

  			uniforms = material.uniforms;

  		}

  		return uniforms;

  	}

  	function acquireProgram( parameters, cacheKey ) {

  		let program;

  		// Check if code has been already compiled
  		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

  			const preexistingProgram = programs[ p ];

  			if ( preexistingProgram.cacheKey === cacheKey ) {

  				program = preexistingProgram;
  				++ program.usedTimes;

  				break;

  			}

  		}

  		if ( program === undefined ) {

  			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
  			programs.push( program );

  		}

  		return program;

  	}

  	function releaseProgram( program ) {

  		if ( -- program.usedTimes === 0 ) {

  			// Remove from unordered set
  			const i = programs.indexOf( program );
  			programs[ i ] = programs[ programs.length - 1 ];
  			programs.pop();

  			// Free WebGL resources
  			program.destroy();

  		}

  	}

  	function releaseShaderCache( material ) {

  		_customShaders.remove( material );

  	}

  	function dispose() {

  		_customShaders.dispose();

  	}

  	return {
  		getParameters: getParameters,
  		getProgramCacheKey: getProgramCacheKey,
  		getUniforms: getUniforms,
  		acquireProgram: acquireProgram,
  		releaseProgram: releaseProgram,
  		releaseShaderCache: releaseShaderCache,
  		// Exposed for resource monitoring & error feedback via renderer.info:
  		programs: programs,
  		dispose: dispose
  	};

  }

  function WebGLProperties() {

  	let properties = new WeakMap();

  	function has( object ) {

  		return properties.has( object );

  	}

  	function get( object ) {

  		let map = properties.get( object );

  		if ( map === undefined ) {

  			map = {};
  			properties.set( object, map );

  		}

  		return map;

  	}

  	function remove( object ) {

  		properties.delete( object );

  	}

  	function update( object, key, value ) {

  		properties.get( object )[ key ] = value;

  	}

  	function dispose() {

  		properties = new WeakMap();

  	}

  	return {
  		has: has,
  		get: get,
  		remove: remove,
  		update: update,
  		dispose: dispose
  	};

  }

  function painterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.material.id !== b.material.id ) {

  		return a.material.id - b.material.id;

  	} else if ( a.z !== b.z ) {

  		return a.z - b.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  function reversePainterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.z !== b.z ) {

  		return b.z - a.z;

  	} else {

  		return a.id - b.id;

  	}

  }


  function WebGLRenderList() {

  	const renderItems = [];
  	let renderItemsIndex = 0;

  	const opaque = [];
  	const transmissive = [];
  	const transparent = [];

  	function init() {

  		renderItemsIndex = 0;

  		opaque.length = 0;
  		transmissive.length = 0;
  		transparent.length = 0;

  	}

  	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

  		let renderItem = renderItems[ renderItemsIndex ];

  		if ( renderItem === undefined ) {

  			renderItem = {
  				id: object.id,
  				object: object,
  				geometry: geometry,
  				material: material,
  				groupOrder: groupOrder,
  				renderOrder: object.renderOrder,
  				z: z,
  				group: group
  			};

  			renderItems[ renderItemsIndex ] = renderItem;

  		} else {

  			renderItem.id = object.id;
  			renderItem.object = object;
  			renderItem.geometry = geometry;
  			renderItem.material = material;
  			renderItem.groupOrder = groupOrder;
  			renderItem.renderOrder = object.renderOrder;
  			renderItem.z = z;
  			renderItem.group = group;

  		}

  		renderItemsIndex ++;

  		return renderItem;

  	}

  	function push( object, geometry, material, groupOrder, z, group ) {

  		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

  		if ( material.transmission > 0.0 ) {

  			transmissive.push( renderItem );

  		} else if ( material.transparent === true ) {

  			transparent.push( renderItem );

  		} else {

  			opaque.push( renderItem );

  		}

  	}

  	function unshift( object, geometry, material, groupOrder, z, group ) {

  		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

  		if ( material.transmission > 0.0 ) {

  			transmissive.unshift( renderItem );

  		} else if ( material.transparent === true ) {

  			transparent.unshift( renderItem );

  		} else {

  			opaque.unshift( renderItem );

  		}

  	}

  	function sort( customOpaqueSort, customTransparentSort ) {

  		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
  		if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
  		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

  	}

  	function finish() {

  		// Clear references from inactive renderItems in the list

  		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

  			const renderItem = renderItems[ i ];

  			if ( renderItem.id === null ) break;

  			renderItem.id = null;
  			renderItem.object = null;
  			renderItem.geometry = null;
  			renderItem.material = null;
  			renderItem.group = null;

  		}

  	}

  	return {

  		opaque: opaque,
  		transmissive: transmissive,
  		transparent: transparent,

  		init: init,
  		push: push,
  		unshift: unshift,
  		finish: finish,

  		sort: sort
  	};

  }

  function WebGLRenderLists() {

  	let lists = new WeakMap();

  	function get( scene, renderCallDepth ) {

  		const listArray = lists.get( scene );
  		let list;

  		if ( listArray === undefined ) {

  			list = new WebGLRenderList();
  			lists.set( scene, [ list ] );

  		} else {

  			if ( renderCallDepth >= listArray.length ) {

  				list = new WebGLRenderList();
  				listArray.push( list );

  			} else {

  				list = listArray[ renderCallDepth ];

  			}

  		}

  		return list;

  	}

  	function dispose() {

  		lists = new WeakMap();

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  function UniformsCache() {

  	const lights = {};

  	return {

  		get: function ( light ) {

  			if ( lights[ light.id ] !== undefined ) {

  				return lights[ light.id ];

  			}

  			let uniforms;

  			switch ( light.type ) {

  				case 'DirectionalLight':
  					uniforms = {
  						direction: new Vector3(),
  						color: new Color()
  					};
  					break;

  				case 'SpotLight':
  					uniforms = {
  						position: new Vector3(),
  						direction: new Vector3(),
  						color: new Color(),
  						distance: 0,
  						coneCos: 0,
  						penumbraCos: 0,
  						decay: 0
  					};
  					break;

  				case 'PointLight':
  					uniforms = {
  						position: new Vector3(),
  						color: new Color(),
  						distance: 0,
  						decay: 0
  					};
  					break;

  				case 'HemisphereLight':
  					uniforms = {
  						direction: new Vector3(),
  						skyColor: new Color(),
  						groundColor: new Color()
  					};
  					break;

  				case 'RectAreaLight':
  					uniforms = {
  						color: new Color(),
  						position: new Vector3(),
  						halfWidth: new Vector3(),
  						halfHeight: new Vector3()
  					};
  					break;

  			}

  			lights[ light.id ] = uniforms;

  			return uniforms;

  		}

  	};

  }

  function ShadowUniformsCache() {

  	const lights = {};

  	return {

  		get: function ( light ) {

  			if ( lights[ light.id ] !== undefined ) {

  				return lights[ light.id ];

  			}

  			let uniforms;

  			switch ( light.type ) {

  				case 'DirectionalLight':
  					uniforms = {
  						shadowIntensity: 1,
  						shadowBias: 0,
  						shadowNormalBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2()
  					};
  					break;

  				case 'SpotLight':
  					uniforms = {
  						shadowIntensity: 1,
  						shadowBias: 0,
  						shadowNormalBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2()
  					};
  					break;

  				case 'PointLight':
  					uniforms = {
  						shadowIntensity: 1,
  						shadowBias: 0,
  						shadowNormalBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2(),
  						shadowCameraNear: 1,
  						shadowCameraFar: 1000
  					};
  					break;

  				// TODO (abelnation): set RectAreaLight shadow uniforms

  			}

  			lights[ light.id ] = uniforms;

  			return uniforms;

  		}

  	};

  }



  let nextVersion = 0;

  function shadowCastingAndTexturingLightsFirst( lightA, lightB ) {

  	return ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );

  }

  function WebGLLights( extensions ) {

  	const cache = new UniformsCache();

  	const shadowCache = ShadowUniformsCache();

  	const state = {

  		version: 0,

  		hash: {
  			directionalLength: -1,
  			pointLength: -1,
  			spotLength: -1,
  			rectAreaLength: -1,
  			hemiLength: -1,

  			numDirectionalShadows: -1,
  			numPointShadows: -1,
  			numSpotShadows: -1,
  			numSpotMaps: -1,

  			numLightProbes: -1
  		},

  		ambient: [ 0, 0, 0 ],
  		probe: [],
  		directional: [],
  		directionalShadow: [],
  		directionalShadowMap: [],
  		directionalShadowMatrix: [],
  		spot: [],
  		spotLightMap: [],
  		spotShadow: [],
  		spotShadowMap: [],
  		spotLightMatrix: [],
  		rectArea: [],
  		rectAreaLTC1: null,
  		rectAreaLTC2: null,
  		point: [],
  		pointShadow: [],
  		pointShadowMap: [],
  		pointShadowMatrix: [],
  		hemi: [],
  		numSpotLightShadowsWithMaps: 0,
  		numLightProbes: 0

  	};

  	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

  	const vector3 = new Vector3();
  	const matrix4 = new Matrix4();
  	const matrix42 = new Matrix4();

  	function setup( lights ) {

  		let r = 0, g = 0, b = 0;

  		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

  		let directionalLength = 0;
  		let pointLength = 0;
  		let spotLength = 0;
  		let rectAreaLength = 0;
  		let hemiLength = 0;

  		let numDirectionalShadows = 0;
  		let numPointShadows = 0;
  		let numSpotShadows = 0;
  		let numSpotMaps = 0;
  		let numSpotShadowsWithMaps = 0;

  		let numLightProbes = 0;

  		// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
  		lights.sort( shadowCastingAndTexturingLightsFirst );

  		for ( let i = 0, l = lights.length; i < l; i ++ ) {

  			const light = lights[ i ];

  			const color = light.color;
  			const intensity = light.intensity;
  			const distance = light.distance;

  			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

  			if ( light.isAmbientLight ) {

  				r += color.r * intensity;
  				g += color.g * intensity;
  				b += color.b * intensity;

  			} else if ( light.isLightProbe ) {

  				for ( let j = 0; j < 9; j ++ ) {

  					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

  				}

  				numLightProbes ++;

  			} else if ( light.isDirectionalLight ) {

  				const uniforms = cache.get( light );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

  				if ( light.castShadow ) {

  					const shadow = light.shadow;

  					const shadowUniforms = shadowCache.get( light );

  					shadowUniforms.shadowIntensity = shadow.intensity;
  					shadowUniforms.shadowBias = shadow.bias;
  					shadowUniforms.shadowNormalBias = shadow.normalBias;
  					shadowUniforms.shadowRadius = shadow.radius;
  					shadowUniforms.shadowMapSize = shadow.mapSize;

  					state.directionalShadow[ directionalLength ] = shadowUniforms;
  					state.directionalShadowMap[ directionalLength ] = shadowMap;
  					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

  					numDirectionalShadows ++;

  				}

  				state.directional[ directionalLength ] = uniforms;

  				directionalLength ++;

  			} else if ( light.isSpotLight ) {

  				const uniforms = cache.get( light );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );

  				uniforms.color.copy( color ).multiplyScalar( intensity );
  				uniforms.distance = distance;

  				uniforms.coneCos = Math.cos( light.angle );
  				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
  				uniforms.decay = light.decay;

  				state.spot[ spotLength ] = uniforms;

  				const shadow = light.shadow;

  				if ( light.map ) {

  					state.spotLightMap[ numSpotMaps ] = light.map;
  					numSpotMaps ++;

  					// make sure the lightMatrix is up to date
  					// TODO : do it if required only
  					shadow.updateMatrices( light );

  					if ( light.castShadow ) numSpotShadowsWithMaps ++;

  				}

  				state.spotLightMatrix[ spotLength ] = shadow.matrix;

  				if ( light.castShadow ) {

  					const shadowUniforms = shadowCache.get( light );

  					shadowUniforms.shadowIntensity = shadow.intensity;
  					shadowUniforms.shadowBias = shadow.bias;
  					shadowUniforms.shadowNormalBias = shadow.normalBias;
  					shadowUniforms.shadowRadius = shadow.radius;
  					shadowUniforms.shadowMapSize = shadow.mapSize;

  					state.spotShadow[ spotLength ] = shadowUniforms;
  					state.spotShadowMap[ spotLength ] = shadowMap;

  					numSpotShadows ++;

  				}

  				spotLength ++;

  			} else if ( light.isRectAreaLight ) {

  				const uniforms = cache.get( light );

  				uniforms.color.copy( color ).multiplyScalar( intensity );

  				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
  				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

  				state.rectArea[ rectAreaLength ] = uniforms;

  				rectAreaLength ++;

  			} else if ( light.isPointLight ) {

  				const uniforms = cache.get( light );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
  				uniforms.distance = light.distance;
  				uniforms.decay = light.decay;

  				if ( light.castShadow ) {

  					const shadow = light.shadow;

  					const shadowUniforms = shadowCache.get( light );

  					shadowUniforms.shadowIntensity = shadow.intensity;
  					shadowUniforms.shadowBias = shadow.bias;
  					shadowUniforms.shadowNormalBias = shadow.normalBias;
  					shadowUniforms.shadowRadius = shadow.radius;
  					shadowUniforms.shadowMapSize = shadow.mapSize;
  					shadowUniforms.shadowCameraNear = shadow.camera.near;
  					shadowUniforms.shadowCameraFar = shadow.camera.far;

  					state.pointShadow[ pointLength ] = shadowUniforms;
  					state.pointShadowMap[ pointLength ] = shadowMap;
  					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

  					numPointShadows ++;

  				}

  				state.point[ pointLength ] = uniforms;

  				pointLength ++;

  			} else if ( light.isHemisphereLight ) {

  				const uniforms = cache.get( light );

  				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
  				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

  				state.hemi[ hemiLength ] = uniforms;

  				hemiLength ++;

  			}

  		}

  		if ( rectAreaLength > 0 ) {

  			if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

  				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
  				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

  			} else {

  				state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
  				state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

  			}

  		}

  		state.ambient[ 0 ] = r;
  		state.ambient[ 1 ] = g;
  		state.ambient[ 2 ] = b;

  		const hash = state.hash;

  		if ( hash.directionalLength !== directionalLength ||
  			hash.pointLength !== pointLength ||
  			hash.spotLength !== spotLength ||
  			hash.rectAreaLength !== rectAreaLength ||
  			hash.hemiLength !== hemiLength ||
  			hash.numDirectionalShadows !== numDirectionalShadows ||
  			hash.numPointShadows !== numPointShadows ||
  			hash.numSpotShadows !== numSpotShadows ||
  			hash.numSpotMaps !== numSpotMaps ||
  			hash.numLightProbes !== numLightProbes ) {

  			state.directional.length = directionalLength;
  			state.spot.length = spotLength;
  			state.rectArea.length = rectAreaLength;
  			state.point.length = pointLength;
  			state.hemi.length = hemiLength;

  			state.directionalShadow.length = numDirectionalShadows;
  			state.directionalShadowMap.length = numDirectionalShadows;
  			state.pointShadow.length = numPointShadows;
  			state.pointShadowMap.length = numPointShadows;
  			state.spotShadow.length = numSpotShadows;
  			state.spotShadowMap.length = numSpotShadows;
  			state.directionalShadowMatrix.length = numDirectionalShadows;
  			state.pointShadowMatrix.length = numPointShadows;
  			state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
  			state.spotLightMap.length = numSpotMaps;
  			state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
  			state.numLightProbes = numLightProbes;

  			hash.directionalLength = directionalLength;
  			hash.pointLength = pointLength;
  			hash.spotLength = spotLength;
  			hash.rectAreaLength = rectAreaLength;
  			hash.hemiLength = hemiLength;

  			hash.numDirectionalShadows = numDirectionalShadows;
  			hash.numPointShadows = numPointShadows;
  			hash.numSpotShadows = numSpotShadows;
  			hash.numSpotMaps = numSpotMaps;

  			hash.numLightProbes = numLightProbes;

  			state.version = nextVersion ++;

  		}

  	}

  	function setupView( lights, camera ) {

  		let directionalLength = 0;
  		let pointLength = 0;
  		let spotLength = 0;
  		let rectAreaLength = 0;
  		let hemiLength = 0;

  		const viewMatrix = camera.matrixWorldInverse;

  		for ( let i = 0, l = lights.length; i < l; i ++ ) {

  			const light = lights[ i ];

  			if ( light.isDirectionalLight ) {

  				const uniforms = state.directional[ directionalLength ];

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				directionalLength ++;

  			} else if ( light.isSpotLight ) {

  				const uniforms = state.spot[ spotLength ];

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				spotLength ++;

  			} else if ( light.isRectAreaLight ) {

  				const uniforms = state.rectArea[ rectAreaLength ];

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				// extract local rotation of light to derive width/height half vectors
  				matrix42.identity();
  				matrix4.copy( light.matrixWorld );
  				matrix4.premultiply( viewMatrix );
  				matrix42.extractRotation( matrix4 );

  				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
  				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

  				uniforms.halfWidth.applyMatrix4( matrix42 );
  				uniforms.halfHeight.applyMatrix4( matrix42 );

  				rectAreaLength ++;

  			} else if ( light.isPointLight ) {

  				const uniforms = state.point[ pointLength ];

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				pointLength ++;

  			} else if ( light.isHemisphereLight ) {

  				const uniforms = state.hemi[ hemiLength ];

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				uniforms.direction.transformDirection( viewMatrix );

  				hemiLength ++;

  			}

  		}

  	}

  	return {
  		setup: setup,
  		setupView: setupView,
  		state: state
  	};

  }

  function WebGLRenderState( extensions ) {

  	const lights = new WebGLLights( extensions );

  	const lightsArray = [];
  	const shadowsArray = [];

  	function init( camera ) {

  		state.camera = camera;

  		lightsArray.length = 0;
  		shadowsArray.length = 0;

  	}

  	function pushLight( light ) {

  		lightsArray.push( light );

  	}

  	function pushShadow( shadowLight ) {

  		shadowsArray.push( shadowLight );

  	}

  	function setupLights() {

  		lights.setup( lightsArray );

  	}

  	function setupLightsView( camera ) {

  		lights.setupView( lightsArray, camera );

  	}

  	const state = {
  		lightsArray: lightsArray,
  		shadowsArray: shadowsArray,

  		camera: null,

  		lights: lights,

  		transmissionRenderTarget: {}
  	};

  	return {
  		init: init,
  		state: state,
  		setupLights: setupLights,
  		setupLightsView: setupLightsView,

  		pushLight: pushLight,
  		pushShadow: pushShadow
  	};

  }

  function WebGLRenderStates( extensions ) {

  	let renderStates = new WeakMap();

  	function get( scene, renderCallDepth = 0 ) {

  		const renderStateArray = renderStates.get( scene );
  		let renderState;

  		if ( renderStateArray === undefined ) {

  			renderState = new WebGLRenderState( extensions );
  			renderStates.set( scene, [ renderState ] );

  		} else {

  			if ( renderCallDepth >= renderStateArray.length ) {

  				renderState = new WebGLRenderState( extensions );
  				renderStateArray.push( renderState );

  			} else {

  				renderState = renderStateArray[ renderCallDepth ];

  			}

  		}

  		return renderState;

  	}

  	function dispose() {

  		renderStates = new WeakMap();

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

  const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

  function WebGLShadowMap( renderer, objects, capabilities ) {

  	let _frustum = new Frustum();

  	const _shadowMapSize = new Vector2(),
  		_viewportSize = new Vector2(),

  		_viewport = new Vector4(),

  		_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
  		_distanceMaterial = new MeshDistanceMaterial(),

  		_materialCache = {},

  		_maxTextureSize = capabilities.maxTextureSize;

  	const shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };

  	const shadowMaterialVertical = new ShaderMaterial( {
  		defines: {
  			VSM_SAMPLES: 8
  		},
  		uniforms: {
  			shadow_pass: { value: null },
  			resolution: { value: new Vector2() },
  			radius: { value: 4.0 }
  		},

  		vertexShader: vertex,
  		fragmentShader: fragment

  	} );

  	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

  	const fullScreenTri = new BufferGeometry();
  	fullScreenTri.setAttribute(
  		'position',
  		new BufferAttribute(
  			new Float32Array( [ -1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5 ] ),
  			3
  		)
  	);

  	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

  	const scope = this;

  	this.enabled = false;

  	this.autoUpdate = true;
  	this.needsUpdate = false;

  	this.type = PCFShadowMap;
  	let _previousType = this.type;

  	this.render = function ( lights, scene, camera ) {

  		if ( scope.enabled === false ) return;
  		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

  		if ( lights.length === 0 ) return;

  		const currentRenderTarget = renderer.getRenderTarget();
  		const activeCubeFace = renderer.getActiveCubeFace();
  		const activeMipmapLevel = renderer.getActiveMipmapLevel();

  		const _state = renderer.state;

  		// Set GL state for depth map.
  		_state.setBlending( NoBlending );

  		if ( _state.buffers.depth.getReversed() === true ) {

  			_state.buffers.color.setClear( 0, 0, 0, 0 );

  		} else {

  			_state.buffers.color.setClear( 1, 1, 1, 1 );

  		}

  		_state.buffers.depth.setTest( true );
  		_state.setScissorTest( false );

  		// check for shadow map type changes

  		const toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );
  		const fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );

  		// render depth map

  		for ( let i = 0, il = lights.length; i < il; i ++ ) {

  			const light = lights[ i ];
  			const shadow = light.shadow;

  			if ( shadow === undefined ) {

  				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
  				continue;

  			}

  			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

  			_shadowMapSize.copy( shadow.mapSize );

  			const shadowFrameExtents = shadow.getFrameExtents();

  			_shadowMapSize.multiply( shadowFrameExtents );

  			_viewportSize.copy( shadow.mapSize );

  			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

  				if ( _shadowMapSize.x > _maxTextureSize ) {

  					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
  					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
  					shadow.mapSize.x = _viewportSize.x;

  				}

  				if ( _shadowMapSize.y > _maxTextureSize ) {

  					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
  					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
  					shadow.mapSize.y = _viewportSize.y;

  				}

  			}

  			if ( shadow.map === null || toVSM === true || fromVSM === true ) {

  				const pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};

  				if ( shadow.map !== null ) {

  					shadow.map.dispose();

  				}

  				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
  				shadow.map.texture.name = light.name + '.shadowMap';

  				shadow.camera.updateProjectionMatrix();

  			}

  			renderer.setRenderTarget( shadow.map );
  			renderer.clear();

  			const viewportCount = shadow.getViewportCount();

  			for ( let vp = 0; vp < viewportCount; vp ++ ) {

  				const viewport = shadow.getViewport( vp );

  				_viewport.set(
  					_viewportSize.x * viewport.x,
  					_viewportSize.y * viewport.y,
  					_viewportSize.x * viewport.z,
  					_viewportSize.y * viewport.w
  				);

  				_state.viewport( _viewport );

  				shadow.updateMatrices( light, vp );

  				_frustum = shadow.getFrustum();

  				renderObject( scene, camera, shadow.camera, light, this.type );

  			}

  			// do blur pass for VSM

  			if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {

  				VSMPass( shadow, camera );

  			}

  			shadow.needsUpdate = false;

  		}

  		_previousType = this.type;

  		scope.needsUpdate = false;

  		renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

  	};

  	function VSMPass( shadow, camera ) {

  		const geometry = objects.update( fullScreenMesh );

  		if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

  			shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
  			shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

  			shadowMaterialVertical.needsUpdate = true;
  			shadowMaterialHorizontal.needsUpdate = true;

  		}

  		if ( shadow.mapPass === null ) {

  			shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

  		}

  		// vertical pass

  		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
  		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
  		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
  		renderer.setRenderTarget( shadow.mapPass );
  		renderer.clear();
  		renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

  		// horizontal pass

  		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
  		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
  		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
  		renderer.setRenderTarget( shadow.map );
  		renderer.clear();
  		renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

  	}

  	function getDepthMaterial( object, material, light, type ) {

  		let result = null;

  		const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

  		if ( customMaterial !== undefined ) {

  			result = customMaterial;

  		} else {

  			result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

  			if ( ( renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||
  				( material.displacementMap && material.displacementScale !== 0 ) ||
  				( material.alphaMap && material.alphaTest > 0 ) ||
  				( material.map && material.alphaTest > 0 ) ||
  				( material.alphaToCoverage === true ) ) {

  				// in this case we need a unique material instance reflecting the
  				// appropriate state

  				const keyA = result.uuid, keyB = material.uuid;

  				let materialsForVariant = _materialCache[ keyA ];

  				if ( materialsForVariant === undefined ) {

  					materialsForVariant = {};
  					_materialCache[ keyA ] = materialsForVariant;

  				}

  				let cachedMaterial = materialsForVariant[ keyB ];

  				if ( cachedMaterial === undefined ) {

  					cachedMaterial = result.clone();
  					materialsForVariant[ keyB ] = cachedMaterial;
  					material.addEventListener( 'dispose', onMaterialDispose );

  				}

  				result = cachedMaterial;

  			}

  		}

  		result.visible = material.visible;
  		result.wireframe = material.wireframe;

  		if ( type === VSMShadowMap ) {

  			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

  		} else {

  			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

  		}

  		result.alphaMap = material.alphaMap;
  		result.alphaTest = ( material.alphaToCoverage === true ) ? 0.5 : material.alphaTest; // approximate alphaToCoverage by using a fixed alphaTest value
  		result.map = material.map;

  		result.clipShadows = material.clipShadows;
  		result.clippingPlanes = material.clippingPlanes;
  		result.clipIntersection = material.clipIntersection;

  		result.displacementMap = material.displacementMap;
  		result.displacementScale = material.displacementScale;
  		result.displacementBias = material.displacementBias;

  		result.wireframeLinewidth = material.wireframeLinewidth;
  		result.linewidth = material.linewidth;

  		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

  			const materialProperties = renderer.properties.get( result );
  			materialProperties.light = light;

  		}

  		return result;

  	}

  	function renderObject( object, camera, shadowCamera, light, type ) {

  		if ( object.visible === false ) return;

  		const visible = object.layers.test( camera.layers );

  		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

  			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

  				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

  				const geometry = objects.update( object );
  				const material = object.material;

  				if ( Array.isArray( material ) ) {

  					const groups = geometry.groups;

  					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

  						const group = groups[ k ];
  						const groupMaterial = material[ group.materialIndex ];

  						if ( groupMaterial && groupMaterial.visible ) {

  							const depthMaterial = getDepthMaterial( object, groupMaterial, light, type );

  							object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

  							renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

  							object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, group );

  						}

  					}

  				} else if ( material.visible ) {

  					const depthMaterial = getDepthMaterial( object, material, light, type );

  					object.onBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

  					renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

  					object.onAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial, null );

  				}

  			}

  		}

  		const children = object.children;

  		for ( let i = 0, l = children.length; i < l; i ++ ) {

  			renderObject( children[ i ], camera, shadowCamera, light, type );

  		}

  	}

  	function onMaterialDispose( event ) {

  		const material = event.target;

  		material.removeEventListener( 'dispose', onMaterialDispose );

  		// make sure to remove the unique distance/depth materials used for shadow map rendering

  		for ( const id in _materialCache ) {

  			const cache = _materialCache[ id ];

  			const uuid = event.target.uuid;

  			if ( uuid in cache ) {

  				const shadowMaterial = cache[ uuid ];
  				shadowMaterial.dispose();
  				delete cache[ uuid ];

  			}

  		}

  	}

  }

  const reversedFuncs = {
  	[ NeverDepth ]: AlwaysDepth,
  	[ LessDepth ]: GreaterDepth,
  	[ EqualDepth ]: NotEqualDepth,
  	[ LessEqualDepth ]: GreaterEqualDepth,

  	[ AlwaysDepth ]: NeverDepth,
  	[ GreaterDepth ]: LessDepth,
  	[ NotEqualDepth ]: EqualDepth,
  	[ GreaterEqualDepth ]: LessEqualDepth,
  };

  function WebGLState( gl, extensions ) {

  	function ColorBuffer() {

  		let locked = false;

  		const color = new Vector4();
  		let currentColorMask = null;
  		const currentColorClear = new Vector4( 0, 0, 0, 0 );

  		return {

  			setMask: function ( colorMask ) {

  				if ( currentColorMask !== colorMask && ! locked ) {

  					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
  					currentColorMask = colorMask;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( r, g, b, a, premultipliedAlpha ) {

  				if ( premultipliedAlpha === true ) {

  					r *= a; g *= a; b *= a;

  				}

  				color.set( r, g, b, a );

  				if ( currentColorClear.equals( color ) === false ) {

  					gl.clearColor( r, g, b, a );
  					currentColorClear.copy( color );

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentColorMask = null;
  				currentColorClear.set( -1, 0, 0, 0 ); // set to invalid state

  			}

  		};

  	}

  	function DepthBuffer() {

  		let locked = false;

  		let currentReversed = false;
  		let currentDepthMask = null;
  		let currentDepthFunc = null;
  		let currentDepthClear = null;

  		return {

  			setReversed: function ( reversed ) {

  				if ( currentReversed !== reversed ) {

  					const ext = extensions.get( 'EXT_clip_control' );

  					if ( reversed ) {

  						ext.clipControlEXT( ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT );

  					} else {

  						ext.clipControlEXT( ext.LOWER_LEFT_EXT, ext.NEGATIVE_ONE_TO_ONE_EXT );

  					}

  					currentReversed = reversed;

  					const oldDepth = currentDepthClear;
  					currentDepthClear = null;
  					this.setClear( oldDepth );

  				}

  			},

  			getReversed: function () {

  				return currentReversed;

  			},

  			setTest: function ( depthTest ) {

  				if ( depthTest ) {

  					enable( gl.DEPTH_TEST );

  				} else {

  					disable( gl.DEPTH_TEST );

  				}

  			},

  			setMask: function ( depthMask ) {

  				if ( currentDepthMask !== depthMask && ! locked ) {

  					gl.depthMask( depthMask );
  					currentDepthMask = depthMask;

  				}

  			},

  			setFunc: function ( depthFunc ) {

  				if ( currentReversed ) depthFunc = reversedFuncs[ depthFunc ];

  				if ( currentDepthFunc !== depthFunc ) {

  					switch ( depthFunc ) {

  						case NeverDepth:

  							gl.depthFunc( gl.NEVER );
  							break;

  						case AlwaysDepth:

  							gl.depthFunc( gl.ALWAYS );
  							break;

  						case LessDepth:

  							gl.depthFunc( gl.LESS );
  							break;

  						case LessEqualDepth:

  							gl.depthFunc( gl.LEQUAL );
  							break;

  						case EqualDepth:

  							gl.depthFunc( gl.EQUAL );
  							break;

  						case GreaterEqualDepth:

  							gl.depthFunc( gl.GEQUAL );
  							break;

  						case GreaterDepth:

  							gl.depthFunc( gl.GREATER );
  							break;

  						case NotEqualDepth:

  							gl.depthFunc( gl.NOTEQUAL );
  							break;

  						default:

  							gl.depthFunc( gl.LEQUAL );

  					}

  					currentDepthFunc = depthFunc;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( depth ) {

  				if ( currentDepthClear !== depth ) {

  					if ( currentReversed ) {

  						depth = 1 - depth;

  					}

  					gl.clearDepth( depth );
  					currentDepthClear = depth;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentDepthMask = null;
  				currentDepthFunc = null;
  				currentDepthClear = null;
  				currentReversed = false;

  			}

  		};

  	}

  	function StencilBuffer() {

  		let locked = false;

  		let currentStencilMask = null;
  		let currentStencilFunc = null;
  		let currentStencilRef = null;
  		let currentStencilFuncMask = null;
  		let currentStencilFail = null;
  		let currentStencilZFail = null;
  		let currentStencilZPass = null;
  		let currentStencilClear = null;

  		return {

  			setTest: function ( stencilTest ) {

  				if ( ! locked ) {

  					if ( stencilTest ) {

  						enable( gl.STENCIL_TEST );

  					} else {

  						disable( gl.STENCIL_TEST );

  					}

  				}

  			},

  			setMask: function ( stencilMask ) {

  				if ( currentStencilMask !== stencilMask && ! locked ) {

  					gl.stencilMask( stencilMask );
  					currentStencilMask = stencilMask;

  				}

  			},

  			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

  				if ( currentStencilFunc !== stencilFunc ||
  				     currentStencilRef !== stencilRef ||
  				     currentStencilFuncMask !== stencilMask ) {

  					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

  					currentStencilFunc = stencilFunc;
  					currentStencilRef = stencilRef;
  					currentStencilFuncMask = stencilMask;

  				}

  			},

  			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

  				if ( currentStencilFail !== stencilFail ||
  				     currentStencilZFail !== stencilZFail ||
  				     currentStencilZPass !== stencilZPass ) {

  					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

  					currentStencilFail = stencilFail;
  					currentStencilZFail = stencilZFail;
  					currentStencilZPass = stencilZPass;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( stencil ) {

  				if ( currentStencilClear !== stencil ) {

  					gl.clearStencil( stencil );
  					currentStencilClear = stencil;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentStencilMask = null;
  				currentStencilFunc = null;
  				currentStencilRef = null;
  				currentStencilFuncMask = null;
  				currentStencilFail = null;
  				currentStencilZFail = null;
  				currentStencilZPass = null;
  				currentStencilClear = null;

  			}

  		};

  	}

  	//

  	const colorBuffer = new ColorBuffer();
  	const depthBuffer = new DepthBuffer();
  	const stencilBuffer = new StencilBuffer();

  	const uboBindings = new WeakMap();
  	const uboProgramMap = new WeakMap();

  	let enabledCapabilities = {};

  	let currentBoundFramebuffers = {};
  	let currentDrawbuffers = new WeakMap();
  	let defaultDrawbuffers = [];

  	let currentProgram = null;

  	let currentBlendingEnabled = false;
  	let currentBlending = null;
  	let currentBlendEquation = null;
  	let currentBlendSrc = null;
  	let currentBlendDst = null;
  	let currentBlendEquationAlpha = null;
  	let currentBlendSrcAlpha = null;
  	let currentBlendDstAlpha = null;
  	let currentBlendColor = new Color( 0, 0, 0 );
  	let currentBlendAlpha = 0;
  	let currentPremultipledAlpha = false;

  	let currentFlipSided = null;
  	let currentCullFace = null;

  	let currentLineWidth = null;

  	let currentPolygonOffsetFactor = null;
  	let currentPolygonOffsetUnits = null;

  	const maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

  	let lineWidthAvailable = false;
  	let version = 0;
  	const glVersion = gl.getParameter( gl.VERSION );

  	if ( glVersion.indexOf( 'WebGL' ) !== -1 ) {

  		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
  		lineWidthAvailable = ( version >= 1.0 );

  	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== -1 ) {

  		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
  		lineWidthAvailable = ( version >= 2.0 );

  	}

  	let currentTextureSlot = null;
  	let currentBoundTextures = {};

  	const scissorParam = gl.getParameter( gl.SCISSOR_BOX );
  	const viewportParam = gl.getParameter( gl.VIEWPORT );

  	const currentScissor = new Vector4().fromArray( scissorParam );
  	const currentViewport = new Vector4().fromArray( viewportParam );

  	function createTexture( type, target, count, dimensions ) {

  		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
  		const texture = gl.createTexture();

  		gl.bindTexture( type, texture );
  		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
  		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

  		for ( let i = 0; i < count; i ++ ) {

  			if ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) {

  				gl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

  			} else {

  				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

  			}

  		}

  		return texture;

  	}

  	const emptyTextures = {};
  	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
  	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
  	emptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );
  	emptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );

  	// init

  	colorBuffer.setClear( 0, 0, 0, 1 );
  	depthBuffer.setClear( 1 );
  	stencilBuffer.setClear( 0 );

  	enable( gl.DEPTH_TEST );
  	depthBuffer.setFunc( LessEqualDepth );

  	setFlipSided( false );
  	setCullFace( CullFaceBack );
  	enable( gl.CULL_FACE );

  	setBlending( NoBlending );

  	//

  	function enable( id ) {

  		if ( enabledCapabilities[ id ] !== true ) {

  			gl.enable( id );
  			enabledCapabilities[ id ] = true;

  		}

  	}

  	function disable( id ) {

  		if ( enabledCapabilities[ id ] !== false ) {

  			gl.disable( id );
  			enabledCapabilities[ id ] = false;

  		}

  	}

  	function bindFramebuffer( target, framebuffer ) {

  		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

  			gl.bindFramebuffer( target, framebuffer );

  			currentBoundFramebuffers[ target ] = framebuffer;

  			// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

  			if ( target === gl.DRAW_FRAMEBUFFER ) {

  				currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

  			}

  			if ( target === gl.FRAMEBUFFER ) {

  				currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

  			}

  			return true;

  		}

  		return false;

  	}

  	function drawBuffers( renderTarget, framebuffer ) {

  		let drawBuffers = defaultDrawbuffers;

  		let needsUpdate = false;

  		if ( renderTarget ) {

  			drawBuffers = currentDrawbuffers.get( framebuffer );

  			if ( drawBuffers === undefined ) {

  				drawBuffers = [];
  				currentDrawbuffers.set( framebuffer, drawBuffers );

  			}

  			const textures = renderTarget.textures;

  			if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

  				for ( let i = 0, il = textures.length; i < il; i ++ ) {

  					drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

  				}

  				drawBuffers.length = textures.length;

  				needsUpdate = true;

  			}

  		} else {

  			if ( drawBuffers[ 0 ] !== gl.BACK ) {

  				drawBuffers[ 0 ] = gl.BACK;

  				needsUpdate = true;

  			}

  		}

  		if ( needsUpdate ) {

  			gl.drawBuffers( drawBuffers );

  		}

  	}

  	function useProgram( program ) {

  		if ( currentProgram !== program ) {

  			gl.useProgram( program );

  			currentProgram = program;

  			return true;

  		}

  		return false;

  	}

  	const equationToGL = {
  		[ AddEquation ]: gl.FUNC_ADD,
  		[ SubtractEquation ]: gl.FUNC_SUBTRACT,
  		[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
  	};

  	equationToGL[ MinEquation ] = gl.MIN;
  	equationToGL[ MaxEquation ] = gl.MAX;

  	const factorToGL = {
  		[ ZeroFactor ]: gl.ZERO,
  		[ OneFactor ]: gl.ONE,
  		[ SrcColorFactor ]: gl.SRC_COLOR,
  		[ SrcAlphaFactor ]: gl.SRC_ALPHA,
  		[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
  		[ DstColorFactor ]: gl.DST_COLOR,
  		[ DstAlphaFactor ]: gl.DST_ALPHA,
  		[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
  		[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
  		[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
  		[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA,
  		[ ConstantColorFactor ]: gl.CONSTANT_COLOR,
  		[ OneMinusConstantColorFactor ]: gl.ONE_MINUS_CONSTANT_COLOR,
  		[ ConstantAlphaFactor ]: gl.CONSTANT_ALPHA,
  		[ OneMinusConstantAlphaFactor ]: gl.ONE_MINUS_CONSTANT_ALPHA
  	};

  	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha ) {

  		if ( blending === NoBlending ) {

  			if ( currentBlendingEnabled === true ) {

  				disable( gl.BLEND );
  				currentBlendingEnabled = false;

  			}

  			return;

  		}

  		if ( currentBlendingEnabled === false ) {

  			enable( gl.BLEND );
  			currentBlendingEnabled = true;

  		}

  		if ( blending !== CustomBlending ) {

  			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

  				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

  					gl.blendEquation( gl.FUNC_ADD );

  					currentBlendEquation = AddEquation;
  					currentBlendEquationAlpha = AddEquation;

  				}

  				if ( premultipliedAlpha ) {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
  							break;

  						case AdditiveBlending:
  							gl.blendFunc( gl.ONE, gl.ONE );
  							break;

  						case SubtractiveBlending:
  							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
  							break;

  						case MultiplyBlending:
  							gl.blendFuncSeparate( gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE );
  							break;

  						default:
  							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				} else {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
  							break;

  						case AdditiveBlending:
  							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE );
  							break;

  						case SubtractiveBlending:
  							console.error( 'THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true' );
  							break;

  						case MultiplyBlending:
  							console.error( 'THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true' );
  							break;

  						default:
  							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				}

  				currentBlendSrc = null;
  				currentBlendDst = null;
  				currentBlendSrcAlpha = null;
  				currentBlendDstAlpha = null;
  				currentBlendColor.set( 0, 0, 0 );
  				currentBlendAlpha = 0;

  				currentBlending = blending;
  				currentPremultipledAlpha = premultipliedAlpha;

  			}

  			return;

  		}

  		// custom blending

  		blendEquationAlpha = blendEquationAlpha || blendEquation;
  		blendSrcAlpha = blendSrcAlpha || blendSrc;
  		blendDstAlpha = blendDstAlpha || blendDst;

  		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

  			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

  			currentBlendEquation = blendEquation;
  			currentBlendEquationAlpha = blendEquationAlpha;

  		}

  		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

  			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

  			currentBlendSrc = blendSrc;
  			currentBlendDst = blendDst;
  			currentBlendSrcAlpha = blendSrcAlpha;
  			currentBlendDstAlpha = blendDstAlpha;

  		}

  		if ( blendColor.equals( currentBlendColor ) === false || blendAlpha !== currentBlendAlpha ) {

  			gl.blendColor( blendColor.r, blendColor.g, blendColor.b, blendAlpha );

  			currentBlendColor.copy( blendColor );
  			currentBlendAlpha = blendAlpha;

  		}

  		currentBlending = blending;
  		currentPremultipledAlpha = false;

  	}

  	function setMaterial( material, frontFaceCW ) {

  		material.side === DoubleSide
  			? disable( gl.CULL_FACE )
  			: enable( gl.CULL_FACE );

  		let flipSided = ( material.side === BackSide );
  		if ( frontFaceCW ) flipSided = ! flipSided;

  		setFlipSided( flipSided );

  		( material.blending === NormalBlending && material.transparent === false )
  			? setBlending( NoBlending )
  			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha );

  		depthBuffer.setFunc( material.depthFunc );
  		depthBuffer.setTest( material.depthTest );
  		depthBuffer.setMask( material.depthWrite );
  		colorBuffer.setMask( material.colorWrite );

  		const stencilWrite = material.stencilWrite;
  		stencilBuffer.setTest( stencilWrite );
  		if ( stencilWrite ) {

  			stencilBuffer.setMask( material.stencilWriteMask );
  			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
  			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

  		}

  		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  		material.alphaToCoverage === true
  			? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
  			: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

  	}

  	//

  	function setFlipSided( flipSided ) {

  		if ( currentFlipSided !== flipSided ) {

  			if ( flipSided ) {

  				gl.frontFace( gl.CW );

  			} else {

  				gl.frontFace( gl.CCW );

  			}

  			currentFlipSided = flipSided;

  		}

  	}

  	function setCullFace( cullFace ) {

  		if ( cullFace !== CullFaceNone ) {

  			enable( gl.CULL_FACE );

  			if ( cullFace !== currentCullFace ) {

  				if ( cullFace === CullFaceBack ) {

  					gl.cullFace( gl.BACK );

  				} else if ( cullFace === CullFaceFront ) {

  					gl.cullFace( gl.FRONT );

  				} else {

  					gl.cullFace( gl.FRONT_AND_BACK );

  				}

  			}

  		} else {

  			disable( gl.CULL_FACE );

  		}

  		currentCullFace = cullFace;

  	}

  	function setLineWidth( width ) {

  		if ( width !== currentLineWidth ) {

  			if ( lineWidthAvailable ) gl.lineWidth( width );

  			currentLineWidth = width;

  		}

  	}

  	function setPolygonOffset( polygonOffset, factor, units ) {

  		if ( polygonOffset ) {

  			enable( gl.POLYGON_OFFSET_FILL );

  			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

  				gl.polygonOffset( factor, units );

  				currentPolygonOffsetFactor = factor;
  				currentPolygonOffsetUnits = units;

  			}

  		} else {

  			disable( gl.POLYGON_OFFSET_FILL );

  		}

  	}

  	function setScissorTest( scissorTest ) {

  		if ( scissorTest ) {

  			enable( gl.SCISSOR_TEST );

  		} else {

  			disable( gl.SCISSOR_TEST );

  		}

  	}

  	// texture

  	function activeTexture( webglSlot ) {

  		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

  		if ( currentTextureSlot !== webglSlot ) {

  			gl.activeTexture( webglSlot );
  			currentTextureSlot = webglSlot;

  		}

  	}

  	function bindTexture( webglType, webglTexture, webglSlot ) {

  		if ( webglSlot === undefined ) {

  			if ( currentTextureSlot === null ) {

  				webglSlot = gl.TEXTURE0 + maxTextures - 1;

  			} else {

  				webglSlot = currentTextureSlot;

  			}

  		}

  		let boundTexture = currentBoundTextures[ webglSlot ];

  		if ( boundTexture === undefined ) {

  			boundTexture = { type: undefined, texture: undefined };
  			currentBoundTextures[ webglSlot ] = boundTexture;

  		}

  		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

  			if ( currentTextureSlot !== webglSlot ) {

  				gl.activeTexture( webglSlot );
  				currentTextureSlot = webglSlot;

  			}

  			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

  			boundTexture.type = webglType;
  			boundTexture.texture = webglTexture;

  		}

  	}

  	function unbindTexture() {

  		const boundTexture = currentBoundTextures[ currentTextureSlot ];

  		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

  			gl.bindTexture( boundTexture.type, null );

  			boundTexture.type = undefined;
  			boundTexture.texture = undefined;

  		}

  	}

  	function compressedTexImage2D() {

  		try {

  			gl.compressedTexImage2D( ...arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function compressedTexImage3D() {

  		try {

  			gl.compressedTexImage3D( ...arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texSubImage2D() {

  		try {

  			gl.texSubImage2D( ...arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texSubImage3D() {

  		try {

  			gl.texSubImage3D( ...arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function compressedTexSubImage2D() {

  		try {

  			gl.compressedTexSubImage2D( ...arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function compressedTexSubImage3D() {

  		try {

  			gl.compressedTexSubImage3D( ...arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texStorage2D() {

  		try {

  			gl.texStorage2D( ...arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texStorage3D() {

  		try {

  			gl.texStorage3D( ...arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texImage2D() {

  		try {

  			gl.texImage2D( ...arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texImage3D() {

  		try {

  			gl.texImage3D( ...arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	//

  	function scissor( scissor ) {

  		if ( currentScissor.equals( scissor ) === false ) {

  			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
  			currentScissor.copy( scissor );

  		}

  	}

  	function viewport( viewport ) {

  		if ( currentViewport.equals( viewport ) === false ) {

  			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
  			currentViewport.copy( viewport );

  		}

  	}

  	function updateUBOMapping( uniformsGroup, program ) {

  		let mapping = uboProgramMap.get( program );

  		if ( mapping === undefined ) {

  			mapping = new WeakMap();

  			uboProgramMap.set( program, mapping );

  		}

  		let blockIndex = mapping.get( uniformsGroup );

  		if ( blockIndex === undefined ) {

  			blockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );

  			mapping.set( uniformsGroup, blockIndex );

  		}

  	}

  	function uniformBlockBinding( uniformsGroup, program ) {

  		const mapping = uboProgramMap.get( program );
  		const blockIndex = mapping.get( uniformsGroup );

  		if ( uboBindings.get( program ) !== blockIndex ) {

  			// bind shader specific block index to global block point
  			gl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );

  			uboBindings.set( program, blockIndex );

  		}

  	}

  	//

  	function reset() {

  		// reset state

  		gl.disable( gl.BLEND );
  		gl.disable( gl.CULL_FACE );
  		gl.disable( gl.DEPTH_TEST );
  		gl.disable( gl.POLYGON_OFFSET_FILL );
  		gl.disable( gl.SCISSOR_TEST );
  		gl.disable( gl.STENCIL_TEST );
  		gl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

  		gl.blendEquation( gl.FUNC_ADD );
  		gl.blendFunc( gl.ONE, gl.ZERO );
  		gl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );
  		gl.blendColor( 0, 0, 0, 0 );

  		gl.colorMask( true, true, true, true );
  		gl.clearColor( 0, 0, 0, 0 );

  		gl.depthMask( true );
  		gl.depthFunc( gl.LESS );

  		depthBuffer.setReversed( false );

  		gl.clearDepth( 1 );

  		gl.stencilMask( 0xffffffff );
  		gl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );
  		gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );
  		gl.clearStencil( 0 );

  		gl.cullFace( gl.BACK );
  		gl.frontFace( gl.CCW );

  		gl.polygonOffset( 0, 0 );

  		gl.activeTexture( gl.TEXTURE0 );

  		gl.bindFramebuffer( gl.FRAMEBUFFER, null );
  		gl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );
  		gl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );

  		gl.useProgram( null );

  		gl.lineWidth( 1 );

  		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
  		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

  		// reset internals

  		enabledCapabilities = {};

  		currentTextureSlot = null;
  		currentBoundTextures = {};

  		currentBoundFramebuffers = {};
  		currentDrawbuffers = new WeakMap();
  		defaultDrawbuffers = [];

  		currentProgram = null;

  		currentBlendingEnabled = false;
  		currentBlending = null;
  		currentBlendEquation = null;
  		currentBlendSrc = null;
  		currentBlendDst = null;
  		currentBlendEquationAlpha = null;
  		currentBlendSrcAlpha = null;
  		currentBlendDstAlpha = null;
  		currentBlendColor = new Color( 0, 0, 0 );
  		currentBlendAlpha = 0;
  		currentPremultipledAlpha = false;

  		currentFlipSided = null;
  		currentCullFace = null;

  		currentLineWidth = null;

  		currentPolygonOffsetFactor = null;
  		currentPolygonOffsetUnits = null;

  		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
  		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

  		colorBuffer.reset();
  		depthBuffer.reset();
  		stencilBuffer.reset();

  	}

  	return {

  		buffers: {
  			color: colorBuffer,
  			depth: depthBuffer,
  			stencil: stencilBuffer
  		},

  		enable: enable,
  		disable: disable,

  		bindFramebuffer: bindFramebuffer,
  		drawBuffers: drawBuffers,

  		useProgram: useProgram,

  		setBlending: setBlending,
  		setMaterial: setMaterial,

  		setFlipSided: setFlipSided,
  		setCullFace: setCullFace,

  		setLineWidth: setLineWidth,
  		setPolygonOffset: setPolygonOffset,

  		setScissorTest: setScissorTest,

  		activeTexture: activeTexture,
  		bindTexture: bindTexture,
  		unbindTexture: unbindTexture,
  		compressedTexImage2D: compressedTexImage2D,
  		compressedTexImage3D: compressedTexImage3D,
  		texImage2D: texImage2D,
  		texImage3D: texImage3D,

  		updateUBOMapping: updateUBOMapping,
  		uniformBlockBinding: uniformBlockBinding,

  		texStorage2D: texStorage2D,
  		texStorage3D: texStorage3D,
  		texSubImage2D: texSubImage2D,
  		texSubImage3D: texSubImage3D,
  		compressedTexSubImage2D: compressedTexSubImage2D,
  		compressedTexSubImage3D: compressedTexSubImage3D,

  		scissor: scissor,
  		viewport: viewport,

  		reset: reset

  	};

  }

  function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

  	const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
  	const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );

  	const _imageDimensions = new Vector2();
  	const _videoTextures = new WeakMap();
  	let _canvas;

  	const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

  	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

  	let useOffscreenCanvas = false;

  	try {

  		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
  			// eslint-disable-next-line compat/compat
  			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

  	} catch ( err ) {

  		// Ignore any errors

  	}

  	function createCanvas( width, height ) {

  		// Use OffscreenCanvas when available. Specially needed in web workers

  		return useOffscreenCanvas ?
  			// eslint-disable-next-line compat/compat
  			new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

  	}

  	function resizeImage( image, needsNewCanvas, maxSize ) {

  		let scale = 1;

  		const dimensions = getDimensions( image );

  		// handle case if texture exceeds max size

  		if ( dimensions.width > maxSize || dimensions.height > maxSize ) {

  			scale = maxSize / Math.max( dimensions.width, dimensions.height );

  		}

  		// only perform resize if necessary

  		if ( scale < 1 ) {

  			// only perform resize for certain image types

  			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||
  				( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) ) {

  				const width = Math.floor( scale * dimensions.width );
  				const height = Math.floor( scale * dimensions.height );

  				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

  				// cube textures can't reuse the same canvas

  				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

  				canvas.width = width;
  				canvas.height = height;

  				const context = canvas.getContext( '2d' );
  				context.drawImage( image, 0, 0, width, height );

  				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').' );

  				return canvas;

  			} else {

  				if ( 'data' in image ) {

  					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').' );

  				}

  				return image;

  			}

  		}

  		return image;

  	}

  	function textureNeedsGenerateMipmaps( texture ) {

  		return texture.generateMipmaps;

  	}

  	function generateMipmap( target ) {

  		_gl.generateMipmap( target );

  	}

  	function getTargetType( texture ) {

  		if ( texture.isWebGLCubeRenderTarget ) return _gl.TEXTURE_CUBE_MAP;
  		if ( texture.isWebGL3DRenderTarget ) return _gl.TEXTURE_3D;
  		if ( texture.isWebGLArrayRenderTarget || texture.isCompressedArrayTexture ) return _gl.TEXTURE_2D_ARRAY;
  		return _gl.TEXTURE_2D;

  	}

  	function getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

  		if ( internalFormatName !== null ) {

  			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

  			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

  		}

  		let internalFormat = glFormat;

  		if ( glFormat === _gl.RED ) {

  			if ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;
  			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;
  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;

  		}

  		if ( glFormat === _gl.RED_INTEGER ) {

  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8UI;
  			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.R16UI;
  			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.R32UI;
  			if ( glType === _gl.BYTE ) internalFormat = _gl.R8I;
  			if ( glType === _gl.SHORT ) internalFormat = _gl.R16I;
  			if ( glType === _gl.INT ) internalFormat = _gl.R32I;

  		}

  		if ( glFormat === _gl.RG ) {

  			if ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;
  			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;
  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;

  		}

  		if ( glFormat === _gl.RG_INTEGER ) {

  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8UI;
  			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RG16UI;
  			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RG32UI;
  			if ( glType === _gl.BYTE ) internalFormat = _gl.RG8I;
  			if ( glType === _gl.SHORT ) internalFormat = _gl.RG16I;
  			if ( glType === _gl.INT ) internalFormat = _gl.RG32I;

  		}

  		if ( glFormat === _gl.RGB_INTEGER ) {

  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGB8UI;
  			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RGB16UI;
  			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RGB32UI;
  			if ( glType === _gl.BYTE ) internalFormat = _gl.RGB8I;
  			if ( glType === _gl.SHORT ) internalFormat = _gl.RGB16I;
  			if ( glType === _gl.INT ) internalFormat = _gl.RGB32I;

  		}

  		if ( glFormat === _gl.RGBA_INTEGER ) {

  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGBA8UI;
  			if ( glType === _gl.UNSIGNED_SHORT ) internalFormat = _gl.RGBA16UI;
  			if ( glType === _gl.UNSIGNED_INT ) internalFormat = _gl.RGBA32UI;
  			if ( glType === _gl.BYTE ) internalFormat = _gl.RGBA8I;
  			if ( glType === _gl.SHORT ) internalFormat = _gl.RGBA16I;
  			if ( glType === _gl.INT ) internalFormat = _gl.RGBA32I;

  		}

  		if ( glFormat === _gl.RGB ) {

  			if ( glType === _gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = _gl.RGB9_E5;
  			if ( glType === _gl.UNSIGNED_INT_10F_11F_11F_REV ) internalFormat = _gl.R11F_G11F_B10F;

  		}

  		if ( glFormat === _gl.RGBA ) {

  			const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );

  			if ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;
  			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;
  			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
  			if ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;
  			if ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;

  		}

  		if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
  			internalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||
  			internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

  			extensions.get( 'EXT_color_buffer_float' );

  		}

  		return internalFormat;

  	}

  	function getInternalDepthFormat( useStencil, depthType ) {

  		let glInternalFormat;
  		if ( useStencil ) {

  			if ( depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type ) {

  				glInternalFormat = _gl.DEPTH24_STENCIL8;

  			} else if ( depthType === FloatType ) {

  				glInternalFormat = _gl.DEPTH32F_STENCIL8;

  			} else if ( depthType === UnsignedShortType ) {

  				glInternalFormat = _gl.DEPTH24_STENCIL8;
  				console.warn( 'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.' );

  			}

  		} else {

  			if ( depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type ) {

  				glInternalFormat = _gl.DEPTH_COMPONENT24;

  			} else if ( depthType === FloatType ) {

  				glInternalFormat = _gl.DEPTH_COMPONENT32F;

  			} else if ( depthType === UnsignedShortType ) {

  				glInternalFormat = _gl.DEPTH_COMPONENT16;

  			}

  		}

  		return glInternalFormat;

  	}

  	function getMipLevels( texture, image ) {

  		if ( textureNeedsGenerateMipmaps( texture ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

  			return Math.log2( Math.max( image.width, image.height ) ) + 1;

  		} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

  			// user-defined mipmaps

  			return texture.mipmaps.length;

  		} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

  			return image.mipmaps.length;

  		} else {

  			// texture without mipmaps (only base level)

  			return 1;

  		}

  	}

  	//

  	function onTextureDispose( event ) {

  		const texture = event.target;

  		texture.removeEventListener( 'dispose', onTextureDispose );

  		deallocateTexture( texture );

  		if ( texture.isVideoTexture ) {

  			_videoTextures.delete( texture );

  		}

  	}

  	function onRenderTargetDispose( event ) {

  		const renderTarget = event.target;

  		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

  		deallocateRenderTarget( renderTarget );

  	}

  	//

  	function deallocateTexture( texture ) {

  		const textureProperties = properties.get( texture );

  		if ( textureProperties.__webglInit === undefined ) return;

  		// check if it's necessary to remove the WebGLTexture object

  		const source = texture.source;
  		const webglTextures = _sources.get( source );

  		if ( webglTextures ) {

  			const webglTexture = webglTextures[ textureProperties.__cacheKey ];
  			webglTexture.usedTimes --;

  			// the WebGLTexture object is not used anymore, remove it

  			if ( webglTexture.usedTimes === 0 ) {

  				deleteTexture( texture );

  			}

  			// remove the weak map entry if no WebGLTexture uses the source anymore

  			if ( Object.keys( webglTextures ).length === 0 ) {

  				_sources.delete( source );

  			}

  		}

  		properties.remove( texture );

  	}

  	function deleteTexture( texture ) {

  		const textureProperties = properties.get( texture );
  		_gl.deleteTexture( textureProperties.__webglTexture );

  		const source = texture.source;
  		const webglTextures = _sources.get( source );
  		delete webglTextures[ textureProperties.__cacheKey ];

  		info.memory.textures --;

  	}

  	function deallocateRenderTarget( renderTarget ) {

  		const renderTargetProperties = properties.get( renderTarget );

  		if ( renderTarget.depthTexture ) {

  			renderTarget.depthTexture.dispose();

  			properties.remove( renderTarget.depthTexture );

  		}

  		if ( renderTarget.isWebGLCubeRenderTarget ) {

  			for ( let i = 0; i < 6; i ++ ) {

  				if ( Array.isArray( renderTargetProperties.__webglFramebuffer[ i ] ) ) {

  					for ( let level = 0; level < renderTargetProperties.__webglFramebuffer[ i ].length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ][ level ] );

  				} else {

  					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );

  				}

  				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

  			}

  		} else {

  			if ( Array.isArray( renderTargetProperties.__webglFramebuffer ) ) {

  				for ( let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level ++ ) _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ level ] );

  			} else {

  				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );

  			}

  			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
  			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

  			if ( renderTargetProperties.__webglColorRenderbuffer ) {

  				for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

  					if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

  				}

  			}

  			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

  		}

  		const textures = renderTarget.textures;

  		for ( let i = 0, il = textures.length; i < il; i ++ ) {

  			const attachmentProperties = properties.get( textures[ i ] );

  			if ( attachmentProperties.__webglTexture ) {

  				_gl.deleteTexture( attachmentProperties.__webglTexture );

  				info.memory.textures --;

  			}

  			properties.remove( textures[ i ] );

  		}

  		properties.remove( renderTarget );

  	}

  	//

  	let textureUnits = 0;

  	function resetTextureUnits() {

  		textureUnits = 0;

  	}

  	function allocateTextureUnit() {

  		const textureUnit = textureUnits;

  		if ( textureUnit >= capabilities.maxTextures ) {

  			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

  		}

  		textureUnits += 1;

  		return textureUnit;

  	}

  	function getTextureCacheKey( texture ) {

  		const array = [];

  		array.push( texture.wrapS );
  		array.push( texture.wrapT );
  		array.push( texture.wrapR || 0 );
  		array.push( texture.magFilter );
  		array.push( texture.minFilter );
  		array.push( texture.anisotropy );
  		array.push( texture.internalFormat );
  		array.push( texture.format );
  		array.push( texture.type );
  		array.push( texture.generateMipmaps );
  		array.push( texture.premultiplyAlpha );
  		array.push( texture.flipY );
  		array.push( texture.unpackAlignment );
  		array.push( texture.colorSpace );

  		return array.join();

  	}

  	//

  	function setTexture2D( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.isVideoTexture ) updateVideoTexture( texture );

  		if ( texture.isRenderTargetTexture === false && texture.isExternalTexture !== true && texture.version > 0 && textureProperties.__version !== texture.version ) {

  			const image = texture.image;

  			if ( image === null ) {

  				console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );

  			} else if ( image.complete === false ) {

  				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

  			} else {

  				uploadTexture( textureProperties, texture, slot );
  				return;

  			}

  		} else if ( texture.isExternalTexture ) {

  			textureProperties.__webglTexture = texture.sourceTexture ? texture.sourceTexture : null;

  		}

  		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  	}

  	function setTexture2DArray( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

  			uploadTexture( textureProperties, texture, slot );
  			return;

  		}

  		state.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  	}

  	function setTexture3D( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

  			uploadTexture( textureProperties, texture, slot );
  			return;

  		}

  		state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  	}

  	function setTextureCube( texture, slot ) {

  		const textureProperties = properties.get( texture );

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			uploadCubeTexture( textureProperties, texture, slot );
  			return;

  		}

  		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  	}

  	const wrappingToGL = {
  		[ RepeatWrapping ]: _gl.REPEAT,
  		[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,
  		[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT
  	};

  	const filterToGL = {
  		[ NearestFilter ]: _gl.NEAREST,
  		[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,
  		[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,

  		[ LinearFilter ]: _gl.LINEAR,
  		[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,
  		[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR
  	};

  	const compareToGL = {
  		[ NeverCompare ]: _gl.NEVER,
  		[ AlwaysCompare ]: _gl.ALWAYS,
  		[ LessCompare ]: _gl.LESS,
  		[ LessEqualCompare ]: _gl.LEQUAL,
  		[ EqualCompare ]: _gl.EQUAL,
  		[ GreaterEqualCompare ]: _gl.GEQUAL,
  		[ GreaterCompare ]: _gl.GREATER,
  		[ NotEqualCompare ]: _gl.NOTEQUAL
  	};

  	function setTextureParameters( textureType, texture ) {

  		if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false &&
  			( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
  			texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter ) ) {

  			console.warn( 'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.' );

  		}

  		_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
  		_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

  		if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

  		}

  		_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );
  		_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );

  		if ( texture.compareFunction ) {

  			_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );
  			_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

  		}

  		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

  			if ( texture.magFilter === NearestFilter ) return;
  			if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
  			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension

  			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

  				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );
  				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
  				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

  			}

  		}

  	}

  	function initTexture( textureProperties, texture ) {

  		let forceUpload = false;

  		if ( textureProperties.__webglInit === undefined ) {

  			textureProperties.__webglInit = true;

  			texture.addEventListener( 'dispose', onTextureDispose );

  		}

  		// create Source <-> WebGLTextures mapping if necessary

  		const source = texture.source;
  		let webglTextures = _sources.get( source );

  		if ( webglTextures === undefined ) {

  			webglTextures = {};
  			_sources.set( source, webglTextures );

  		}

  		// check if there is already a WebGLTexture object for the given texture parameters

  		const textureCacheKey = getTextureCacheKey( texture );

  		if ( textureCacheKey !== textureProperties.__cacheKey ) {

  			// if not, create a new instance of WebGLTexture

  			if ( webglTextures[ textureCacheKey ] === undefined ) {

  				// create new entry

  				webglTextures[ textureCacheKey ] = {
  					texture: _gl.createTexture(),
  					usedTimes: 0
  				};

  				info.memory.textures ++;

  				// when a new instance of WebGLTexture was created, a texture upload is required
  				// even if the image contents are identical

  				forceUpload = true;

  			}

  			webglTextures[ textureCacheKey ].usedTimes ++;

  			// every time the texture cache key changes, it's necessary to check if an instance of
  			// WebGLTexture can be deleted in order to avoid a memory leak.

  			const webglTexture = webglTextures[ textureProperties.__cacheKey ];

  			if ( webglTexture !== undefined ) {

  				webglTextures[ textureProperties.__cacheKey ].usedTimes --;

  				if ( webglTexture.usedTimes === 0 ) {

  					deleteTexture( texture );

  				}

  			}

  			// store references to cache key and WebGLTexture object

  			textureProperties.__cacheKey = textureCacheKey;
  			textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

  		}

  		return forceUpload;

  	}

  	function getRow( index, rowLength, componentStride ) {

  		return Math.floor( Math.floor( index / componentStride ) / rowLength );

  	}

  	function updateTexture( texture, image, glFormat, glType ) {

  		const componentStride = 4; // only RGBA supported

  		const updateRanges = texture.updateRanges;

  		if ( updateRanges.length === 0 ) {

  			state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

  		} else {

  			// Before applying update ranges, we merge any adjacent / overlapping
  			// ranges to reduce load on `gl.texSubImage2D`. Empirically, this has led
  			// to performance improvements for applications which make heavy use of
  			// update ranges. Likely due to GPU command overhead.
  			//
  			// Note that to reduce garbage collection between frames, we merge the
  			// update ranges in-place. This is safe because this method will clear the
  			// update ranges once updated.

  			updateRanges.sort( ( a, b ) => a.start - b.start );

  			// To merge the update ranges in-place, we work from left to right in the
  			// existing updateRanges array, merging ranges. This may result in a final
  			// array which is smaller than the original. This index tracks the last
  			// index representing a merged range, any data after this index can be
  			// trimmed once the merge algorithm is completed.
  			let mergeIndex = 0;

  			for ( let i = 1; i < updateRanges.length; i ++ ) {

  				const previousRange = updateRanges[ mergeIndex ];
  				const range = updateRanges[ i ];

  				// Only merge if in the same row and overlapping/adjacent
  				const previousEnd = previousRange.start + previousRange.count;
  				const currentRow = getRow( range.start, image.width, componentStride );
  				const previousRow = getRow( previousRange.start, image.width, componentStride );

  				// We add one here to merge adjacent ranges. This is safe because ranges
  				// operate over positive integers.
  				if (
  					range.start <= previousEnd + 1 &&
  					currentRow === previousRow &&
  					getRow( range.start + range.count - 1, image.width, componentStride ) === currentRow // ensure range doesn't spill
  				) {

  					previousRange.count = Math.max(
  						previousRange.count,
  						range.start + range.count - previousRange.start
  					);

  				} else {

  					++ mergeIndex;
  					updateRanges[ mergeIndex ] = range;

  				}


  			}

  			// Trim the array to only contain the merged ranges.
  			updateRanges.length = mergeIndex + 1;

  			const currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
  			const currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
  			const currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );

  			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );

  			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

  				const range = updateRanges[ i ];

  				const pixelStart = Math.floor( range.start / componentStride );
  				const pixelCount = Math.ceil( range.count / componentStride );

  				const x = pixelStart % image.width;
  				const y = Math.floor( pixelStart / image.width );

  				// Assumes update ranges refer to contiguous memory
  				const width = pixelCount;
  				const height = 1;

  				_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, x );
  				_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, y );

  				state.texSubImage2D( _gl.TEXTURE_2D, 0, x, y, width, height, glFormat, glType, image.data );

  			}

  			texture.clearUpdateRanges();

  			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );

  		}

  	}

  	function uploadTexture( textureProperties, texture, slot ) {

  		let textureType = _gl.TEXTURE_2D;

  		if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;
  		if ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;

  		const forceUpload = initTexture( textureProperties, texture );
  		const source = texture.source;

  		state.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  		const sourceProperties = properties.get( source );

  		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

  			state.activeTexture( _gl.TEXTURE0 + slot );

  			const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
  			const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
  			const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

  			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
  			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
  			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
  			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

  			let image = resizeImage( texture.image, false, capabilities.maxTextureSize );
  			image = verifyColorSpace( texture, image );

  			const glFormat = utils.convert( texture.format, texture.colorSpace );

  			const glType = utils.convert( texture.type );
  			let glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );

  			setTextureParameters( textureType, texture );

  			let mipmap;
  			const mipmaps = texture.mipmaps;

  			const useTexStorage = ( texture.isVideoTexture !== true );
  			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
  			const dataReady = source.dataReady;
  			const levels = getMipLevels( texture, image );

  			if ( texture.isDepthTexture ) {

  				glInternalFormat = getInternalDepthFormat( texture.format === DepthStencilFormat, texture.type );

  				//

  				if ( allocateMemory ) {

  					if ( useTexStorage ) {

  						state.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );

  					} else {

  						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

  					}

  				}

  			} else if ( texture.isDataTexture ) {

  				// use manually created mipmaps if available
  				// if there are no manual mipmaps
  				// set 0 level mipmap and then use GL to generate other mipmap levels

  				if ( mipmaps.length > 0 ) {

  					if ( useTexStorage && allocateMemory ) {

  						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

  					}

  					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

  						mipmap = mipmaps[ i ];

  						if ( useTexStorage ) {

  							if ( dataReady ) {

  								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

  							}

  						} else {

  							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  						}

  					}

  					texture.generateMipmaps = false;

  				} else {

  					if ( useTexStorage ) {

  						if ( allocateMemory ) {

  							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

  						}

  						if ( dataReady ) {

  							updateTexture( texture, image, glFormat, glType );

  						}

  					} else {

  						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

  					}

  				}

  			} else if ( texture.isCompressedTexture ) {

  				if ( texture.isCompressedArrayTexture ) {

  					if ( useTexStorage && allocateMemory ) {

  						state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );

  					}

  					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

  						mipmap = mipmaps[ i ];

  						if ( texture.format !== RGBAFormat ) {

  							if ( glFormat !== null ) {

  								if ( useTexStorage ) {

  									if ( dataReady ) {

  										if ( texture.layerUpdates.size > 0 ) {

  											const layerByteLength = getByteLength( mipmap.width, mipmap.height, texture.format, texture.type );

  											for ( const layerIndex of texture.layerUpdates ) {

  												const layerData = mipmap.data.subarray(
  													layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,
  													( layerIndex + 1 ) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT
  												);
  												state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData );

  											}

  											texture.clearLayerUpdates();

  										} else {

  											state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );

  										}

  									}

  								} else {

  									state.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );

  								}

  							} else {

  								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

  							}

  						} else {

  							if ( useTexStorage ) {

  								if ( dataReady ) {

  									state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

  								}

  							} else {

  								state.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );

  							}

  						}

  					}

  				} else {

  					if ( useTexStorage && allocateMemory ) {

  						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

  					}

  					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

  						mipmap = mipmaps[ i ];

  						if ( texture.format !== RGBAFormat ) {

  							if ( glFormat !== null ) {

  								if ( useTexStorage ) {

  									if ( dataReady ) {

  										state.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

  									}

  								} else {

  									state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  								}

  							} else {

  								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

  							}

  						} else {

  							if ( useTexStorage ) {

  								if ( dataReady ) {

  									state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

  								}

  							} else {

  								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  							}

  						}

  					}

  				}

  			} else if ( texture.isDataArrayTexture ) {

  				if ( useTexStorage ) {

  					if ( allocateMemory ) {

  						state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );

  					}

  					if ( dataReady ) {

  						if ( texture.layerUpdates.size > 0 ) {

  							const layerByteLength = getByteLength( image.width, image.height, texture.format, texture.type );

  							for ( const layerIndex of texture.layerUpdates ) {

  								const layerData = image.data.subarray(
  									layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
  									( layerIndex + 1 ) * layerByteLength / image.data.BYTES_PER_ELEMENT
  								);
  								state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData );

  							}

  							texture.clearLayerUpdates();

  						} else {

  							state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

  						}

  					}

  				} else {

  					state.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

  				}

  			} else if ( texture.isData3DTexture ) {

  				if ( useTexStorage ) {

  					if ( allocateMemory ) {

  						state.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );

  					}

  					if ( dataReady ) {

  						state.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

  					}

  				} else {

  					state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

  				}

  			} else if ( texture.isFramebufferTexture ) {

  				if ( allocateMemory ) {

  					if ( useTexStorage ) {

  						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

  					} else {

  						let width = image.width, height = image.height;

  						for ( let i = 0; i < levels; i ++ ) {

  							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );

  							width >>= 1;
  							height >>= 1;

  						}

  					}

  				}

  			} else {

  				// regular Texture (image, video, canvas)

  				// use manually created mipmaps if available
  				// if there are no manual mipmaps
  				// set 0 level mipmap and then use GL to generate other mipmap levels

  				if ( mipmaps.length > 0 ) {

  					if ( useTexStorage && allocateMemory ) {

  						const dimensions = getDimensions( mipmaps[ 0 ] );

  						state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

  					}

  					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

  						mipmap = mipmaps[ i ];

  						if ( useTexStorage ) {

  							if ( dataReady ) {

  								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );

  							}

  						} else {

  							state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

  						}

  					}

  					texture.generateMipmaps = false;

  				} else {

  					if ( useTexStorage ) {

  						if ( allocateMemory ) {

  							const dimensions = getDimensions( image );

  							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height );

  						}

  						if ( dataReady ) {

  							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );

  						}

  					} else {

  						state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );

  					}

  				}

  			}

  			if ( textureNeedsGenerateMipmaps( texture ) ) {

  				generateMipmap( textureType );

  			}

  			sourceProperties.__version = source.version;

  			if ( texture.onUpdate ) texture.onUpdate( texture );

  		}

  		textureProperties.__version = texture.version;

  	}

  	function uploadCubeTexture( textureProperties, texture, slot ) {

  		if ( texture.image.length !== 6 ) return;

  		const forceUpload = initTexture( textureProperties, texture );
  		const source = texture.source;

  		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

  		const sourceProperties = properties.get( source );

  		if ( source.version !== sourceProperties.__version || forceUpload === true ) {

  			state.activeTexture( _gl.TEXTURE0 + slot );

  			const workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );
  			const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );
  			const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;

  			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
  			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
  			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
  			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );

  			const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
  			const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

  			const cubeImage = [];

  			for ( let i = 0; i < 6; i ++ ) {

  				if ( ! isCompressed && ! isDataTexture ) {

  					cubeImage[ i ] = resizeImage( texture.image[ i ], true, capabilities.maxCubemapSize );

  				} else {

  					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

  				}

  				cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

  			}

  			const image = cubeImage[ 0 ],
  				glFormat = utils.convert( texture.format, texture.colorSpace ),
  				glType = utils.convert( texture.type ),
  				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );

  			const useTexStorage = ( texture.isVideoTexture !== true );
  			const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
  			const dataReady = source.dataReady;
  			let levels = getMipLevels( texture, image );

  			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

  			let mipmaps;

  			if ( isCompressed ) {

  				if ( useTexStorage && allocateMemory ) {

  					state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );

  				}

  				for ( let i = 0; i < 6; i ++ ) {

  					mipmaps = cubeImage[ i ].mipmaps;

  					for ( let j = 0; j < mipmaps.length; j ++ ) {

  						const mipmap = mipmaps[ j ];

  						if ( texture.format !== RGBAFormat ) {

  							if ( glFormat !== null ) {

  								if ( useTexStorage ) {

  									if ( dataReady ) {

  										state.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

  									}

  								} else {

  									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  								}

  							} else {

  								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

  							}

  						} else {

  							if ( useTexStorage ) {

  								if ( dataReady ) {

  									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

  								}

  							} else {

  								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  							}

  						}

  					}

  				}

  			} else {

  				mipmaps = texture.mipmaps;

  				if ( useTexStorage && allocateMemory ) {

  					// TODO: Uniformly handle mipmap definitions
  					// Normal textures and compressed cube textures define base level + mips with their mipmap array
  					// Uncompressed cube textures use their mipmap array only for mips (no base level)

  					if ( mipmaps.length > 0 ) levels ++;

  					const dimensions = getDimensions( cubeImage[ 0 ] );

  					state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height );

  				}

  				for ( let i = 0; i < 6; i ++ ) {

  					if ( isDataTexture ) {

  						if ( useTexStorage ) {

  							if ( dataReady ) {

  								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

  							}

  						} else {

  							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

  						}

  						for ( let j = 0; j < mipmaps.length; j ++ ) {

  							const mipmap = mipmaps[ j ];
  							const mipmapImage = mipmap.image[ i ].image;

  							if ( useTexStorage ) {

  								if ( dataReady ) {

  									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

  								}

  							} else {

  								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

  							}

  						}

  					} else {

  						if ( useTexStorage ) {

  							if ( dataReady ) {

  								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

  							}

  						} else {

  							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

  						}

  						for ( let j = 0; j < mipmaps.length; j ++ ) {

  							const mipmap = mipmaps[ j ];

  							if ( useTexStorage ) {

  								if ( dataReady ) {

  									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

  								}

  							} else {

  								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

  							}

  						}

  					}

  				}

  			}

  			if ( textureNeedsGenerateMipmaps( texture ) ) {

  				// We assume images for cube map have the same size.
  				generateMipmap( _gl.TEXTURE_CUBE_MAP );

  			}

  			sourceProperties.__version = source.version;

  			if ( texture.onUpdate ) texture.onUpdate( texture );

  		}

  		textureProperties.__version = texture.version;

  	}

  	// Render targets

  	// Setup storage for target texture and bind it to correct framebuffer
  	function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget, level ) {

  		const glFormat = utils.convert( texture.format, texture.colorSpace );
  		const glType = utils.convert( texture.type );
  		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
  		const renderTargetProperties = properties.get( renderTarget );
  		const textureProperties = properties.get( texture );

  		textureProperties.__renderTarget = renderTarget;

  		if ( ! renderTargetProperties.__hasExternalTextures ) {

  			const width = Math.max( 1, renderTarget.width >> level );
  			const height = Math.max( 1, renderTarget.height >> level );

  			if ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {

  				state.texImage3D( textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null );

  			} else {

  				state.texImage2D( textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null );

  			}

  		}

  		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  		if ( useMultisampledRTT( renderTarget ) ) {

  			multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

  		} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753

  			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, level );

  		}

  		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

  	}

  	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

  		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

  		if ( renderTarget.depthBuffer ) {

  			// retrieve the depth attachment types
  			const depthTexture = renderTarget.depthTexture;
  			const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
  			const glInternalFormat = getInternalDepthFormat( renderTarget.stencilBuffer, depthType );
  			const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

  			// set up the attachment
  			const samples = getRenderTargetSamples( renderTarget );
  			const isUseMultisampledRTT = useMultisampledRTT( renderTarget );
  			if ( isUseMultisampledRTT ) {

  				multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  			} else if ( isMultisample ) {

  				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  			} else {

  				_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

  			}

  			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );

  		} else {

  			const textures = renderTarget.textures;

  			for ( let i = 0; i < textures.length; i ++ ) {

  				const texture = textures[ i ];

  				const glFormat = utils.convert( texture.format, texture.colorSpace );
  				const glType = utils.convert( texture.type );
  				const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
  				const samples = getRenderTargetSamples( renderTarget );

  				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

  					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  				} else if ( useMultisampledRTT( renderTarget ) ) {

  					multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  				} else {

  					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

  				}

  			}

  		}

  		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

  	}

  	// Setup resources for a Depth Texture for a FBO (needs an extension)
  	function setupDepthTexture( framebuffer, renderTarget ) {

  		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
  		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

  		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

  			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

  		}

  		const textureProperties = properties.get( renderTarget.depthTexture );
  		textureProperties.__renderTarget = renderTarget;

  		// upload an empty depth texture with framebuffer size
  		if ( ! textureProperties.__webglTexture ||
  				renderTarget.depthTexture.image.width !== renderTarget.width ||
  				renderTarget.depthTexture.image.height !== renderTarget.height ) {

  			renderTarget.depthTexture.image.width = renderTarget.width;
  			renderTarget.depthTexture.image.height = renderTarget.height;
  			renderTarget.depthTexture.needsUpdate = true;

  		}

  		setTexture2D( renderTarget.depthTexture, 0 );

  		const webglDepthTexture = textureProperties.__webglTexture;
  		const samples = getRenderTargetSamples( renderTarget );

  		if ( renderTarget.depthTexture.format === DepthFormat ) {

  			if ( useMultisampledRTT( renderTarget ) ) {

  				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

  			} else {

  				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

  			}

  		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

  			if ( useMultisampledRTT( renderTarget ) ) {

  				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

  			} else {

  				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

  			}

  		} else {

  			throw new Error( 'Unknown depthTexture format' );

  		}

  	}

  	// Setup GL resources for a non-texture depth buffer
  	function setupDepthRenderbuffer( renderTarget ) {

  		const renderTargetProperties = properties.get( renderTarget );
  		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

  		// if the bound depth texture has changed
  		if ( renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture ) {

  			// fire the dispose event to get rid of stored state associated with the previously bound depth buffer
  			const depthTexture = renderTarget.depthTexture;
  			if ( renderTargetProperties.__depthDisposeCallback ) {

  				renderTargetProperties.__depthDisposeCallback();

  			}

  			// set up dispose listeners to track when the currently attached buffer is implicitly unbound
  			if ( depthTexture ) {

  				const disposeEvent = () => {

  					delete renderTargetProperties.__boundDepthTexture;
  					delete renderTargetProperties.__depthDisposeCallback;
  					depthTexture.removeEventListener( 'dispose', disposeEvent );

  				};

  				depthTexture.addEventListener( 'dispose', disposeEvent );
  				renderTargetProperties.__depthDisposeCallback = disposeEvent;

  			}

  			renderTargetProperties.__boundDepthTexture = depthTexture;

  		}

  		if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

  			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

  			const mipmaps = renderTarget.texture.mipmaps;

  			if ( mipmaps && mipmaps.length > 0 ) {

  				setupDepthTexture( renderTargetProperties.__webglFramebuffer[ 0 ], renderTarget );

  			} else {

  				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

  			}

  		} else {

  			if ( isCube ) {

  				renderTargetProperties.__webglDepthbuffer = [];

  				for ( let i = 0; i < 6; i ++ ) {

  					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );

  					if ( renderTargetProperties.__webglDepthbuffer[ i ] === undefined ) {

  						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
  						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

  					} else {

  						// attach buffer if it's been created already
  						const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
  						const renderbuffer = renderTargetProperties.__webglDepthbuffer[ i ];
  						_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
  						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );

  					}

  				}

  			} else {

  				const mipmaps = renderTarget.texture.mipmaps;

  				if ( mipmaps && mipmaps.length > 0 ) {

  					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ 0 ] );

  				} else {

  					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

  				}

  				if ( renderTargetProperties.__webglDepthbuffer === undefined ) {

  					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
  					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

  				} else {

  					// attach buffer if it's been created already
  					const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
  					const renderbuffer = renderTargetProperties.__webglDepthbuffer;
  					_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
  					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer );

  				}

  			}

  		}

  		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

  	}

  	// rebind framebuffer with external textures
  	function rebindTextures( renderTarget, colorTexture, depthTexture ) {

  		const renderTargetProperties = properties.get( renderTarget );

  		if ( colorTexture !== undefined ) {

  			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0 );

  		}

  		if ( depthTexture !== undefined ) {

  			setupDepthRenderbuffer( renderTarget );

  		}

  	}

  	// Set up GL resources for the render target
  	function setupRenderTarget( renderTarget ) {

  		const texture = renderTarget.texture;

  		const renderTargetProperties = properties.get( renderTarget );
  		const textureProperties = properties.get( texture );

  		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

  		const textures = renderTarget.textures;

  		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
  		const isMultipleRenderTargets = ( textures.length > 1 );

  		if ( ! isMultipleRenderTargets ) {

  			if ( textureProperties.__webglTexture === undefined ) {

  				textureProperties.__webglTexture = _gl.createTexture();

  			}

  			textureProperties.__version = texture.version;
  			info.memory.textures ++;

  		}

  		// Setup framebuffer

  		if ( isCube ) {

  			renderTargetProperties.__webglFramebuffer = [];

  			for ( let i = 0; i < 6; i ++ ) {

  				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

  					renderTargetProperties.__webglFramebuffer[ i ] = [];

  					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

  						renderTargetProperties.__webglFramebuffer[ i ][ level ] = _gl.createFramebuffer();

  					}

  				} else {

  					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

  				}

  			}

  		} else {

  			if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

  				renderTargetProperties.__webglFramebuffer = [];

  				for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

  					renderTargetProperties.__webglFramebuffer[ level ] = _gl.createFramebuffer();

  				}

  			} else {

  				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

  			}

  			if ( isMultipleRenderTargets ) {

  				for ( let i = 0, il = textures.length; i < il; i ++ ) {

  					const attachmentProperties = properties.get( textures[ i ] );

  					if ( attachmentProperties.__webglTexture === undefined ) {

  						attachmentProperties.__webglTexture = _gl.createTexture();

  						info.memory.textures ++;

  					}

  				}

  			}

  			if ( ( renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

  				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
  				renderTargetProperties.__webglColorRenderbuffer = [];

  				state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

  				for ( let i = 0; i < textures.length; i ++ ) {

  					const texture = textures[ i ];
  					renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

  					_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

  					const glFormat = utils.convert( texture.format, texture.colorSpace );
  					const glType = utils.convert( texture.type );
  					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );
  					const samples = getRenderTargetSamples( renderTarget );
  					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

  				}

  				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

  				if ( renderTarget.depthBuffer ) {

  					renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
  					setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

  				}

  				state.bindFramebuffer( _gl.FRAMEBUFFER, null );

  			}

  		}

  		// Setup color buffer

  		if ( isCube ) {

  			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
  			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture );

  			for ( let i = 0; i < 6; i ++ ) {

  				if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

  					for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

  						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ][ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level );

  					}

  				} else {

  					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0 );

  				}

  			}

  			if ( textureNeedsGenerateMipmaps( texture ) ) {

  				generateMipmap( _gl.TEXTURE_CUBE_MAP );

  			}

  			state.unbindTexture();

  		} else if ( isMultipleRenderTargets ) {

  			for ( let i = 0, il = textures.length; i < il; i ++ ) {

  				const attachment = textures[ i ];
  				const attachmentProperties = properties.get( attachment );

  				let glTextureType = _gl.TEXTURE_2D;

  				if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

  					glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

  				}

  				state.bindTexture( glTextureType, attachmentProperties.__webglTexture );
  				setTextureParameters( glTextureType, attachment );
  				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, glTextureType, 0 );

  				if ( textureNeedsGenerateMipmaps( attachment ) ) {

  					generateMipmap( glTextureType );

  				}

  			}

  			state.unbindTexture();

  		} else {

  			let glTextureType = _gl.TEXTURE_2D;

  			if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

  				glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

  			}

  			state.bindTexture( glTextureType, textureProperties.__webglTexture );
  			setTextureParameters( glTextureType, texture );

  			if ( texture.mipmaps && texture.mipmaps.length > 0 ) {

  				for ( let level = 0; level < texture.mipmaps.length; level ++ ) {

  					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ level ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level );

  				}

  			} else {

  				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0 );

  			}

  			if ( textureNeedsGenerateMipmaps( texture ) ) {

  				generateMipmap( glTextureType );

  			}

  			state.unbindTexture();

  		}

  		// Setup depth and stencil buffers

  		if ( renderTarget.depthBuffer ) {

  			setupDepthRenderbuffer( renderTarget );

  		}

  	}

  	function updateRenderTargetMipmap( renderTarget ) {

  		const textures = renderTarget.textures;

  		for ( let i = 0, il = textures.length; i < il; i ++ ) {

  			const texture = textures[ i ];

  			if ( textureNeedsGenerateMipmaps( texture ) ) {

  				const targetType = getTargetType( renderTarget );
  				const webglTexture = properties.get( texture ).__webglTexture;

  				state.bindTexture( targetType, webglTexture );
  				generateMipmap( targetType );
  				state.unbindTexture();

  			}

  		}

  	}

  	const invalidationArrayRead = [];
  	const invalidationArrayDraw = [];

  	function updateMultisampleRenderTarget( renderTarget ) {

  		if ( renderTarget.samples > 0 ) {

  			if ( useMultisampledRTT( renderTarget ) === false ) {

  				const textures = renderTarget.textures;
  				const width = renderTarget.width;
  				const height = renderTarget.height;
  				let mask = _gl.COLOR_BUFFER_BIT;
  				const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
  				const renderTargetProperties = properties.get( renderTarget );
  				const isMultipleRenderTargets = ( textures.length > 1 );

  				// If MRT we need to remove FBO attachments
  				if ( isMultipleRenderTargets ) {

  					for ( let i = 0; i < textures.length; i ++ ) {

  						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
  						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );

  						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
  						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );

  					}

  				}

  				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

  				const mipmaps = renderTarget.texture.mipmaps;

  				if ( mipmaps && mipmaps.length > 0 ) {

  					state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ 0 ] );

  				} else {

  					state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

  				}

  				for ( let i = 0; i < textures.length; i ++ ) {

  					if ( renderTarget.resolveDepthBuffer ) {

  						if ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;

  						// resolving stencil is slow with a D3D backend. disable it for all transmission render targets (see #27799)

  						if ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;

  					}

  					if ( isMultipleRenderTargets ) {

  						_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

  						const webglTexture = properties.get( textures[ i ] ).__webglTexture;
  						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );

  					}

  					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

  					if ( supportsInvalidateFramebuffer === true ) {

  						invalidationArrayRead.length = 0;
  						invalidationArrayDraw.length = 0;

  						invalidationArrayRead.push( _gl.COLOR_ATTACHMENT0 + i );

  						if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false ) {

  							invalidationArrayRead.push( depthStyle );
  							invalidationArrayDraw.push( depthStyle );

  							_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, invalidationArrayDraw );

  						}

  						_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArrayRead );

  					}

  				}

  				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
  				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

  				// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
  				if ( isMultipleRenderTargets ) {

  					for ( let i = 0; i < textures.length; i ++ ) {

  						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
  						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

  						const webglTexture = properties.get( textures[ i ] ).__webglTexture;

  						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
  						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );

  					}

  				}

  				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

  			} else {

  				if ( renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer ) {

  					const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

  					_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );

  				}

  			}

  		}

  	}

  	function getRenderTargetSamples( renderTarget ) {

  		return Math.min( capabilities.maxSamples, renderTarget.samples );

  	}

  	function useMultisampledRTT( renderTarget ) {

  		const renderTargetProperties = properties.get( renderTarget );

  		return renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

  	}

  	function updateVideoTexture( texture ) {

  		const frame = info.render.frame;

  		// Check the last frame we updated the VideoTexture

  		if ( _videoTextures.get( texture ) !== frame ) {

  			_videoTextures.set( texture, frame );
  			texture.update();

  		}

  	}

  	function verifyColorSpace( texture, image ) {

  		const colorSpace = texture.colorSpace;
  		const format = texture.format;
  		const type = texture.type;

  		if ( texture.isCompressedTexture === true || texture.isVideoTexture === true ) return image;

  		if ( colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace ) {

  			// sRGB

  			if ( ColorManagement.getTransfer( colorSpace ) === SRGBTransfer ) {

  				// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

  				if ( format !== RGBAFormat || type !== UnsignedByteType ) {

  					console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

  				}

  			} else {

  				console.error( 'THREE.WebGLTextures: Unsupported texture color space:', colorSpace );

  			}

  		}

  		return image;

  	}

  	function getDimensions( image ) {

  		if ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) {

  			// if intrinsic data are not available, fallback to width/height

  			_imageDimensions.width = image.naturalWidth || image.width;
  			_imageDimensions.height = image.naturalHeight || image.height;

  		} else if ( typeof VideoFrame !== 'undefined' && image instanceof VideoFrame ) {

  			_imageDimensions.width = image.displayWidth;
  			_imageDimensions.height = image.displayHeight;

  		} else {

  			_imageDimensions.width = image.width;
  			_imageDimensions.height = image.height;

  		}

  		return _imageDimensions;

  	}

  	//

  	this.allocateTextureUnit = allocateTextureUnit;
  	this.resetTextureUnits = resetTextureUnits;

  	this.setTexture2D = setTexture2D;
  	this.setTexture2DArray = setTexture2DArray;
  	this.setTexture3D = setTexture3D;
  	this.setTextureCube = setTextureCube;
  	this.rebindTextures = rebindTextures;
  	this.setupRenderTarget = setupRenderTarget;
  	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  	this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  	this.setupFrameBufferTexture = setupFrameBufferTexture;
  	this.useMultisampledRTT = useMultisampledRTT;

  }

  function WebGLUtils( gl, extensions ) {

  	function convert( p, colorSpace = NoColorSpace ) {

  		let extension;

  		const transfer = ColorManagement.getTransfer( colorSpace );

  		if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
  		if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
  		if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
  		if ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;
  		if ( p === UnsignedInt101111Type ) return gl.UNSIGNED_INT_10F_11F_11F_REV;

  		if ( p === ByteType ) return gl.BYTE;
  		if ( p === ShortType ) return gl.SHORT;
  		if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
  		if ( p === IntType ) return gl.INT;
  		if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
  		if ( p === FloatType ) return gl.FLOAT;
  		if ( p === HalfFloatType ) return gl.HALF_FLOAT;

  		if ( p === AlphaFormat ) return gl.ALPHA;
  		if ( p === RGBFormat ) return gl.RGB;
  		if ( p === RGBAFormat ) return gl.RGBA;
  		if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
  		if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

  		// WebGL2 formats.

  		if ( p === RedFormat ) return gl.RED;
  		if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
  		if ( p === RGFormat ) return gl.RG;
  		if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
  		if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

  		// S3TC

  		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

  			if ( transfer === SRGBTransfer ) {

  				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

  				if ( extension !== null ) {

  					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
  					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

  				} else {

  					return null;

  				}

  			} else {

  				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

  				if ( extension !== null ) {

  					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
  					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

  				} else {

  					return null;

  				}

  			}

  		}

  		// PVRTC

  		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  			if ( extension !== null ) {

  				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
  				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
  				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
  				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

  			} else {

  				return null;

  			}

  		}

  		// ETC

  		if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

  			if ( extension !== null ) {

  				if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
  				if ( p === RGBA_ETC2_EAC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

  			} else {

  				return null;

  			}

  		}

  		// ASTC

  		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
  			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
  			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
  			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
  			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

  			if ( extension !== null ) {

  				if ( p === RGBA_ASTC_4x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
  				if ( p === RGBA_ASTC_5x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
  				if ( p === RGBA_ASTC_5x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
  				if ( p === RGBA_ASTC_6x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
  				if ( p === RGBA_ASTC_6x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
  				if ( p === RGBA_ASTC_8x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
  				if ( p === RGBA_ASTC_8x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
  				if ( p === RGBA_ASTC_8x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
  				if ( p === RGBA_ASTC_10x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
  				if ( p === RGBA_ASTC_10x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
  				if ( p === RGBA_ASTC_10x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
  				if ( p === RGBA_ASTC_10x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
  				if ( p === RGBA_ASTC_12x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
  				if ( p === RGBA_ASTC_12x12_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

  			} else {

  				return null;

  			}

  		}

  		// BPTC

  		if ( p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format ) {

  			extension = extensions.get( 'EXT_texture_compression_bptc' );

  			if ( extension !== null ) {

  				if ( p === RGBA_BPTC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
  				if ( p === RGB_BPTC_SIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
  				if ( p === RGB_BPTC_UNSIGNED_Format ) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;

  			} else {

  				return null;

  			}

  		}

  		// RGTC

  		if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

  			extension = extensions.get( 'EXT_texture_compression_rgtc' );

  			if ( extension !== null ) {

  				if ( p === RED_RGTC1_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
  				if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
  				if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
  				if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

  			} else {

  				return null;

  			}

  		}

  		//

  		if ( p === UnsignedInt248Type ) return gl.UNSIGNED_INT_24_8;

  		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

  		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

  	}

  	return { convert: convert };

  }

  const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;

  const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;

  /**
   * A XR module that manages the access to the Depth Sensing API.
   */
  class WebXRDepthSensing {

  	/**
  	 * Constructs a new depth sensing module.
  	 */
  	constructor() {

  		/**
  		 * An opaque texture representing the depth of the user's environment.
  		 *
  		 * @type {?ExternalTexture}
  		 */
  		this.texture = null;

  		/**
  		 * A plane mesh for visualizing the depth texture.
  		 *
  		 * @type {?Mesh}
  		 */
  		this.mesh = null;

  		/**
  		 * The depth near value.
  		 *
  		 * @type {number}
  		 */
  		this.depthNear = 0;

  		/**
  		 * The depth near far.
  		 *
  		 * @type {number}
  		 */
  		this.depthFar = 0;

  	}

  	/**
  	 * Inits the depth sensing module
  	 *
  	 * @param {XRWebGLDepthInformation} depthData - The XR depth data.
  	 * @param {XRRenderState} renderState - The XR render state.
  	 */
  	init( depthData, renderState ) {

  		if ( this.texture === null ) {

  			const texture = new ExternalTexture( depthData.texture );

  			if ( ( depthData.depthNear !== renderState.depthNear ) || ( depthData.depthFar !== renderState.depthFar ) ) {

  				this.depthNear = depthData.depthNear;
  				this.depthFar = depthData.depthFar;

  			}

  			this.texture = texture;

  		}

  	}

  	/**
  	 * Returns a plane mesh that visualizes the depth texture.
  	 *
  	 * @param {ArrayCamera} cameraXR - The XR camera.
  	 * @return {?Mesh} The plane mesh.
  	 */
  	getMesh( cameraXR ) {

  		if ( this.texture !== null ) {

  			if ( this.mesh === null ) {

  				const viewport = cameraXR.cameras[ 0 ].viewport;
  				const material = new ShaderMaterial( {
  					vertexShader: _occlusion_vertex,
  					fragmentShader: _occlusion_fragment,
  					uniforms: {
  						depthColor: { value: this.texture },
  						depthWidth: { value: viewport.z },
  						depthHeight: { value: viewport.w }
  					}
  				} );

  				this.mesh = new Mesh( new PlaneGeometry( 20, 20 ), material );

  			}

  		}

  		return this.mesh;

  	}

  	/**
  	 * Resets the module
  	 */
  	reset() {

  		this.texture = null;
  		this.mesh = null;

  	}

  	/**
  	 * Returns a texture representing the depth of the user's environment.
  	 *
  	 * @return {?ExternalTexture} The depth texture.
  	 */
  	getDepthTexture() {

  		return this.texture;

  	}

  }

  /**
   * This class represents an abstraction of the WebXR Device API and is
   * internally used by {@link WebGLRenderer}. `WebXRManager` also provides a public
   * interface that allows users to enable/disable XR and perform XR related
   * tasks like for instance retrieving controllers.
   *
   * @augments EventDispatcher
   * @hideconstructor
   */
  class WebXRManager extends EventDispatcher {

  	/**
  	 * Constructs a new WebGL renderer.
  	 *
  	 * @param {WebGLRenderer} renderer - The renderer.
  	 * @param {WebGL2RenderingContext} gl - The rendering context.
  	 */
  	constructor( renderer, gl ) {

  		super();

  		const scope = this;

  		let session = null;

  		let framebufferScaleFactor = 1.0;

  		let referenceSpace = null;
  		let referenceSpaceType = 'local-floor';
  		// Set default foveation to maximum.
  		let foveation = 1.0;
  		let customReferenceSpace = null;

  		let pose = null;
  		let glBinding = null;
  		let glProjLayer = null;
  		let glBaseLayer = null;
  		let xrFrame = null;

  		const supportsGlBinding = typeof XRWebGLBinding !== 'undefined';

  		const depthSensing = new WebXRDepthSensing();
  		const cameraAccessTextures = {};
  		const attributes = gl.getContextAttributes();

  		let initialRenderTarget = null;
  		let newRenderTarget = null;

  		const controllers = [];
  		const controllerInputSources = [];

  		const currentSize = new Vector2();
  		let currentPixelRatio = null;

  		//

  		const cameraL = new PerspectiveCamera();
  		cameraL.viewport = new Vector4();

  		const cameraR = new PerspectiveCamera();
  		cameraR.viewport = new Vector4();

  		const cameras = [ cameraL, cameraR ];

  		const cameraXR = new ArrayCamera();

  		let _currentDepthNear = null;
  		let _currentDepthFar = null;

  		//

  		/**
  		 * Whether the manager's XR camera should be automatically updated or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.cameraAutoUpdate = true;

  		/**
  		 * This flag notifies the renderer to be ready for XR rendering. Set it to `true`
  		 * if you are going to use XR in your app.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.enabled = false;

  		/**
  		 * Whether XR presentation is active or not.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default false
  		 */
  		this.isPresenting = false;

  		/**
  		 * Returns a group representing the `target ray` space of the XR controller.
  		 * Use this space for visualizing 3D objects that support the user in pointing
  		 * tasks like UI interaction.
  		 *
  		 * @param {number} index - The index of the controller.
  		 * @return {Group} A group representing the `target ray` space.
  		 */
  		this.getController = function ( index ) {

  			let controller = controllers[ index ];

  			if ( controller === undefined ) {

  				controller = new WebXRController();
  				controllers[ index ] = controller;

  			}

  			return controller.getTargetRaySpace();

  		};

  		/**
  		 * Returns a group representing the `grip` space of the XR controller.
  		 * Use this space for visualizing 3D objects that support the user in pointing
  		 * tasks like UI interaction.
  		 *
  		 * Note: If you want to show something in the user's hand AND offer a
  		 * pointing ray at the same time, you'll want to attached the handheld object
  		 * to the group returned by `getControllerGrip()` and the ray to the
  		 * group returned by `getController()`. The idea is to have two
  		 * different groups in two different coordinate spaces for the same WebXR
  		 * controller.
  		 *
  		 * @param {number} index - The index of the controller.
  		 * @return {Group} A group representing the `grip` space.
  		 */
  		this.getControllerGrip = function ( index ) {

  			let controller = controllers[ index ];

  			if ( controller === undefined ) {

  				controller = new WebXRController();
  				controllers[ index ] = controller;

  			}

  			return controller.getGripSpace();

  		};

  		/**
  		 * Returns a group representing the `hand` space of the XR controller.
  		 * Use this space for visualizing 3D objects that support the user in pointing
  		 * tasks like UI interaction.
  		 *
  		 * @param {number} index - The index of the controller.
  		 * @return {Group} A group representing the `hand` space.
  		 */
  		this.getHand = function ( index ) {

  			let controller = controllers[ index ];

  			if ( controller === undefined ) {

  				controller = new WebXRController();
  				controllers[ index ] = controller;

  			}

  			return controller.getHandSpace();

  		};

  		//

  		function onSessionEvent( event ) {

  			const controllerIndex = controllerInputSources.indexOf( event.inputSource );

  			if ( controllerIndex === -1 ) {

  				return;

  			}

  			const controller = controllers[ controllerIndex ];

  			if ( controller !== undefined ) {

  				controller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );
  				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

  			}

  		}

  		function onSessionEnd() {

  			session.removeEventListener( 'select', onSessionEvent );
  			session.removeEventListener( 'selectstart', onSessionEvent );
  			session.removeEventListener( 'selectend', onSessionEvent );
  			session.removeEventListener( 'squeeze', onSessionEvent );
  			session.removeEventListener( 'squeezestart', onSessionEvent );
  			session.removeEventListener( 'squeezeend', onSessionEvent );
  			session.removeEventListener( 'end', onSessionEnd );
  			session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

  			for ( let i = 0; i < controllers.length; i ++ ) {

  				const inputSource = controllerInputSources[ i ];

  				if ( inputSource === null ) continue;

  				controllerInputSources[ i ] = null;

  				controllers[ i ].disconnect( inputSource );

  			}

  			_currentDepthNear = null;
  			_currentDepthFar = null;

  			depthSensing.reset();
  			for ( const key in cameraAccessTextures ) {

  				delete cameraAccessTextures[ key ];

  			}

  			// restore framebuffer/rendering state

  			renderer.setRenderTarget( initialRenderTarget );

  			glBaseLayer = null;
  			glProjLayer = null;
  			glBinding = null;
  			session = null;
  			newRenderTarget = null;

  			//

  			animation.stop();

  			scope.isPresenting = false;

  			renderer.setPixelRatio( currentPixelRatio );
  			renderer.setSize( currentSize.width, currentSize.height, false );

  			scope.dispatchEvent( { type: 'sessionend' } );

  		}

  		/**
  		 * Sets the framebuffer scale factor.
  		 *
  		 * This method can not be used during a XR session.
  		 *
  		 * @param {number} value - The framebuffer scale factor.
  		 */
  		this.setFramebufferScaleFactor = function ( value ) {

  			framebufferScaleFactor = value;

  			if ( scope.isPresenting === true ) {

  				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

  			}

  		};

  		/**
  		 * Sets the reference space type. Can be used to configure a spatial relationship with the user's physical
  		 * environment. Depending on how the user moves in 3D space, setting an appropriate reference space can
  		 * improve tracking. Default is `local-floor`. Valid values can be found here
  		 * https://developer.mozilla.org/en-US/docs/Web/API/XRReferenceSpace#reference_space_types.
  		 *
  		 * This method can not be used during a XR session.
  		 *
  		 * @param {string} value - The reference space type.
  		 */
  		this.setReferenceSpaceType = function ( value ) {

  			referenceSpaceType = value;

  			if ( scope.isPresenting === true ) {

  				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

  			}

  		};

  		/**
  		 * Returns the XR reference space.
  		 *
  		 * @return {XRReferenceSpace} The XR reference space.
  		 */
  		this.getReferenceSpace = function () {

  			return customReferenceSpace || referenceSpace;

  		};

  		/**
  		 * Sets a custom XR reference space.
  		 *
  		 * @param {XRReferenceSpace} space - The XR reference space.
  		 */
  		this.setReferenceSpace = function ( space ) {

  			customReferenceSpace = space;

  		};

  		/**
  		 * Returns the current base layer.
  		 *
  		 * This is an `XRProjectionLayer` when the targeted XR device supports the
  		 * WebXR Layers API, or an `XRWebGLLayer` otherwise.
  		 *
  		 * @return {?(XRWebGLLayer|XRProjectionLayer)} The XR base layer.
  		 */
  		this.getBaseLayer = function () {

  			return glProjLayer !== null ? glProjLayer : glBaseLayer;

  		};

  		/**
  		 * Returns the current XR binding.
  		 *
  		 * Creates a new binding if needed and the browser is
  		 * capable of doing so.
  		 *
  		 * @return {?XRWebGLBinding} The XR binding. Returns `null` if one cannot be created.
  		 */
  		this.getBinding = function () {

  			if ( glBinding === null && supportsGlBinding ) {

  				glBinding = new XRWebGLBinding( session, gl );

  			}

  			return glBinding;

  		};

  		/**
  		 * Returns the current XR frame.
  		 *
  		 * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
  		 */
  		this.getFrame = function () {

  			return xrFrame;

  		};

  		/**
  		 * Returns the current XR session.
  		 *
  		 * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
  		 */
  		this.getSession = function () {

  			return session;

  		};

  		/**
  		 * After a XR session has been requested usually with one of the `*Button` modules, it
  		 * is injected into the renderer with this method. This method triggers the start of
  		 * the actual XR rendering.
  		 *
  		 * @async
  		 * @param {XRSession} value - The XR session to set.
  		 * @return {Promise} A Promise that resolves when the session has been set.
  		 */
  		this.setSession = async function ( value ) {

  			session = value;

  			if ( session !== null ) {

  				initialRenderTarget = renderer.getRenderTarget();

  				session.addEventListener( 'select', onSessionEvent );
  				session.addEventListener( 'selectstart', onSessionEvent );
  				session.addEventListener( 'selectend', onSessionEvent );
  				session.addEventListener( 'squeeze', onSessionEvent );
  				session.addEventListener( 'squeezestart', onSessionEvent );
  				session.addEventListener( 'squeezeend', onSessionEvent );
  				session.addEventListener( 'end', onSessionEnd );
  				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

  				if ( attributes.xrCompatible !== true ) {

  					await gl.makeXRCompatible();

  				}

  				currentPixelRatio = renderer.getPixelRatio();
  				renderer.getSize( currentSize );


  				// Check that the browser implements the necessary APIs to use an
  				// XRProjectionLayer rather than an XRWebGLLayer
  				const supportsLayers = supportsGlBinding && 'createProjectionLayer' in XRWebGLBinding.prototype;

  				if ( ! supportsLayers ) {

  					const layerInit = {
  						antialias: attributes.antialias,
  						alpha: true,
  						depth: attributes.depth,
  						stencil: attributes.stencil,
  						framebufferScaleFactor: framebufferScaleFactor
  					};

  					glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

  					session.updateRenderState( { baseLayer: glBaseLayer } );

  					renderer.setPixelRatio( 1 );
  					renderer.setSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false );

  					newRenderTarget = new WebGLRenderTarget(
  						glBaseLayer.framebufferWidth,
  						glBaseLayer.framebufferHeight,
  						{
  							format: RGBAFormat,
  							type: UnsignedByteType,
  							colorSpace: renderer.outputColorSpace,
  							stencilBuffer: attributes.stencil,
  							resolveDepthBuffer: ( glBaseLayer.ignoreDepthValues === false ),
  							resolveStencilBuffer: ( glBaseLayer.ignoreDepthValues === false )

  						}
  					);

  				} else {

  					let depthFormat = null;
  					let depthType = null;
  					let glDepthFormat = null;

  					if ( attributes.depth ) {

  						glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
  						depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
  						depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

  					}

  					const projectionlayerInit = {
  						colorFormat: gl.RGBA8,
  						depthFormat: glDepthFormat,
  						scaleFactor: framebufferScaleFactor
  					};

  					glBinding = this.getBinding();

  					glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

  					session.updateRenderState( { layers: [ glProjLayer ] } );

  					renderer.setPixelRatio( 1 );
  					renderer.setSize( glProjLayer.textureWidth, glProjLayer.textureHeight, false );

  					newRenderTarget = new WebGLRenderTarget(
  						glProjLayer.textureWidth,
  						glProjLayer.textureHeight,
  						{
  							format: RGBAFormat,
  							type: UnsignedByteType,
  							depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
  							stencilBuffer: attributes.stencil,
  							colorSpace: renderer.outputColorSpace,
  							samples: attributes.antialias ? 4 : 0,
  							resolveDepthBuffer: ( glProjLayer.ignoreDepthValues === false ),
  							resolveStencilBuffer: ( glProjLayer.ignoreDepthValues === false )
  						} );

  				}

  				newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

  				this.setFoveation( foveation );

  				customReferenceSpace = null;
  				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

  				animation.setContext( session );
  				animation.start();

  				scope.isPresenting = true;

  				scope.dispatchEvent( { type: 'sessionstart' } );

  			}

  		};

  		/**
  		 * Returns the environment blend mode from the current XR session.
  		 *
  		 * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
  		 */
  		this.getEnvironmentBlendMode = function () {

  			if ( session !== null ) {

  				return session.environmentBlendMode;

  			}

  		};

  		/**
  		 * Returns the current depth texture computed via depth sensing.
  		 *
  		 * See {@link WebXRDepthSensing#getDepthTexture}.
  		 *
  		 * @return {?Texture} The depth texture.
  		 */
  		this.getDepthTexture = function () {

  			return depthSensing.getDepthTexture();

  		};

  		function onInputSourcesChange( event ) {

  			// Notify disconnected

  			for ( let i = 0; i < event.removed.length; i ++ ) {

  				const inputSource = event.removed[ i ];
  				const index = controllerInputSources.indexOf( inputSource );

  				if ( index >= 0 ) {

  					controllerInputSources[ index ] = null;
  					controllers[ index ].disconnect( inputSource );

  				}

  			}

  			// Notify connected

  			for ( let i = 0; i < event.added.length; i ++ ) {

  				const inputSource = event.added[ i ];

  				let controllerIndex = controllerInputSources.indexOf( inputSource );

  				if ( controllerIndex === -1 ) {

  					// Assign input source a controller that currently has no input source

  					for ( let i = 0; i < controllers.length; i ++ ) {

  						if ( i >= controllerInputSources.length ) {

  							controllerInputSources.push( inputSource );
  							controllerIndex = i;
  							break;

  						} else if ( controllerInputSources[ i ] === null ) {

  							controllerInputSources[ i ] = inputSource;
  							controllerIndex = i;
  							break;

  						}

  					}

  					// If all controllers do currently receive input we ignore new ones

  					if ( controllerIndex === -1 ) break;

  				}

  				const controller = controllers[ controllerIndex ];

  				if ( controller ) {

  					controller.connect( inputSource );

  				}

  			}

  		}

  		//

  		const cameraLPos = new Vector3();
  		const cameraRPos = new Vector3();

  		/**
  		 * Assumes 2 cameras that are parallel and share an X-axis, and that
  		 * the cameras' projection and world matrices have already been set.
  		 * And that near and far planes are identical for both cameras.
  		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
  		 *
  		 * @param {ArrayCamera} camera - The camera to update.
  		 * @param {PerspectiveCamera} cameraL - The left camera.
  		 * @param {PerspectiveCamera} cameraR - The right camera.
  		 */
  		function setProjectionFromUnion( camera, cameraL, cameraR ) {

  			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
  			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

  			const ipd = cameraLPos.distanceTo( cameraRPos );

  			const projL = cameraL.projectionMatrix.elements;
  			const projR = cameraR.projectionMatrix.elements;

  			// VR systems will have identical far and near planes, and
  			// most likely identical top and bottom frustum extents.
  			// Use the left camera for these values.
  			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
  			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
  			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
  			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

  			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
  			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
  			const left = near * leftFov;
  			const right = near * rightFov;

  			// Calculate the new camera's position offset from the
  			// left camera. xOffset should be roughly half `ipd`.
  			const zOffset = ipd / ( - leftFov + rightFov );
  			const xOffset = zOffset * - leftFov;

  			// TODO: Better way to apply this offset?
  			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
  			camera.translateX( xOffset );
  			camera.translateZ( zOffset );
  			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
  			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

  			// Check if the projection uses an infinite far plane.
  			if ( projL[ 10 ] === -1 ) {

  				// Use the projection matrix from the left eye.
  				// The camera offset is sufficient to include the view volumes
  				// of both eyes (assuming symmetric projections).
  				camera.projectionMatrix.copy( cameraL.projectionMatrix );
  				camera.projectionMatrixInverse.copy( cameraL.projectionMatrixInverse );

  			} else {

  				// Find the union of the frustum values of the cameras and scale
  				// the values so that the near plane's position does not change in world space,
  				// although must now be relative to the new union camera.
  				const near2 = near + zOffset;
  				const far2 = far + zOffset;
  				const left2 = left - xOffset;
  				const right2 = right + ( ipd - xOffset );
  				const top2 = topFov * far / far2 * near2;
  				const bottom2 = bottomFov * far / far2 * near2;

  				camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
  				camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();

  			}

  		}

  		function updateCamera( camera, parent ) {

  			if ( parent === null ) {

  				camera.matrixWorld.copy( camera.matrix );

  			} else {

  				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

  			}

  			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

  		}

  		/**
  		 * Updates the state of the XR camera. Use this method on app level if you
  		 * set `cameraAutoUpdate` to `false`. The method requires the non-XR
  		 * camera of the scene as a parameter. The passed in camera's transformation
  		 * is automatically adjusted to the position of the XR camera when calling
  		 * this method.
  		 *
  		 * @param {Camera} camera - The camera.
  		 */
  		this.updateCamera = function ( camera ) {

  			if ( session === null ) return;

  			let depthNear = camera.near;
  			let depthFar = camera.far;

  			if ( depthSensing.texture !== null ) {

  				if ( depthSensing.depthNear > 0 ) depthNear = depthSensing.depthNear;
  				if ( depthSensing.depthFar > 0 ) depthFar = depthSensing.depthFar;

  			}

  			cameraXR.near = cameraR.near = cameraL.near = depthNear;
  			cameraXR.far = cameraR.far = cameraL.far = depthFar;

  			if ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {

  				// Note that the new renderState won't apply until the next frame. See #18320

  				session.updateRenderState( {
  					depthNear: cameraXR.near,
  					depthFar: cameraXR.far
  				} );

  				_currentDepthNear = cameraXR.near;
  				_currentDepthFar = cameraXR.far;

  			}

  			// inherit camera layers and enable eye layers (1 = left, 2 = right)
  			cameraXR.layers.mask = camera.layers.mask | 0b110;
  			cameraL.layers.mask = cameraXR.layers.mask & 0b011;
  			cameraR.layers.mask = cameraXR.layers.mask & 0b101;

  			const parent = camera.parent;
  			const cameras = cameraXR.cameras;

  			updateCamera( cameraXR, parent );

  			for ( let i = 0; i < cameras.length; i ++ ) {

  				updateCamera( cameras[ i ], parent );

  			}

  			// update projection matrix for proper view frustum culling

  			if ( cameras.length === 2 ) {

  				setProjectionFromUnion( cameraXR, cameraL, cameraR );

  			} else {

  				// assume single camera setup (AR)

  				cameraXR.projectionMatrix.copy( cameraL.projectionMatrix );

  			}

  			// update user camera and its children

  			updateUserCamera( camera, cameraXR, parent );

  		};

  		function updateUserCamera( camera, cameraXR, parent ) {

  			if ( parent === null ) {

  				camera.matrix.copy( cameraXR.matrixWorld );

  			} else {

  				camera.matrix.copy( parent.matrixWorld );
  				camera.matrix.invert();
  				camera.matrix.multiply( cameraXR.matrixWorld );

  			}

  			camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
  			camera.updateMatrixWorld( true );

  			camera.projectionMatrix.copy( cameraXR.projectionMatrix );
  			camera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );

  			if ( camera.isPerspectiveCamera ) {

  				camera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );
  				camera.zoom = 1;

  			}

  		}

  		/**
  		 * Returns an instance of {@link ArrayCamera} which represents the XR camera
  		 * of the active XR session. For each view it holds a separate camera object.
  		 *
  		 * The camera's `fov` is currently not used and does not reflect the fov of
  		 * the XR camera. If you need the fov on app level, you have to compute in
  		 * manually from the XR camera's projection matrices.
  		 *
  		 * @return {ArrayCamera} The XR camera.
  		 */
  		this.getCamera = function () {

  			return cameraXR;

  		};

  		/**
  		 * Returns the amount of foveation used by the XR compositor for the projection layer.
  		 *
  		 * @return {number|undefined} The amount of foveation.
  		 */
  		this.getFoveation = function () {

  			if ( glProjLayer === null && glBaseLayer === null ) {

  				return undefined;

  			}

  			return foveation;

  		};

  		/**
  		 * Sets the foveation value.
  		 *
  		 * @param {number} value - A number in the range `[0,1]` where `0` means no foveation (full resolution)
  		 * and `1` means maximum foveation (the edges render at lower resolution).
  		 */
  		this.setFoveation = function ( value ) {

  			// 0 = no foveation = full resolution
  			// 1 = maximum foveation = the edges render at lower resolution

  			foveation = value;

  			if ( glProjLayer !== null ) {

  				glProjLayer.fixedFoveation = value;

  			}

  			if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

  				glBaseLayer.fixedFoveation = value;

  			}

  		};

  		/**
  		 * Returns `true` if depth sensing is supported.
  		 *
  		 * @return {boolean} Whether depth sensing is supported or not.
  		 */
  		this.hasDepthSensing = function () {

  			return depthSensing.texture !== null;

  		};

  		/**
  		 * Returns the depth sensing mesh.
  		 *
  		 * See {@link WebXRDepthSensing#getMesh}.
  		 *
  		 * @return {Mesh} The depth sensing mesh.
  		 */
  		this.getDepthSensingMesh = function () {

  			return depthSensing.getMesh( cameraXR );

  		};

  		/**
  		 * Retrieves an opaque texture from the view-aligned {@link XRCamera}.
  		 * Only available during the current animation loop.
  		 *
  		 * @param {XRCamera} xrCamera - The camera to query.
  		 * @return {?Texture} An opaque texture representing the current raw camera frame.
  		 */
  		this.getCameraTexture = function ( xrCamera ) {

  			return cameraAccessTextures[ xrCamera ];

  		};

  		// Animation Loop

  		let onAnimationFrameCallback = null;

  		function onAnimationFrame( time, frame ) {

  			pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
  			xrFrame = frame;

  			if ( pose !== null ) {

  				const views = pose.views;

  				if ( glBaseLayer !== null ) {

  					renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
  					renderer.setRenderTarget( newRenderTarget );

  				}

  				let cameraXRNeedsUpdate = false;

  				// check if it's necessary to rebuild cameraXR's camera list

  				if ( views.length !== cameraXR.cameras.length ) {

  					cameraXR.cameras.length = 0;
  					cameraXRNeedsUpdate = true;

  				}

  				for ( let i = 0; i < views.length; i ++ ) {

  					const view = views[ i ];

  					let viewport = null;

  					if ( glBaseLayer !== null ) {

  						viewport = glBaseLayer.getViewport( view );

  					} else {

  						const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
  						viewport = glSubImage.viewport;

  						// For side-by-side projection, we only produce a single texture for both eyes.
  						if ( i === 0 ) {

  							renderer.setRenderTargetTextures(
  								newRenderTarget,
  								glSubImage.colorTexture,
  								glSubImage.depthStencilTexture );

  							renderer.setRenderTarget( newRenderTarget );

  						}

  					}

  					let camera = cameras[ i ];

  					if ( camera === undefined ) {

  						camera = new PerspectiveCamera();
  						camera.layers.enable( i );
  						camera.viewport = new Vector4();
  						cameras[ i ] = camera;

  					}

  					camera.matrix.fromArray( view.transform.matrix );
  					camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
  					camera.projectionMatrix.fromArray( view.projectionMatrix );
  					camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();
  					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

  					if ( i === 0 ) {

  						cameraXR.matrix.copy( camera.matrix );
  						cameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );

  					}

  					if ( cameraXRNeedsUpdate === true ) {

  						cameraXR.cameras.push( camera );

  					}

  				}

  				//

  				const enabledFeatures = session.enabledFeatures;
  				const gpuDepthSensingEnabled = enabledFeatures &&
  					enabledFeatures.includes( 'depth-sensing' ) &&
  					session.depthUsage == 'gpu-optimized';

  				if ( gpuDepthSensingEnabled && supportsGlBinding ) {

  					glBinding = scope.getBinding();

  					const depthData = glBinding.getDepthInformation( views[ 0 ] );

  					if ( depthData && depthData.isValid && depthData.texture ) {

  						depthSensing.init( depthData, session.renderState );

  					}

  				}

  				const cameraAccessEnabled = enabledFeatures &&
  				    enabledFeatures.includes( 'camera-access' );

  				if ( cameraAccessEnabled && supportsGlBinding ) {

  					renderer.state.unbindTexture();

  					glBinding = scope.getBinding();

  					for ( let i = 0; i < views.length; i ++ ) {

  						const camera = views[ i ].camera;

  						if ( camera ) {

  							let cameraTex = cameraAccessTextures[ camera ];

  							if ( ! cameraTex ) {

  								cameraTex = new ExternalTexture();
  								cameraAccessTextures[ camera ] = cameraTex;

  							}

  							const glTexture = glBinding.getCameraImage( camera );
  							cameraTex.sourceTexture = glTexture;

  						}

  					}

  				}

  			}

  			//

  			for ( let i = 0; i < controllers.length; i ++ ) {

  				const inputSource = controllerInputSources[ i ];
  				const controller = controllers[ i ];

  				if ( inputSource !== null && controller !== undefined ) {

  					controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

  				}

  			}

  			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

  			if ( frame.detectedPlanes ) {

  				scope.dispatchEvent( { type: 'planesdetected', data: frame } );

  			}

  			xrFrame = null;

  		}

  		const animation = new WebGLAnimation();

  		animation.setAnimationLoop( onAnimationFrame );

  		this.setAnimationLoop = function ( callback ) {

  			onAnimationFrameCallback = callback;

  		};

  		this.dispose = function () {};

  	}

  }

  const _e1 = /*@__PURE__*/ new Euler();
  const _m1 = /*@__PURE__*/ new Matrix4();

  function WebGLMaterials( renderer, properties ) {

  	function refreshTransformUniform( map, uniform ) {

  		if ( map.matrixAutoUpdate === true ) {

  			map.updateMatrix();

  		}

  		uniform.value.copy( map.matrix );

  	}

  	function refreshFogUniforms( uniforms, fog ) {

  		fog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );

  		if ( fog.isFog ) {

  			uniforms.fogNear.value = fog.near;
  			uniforms.fogFar.value = fog.far;

  		} else if ( fog.isFogExp2 ) {

  			uniforms.fogDensity.value = fog.density;

  		}

  	}

  	function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

  		if ( material.isMeshBasicMaterial ) {

  			refreshUniformsCommon( uniforms, material );

  		} else if ( material.isMeshLambertMaterial ) {

  			refreshUniformsCommon( uniforms, material );

  		} else if ( material.isMeshToonMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsToon( uniforms, material );

  		} else if ( material.isMeshPhongMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsPhong( uniforms, material );

  		} else if ( material.isMeshStandardMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsStandard( uniforms, material );

  			if ( material.isMeshPhysicalMaterial ) {

  				refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

  			}

  		} else if ( material.isMeshMatcapMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsMatcap( uniforms, material );

  		} else if ( material.isMeshDepthMaterial ) {

  			refreshUniformsCommon( uniforms, material );

  		} else if ( material.isMeshDistanceMaterial ) {

  			refreshUniformsCommon( uniforms, material );
  			refreshUniformsDistance( uniforms, material );

  		} else if ( material.isMeshNormalMaterial ) {

  			refreshUniformsCommon( uniforms, material );

  		} else if ( material.isLineBasicMaterial ) {

  			refreshUniformsLine( uniforms, material );

  			if ( material.isLineDashedMaterial ) {

  				refreshUniformsDash( uniforms, material );

  			}

  		} else if ( material.isPointsMaterial ) {

  			refreshUniformsPoints( uniforms, material, pixelRatio, height );

  		} else if ( material.isSpriteMaterial ) {

  			refreshUniformsSprites( uniforms, material );

  		} else if ( material.isShadowMaterial ) {

  			uniforms.color.value.copy( material.color );
  			uniforms.opacity.value = material.opacity;

  		} else if ( material.isShaderMaterial ) {

  			material.uniformsNeedUpdate = false; // #15581

  		}

  	}

  	function refreshUniformsCommon( uniforms, material ) {

  		uniforms.opacity.value = material.opacity;

  		if ( material.color ) {

  			uniforms.diffuse.value.copy( material.color );

  		}

  		if ( material.emissive ) {

  			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

  		}

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  			refreshTransformUniform( material.map, uniforms.mapTransform );

  		}

  		if ( material.alphaMap ) {

  			uniforms.alphaMap.value = material.alphaMap;

  			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;

  			refreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );

  			uniforms.bumpScale.value = material.bumpScale;

  			if ( material.side === BackSide ) {

  				uniforms.bumpScale.value *= -1;

  			}

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;

  			refreshTransformUniform( material.normalMap, uniforms.normalMapTransform );

  			uniforms.normalScale.value.copy( material.normalScale );

  			if ( material.side === BackSide ) {

  				uniforms.normalScale.value.negate();

  			}

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;

  			refreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );

  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  			refreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );

  		}

  		if ( material.specularMap ) {

  			uniforms.specularMap.value = material.specularMap;

  			refreshTransformUniform( material.specularMap, uniforms.specularMapTransform );

  		}

  		if ( material.alphaTest > 0 ) {

  			uniforms.alphaTest.value = material.alphaTest;

  		}

  		const materialProperties = properties.get( material );

  		const envMap = materialProperties.envMap;
  		const envMapRotation = materialProperties.envMapRotation;

  		if ( envMap ) {

  			uniforms.envMap.value = envMap;

  			_e1.copy( envMapRotation );

  			// accommodate left-handed frame
  			_e1.x *= -1; _e1.y *= -1; _e1.z *= -1;

  			if ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) {

  				// environment maps which are not cube render targets or PMREMs follow a different convention
  				_e1.y *= -1;
  				_e1.z *= -1;

  			}

  			uniforms.envMapRotation.value.setFromMatrix4( _m1.makeRotationFromEuler( _e1 ) );

  			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? -1 : 1;

  			uniforms.reflectivity.value = material.reflectivity;
  			uniforms.ior.value = material.ior;
  			uniforms.refractionRatio.value = material.refractionRatio;

  		}

  		if ( material.lightMap ) {

  			uniforms.lightMap.value = material.lightMap;
  			uniforms.lightMapIntensity.value = material.lightMapIntensity;

  			refreshTransformUniform( material.lightMap, uniforms.lightMapTransform );

  		}

  		if ( material.aoMap ) {

  			uniforms.aoMap.value = material.aoMap;
  			uniforms.aoMapIntensity.value = material.aoMapIntensity;

  			refreshTransformUniform( material.aoMap, uniforms.aoMapTransform );

  		}

  	}

  	function refreshUniformsLine( uniforms, material ) {

  		uniforms.diffuse.value.copy( material.color );
  		uniforms.opacity.value = material.opacity;

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  			refreshTransformUniform( material.map, uniforms.mapTransform );

  		}

  	}

  	function refreshUniformsDash( uniforms, material ) {

  		uniforms.dashSize.value = material.dashSize;
  		uniforms.totalSize.value = material.dashSize + material.gapSize;
  		uniforms.scale.value = material.scale;

  	}

  	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

  		uniforms.diffuse.value.copy( material.color );
  		uniforms.opacity.value = material.opacity;
  		uniforms.size.value = material.size * pixelRatio;
  		uniforms.scale.value = height * 0.5;

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  			refreshTransformUniform( material.map, uniforms.uvTransform );

  		}

  		if ( material.alphaMap ) {

  			uniforms.alphaMap.value = material.alphaMap;

  			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

  		}

  		if ( material.alphaTest > 0 ) {

  			uniforms.alphaTest.value = material.alphaTest;

  		}

  	}

  	function refreshUniformsSprites( uniforms, material ) {

  		uniforms.diffuse.value.copy( material.color );
  		uniforms.opacity.value = material.opacity;
  		uniforms.rotation.value = material.rotation;

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  			refreshTransformUniform( material.map, uniforms.mapTransform );

  		}

  		if ( material.alphaMap ) {

  			uniforms.alphaMap.value = material.alphaMap;

  			refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

  		}

  		if ( material.alphaTest > 0 ) {

  			uniforms.alphaTest.value = material.alphaTest;

  		}

  	}

  	function refreshUniformsPhong( uniforms, material ) {

  		uniforms.specular.value.copy( material.specular );
  		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

  	}

  	function refreshUniformsToon( uniforms, material ) {

  		if ( material.gradientMap ) {

  			uniforms.gradientMap.value = material.gradientMap;

  		}

  	}

  	function refreshUniformsStandard( uniforms, material ) {

  		uniforms.metalness.value = material.metalness;

  		if ( material.metalnessMap ) {

  			uniforms.metalnessMap.value = material.metalnessMap;

  			refreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );

  		}

  		uniforms.roughness.value = material.roughness;

  		if ( material.roughnessMap ) {

  			uniforms.roughnessMap.value = material.roughnessMap;

  			refreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );

  		}

  		if ( material.envMap ) {

  			//uniforms.envMap.value = material.envMap; // part of uniforms common

  			uniforms.envMapIntensity.value = material.envMapIntensity;

  		}

  	}

  	function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

  		uniforms.ior.value = material.ior; // also part of uniforms common

  		if ( material.sheen > 0 ) {

  			uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

  			uniforms.sheenRoughness.value = material.sheenRoughness;

  			if ( material.sheenColorMap ) {

  				uniforms.sheenColorMap.value = material.sheenColorMap;

  				refreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );

  			}

  			if ( material.sheenRoughnessMap ) {

  				uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

  				refreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );

  			}

  		}

  		if ( material.clearcoat > 0 ) {

  			uniforms.clearcoat.value = material.clearcoat;
  			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

  			if ( material.clearcoatMap ) {

  				uniforms.clearcoatMap.value = material.clearcoatMap;

  				refreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );

  			}

  			if ( material.clearcoatRoughnessMap ) {

  				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

  				refreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );

  			}

  			if ( material.clearcoatNormalMap ) {

  				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

  				refreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );

  				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );

  				if ( material.side === BackSide ) {

  					uniforms.clearcoatNormalScale.value.negate();

  				}

  			}

  		}

  		if ( material.dispersion > 0 ) {

  			uniforms.dispersion.value = material.dispersion;

  		}

  		if ( material.iridescence > 0 ) {

  			uniforms.iridescence.value = material.iridescence;
  			uniforms.iridescenceIOR.value = material.iridescenceIOR;
  			uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
  			uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

  			if ( material.iridescenceMap ) {

  				uniforms.iridescenceMap.value = material.iridescenceMap;

  				refreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );

  			}

  			if ( material.iridescenceThicknessMap ) {

  				uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

  				refreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );

  			}

  		}

  		if ( material.transmission > 0 ) {

  			uniforms.transmission.value = material.transmission;
  			uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
  			uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

  			if ( material.transmissionMap ) {

  				uniforms.transmissionMap.value = material.transmissionMap;

  				refreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );

  			}

  			uniforms.thickness.value = material.thickness;

  			if ( material.thicknessMap ) {

  				uniforms.thicknessMap.value = material.thicknessMap;

  				refreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );

  			}

  			uniforms.attenuationDistance.value = material.attenuationDistance;
  			uniforms.attenuationColor.value.copy( material.attenuationColor );

  		}

  		if ( material.anisotropy > 0 ) {

  			uniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

  			if ( material.anisotropyMap ) {

  				uniforms.anisotropyMap.value = material.anisotropyMap;

  				refreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );

  			}

  		}

  		uniforms.specularIntensity.value = material.specularIntensity;
  		uniforms.specularColor.value.copy( material.specularColor );

  		if ( material.specularColorMap ) {

  			uniforms.specularColorMap.value = material.specularColorMap;

  			refreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );

  		}

  		if ( material.specularIntensityMap ) {

  			uniforms.specularIntensityMap.value = material.specularIntensityMap;

  			refreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );

  		}

  	}

  	function refreshUniformsMatcap( uniforms, material ) {

  		if ( material.matcap ) {

  			uniforms.matcap.value = material.matcap;

  		}

  	}

  	function refreshUniformsDistance( uniforms, material ) {

  		const light = properties.get( material ).light;

  		uniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );
  		uniforms.nearDistance.value = light.shadow.camera.near;
  		uniforms.farDistance.value = light.shadow.camera.far;

  	}

  	return {
  		refreshFogUniforms: refreshFogUniforms,
  		refreshMaterialUniforms: refreshMaterialUniforms
  	};

  }

  function WebGLUniformsGroups( gl, info, capabilities, state ) {

  	let buffers = {};
  	let updateList = {};
  	let allocatedBindingPoints = [];

  	const maxBindingPoints = gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ); // binding points are global whereas block indices are per shader program

  	function bind( uniformsGroup, program ) {

  		const webglProgram = program.program;
  		state.uniformBlockBinding( uniformsGroup, webglProgram );

  	}

  	function update( uniformsGroup, program ) {

  		let buffer = buffers[ uniformsGroup.id ];

  		if ( buffer === undefined ) {

  			prepareUniformsGroup( uniformsGroup );

  			buffer = createBuffer( uniformsGroup );
  			buffers[ uniformsGroup.id ] = buffer;

  			uniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );

  		}

  		// ensure to update the binding points/block indices mapping for this program

  		const webglProgram = program.program;
  		state.updateUBOMapping( uniformsGroup, webglProgram );

  		// update UBO once per frame

  		const frame = info.render.frame;

  		if ( updateList[ uniformsGroup.id ] !== frame ) {

  			updateBufferData( uniformsGroup );

  			updateList[ uniformsGroup.id ] = frame;

  		}

  	}

  	function createBuffer( uniformsGroup ) {

  		// the setup of an UBO is independent of a particular shader program but global

  		const bindingPointIndex = allocateBindingPointIndex();
  		uniformsGroup.__bindingPointIndex = bindingPointIndex;

  		const buffer = gl.createBuffer();
  		const size = uniformsGroup.__size;
  		const usage = uniformsGroup.usage;

  		gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );
  		gl.bufferData( gl.UNIFORM_BUFFER, size, usage );
  		gl.bindBuffer( gl.UNIFORM_BUFFER, null );
  		gl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );

  		return buffer;

  	}

  	function allocateBindingPointIndex() {

  		for ( let i = 0; i < maxBindingPoints; i ++ ) {

  			if ( allocatedBindingPoints.indexOf( i ) === -1 ) {

  				allocatedBindingPoints.push( i );
  				return i;

  			}

  		}

  		console.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );

  		return 0;

  	}

  	function updateBufferData( uniformsGroup ) {

  		const buffer = buffers[ uniformsGroup.id ];
  		const uniforms = uniformsGroup.uniforms;
  		const cache = uniformsGroup.__cache;

  		gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );

  		for ( let i = 0, il = uniforms.length; i < il; i ++ ) {

  			const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

  			for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

  				const uniform = uniformArray[ j ];

  				if ( hasUniformChanged( uniform, i, j, cache ) === true ) {

  					const offset = uniform.__offset;

  					const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

  					let arrayOffset = 0;

  					for ( let k = 0; k < values.length; k ++ ) {

  						const value = values[ k ];

  						const info = getUniformSize( value );

  						// TODO add integer and struct support
  						if ( typeof value === 'number' || typeof value === 'boolean' ) {

  							uniform.__data[ 0 ] = value;
  							gl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );

  						} else if ( value.isMatrix3 ) {

  							// manually converting 3x3 to 3x4

  							uniform.__data[ 0 ] = value.elements[ 0 ];
  							uniform.__data[ 1 ] = value.elements[ 1 ];
  							uniform.__data[ 2 ] = value.elements[ 2 ];
  							uniform.__data[ 3 ] = 0;
  							uniform.__data[ 4 ] = value.elements[ 3 ];
  							uniform.__data[ 5 ] = value.elements[ 4 ];
  							uniform.__data[ 6 ] = value.elements[ 5 ];
  							uniform.__data[ 7 ] = 0;
  							uniform.__data[ 8 ] = value.elements[ 6 ];
  							uniform.__data[ 9 ] = value.elements[ 7 ];
  							uniform.__data[ 10 ] = value.elements[ 8 ];
  							uniform.__data[ 11 ] = 0;

  						} else {

  							value.toArray( uniform.__data, arrayOffset );

  							arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;

  						}

  					}

  					gl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );

  				}

  			}

  		}

  		gl.bindBuffer( gl.UNIFORM_BUFFER, null );

  	}

  	function hasUniformChanged( uniform, index, indexArray, cache ) {

  		const value = uniform.value;
  		const indexString = index + '_' + indexArray;

  		if ( cache[ indexString ] === undefined ) {

  			// cache entry does not exist so far

  			if ( typeof value === 'number' || typeof value === 'boolean' ) {

  				cache[ indexString ] = value;

  			} else {

  				cache[ indexString ] = value.clone();

  			}

  			return true;

  		} else {

  			const cachedObject = cache[ indexString ];

  			// compare current value with cached entry

  			if ( typeof value === 'number' || typeof value === 'boolean' ) {

  				if ( cachedObject !== value ) {

  					cache[ indexString ] = value;
  					return true;

  				}

  			} else {

  				if ( cachedObject.equals( value ) === false ) {

  					cachedObject.copy( value );
  					return true;

  				}

  			}

  		}

  		return false;

  	}

  	function prepareUniformsGroup( uniformsGroup ) {

  		// determine total buffer size according to the STD140 layout
  		// Hint: STD140 is the only supported layout in WebGL 2

  		const uniforms = uniformsGroup.uniforms;

  		let offset = 0; // global buffer offset in bytes
  		const chunkSize = 16; // size of a chunk in bytes

  		for ( let i = 0, l = uniforms.length; i < l; i ++ ) {

  			const uniformArray = Array.isArray( uniforms[ i ] ) ? uniforms[ i ] : [ uniforms[ i ] ];

  			for ( let j = 0, jl = uniformArray.length; j < jl; j ++ ) {

  				const uniform = uniformArray[ j ];

  				const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

  				for ( let k = 0, kl = values.length; k < kl; k ++ ) {

  					const value = values[ k ];

  					const info = getUniformSize( value );

  					const chunkOffset = offset % chunkSize; // offset in the current chunk
  					const chunkPadding = chunkOffset % info.boundary; // required padding to match boundary
  					const chunkStart = chunkOffset + chunkPadding; // the start position in the current chunk for the data

  					offset += chunkPadding;

  					// Check for chunk overflow
  					if ( chunkStart !== 0 && ( chunkSize - chunkStart ) < info.storage ) {

  						// Add padding and adjust offset
  						offset += ( chunkSize - chunkStart );

  					}

  					// the following two properties will be used for partial buffer updates
  					uniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );
  					uniform.__offset = offset;

  					// Update the global offset
  					offset += info.storage;

  				}

  			}

  		}

  		// ensure correct final padding

  		const chunkOffset = offset % chunkSize;

  		if ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );

  		//

  		uniformsGroup.__size = offset;
  		uniformsGroup.__cache = {};

  		return this;

  	}

  	function getUniformSize( value ) {

  		const info = {
  			boundary: 0, // bytes
  			storage: 0 // bytes
  		};

  		// determine sizes according to STD140

  		if ( typeof value === 'number' || typeof value === 'boolean' ) {

  			// float/int/bool

  			info.boundary = 4;
  			info.storage = 4;

  		} else if ( value.isVector2 ) {

  			// vec2

  			info.boundary = 8;
  			info.storage = 8;

  		} else if ( value.isVector3 || value.isColor ) {

  			// vec3

  			info.boundary = 16;
  			info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes

  		} else if ( value.isVector4 ) {

  			// vec4

  			info.boundary = 16;
  			info.storage = 16;

  		} else if ( value.isMatrix3 ) {

  			// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

  			info.boundary = 48;
  			info.storage = 48;

  		} else if ( value.isMatrix4 ) {

  			// mat4

  			info.boundary = 64;
  			info.storage = 64;

  		} else if ( value.isTexture ) {

  			console.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );

  		} else {

  			console.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );

  		}

  		return info;

  	}

  	function onUniformsGroupsDispose( event ) {

  		const uniformsGroup = event.target;

  		uniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );

  		const index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );
  		allocatedBindingPoints.splice( index, 1 );

  		gl.deleteBuffer( buffers[ uniformsGroup.id ] );

  		delete buffers[ uniformsGroup.id ];
  		delete updateList[ uniformsGroup.id ];

  	}

  	function dispose() {

  		for ( const id in buffers ) {

  			gl.deleteBuffer( buffers[ id ] );

  		}

  		allocatedBindingPoints = [];
  		buffers = {};
  		updateList = {};

  	}

  	return {

  		bind: bind,
  		update: update,

  		dispose: dispose

  	};

  }

  /**
   * This renderer uses WebGL 2 to display scenes.
   *
   * WebGL 1 is not supported since `r163`.
   */
  class WebGLRenderer {

  	/**
  	 * Constructs a new WebGL renderer.
  	 *
  	 * @param {WebGLRenderer~Options} [parameters] - The configuration parameter.
  	 */
  	constructor( parameters = {} ) {

  		const {
  			canvas = createCanvasElement(),
  			context = null,
  			depth = true,
  			stencil = false,
  			alpha = false,
  			antialias = false,
  			premultipliedAlpha = true,
  			preserveDrawingBuffer = false,
  			powerPreference = 'default',
  			failIfMajorPerformanceCaveat = false,
  			reversedDepthBuffer = false,
  		} = parameters;

  		/**
  		 * This flag can be used for type testing.
  		 *
  		 * @type {boolean}
  		 * @readonly
  		 * @default true
  		 */
  		this.isWebGLRenderer = true;

  		let _alpha;

  		if ( context !== null ) {

  			if ( typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext ) {

  				throw new Error( 'THREE.WebGLRenderer: WebGL 1 is not supported since r163.' );

  			}

  			_alpha = context.getContextAttributes().alpha;

  		} else {

  			_alpha = alpha;

  		}

  		const uintClearColor = new Uint32Array( 4 );
  		const intClearColor = new Int32Array( 4 );

  		let currentRenderList = null;
  		let currentRenderState = null;

  		// render() can be called from within a callback triggered by another render.
  		// We track this so that the nested render call gets its list and state isolated from the parent render call.

  		const renderListStack = [];
  		const renderStateStack = [];

  		// public properties

  		/**
  		 * A canvas where the renderer draws its output.This is automatically created by the renderer
  		 * in the constructor (if not provided already); you just need to add it to your page like so:
  		 * ```js
  		 * document.body.appendChild( renderer.domElement );
  		 * ```
  		 *
  		 * @type {DOMElement}
  		 */
  		this.domElement = canvas;

  		/**
  		 * A object with debug configuration settings.
  		 *
  		 * - `checkShaderErrors`: If it is `true`, defines whether material shader programs are
  		 * checked for errors during compilation and linkage process. It may be useful to disable
  		 * this check in production for performance gain. It is strongly recommended to keep these
  		 * checks enabled during development. If the shader does not compile and link - it will not
  		 * work and associated material will not render.
  		 * - `onShaderError(gl, program, glVertexShader,glFragmentShader)`: A callback function that
  		 * can be used for custom error reporting. The callback receives the WebGL context, an instance
  		 * of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader.
  		 * Assigning a custom function disables the default error reporting.
  		 *
  		 * @type {Object}
  		 */
  		this.debug = {

  			/**
  			 * Enables error checking and reporting when shader programs are being compiled.
  			 * @type {boolean}
  			 */
  			checkShaderErrors: true,
  			/**
  			 * Callback for custom error reporting.
  			 * @type {?Function}
  			 */
  			onShaderError: null
  		};

  		// clearing

  		/**
  		 * Whether the renderer should automatically clear its output before rendering a frame or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoClear = true;

  		/**
  		 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
  		 * the color buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoClearColor = true;

  		/**
  		 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
  		 * the depth buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoClearDepth = true;

  		/**
  		 * If {@link WebGLRenderer#autoClear} set to `true`, whether the renderer should clear
  		 * the stencil buffer or not.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.autoClearStencil = true;

  		// scene graph

  		/**
  		 * Whether the renderer should sort objects or not.
  		 *
  		 * Note: Sorting is used to attempt to properly render objects that have some
  		 * degree of transparency. By definition, sorting objects may not work in all
  		 * cases. Depending on the needs of application, it may be necessary to turn
  		 * off sorting and use other methods to deal with transparency rendering e.g.
  		 * manually determining each object's rendering order.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.sortObjects = true;

  		// user-defined clipping

  		/**
  		 * User-defined clipping planes specified in world space. These planes apply globally.
  		 * Points in space whose dot product with the plane is negative are cut away.
  		 *
  		 * @type {Array<Plane>}
  		 */
  		this.clippingPlanes = [];

  		/**
  		 * Whether the renderer respects object-level clipping planes or not.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.localClippingEnabled = false;

  		// tone mapping

  		/**
  		 * The tone mapping technique of the renderer.
  		 *
  		 * @type {(NoToneMapping|LinearToneMapping|ReinhardToneMapping|CineonToneMapping|ACESFilmicToneMapping|CustomToneMapping|AgXToneMapping|NeutralToneMapping)}
  		 * @default NoToneMapping
  		 */
  		this.toneMapping = NoToneMapping;

  		/**
  		 * Exposure level of tone mapping.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.toneMappingExposure = 1.0;

  		// transmission

  		/**
  		 * The normalized resolution scale for the transmission render target, measured in percentage
  		 * of viewport dimensions. Lowering this value can result in significant performance improvements
  		 * when using {@link MeshPhysicalMaterial#transmission}.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.transmissionResolutionScale = 1.0;

  		// internal properties

  		const _this = this;

  		let _isContextLost = false;

  		// internal state cache

  		this._outputColorSpace = SRGBColorSpace;

  		let _currentActiveCubeFace = 0;
  		let _currentActiveMipmapLevel = 0;
  		let _currentRenderTarget = null;
  		let _currentMaterialId = -1;

  		let _currentCamera = null;

  		const _currentViewport = new Vector4();
  		const _currentScissor = new Vector4();
  		let _currentScissorTest = null;

  		const _currentClearColor = new Color( 0x000000 );
  		let _currentClearAlpha = 0;

  		//

  		let _width = canvas.width;
  		let _height = canvas.height;

  		let _pixelRatio = 1;
  		let _opaqueSort = null;
  		let _transparentSort = null;

  		const _viewport = new Vector4( 0, 0, _width, _height );
  		const _scissor = new Vector4( 0, 0, _width, _height );
  		let _scissorTest = false;

  		// frustum

  		const _frustum = new Frustum();

  		// clipping

  		let _clippingEnabled = false;
  		let _localClippingEnabled = false;

  		// camera matrices cache

  		const _projScreenMatrix = new Matrix4();

  		const _vector3 = new Vector3();

  		const _vector4 = new Vector4();

  		const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

  		let _renderBackground = false;

  		function getTargetPixelRatio() {

  			return _currentRenderTarget === null ? _pixelRatio : 1;

  		}

  		// initialize

  		let _gl = context;

  		function getContext( contextName, contextAttributes ) {

  			return canvas.getContext( contextName, contextAttributes );

  		}

  		try {

  			const contextAttributes = {
  				alpha: true,
  				depth,
  				stencil,
  				antialias,
  				premultipliedAlpha,
  				preserveDrawingBuffer,
  				powerPreference,
  				failIfMajorPerformanceCaveat,
  			};

  			// OffscreenCanvas does not have setAttribute, see #22811
  			if ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

  			// event listeners must be registered before WebGL context is created, see #12753
  			canvas.addEventListener( 'webglcontextlost', onContextLost, false );
  			canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
  			canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

  			if ( _gl === null ) {

  				const contextName = 'webgl2';

  				_gl = getContext( contextName, contextAttributes );

  				if ( _gl === null ) {

  					if ( getContext( contextName ) ) {

  						throw new Error( 'Error creating WebGL context with your selected attributes.' );

  					} else {

  						throw new Error( 'Error creating WebGL context.' );

  					}

  				}

  			}

  		} catch ( error ) {

  			console.error( 'THREE.WebGLRenderer: ' + error.message );
  			throw error;

  		}

  		let extensions, capabilities, state, info;
  		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
  		let programCache, materials, renderLists, renderStates, clipping, shadowMap;

  		let background, morphtargets, bufferRenderer, indexedBufferRenderer;

  		let utils, bindingStates, uniformsGroups;

  		function initGLContext() {

  			extensions = new WebGLExtensions( _gl );
  			extensions.init();

  			utils = new WebGLUtils( _gl, extensions );

  			capabilities = new WebGLCapabilities( _gl, extensions, parameters, utils );

  			state = new WebGLState( _gl, extensions );

  			if ( capabilities.reversedDepthBuffer && reversedDepthBuffer ) {

  				state.buffers.depth.setReversed( true );

  			}

  			info = new WebGLInfo( _gl );
  			properties = new WebGLProperties();
  			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
  			cubemaps = new WebGLCubeMaps( _this );
  			cubeuvmaps = new WebGLCubeUVMaps( _this );
  			attributes = new WebGLAttributes( _gl );
  			bindingStates = new WebGLBindingStates( _gl, attributes );
  			geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
  			objects = new WebGLObjects( _gl, geometries, attributes, info );
  			morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
  			clipping = new WebGLClipping( properties );
  			programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
  			materials = new WebGLMaterials( _this, properties );
  			renderLists = new WebGLRenderLists();
  			renderStates = new WebGLRenderStates( extensions );
  			background = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );
  			shadowMap = new WebGLShadowMap( _this, objects, capabilities );
  			uniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );

  			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info );
  			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info );

  			info.programs = programCache.programs;

  			/**
  			 * Holds details about the capabilities of the current rendering context.
  			 *
  			 * @name WebGLRenderer#capabilities
  			 * @type {WebGLRenderer~Capabilities}
  			 */
  			_this.capabilities = capabilities;

  			/**
  			 * Provides methods for retrieving and testing WebGL extensions.
  			 *
  			 * - `get(extensionName:string)`: Used to check whether a WebGL extension is supported
  			 * and return the extension object if available.
  			 * - `has(extensionName:string)`: returns `true` if the extension is supported.
  			 *
  			 * @name WebGLRenderer#extensions
  			 * @type {Object}
  			 */
  			_this.extensions = extensions;

  			/**
  			 * Used to track properties of other objects like native WebGL objects.
  			 *
  			 * @name WebGLRenderer#properties
  			 * @type {Object}
  			 */
  			_this.properties = properties;

  			/**
  			 * Manages the render lists of the renderer.
  			 *
  			 * @name WebGLRenderer#renderLists
  			 * @type {Object}
  			 */
  			_this.renderLists = renderLists;



  			/**
  			 * Interface for managing shadows.
  			 *
  			 * @name WebGLRenderer#shadowMap
  			 * @type {WebGLRenderer~ShadowMap}
  			 */
  			_this.shadowMap = shadowMap;

  			/**
  			 * Interface for managing the WebGL state.
  			 *
  			 * @name WebGLRenderer#state
  			 * @type {Object}
  			 */
  			_this.state = state;

  			/**
  			 * Holds a series of statistical information about the GPU memory
  			 * and the rendering process. Useful for debugging and monitoring.
  			 *
  			 * By default these data are reset at each render call but when having
  			 * multiple render passes per frame (e.g. when using post processing) it can
  			 * be preferred to reset with a custom pattern. First, set `autoReset` to
  			 * `false`.
  			 * ```js
  			 * renderer.info.autoReset = false;
  			 * ```
  			 * Call `reset()` whenever you have finished to render a single frame.
  			 * ```js
  			 * renderer.info.reset();
  			 * ```
  			 *
  			 * @name WebGLRenderer#info
  			 * @type {WebGLRenderer~Info}
  			 */
  			_this.info = info;

  		}

  		initGLContext();

  		// xr

  		const xr = new WebXRManager( _this, _gl );

  		/**
  		 * A reference to the XR manager.
  		 *
  		 * @type {WebXRManager}
  		 */
  		this.xr = xr;

  		/**
  		 * Returns the rendering context.
  		 *
  		 * @return {WebGL2RenderingContext} The rendering context.
  		 */
  		this.getContext = function () {

  			return _gl;

  		};

  		/**
  		 * Returns the rendering context attributes.
  		 *
  		 * @return {WebGLContextAttributes} The rendering context attributes.
  		 */
  		this.getContextAttributes = function () {

  			return _gl.getContextAttributes();

  		};

  		/**
  		 * Simulates a loss of the WebGL context. This requires support for the `WEBGL_lose_context` extension.
  		 */
  		this.forceContextLoss = function () {

  			const extension = extensions.get( 'WEBGL_lose_context' );
  			if ( extension ) extension.loseContext();

  		};

  		/**
  		 * Simulates a restore of the WebGL context. This requires support for the `WEBGL_lose_context` extension.
  		 */
  		this.forceContextRestore = function () {

  			const extension = extensions.get( 'WEBGL_lose_context' );
  			if ( extension ) extension.restoreContext();

  		};

  		/**
  		 * Returns the pixel ratio.
  		 *
  		 * @return {number} The pixel ratio.
  		 */
  		this.getPixelRatio = function () {

  			return _pixelRatio;

  		};

  		/**
  		 * Sets the given pixel ratio and resizes the canvas if necessary.
  		 *
  		 * @param {number} value - The pixel ratio.
  		 */
  		this.setPixelRatio = function ( value ) {

  			if ( value === undefined ) return;

  			_pixelRatio = value;

  			this.setSize( _width, _height, false );

  		};

  		/**
  		 * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
  		 *
  		 * @param {Vector2} target - The method writes the result in this target object.
  		 * @return {Vector2} The renderer's size in logical pixels.
  		 */
  		this.getSize = function ( target ) {

  			return target.set( _width, _height );

  		};

  		/**
  		 * Resizes the output canvas to (width, height) with device pixel ratio taken
  		 * into account, and also sets the viewport to fit that size, starting in (0,
  		 * 0). Setting `updateStyle` to false prevents any style changes to the output canvas.
  		 *
  		 * @param {number} width - The width in logical pixels.
  		 * @param {number} height - The height in logical pixels.
  		 * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
  		 */
  		this.setSize = function ( width, height, updateStyle = true ) {

  			if ( xr.isPresenting ) {

  				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
  				return;

  			}

  			_width = width;
  			_height = height;

  			canvas.width = Math.floor( width * _pixelRatio );
  			canvas.height = Math.floor( height * _pixelRatio );

  			if ( updateStyle === true ) {

  				canvas.style.width = width + 'px';
  				canvas.style.height = height + 'px';

  			}

  			this.setViewport( 0, 0, width, height );

  		};

  		/**
  		 * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
  		 *
  		 * @param {Vector2} target - The method writes the result in this target object.
  		 * @return {Vector2} The drawing buffer size.
  		 */
  		this.getDrawingBufferSize = function ( target ) {

  			return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

  		};

  		/**
  		 * This method allows to define the drawing buffer size by specifying
  		 * width, height and pixel ratio all at once. The size of the drawing
  		 * buffer is computed with this formula:
  		 * ```js
  		 * size.x = width * pixelRatio;
  		 * size.y = height * pixelRatio;
  		 * ```
  		 *
  		 * @param {number} width - The width in logical pixels.
  		 * @param {number} height - The height in logical pixels.
  		 * @param {number} pixelRatio - The pixel ratio.
  		 */
  		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

  			_width = width;
  			_height = height;

  			_pixelRatio = pixelRatio;

  			canvas.width = Math.floor( width * pixelRatio );
  			canvas.height = Math.floor( height * pixelRatio );

  			this.setViewport( 0, 0, width, height );

  		};

  		/**
  		 * Returns the current viewport definition.
  		 *
  		 * @param {Vector2} target - The method writes the result in this target object.
  		 * @return {Vector2} The current viewport definition.
  		 */
  		this.getCurrentViewport = function ( target ) {

  			return target.copy( _currentViewport );

  		};

  		/**
  		 * Returns the viewport definition.
  		 *
  		 * @param {Vector4} target - The method writes the result in this target object.
  		 * @return {Vector4} The viewport definition.
  		 */
  		this.getViewport = function ( target ) {

  			return target.copy( _viewport );

  		};

  		/**
  		 * Sets the viewport to render from `(x, y)` to `(x + width, y + height)`.
  		 *
  		 * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
  		 * Or alternatively a four-component vector specifying all the parameters of the viewport.
  		 * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
  		 * @param {number} width - The width of the viewport in logical pixel unit.
  		 * @param {number} height - The height of the viewport in logical pixel unit.
  		 */
  		this.setViewport = function ( x, y, width, height ) {

  			if ( x.isVector4 ) {

  				_viewport.set( x.x, x.y, x.z, x.w );

  			} else {

  				_viewport.set( x, y, width, height );

  			}

  			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).round() );

  		};

  		/**
  		 * Returns the scissor region.
  		 *
  		 * @param {Vector4} target - The method writes the result in this target object.
  		 * @return {Vector4} The scissor region.
  		 */
  		this.getScissor = function ( target ) {

  			return target.copy( _scissor );

  		};

  		/**
  		 * Sets the scissor region to render from `(x, y)` to `(x + width, y + height)`.
  		 *
  		 * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the scissor region origin in logical pixel unit.
  		 * Or alternatively a four-component vector specifying all the parameters of the scissor region.
  		 * @param {number} y - The vertical coordinate for the lower left corner of the scissor region origin  in logical pixel unit.
  		 * @param {number} width - The width of the scissor region in logical pixel unit.
  		 * @param {number} height - The height of the scissor region in logical pixel unit.
  		 */
  		this.setScissor = function ( x, y, width, height ) {

  			if ( x.isVector4 ) {

  				_scissor.set( x.x, x.y, x.z, x.w );

  			} else {

  				_scissor.set( x, y, width, height );

  			}

  			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).round() );

  		};

  		/**
  		 * Returns `true` if the scissor test is enabled.
  		 *
  		 * @return {boolean} Whether the scissor test is enabled or not.
  		 */
  		this.getScissorTest = function () {

  			return _scissorTest;

  		};

  		/**
  		 * Enable or disable the scissor test. When this is enabled, only the pixels
  		 * within the defined scissor area will be affected by further renderer
  		 * actions.
  		 *
  		 * @param {boolean} boolean - Whether the scissor test is enabled or not.
  		 */
  		this.setScissorTest = function ( boolean ) {

  			state.setScissorTest( _scissorTest = boolean );

  		};

  		/**
  		 * Sets a custom opaque sort function for the render lists. Pass `null`
  		 * to use the default `painterSortStable` function.
  		 *
  		 * @param {?Function} method - The opaque sort function.
  		 */
  		this.setOpaqueSort = function ( method ) {

  			_opaqueSort = method;

  		};

  		/**
  		 * Sets a custom transparent sort function for the render lists. Pass `null`
  		 * to use the default `reversePainterSortStable` function.
  		 *
  		 * @param {?Function} method - The opaque sort function.
  		 */
  		this.setTransparentSort = function ( method ) {

  			_transparentSort = method;

  		};

  		// Clearing

  		/**
  		 * Returns the clear color.
  		 *
  		 * @param {Color} target - The method writes the result in this target object.
  		 * @return {Color} The clear color.
  		 */
  		this.getClearColor = function ( target ) {

  			return target.copy( background.getClearColor() );

  		};

  		/**
  		 * Sets the clear color and alpha.
  		 *
  		 * @param {Color} color - The clear color.
  		 * @param {number} [alpha=1] - The clear alpha.
  		 */
  		this.setClearColor = function () {

  			background.setClearColor( ...arguments );

  		};

  		/**
  		 * Returns the clear alpha. Ranges within `[0,1]`.
  		 *
  		 * @return {number} The clear alpha.
  		 */
  		this.getClearAlpha = function () {

  			return background.getClearAlpha();

  		};

  		/**
  		 * Sets the clear alpha.
  		 *
  		 * @param {number} alpha - The clear alpha.
  		 */
  		this.setClearAlpha = function () {

  			background.setClearAlpha( ...arguments );

  		};

  		/**
  		 * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
  		 * This method initializes the buffers to the current clear color values.
  		 *
  		 * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
  		 * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
  		 * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
  		 */
  		this.clear = function ( color = true, depth = true, stencil = true ) {

  			let bits = 0;

  			if ( color ) {

  				// check if we're trying to clear an integer target
  				let isIntegerFormat = false;
  				if ( _currentRenderTarget !== null ) {

  					const targetFormat = _currentRenderTarget.texture.format;
  					isIntegerFormat = targetFormat === RGBAIntegerFormat ||
  						targetFormat === RGIntegerFormat ||
  						targetFormat === RedIntegerFormat;

  				}

  				// use the appropriate clear functions to clear the target if it's a signed
  				// or unsigned integer target
  				if ( isIntegerFormat ) {

  					const targetType = _currentRenderTarget.texture.type;
  					const isUnsignedType = targetType === UnsignedByteType ||
  						targetType === UnsignedIntType ||
  						targetType === UnsignedShortType ||
  						targetType === UnsignedInt248Type ||
  						targetType === UnsignedShort4444Type ||
  						targetType === UnsignedShort5551Type;

  					const clearColor = background.getClearColor();
  					const a = background.getClearAlpha();
  					const r = clearColor.r;
  					const g = clearColor.g;
  					const b = clearColor.b;

  					if ( isUnsignedType ) {

  						uintClearColor[ 0 ] = r;
  						uintClearColor[ 1 ] = g;
  						uintClearColor[ 2 ] = b;
  						uintClearColor[ 3 ] = a;
  						_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );

  					} else {

  						intClearColor[ 0 ] = r;
  						intClearColor[ 1 ] = g;
  						intClearColor[ 2 ] = b;
  						intClearColor[ 3 ] = a;
  						_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );

  					}

  				} else {

  					bits |= _gl.COLOR_BUFFER_BIT;

  				}

  			}

  			if ( depth ) {

  				bits |= _gl.DEPTH_BUFFER_BIT;

  			}

  			if ( stencil ) {

  				bits |= _gl.STENCIL_BUFFER_BIT;
  				this.state.buffers.stencil.setMask( 0xffffffff );

  			}

  			_gl.clear( bits );

  		};

  		/**
  		 * Clears the color buffer. Equivalent to calling `renderer.clear( true, false, false )`.
  		 */
  		this.clearColor = function () {

  			this.clear( true, false, false );

  		};

  		/**
  		 * Clears the depth buffer. Equivalent to calling `renderer.clear( false, true, false )`.
  		 */
  		this.clearDepth = function () {

  			this.clear( false, true, false );

  		};

  		/**
  		 * Clears the stencil buffer. Equivalent to calling `renderer.clear( false, false, true )`.
  		 */
  		this.clearStencil = function () {

  			this.clear( false, false, true );

  		};

  		/**
  		 * Frees the GPU-related resources allocated by this instance. Call this
  		 * method whenever this instance is no longer used in your app.
  		 */
  		this.dispose = function () {

  			canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
  			canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
  			canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

  			background.dispose();
  			renderLists.dispose();
  			renderStates.dispose();
  			properties.dispose();
  			cubemaps.dispose();
  			cubeuvmaps.dispose();
  			objects.dispose();
  			bindingStates.dispose();
  			uniformsGroups.dispose();
  			programCache.dispose();

  			xr.dispose();

  			xr.removeEventListener( 'sessionstart', onXRSessionStart );
  			xr.removeEventListener( 'sessionend', onXRSessionEnd );

  			animation.stop();

  		};

  		// Events

  		function onContextLost( event ) {

  			event.preventDefault();

  			console.log( 'THREE.WebGLRenderer: Context Lost.' );

  			_isContextLost = true;

  		}

  		function onContextRestore( /* event */ ) {

  			console.log( 'THREE.WebGLRenderer: Context Restored.' );

  			_isContextLost = false;

  			const infoAutoReset = info.autoReset;
  			const shadowMapEnabled = shadowMap.enabled;
  			const shadowMapAutoUpdate = shadowMap.autoUpdate;
  			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
  			const shadowMapType = shadowMap.type;

  			initGLContext();

  			info.autoReset = infoAutoReset;
  			shadowMap.enabled = shadowMapEnabled;
  			shadowMap.autoUpdate = shadowMapAutoUpdate;
  			shadowMap.needsUpdate = shadowMapNeedsUpdate;
  			shadowMap.type = shadowMapType;

  		}

  		function onContextCreationError( event ) {

  			console.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );

  		}

  		function onMaterialDispose( event ) {

  			const material = event.target;

  			material.removeEventListener( 'dispose', onMaterialDispose );

  			deallocateMaterial( material );

  		}

  		// Buffer deallocation

  		function deallocateMaterial( material ) {

  			releaseMaterialProgramReferences( material );

  			properties.remove( material );

  		}


  		function releaseMaterialProgramReferences( material ) {

  			const programs = properties.get( material ).programs;

  			if ( programs !== undefined ) {

  				programs.forEach( function ( program ) {

  					programCache.releaseProgram( program );

  				} );

  				if ( material.isShaderMaterial ) {

  					programCache.releaseShaderCache( material );

  				}

  			}

  		}

  		// Buffer rendering

  		this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

  			if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

  			const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

  			const program = setProgram( camera, scene, geometry, material, object );

  			state.setMaterial( material, frontFaceCW );

  			//

  			let index = geometry.index;
  			let rangeFactor = 1;

  			if ( material.wireframe === true ) {

  				index = geometries.getWireframeAttribute( geometry );

  				if ( index === undefined ) return;

  				rangeFactor = 2;

  			}

  			//

  			const drawRange = geometry.drawRange;
  			const position = geometry.attributes.position;

  			let drawStart = drawRange.start * rangeFactor;
  			let drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;

  			if ( group !== null ) {

  				drawStart = Math.max( drawStart, group.start * rangeFactor );
  				drawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );

  			}

  			if ( index !== null ) {

  				drawStart = Math.max( drawStart, 0 );
  				drawEnd = Math.min( drawEnd, index.count );

  			} else if ( position !== undefined && position !== null ) {

  				drawStart = Math.max( drawStart, 0 );
  				drawEnd = Math.min( drawEnd, position.count );

  			}

  			const drawCount = drawEnd - drawStart;

  			if ( drawCount < 0 || drawCount === Infinity ) return;

  			//

  			bindingStates.setup( object, material, program, geometry, index );

  			let attribute;
  			let renderer = bufferRenderer;

  			if ( index !== null ) {

  				attribute = attributes.get( index );

  				renderer = indexedBufferRenderer;
  				renderer.setIndex( attribute );

  			}

  			//

  			if ( object.isMesh ) {

  				if ( material.wireframe === true ) {

  					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
  					renderer.setMode( _gl.LINES );

  				} else {

  					renderer.setMode( _gl.TRIANGLES );

  				}

  			} else if ( object.isLine ) {

  				let lineWidth = material.linewidth;

  				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

  				state.setLineWidth( lineWidth * getTargetPixelRatio() );

  				if ( object.isLineSegments ) {

  					renderer.setMode( _gl.LINES );

  				} else if ( object.isLineLoop ) {

  					renderer.setMode( _gl.LINE_LOOP );

  				} else {

  					renderer.setMode( _gl.LINE_STRIP );

  				}

  			} else if ( object.isPoints ) {

  				renderer.setMode( _gl.POINTS );

  			} else if ( object.isSprite ) {

  				renderer.setMode( _gl.TRIANGLES );

  			}

  			if ( object.isBatchedMesh ) {

  				if ( object._multiDrawInstances !== null ) {

  					// @deprecated, r174
  					warnOnce( 'THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.' );
  					renderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );

  				} else {

  					if ( ! extensions.get( 'WEBGL_multi_draw' ) ) {

  						const starts = object._multiDrawStarts;
  						const counts = object._multiDrawCounts;
  						const drawCount = object._multiDrawCount;
  						const bytesPerElement = index ? attributes.get( index ).bytesPerElement : 1;
  						const uniforms = properties.get( material ).currentProgram.getUniforms();
  						for ( let i = 0; i < drawCount; i ++ ) {

  							uniforms.setValue( _gl, '_gl_DrawID', i );
  							renderer.render( starts[ i ] / bytesPerElement, counts[ i ] );

  						}

  					} else {

  						renderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );

  					}

  				}

  			} else if ( object.isInstancedMesh ) {

  				renderer.renderInstances( drawStart, drawCount, object.count );

  			} else if ( geometry.isInstancedBufferGeometry ) {

  				const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
  				const instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );

  				renderer.renderInstances( drawStart, drawCount, instanceCount );

  			} else {

  				renderer.render( drawStart, drawCount );

  			}

  		};

  		// Compile

  		function prepareMaterial( material, scene, object ) {

  			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

  				material.side = BackSide;
  				material.needsUpdate = true;
  				getProgram( material, scene, object );

  				material.side = FrontSide;
  				material.needsUpdate = true;
  				getProgram( material, scene, object );

  				material.side = DoubleSide;

  			} else {

  				getProgram( material, scene, object );

  			}

  		}

  		/**
  		 * Compiles all materials in the scene with the camera. This is useful to precompile shaders
  		 * before the first rendering. If you want to add a 3D object to an existing scene, use the third
  		 * optional parameter for applying the target scene.
  		 *
  		 * Note that the (target) scene's lighting and environment must be configured before calling this method.
  		 *
  		 * @param {Object3D} scene - The scene or another type of 3D object to precompile.
  		 * @param {Camera} camera - The camera.
  		 * @param {?Scene} [targetScene=null] - The target scene.
  		 * @return {Set<Material>} The precompiled materials.
  		 */
  		this.compile = function ( scene, camera, targetScene = null ) {

  			if ( targetScene === null ) targetScene = scene;

  			currentRenderState = renderStates.get( targetScene );
  			currentRenderState.init( camera );

  			renderStateStack.push( currentRenderState );

  			// gather lights from both the target scene and the new object that will be added to the scene.

  			targetScene.traverseVisible( function ( object ) {

  				if ( object.isLight && object.layers.test( camera.layers ) ) {

  					currentRenderState.pushLight( object );

  					if ( object.castShadow ) {

  						currentRenderState.pushShadow( object );

  					}

  				}

  			} );

  			if ( scene !== targetScene ) {

  				scene.traverseVisible( function ( object ) {

  					if ( object.isLight && object.layers.test( camera.layers ) ) {

  						currentRenderState.pushLight( object );

  						if ( object.castShadow ) {

  							currentRenderState.pushShadow( object );

  						}

  					}

  				} );

  			}

  			currentRenderState.setupLights();

  			// Only initialize materials in the new scene, not the targetScene.

  			const materials = new Set();

  			scene.traverse( function ( object ) {

  				if ( ! ( object.isMesh || object.isPoints || object.isLine || object.isSprite ) ) {

  					return;

  				}

  				const material = object.material;

  				if ( material ) {

  					if ( Array.isArray( material ) ) {

  						for ( let i = 0; i < material.length; i ++ ) {

  							const material2 = material[ i ];

  							prepareMaterial( material2, targetScene, object );
  							materials.add( material2 );

  						}

  					} else {

  						prepareMaterial( material, targetScene, object );
  						materials.add( material );

  					}

  				}

  			} );

  			currentRenderState = renderStateStack.pop();

  			return materials;

  		};

  		// compileAsync

  		/**
  		 * Asynchronous version of {@link WebGLRenderer#compile}.
  		 *
  		 * This method makes use of the `KHR_parallel_shader_compile` WebGL extension. Hence,
  		 * it is recommended to use this version of `compile()` whenever possible.
  		 *
  		 * @async
  		 * @param {Object3D} scene - The scene or another type of 3D object to precompile.
  		 * @param {Camera} camera - The camera.
  		 * @param {?Scene} [targetScene=null] - The target scene.
  		 * @return {Promise} A Promise that resolves when the given scene can be rendered without unnecessary stalling due to shader compilation.
  		 */
  		this.compileAsync = function ( scene, camera, targetScene = null ) {

  			const materials = this.compile( scene, camera, targetScene );

  			// Wait for all the materials in the new object to indicate that they're
  			// ready to be used before resolving the promise.

  			return new Promise( ( resolve ) => {

  				function checkMaterialsReady() {

  					materials.forEach( function ( material ) {

  						const materialProperties = properties.get( material );
  						const program = materialProperties.currentProgram;

  						if ( program.isReady() ) {

  							// remove any programs that report they're ready to use from the list
  							materials.delete( material );

  						}

  					} );

  					// once the list of compiling materials is empty, call the callback

  					if ( materials.size === 0 ) {

  						resolve( scene );
  						return;

  					}

  					// if some materials are still not ready, wait a bit and check again

  					setTimeout( checkMaterialsReady, 10 );

  				}

  				if ( extensions.get( 'KHR_parallel_shader_compile' ) !== null ) {

  					// If we can check the compilation status of the materials without
  					// blocking then do so right away.

  					checkMaterialsReady();

  				} else {

  					// Otherwise start by waiting a bit to give the materials we just
  					// initialized a chance to finish.

  					setTimeout( checkMaterialsReady, 10 );

  				}

  			} );

  		};

  		// Animation Loop

  		let onAnimationFrameCallback = null;

  		function onAnimationFrame( time ) {

  			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

  		}

  		function onXRSessionStart() {

  			animation.stop();

  		}

  		function onXRSessionEnd() {

  			animation.start();

  		}

  		const animation = new WebGLAnimation();
  		animation.setAnimationLoop( onAnimationFrame );

  		if ( typeof self !== 'undefined' ) animation.setContext( self );

  		this.setAnimationLoop = function ( callback ) {

  			onAnimationFrameCallback = callback;
  			xr.setAnimationLoop( callback );

  			( callback === null ) ? animation.stop() : animation.start();

  		};

  		xr.addEventListener( 'sessionstart', onXRSessionStart );
  		xr.addEventListener( 'sessionend', onXRSessionEnd );

  		// Rendering

  		/**
  		 * Renders the given scene (or other type of 3D object) using the given camera.
  		 *
  		 * The render is done to a previously specified render target set by calling {@link WebGLRenderer#setRenderTarget}
  		 * or to the canvas as usual.
  		 *
  		 * By default render buffers are cleared before rendering but you can prevent
  		 * this by setting the property `autoClear` to `false`. If you want to prevent
  		 * only certain buffers being cleared you can `autoClearColor`, `autoClearDepth`
  		 * or `autoClearStencil` to `false`. To force a clear, use {@link WebGLRenderer#clear}.
  		 *
  		 * @param {Object3D} scene - The scene to render.
  		 * @param {Camera} camera - The camera.
  		 */
  		this.render = function ( scene, camera ) {

  			if ( camera !== undefined && camera.isCamera !== true ) {

  				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
  				return;

  			}

  			if ( _isContextLost === true ) return;

  			// update scene graph

  			if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

  			// update camera matrices and frustum

  			if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

  			if ( xr.enabled === true && xr.isPresenting === true ) {

  				if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

  				camera = xr.getCamera(); // use XR camera for rendering

  			}

  			//
  			if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

  			currentRenderState = renderStates.get( scene, renderStateStack.length );
  			currentRenderState.init( camera );

  			renderStateStack.push( currentRenderState );

  			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  			_frustum.setFromProjectionMatrix( _projScreenMatrix, WebGLCoordinateSystem, camera.reversedDepth );

  			_localClippingEnabled = this.localClippingEnabled;
  			_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );

  			currentRenderList = renderLists.get( scene, renderListStack.length );
  			currentRenderList.init();

  			renderListStack.push( currentRenderList );

  			if ( xr.enabled === true && xr.isPresenting === true ) {

  				const depthSensingMesh = _this.xr.getDepthSensingMesh();

  				if ( depthSensingMesh !== null ) {

  					projectObject( depthSensingMesh, camera, - Infinity, _this.sortObjects );

  				}

  			}

  			projectObject( scene, camera, 0, _this.sortObjects );

  			currentRenderList.finish();

  			if ( _this.sortObjects === true ) {

  				currentRenderList.sort( _opaqueSort, _transparentSort );

  			}

  			_renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
  			if ( _renderBackground ) {

  				background.addToRenderList( currentRenderList, scene );

  			}

  			//

  			this.info.render.frame ++;

  			if ( _clippingEnabled === true ) clipping.beginShadows();

  			const shadowsArray = currentRenderState.state.shadowsArray;

  			shadowMap.render( shadowsArray, scene, camera );

  			if ( _clippingEnabled === true ) clipping.endShadows();

  			//

  			if ( this.info.autoReset === true ) this.info.reset();

  			// render scene

  			const opaqueObjects = currentRenderList.opaque;
  			const transmissiveObjects = currentRenderList.transmissive;

  			currentRenderState.setupLights();

  			if ( camera.isArrayCamera ) {

  				const cameras = camera.cameras;

  				if ( transmissiveObjects.length > 0 ) {

  					for ( let i = 0, l = cameras.length; i < l; i ++ ) {

  						const camera2 = cameras[ i ];

  						renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera2 );

  					}

  				}

  				if ( _renderBackground ) background.render( scene );

  				for ( let i = 0, l = cameras.length; i < l; i ++ ) {

  					const camera2 = cameras[ i ];

  					renderScene( currentRenderList, scene, camera2, camera2.viewport );

  				}

  			} else {

  				if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );

  				if ( _renderBackground ) background.render( scene );

  				renderScene( currentRenderList, scene, camera );

  			}

  			//

  			if ( _currentRenderTarget !== null && _currentActiveMipmapLevel === 0 ) {

  				// resolve multisample renderbuffers to a single-sample texture if necessary

  				textures.updateMultisampleRenderTarget( _currentRenderTarget );

  				// Generate mipmap if we're using any kind of mipmap filtering

  				textures.updateRenderTargetMipmap( _currentRenderTarget );

  			}

  			//

  			if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

  			// _gl.finish();

  			bindingStates.resetDefaultState();
  			_currentMaterialId = -1;
  			_currentCamera = null;

  			renderStateStack.pop();

  			if ( renderStateStack.length > 0 ) {

  				currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

  				if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, currentRenderState.state.camera );

  			} else {

  				currentRenderState = null;

  			}

  			renderListStack.pop();

  			if ( renderListStack.length > 0 ) {

  				currentRenderList = renderListStack[ renderListStack.length - 1 ];

  			} else {

  				currentRenderList = null;

  			}

  		};

  		function projectObject( object, camera, groupOrder, sortObjects ) {

  			if ( object.visible === false ) return;

  			const visible = object.layers.test( camera.layers );

  			if ( visible ) {

  				if ( object.isGroup ) {

  					groupOrder = object.renderOrder;

  				} else if ( object.isLOD ) {

  					if ( object.autoUpdate === true ) object.update( camera );

  				} else if ( object.isLight ) {

  					currentRenderState.pushLight( object );

  					if ( object.castShadow ) {

  						currentRenderState.pushShadow( object );

  					}

  				} else if ( object.isSprite ) {

  					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

  						if ( sortObjects ) {

  							_vector4.setFromMatrixPosition( object.matrixWorld )
  								.applyMatrix4( _projScreenMatrix );

  						}

  						const geometry = objects.update( object );
  						const material = object.material;

  						if ( material.visible ) {

  							currentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );

  						}

  					}

  				} else if ( object.isMesh || object.isLine || object.isPoints ) {

  					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

  						const geometry = objects.update( object );
  						const material = object.material;

  						if ( sortObjects ) {

  							if ( object.boundingSphere !== undefined ) {

  								if ( object.boundingSphere === null ) object.computeBoundingSphere();
  								_vector4.copy( object.boundingSphere.center );

  							} else {

  								if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
  								_vector4.copy( geometry.boundingSphere.center );

  							}

  							_vector4
  								.applyMatrix4( object.matrixWorld )
  								.applyMatrix4( _projScreenMatrix );

  						}

  						if ( Array.isArray( material ) ) {

  							const groups = geometry.groups;

  							for ( let i = 0, l = groups.length; i < l; i ++ ) {

  								const group = groups[ i ];
  								const groupMaterial = material[ group.materialIndex ];

  								if ( groupMaterial && groupMaterial.visible ) {

  									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group );

  								}

  							}

  						} else if ( material.visible ) {

  							currentRenderList.push( object, geometry, material, groupOrder, _vector4.z, null );

  						}

  					}

  				}

  			}

  			const children = object.children;

  			for ( let i = 0, l = children.length; i < l; i ++ ) {

  				projectObject( children[ i ], camera, groupOrder, sortObjects );

  			}

  		}

  		function renderScene( currentRenderList, scene, camera, viewport ) {

  			const opaqueObjects = currentRenderList.opaque;
  			const transmissiveObjects = currentRenderList.transmissive;
  			const transparentObjects = currentRenderList.transparent;

  			currentRenderState.setupLightsView( camera );

  			if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

  			if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

  			if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
  			if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
  			if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

  			// Ensure depth buffer writing is enabled so it can be cleared on next render

  			state.buffers.depth.setTest( true );
  			state.buffers.depth.setMask( true );
  			state.buffers.color.setMask( true );

  			state.setPolygonOffset( false );

  		}

  		function renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {

  			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

  			if ( overrideMaterial !== null ) {

  				return;

  			}

  			if ( currentRenderState.state.transmissionRenderTarget[ camera.id ] === undefined ) {

  				currentRenderState.state.transmissionRenderTarget[ camera.id ] = new WebGLRenderTarget( 1, 1, {
  					generateMipmaps: true,
  					type: ( extensions.has( 'EXT_color_buffer_half_float' ) || extensions.has( 'EXT_color_buffer_float' ) ) ? HalfFloatType : UnsignedByteType,
  					minFilter: LinearMipmapLinearFilter,
  					samples: 4,
  					stencilBuffer: stencil,
  					resolveDepthBuffer: false,
  					resolveStencilBuffer: false,
  					colorSpace: ColorManagement.workingColorSpace,
  				} );

  				// debug

  				/*
  				const geometry = new PlaneGeometry();
  				const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );

  				const mesh = new Mesh( geometry, material );
  				scene.add( mesh );
  				*/

  			}

  			const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[ camera.id ];

  			const activeViewport = camera.viewport || _currentViewport;
  			transmissionRenderTarget.setSize( activeViewport.z * _this.transmissionResolutionScale, activeViewport.w * _this.transmissionResolutionScale );

  			//

  			const currentRenderTarget = _this.getRenderTarget();
  			const currentActiveCubeFace = _this.getActiveCubeFace();
  			const currentActiveMipmapLevel = _this.getActiveMipmapLevel();

  			_this.setRenderTarget( transmissionRenderTarget );

  			_this.getClearColor( _currentClearColor );
  			_currentClearAlpha = _this.getClearAlpha();
  			if ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );

  			_this.clear();

  			if ( _renderBackground ) background.render( scene );

  			// Turn off the features which can affect the frag color for opaque objects pass.
  			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
  			const currentToneMapping = _this.toneMapping;
  			_this.toneMapping = NoToneMapping;

  			// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).
  			// Transmission render pass requires viewport to match the transmissionRenderTarget.
  			const currentCameraViewport = camera.viewport;
  			if ( camera.viewport !== undefined ) camera.viewport = undefined;

  			currentRenderState.setupLightsView( camera );

  			if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

  			renderObjects( opaqueObjects, scene, camera );

  			textures.updateMultisampleRenderTarget( transmissionRenderTarget );
  			textures.updateRenderTargetMipmap( transmissionRenderTarget );

  			if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === false ) { // see #28131

  				let renderTargetNeedsUpdate = false;

  				for ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {

  					const renderItem = transmissiveObjects[ i ];

  					const object = renderItem.object;
  					const geometry = renderItem.geometry;
  					const material = renderItem.material;
  					const group = renderItem.group;

  					if ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {

  						const currentSide = material.side;

  						material.side = BackSide;
  						material.needsUpdate = true;

  						renderObject( object, scene, camera, geometry, material, group );

  						material.side = currentSide;
  						material.needsUpdate = true;

  						renderTargetNeedsUpdate = true;

  					}

  				}

  				if ( renderTargetNeedsUpdate === true ) {

  					textures.updateMultisampleRenderTarget( transmissionRenderTarget );
  					textures.updateRenderTargetMipmap( transmissionRenderTarget );

  				}

  			}

  			_this.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );

  			_this.setClearColor( _currentClearColor, _currentClearAlpha );

  			if ( currentCameraViewport !== undefined ) camera.viewport = currentCameraViewport;

  			_this.toneMapping = currentToneMapping;

  		}

  		function renderObjects( renderList, scene, camera ) {

  			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

  			for ( let i = 0, l = renderList.length; i < l; i ++ ) {

  				const renderItem = renderList[ i ];

  				const object = renderItem.object;
  				const geometry = renderItem.geometry;
  				const group = renderItem.group;
  				let material = renderItem.material;

  				if ( material.allowOverride === true && overrideMaterial !== null ) {

  					material = overrideMaterial;

  				}

  				if ( object.layers.test( camera.layers ) ) {

  					renderObject( object, scene, camera, geometry, material, group );

  				}

  			}

  		}

  		function renderObject( object, scene, camera, geometry, material, group ) {

  			object.onBeforeRender( _this, scene, camera, geometry, material, group );

  			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
  			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

  			material.onBeforeRender( _this, scene, camera, geometry, object, group );

  			if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

  				material.side = BackSide;
  				material.needsUpdate = true;
  				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

  				material.side = FrontSide;
  				material.needsUpdate = true;
  				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

  				material.side = DoubleSide;

  			} else {

  				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

  			}

  			object.onAfterRender( _this, scene, camera, geometry, material, group );

  		}

  		function getProgram( material, scene, object ) {

  			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

  			const materialProperties = properties.get( material );

  			const lights = currentRenderState.state.lights;
  			const shadowsArray = currentRenderState.state.shadowsArray;

  			const lightsStateVersion = lights.state.version;

  			const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
  			const programCacheKey = programCache.getProgramCacheKey( parameters );

  			let programs = materialProperties.programs;

  			// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

  			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
  			materialProperties.fog = scene.fog;
  			materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );
  			materialProperties.envMapRotation = ( materialProperties.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;

  			if ( programs === undefined ) {

  				// new material

  				material.addEventListener( 'dispose', onMaterialDispose );

  				programs = new Map();
  				materialProperties.programs = programs;

  			}

  			let program = programs.get( programCacheKey );

  			if ( program !== undefined ) {

  				// early out if program and light state is identical

  				if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

  					updateCommonMaterialProperties( material, parameters );

  					return program;

  				}

  			} else {

  				parameters.uniforms = programCache.getUniforms( material );

  				material.onBeforeCompile( parameters, _this );

  				program = programCache.acquireProgram( parameters, programCacheKey );
  				programs.set( programCacheKey, program );

  				materialProperties.uniforms = parameters.uniforms;

  			}

  			const uniforms = materialProperties.uniforms;

  			if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

  				uniforms.clippingPlanes = clipping.uniform;

  			}

  			updateCommonMaterialProperties( material, parameters );

  			// store the light setup it was created for

  			materialProperties.needsLights = materialNeedsLights( material );
  			materialProperties.lightsStateVersion = lightsStateVersion;

  			if ( materialProperties.needsLights ) {

  				// wire up the material to this renderer's lighting state

  				uniforms.ambientLightColor.value = lights.state.ambient;
  				uniforms.lightProbe.value = lights.state.probe;
  				uniforms.directionalLights.value = lights.state.directional;
  				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
  				uniforms.spotLights.value = lights.state.spot;
  				uniforms.spotLightShadows.value = lights.state.spotShadow;
  				uniforms.rectAreaLights.value = lights.state.rectArea;
  				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
  				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
  				uniforms.pointLights.value = lights.state.point;
  				uniforms.pointLightShadows.value = lights.state.pointShadow;
  				uniforms.hemisphereLights.value = lights.state.hemi;

  				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
  				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
  				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
  				uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
  				uniforms.spotLightMap.value = lights.state.spotLightMap;
  				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
  				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
  				// TODO (abelnation): add area lights shadow info to uniforms

  			}

  			materialProperties.currentProgram = program;
  			materialProperties.uniformsList = null;

  			return program;

  		}

  		function getUniformList( materialProperties ) {

  			if ( materialProperties.uniformsList === null ) {

  				const progUniforms = materialProperties.currentProgram.getUniforms();
  				materialProperties.uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, materialProperties.uniforms );

  			}

  			return materialProperties.uniformsList;

  		}

  		function updateCommonMaterialProperties( material, parameters ) {

  			const materialProperties = properties.get( material );

  			materialProperties.outputColorSpace = parameters.outputColorSpace;
  			materialProperties.batching = parameters.batching;
  			materialProperties.batchingColor = parameters.batchingColor;
  			materialProperties.instancing = parameters.instancing;
  			materialProperties.instancingColor = parameters.instancingColor;
  			materialProperties.instancingMorph = parameters.instancingMorph;
  			materialProperties.skinning = parameters.skinning;
  			materialProperties.morphTargets = parameters.morphTargets;
  			materialProperties.morphNormals = parameters.morphNormals;
  			materialProperties.morphColors = parameters.morphColors;
  			materialProperties.morphTargetsCount = parameters.morphTargetsCount;
  			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
  			materialProperties.numIntersection = parameters.numClipIntersection;
  			materialProperties.vertexAlphas = parameters.vertexAlphas;
  			materialProperties.vertexTangents = parameters.vertexTangents;
  			materialProperties.toneMapping = parameters.toneMapping;

  		}

  		function setProgram( camera, scene, geometry, material, object ) {

  			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

  			textures.resetTextureUnits();

  			const fog = scene.fog;
  			const environment = material.isMeshStandardMaterial ? scene.environment : null;
  			const colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );
  			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
  			const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
  			const vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );
  			const morphTargets = !! geometry.morphAttributes.position;
  			const morphNormals = !! geometry.morphAttributes.normal;
  			const morphColors = !! geometry.morphAttributes.color;

  			let toneMapping = NoToneMapping;

  			if ( material.toneMapped ) {

  				if ( _currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true ) {

  					toneMapping = _this.toneMapping;

  				}

  			}

  			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

  			const materialProperties = properties.get( material );
  			const lights = currentRenderState.state.lights;

  			if ( _clippingEnabled === true ) {

  				if ( _localClippingEnabled === true || camera !== _currentCamera ) {

  					const useCache =
  						camera === _currentCamera &&
  						material.id === _currentMaterialId;

  					// we might want to call this function with some ClippingGroup
  					// object instead of the material, once it becomes feasible
  					// (#8465, #8379)
  					clipping.setState( material, camera, useCache );

  				}

  			}

  			//

  			let needsProgramChange = false;

  			if ( material.version === materialProperties.__version ) {

  				if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.outputColorSpace !== colorSpace ) {

  					needsProgramChange = true;

  				} else if ( object.isBatchedMesh && materialProperties.batching === false ) {

  					needsProgramChange = true;

  				} else if ( ! object.isBatchedMesh && materialProperties.batching === true ) {

  					needsProgramChange = true;

  				} else if ( object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null ) {

  					needsProgramChange = true;

  				} else if ( object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null ) {

  					needsProgramChange = true;

  				} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

  					needsProgramChange = true;

  				} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

  					needsProgramChange = true;

  				} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

  					needsProgramChange = true;

  				} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

  					needsProgramChange = true;

  				} else if ( object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null ) {

  					needsProgramChange = true;

  				} else if ( object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null ) {

  					needsProgramChange = true;

  				} else if ( object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null ) {

  					needsProgramChange = true;

  				} else if ( object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.envMap !== envMap ) {

  					needsProgramChange = true;

  				} else if ( material.fog === true && materialProperties.fog !== fog ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.numClippingPlanes !== undefined &&
  					( materialProperties.numClippingPlanes !== clipping.numPlanes ||
  					materialProperties.numIntersection !== clipping.numIntersection ) ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.vertexTangents !== vertexTangents ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.morphTargets !== morphTargets ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.morphNormals !== morphNormals ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.morphColors !== morphColors ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.toneMapping !== toneMapping ) {

  					needsProgramChange = true;

  				} else if ( materialProperties.morphTargetsCount !== morphTargetsCount ) {

  					needsProgramChange = true;

  				}

  			} else {

  				needsProgramChange = true;
  				materialProperties.__version = material.version;

  			}

  			//

  			let program = materialProperties.currentProgram;

  			if ( needsProgramChange === true ) {

  				program = getProgram( material, scene, object );

  			}

  			let refreshProgram = false;
  			let refreshMaterial = false;
  			let refreshLights = false;

  			const p_uniforms = program.getUniforms(),
  				m_uniforms = materialProperties.uniforms;

  			if ( state.useProgram( program.program ) ) {

  				refreshProgram = true;
  				refreshMaterial = true;
  				refreshLights = true;

  			}

  			if ( material.id !== _currentMaterialId ) {

  				_currentMaterialId = material.id;

  				refreshMaterial = true;

  			}

  			if ( refreshProgram || _currentCamera !== camera ) {

  				// common camera uniforms

  				const reversedDepthBuffer = state.buffers.depth.getReversed();

  				if ( reversedDepthBuffer && camera.reversedDepth !== true ) {

  					camera._reversedDepth = true;
  					camera.updateProjectionMatrix();

  				}

  				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

  				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

  				const uCamPos = p_uniforms.map.cameraPosition;

  				if ( uCamPos !== undefined ) {

  					uCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) );

  				}

  				if ( capabilities.logarithmicDepthBuffer ) {

  					p_uniforms.setValue( _gl, 'logDepthBufFC',
  						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

  				}

  				// consider moving isOrthographic to UniformLib and WebGLMaterials, see https://github.com/mrdoob/three.js/pull/26467#issuecomment-1645185067

  				if ( material.isMeshPhongMaterial ||
  					material.isMeshToonMaterial ||
  					material.isMeshLambertMaterial ||
  					material.isMeshBasicMaterial ||
  					material.isMeshStandardMaterial ||
  					material.isShaderMaterial ) {

  					p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

  				}

  				if ( _currentCamera !== camera ) {

  					_currentCamera = camera;

  					// lighting uniforms depend on the camera so enforce an update
  					// now, in case this material supports lights - or later, when
  					// the next material that does gets activated:

  					refreshMaterial = true;		// set to true on material change
  					refreshLights = true;		// remains set until update done

  				}

  			}

  			// skinning and morph target uniforms must be set even if material didn't change
  			// auto-setting of texture unit for bone and morph texture must go before other textures
  			// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

  			if ( object.isSkinnedMesh ) {

  				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
  				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

  				const skeleton = object.skeleton;

  				if ( skeleton ) {

  					if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

  					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );

  				}

  			}

  			if ( object.isBatchedMesh ) {

  				p_uniforms.setOptional( _gl, object, 'batchingTexture' );
  				p_uniforms.setValue( _gl, 'batchingTexture', object._matricesTexture, textures );

  				p_uniforms.setOptional( _gl, object, 'batchingIdTexture' );
  				p_uniforms.setValue( _gl, 'batchingIdTexture', object._indirectTexture, textures );

  				p_uniforms.setOptional( _gl, object, 'batchingColorTexture' );
  				if ( object._colorsTexture !== null ) {

  					p_uniforms.setValue( _gl, 'batchingColorTexture', object._colorsTexture, textures );

  				}

  			}

  			const morphAttributes = geometry.morphAttributes;

  			if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined ) ) {

  				morphtargets.update( object, geometry, program );

  			}

  			if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

  				materialProperties.receiveShadow = object.receiveShadow;
  				p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

  			}

  			// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

  			if ( material.isMeshGouraudMaterial && material.envMap !== null ) {

  				m_uniforms.envMap.value = envMap;

  				m_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? -1 : 1;

  			}

  			if ( material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null ) {

  				m_uniforms.envMapIntensity.value = scene.environmentIntensity;

  			}

  			if ( refreshMaterial ) {

  				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

  				if ( materialProperties.needsLights ) {

  					// the current material requires lighting info

  					// note: all lighting uniforms are always set correctly
  					// they simply reference the renderer's state for their
  					// values
  					//
  					// use the current material's .needsUpdate flags to set
  					// the GL state when required

  					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

  				}

  				// refresh uniforms common to several materials

  				if ( fog && material.fog === true ) {

  					materials.refreshFogUniforms( m_uniforms, fog );

  				}

  				materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[ camera.id ] );

  				WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );

  			}

  			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

  				WebGLUniforms.upload( _gl, getUniformList( materialProperties ), m_uniforms, textures );
  				material.uniformsNeedUpdate = false;

  			}

  			if ( material.isSpriteMaterial ) {

  				p_uniforms.setValue( _gl, 'center', object.center );

  			}

  			// common matrices

  			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
  			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
  			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

  			// UBOs

  			if ( material.isShaderMaterial || material.isRawShaderMaterial ) {

  				const groups = material.uniformsGroups;

  				for ( let i = 0, l = groups.length; i < l; i ++ ) {

  					const group = groups[ i ];

  					uniformsGroups.update( group, program );
  					uniformsGroups.bind( group, program );

  				}

  			}

  			return program;

  		}

  		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

  		function markUniformsLightsNeedsUpdate( uniforms, value ) {

  			uniforms.ambientLightColor.needsUpdate = value;
  			uniforms.lightProbe.needsUpdate = value;

  			uniforms.directionalLights.needsUpdate = value;
  			uniforms.directionalLightShadows.needsUpdate = value;
  			uniforms.pointLights.needsUpdate = value;
  			uniforms.pointLightShadows.needsUpdate = value;
  			uniforms.spotLights.needsUpdate = value;
  			uniforms.spotLightShadows.needsUpdate = value;
  			uniforms.rectAreaLights.needsUpdate = value;
  			uniforms.hemisphereLights.needsUpdate = value;

  		}

  		function materialNeedsLights( material ) {

  			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
  				material.isMeshStandardMaterial || material.isShadowMaterial ||
  				( material.isShaderMaterial && material.lights === true );

  		}

  		/**
  		 * Returns the active cube face.
  		 *
  		 * @return {number} The active cube face.
  		 */
  		this.getActiveCubeFace = function () {

  			return _currentActiveCubeFace;

  		};

  		/**
  		 * Returns the active mipmap level.
  		 *
  		 * @return {number} The active mipmap level.
  		 */
  		this.getActiveMipmapLevel = function () {

  			return _currentActiveMipmapLevel;

  		};

  		/**
  		 * Returns the active render target.
  		 *
  		 * @return {?WebGLRenderTarget} The active render target. Returns `null` if no render target
  		 * is currently set.
  		 */
  		this.getRenderTarget = function () {

  			return _currentRenderTarget;

  		};

  		this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

  			const renderTargetProperties = properties.get( renderTarget );

  			renderTargetProperties.__autoAllocateDepthBuffer = renderTarget.resolveDepthBuffer === false;
  			if ( renderTargetProperties.__autoAllocateDepthBuffer === false ) {

  				// The multisample_render_to_texture extension doesn't work properly if there
  				// are midframe flushes and an external depth buffer. Disable use of the extension.
  				renderTargetProperties.__useRenderToTexture = false;

  			}

  			properties.get( renderTarget.texture ).__webglTexture = colorTexture;
  			properties.get( renderTarget.depthTexture ).__webglTexture = renderTargetProperties.__autoAllocateDepthBuffer ? undefined : depthTexture;

  			renderTargetProperties.__hasExternalTextures = true;

  		};

  		this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

  			const renderTargetProperties = properties.get( renderTarget );
  			renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
  			renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

  		};

  		const _scratchFrameBuffer = _gl.createFramebuffer();

  		/**
  		 * Sets the active rendertarget.
  		 *
  		 * @param {?WebGLRenderTarget} renderTarget - The render target to set. When `null` is given,
  		 * the canvas is set as the active render target instead.
  		 * @param {number} [activeCubeFace=0] - The active cube face when using a cube render target.
  		 * Indicates the z layer to render in to when using 3D or array render targets.
  		 * @param {number} [activeMipmapLevel=0] - The active mipmap level.
  		 */
  		this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

  			_currentRenderTarget = renderTarget;
  			_currentActiveCubeFace = activeCubeFace;
  			_currentActiveMipmapLevel = activeMipmapLevel;

  			let useDefaultFramebuffer = true;
  			let framebuffer = null;
  			let isCube = false;
  			let isRenderTarget3D = false;

  			if ( renderTarget ) {

  				const renderTargetProperties = properties.get( renderTarget );

  				if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

  					// We need to make sure to rebind the framebuffer.
  					state.bindFramebuffer( _gl.FRAMEBUFFER, null );
  					useDefaultFramebuffer = false;

  				} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

  					textures.setupRenderTarget( renderTarget );

  				} else if ( renderTargetProperties.__hasExternalTextures ) {

  					// Color and depth texture must be rebound in order for the swapchain to update.
  					textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

  				} else if ( renderTarget.depthBuffer ) {

  					// check if the depth texture is already bound to the frame buffer and that it's been initialized
  					const depthTexture = renderTarget.depthTexture;
  					if ( renderTargetProperties.__boundDepthTexture !== depthTexture ) {

  						// check if the depth texture is compatible
  						if (
  							depthTexture !== null &&
  							properties.has( depthTexture ) &&
  							( renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height )
  						) {

  							throw new Error( 'WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.' );

  						}

  						// Swap the depth buffer to the currently attached one
  						textures.setupDepthRenderbuffer( renderTarget );

  					}

  				}

  				const texture = renderTarget.texture;

  				if ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

  					isRenderTarget3D = true;

  				}

  				const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

  				if ( renderTarget.isWebGLCubeRenderTarget ) {

  					if ( Array.isArray( __webglFramebuffer[ activeCubeFace ] ) ) {

  						framebuffer = __webglFramebuffer[ activeCubeFace ][ activeMipmapLevel ];

  					} else {

  						framebuffer = __webglFramebuffer[ activeCubeFace ];

  					}

  					isCube = true;

  				} else if ( ( renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

  					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

  				} else {

  					if ( Array.isArray( __webglFramebuffer ) ) {

  						framebuffer = __webglFramebuffer[ activeMipmapLevel ];

  					} else {

  						framebuffer = __webglFramebuffer;

  					}

  				}

  				_currentViewport.copy( renderTarget.viewport );
  				_currentScissor.copy( renderTarget.scissor );
  				_currentScissorTest = renderTarget.scissorTest;

  			} else {

  				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
  				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
  				_currentScissorTest = _scissorTest;

  			}

  			// Use a scratch frame buffer if rendering to a mip level to avoid depth buffers
  			// being bound that are different sizes.
  			if ( activeMipmapLevel !== 0 ) {

  				framebuffer = _scratchFrameBuffer;

  			}

  			const framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  			if ( framebufferBound && useDefaultFramebuffer ) {

  				state.drawBuffers( renderTarget, framebuffer );

  			}

  			state.viewport( _currentViewport );
  			state.scissor( _currentScissor );
  			state.setScissorTest( _currentScissorTest );

  			if ( isCube ) {

  				const textureProperties = properties.get( renderTarget.texture );
  				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

  			} else if ( isRenderTarget3D ) {

  				const layer = activeCubeFace;

  				for ( let i = 0; i < renderTarget.textures.length; i ++ ) {

  					const textureProperties = properties.get( renderTarget.textures[ i ] );

  					_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, textureProperties.__webglTexture, activeMipmapLevel, layer );

  				}

  			} else if ( renderTarget !== null && activeMipmapLevel !== 0 ) {

  				// Only bind the frame buffer if we are using a scratch frame buffer to render to a mipmap.
  				// If we rebind the texture when using a multi sample buffer then an error about inconsistent samples will be thrown.
  				const textureProperties = properties.get( renderTarget.texture );
  				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, textureProperties.__webglTexture, activeMipmapLevel );

  			}

  			_currentMaterialId = -1; // reset current material to ensure correct uniform bindings

  		};

  		/**
  		 * Reads the pixel data from the given render target into the given buffer.
  		 *
  		 * @param {WebGLRenderTarget} renderTarget - The render target to read from.
  		 * @param {number} x - The `x` coordinate of the copy region's origin.
  		 * @param {number} y - The `y` coordinate of the copy region's origin.
  		 * @param {number} width - The width of the copy region.
  		 * @param {number} height - The height of the copy region.
  		 * @param {TypedArray} buffer - The result buffer.
  		 * @param {number} [activeCubeFaceIndex] - The active cube face index.
  		 * @param {number} [textureIndex=0] - The texture index of an MRT render target.
  		 */
  		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex, textureIndex = 0 ) {

  			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

  				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
  				return;

  			}

  			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

  			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

  				framebuffer = framebuffer[ activeCubeFaceIndex ];

  			}

  			if ( framebuffer ) {

  				state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  				try {

  					const texture = renderTarget.textures[ textureIndex ];
  					const textureFormat = texture.format;
  					const textureType = texture.type;

  					if ( ! capabilities.textureFormatReadable( textureFormat ) ) {

  						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
  						return;

  					}

  					if ( ! capabilities.textureTypeReadable( textureType ) ) {

  						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
  						return;

  					}

  					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

  					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

  						// when using MRT, select the correct color buffer for the subsequent read command

  						if ( renderTarget.textures.length > 1 ) _gl.readBuffer( _gl.COLOR_ATTACHMENT0 + textureIndex );

  						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

  					}

  				} finally {

  					// restore framebuffer of current render target if necessary

  					const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
  					state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  				}

  			}

  		};

  		/**
  		 * Asynchronous, non-blocking version of {@link WebGLRenderer#readRenderTargetPixels}.
  		 *
  		 * It is recommended to use this version of `readRenderTargetPixels()` whenever possible.
  		 *
  		 * @async
  		 * @param {WebGLRenderTarget} renderTarget - The render target to read from.
  		 * @param {number} x - The `x` coordinate of the copy region's origin.
  		 * @param {number} y - The `y` coordinate of the copy region's origin.
  		 * @param {number} width - The width of the copy region.
  		 * @param {number} height - The height of the copy region.
  		 * @param {TypedArray} buffer - The result buffer.
  		 * @param {number} [activeCubeFaceIndex] - The active cube face index.
  		 * @param {number} [textureIndex=0] - The texture index of an MRT render target.
  		 * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
  		 */
  		this.readRenderTargetPixelsAsync = async function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex, textureIndex = 0 ) {

  			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

  				throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );

  			}

  			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;
  			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

  				framebuffer = framebuffer[ activeCubeFaceIndex ];

  			}

  			if ( framebuffer ) {

  				// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
  				if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

  					// set the active frame buffer to the one we want to read
  					state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  					const texture = renderTarget.textures[ textureIndex ];
  					const textureFormat = texture.format;
  					const textureType = texture.type;

  					if ( ! capabilities.textureFormatReadable( textureFormat ) ) {

  						throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.' );

  					}

  					if ( ! capabilities.textureTypeReadable( textureType ) ) {

  						throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.' );

  					}

  					const glBuffer = _gl.createBuffer();
  					_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );
  					_gl.bufferData( _gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ );

  					// when using MRT, select the correct color buffer for the subsequent read command

  					if ( renderTarget.textures.length > 1 ) _gl.readBuffer( _gl.COLOR_ATTACHMENT0 + textureIndex );

  					_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), 0 );

  					// reset the frame buffer to the currently set buffer before waiting
  					const currFramebuffer = _currentRenderTarget !== null ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
  					state.bindFramebuffer( _gl.FRAMEBUFFER, currFramebuffer );

  					// check if the commands have finished every 8 ms
  					const sync = _gl.fenceSync( _gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );

  					_gl.flush();

  					await probeAsync( _gl, sync, 4 );

  					// read the data and delete the buffer
  					_gl.bindBuffer( _gl.PIXEL_PACK_BUFFER, glBuffer );
  					_gl.getBufferSubData( _gl.PIXEL_PACK_BUFFER, 0, buffer );
  					_gl.deleteBuffer( glBuffer );
  					_gl.deleteSync( sync );

  					return buffer;

  				} else {

  					throw new Error( 'THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.' );

  				}

  			}

  		};

  		/**
  		 * Copies pixels from the current bound framebuffer into the given texture.
  		 *
  		 * @param {FramebufferTexture} texture - The texture.
  		 * @param {?Vector2} [position=null] - The start position of the copy operation.
  		 * @param {number} [level=0] - The mip level. The default represents the base mip.
  		 */
  		this.copyFramebufferToTexture = function ( texture, position = null, level = 0 ) {

  			const levelScale = Math.pow( 2, - level );
  			const width = Math.floor( texture.image.width * levelScale );
  			const height = Math.floor( texture.image.height * levelScale );

  			const x = position !== null ? position.x : 0;
  			const y = position !== null ? position.y : 0;

  			textures.setTexture2D( texture, 0 );

  			_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, x, y, width, height );

  			state.unbindTexture();

  		};

  		const _srcFramebuffer = _gl.createFramebuffer();
  		const _dstFramebuffer = _gl.createFramebuffer();

  		/**
  		 * Copies data of the given source texture into a destination texture.
  		 *
  		 * When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are initialized
  		 * {@link WebGLRenderer#initRenderTarget}.
  		 *
  		 * @param {Texture} srcTexture - The source texture.
  		 * @param {Texture} dstTexture - The destination texture.
  		 * @param {?(Box2|Box3)} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
  		 * @param {?(Vector2|Vector3)} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
  		 * @param {number} [srcLevel=0] - The source mipmap level to copy.
  		 * @param {?number} [dstLevel=null] - The destination mipmap level.
  		 */
  		this.copyTextureToTexture = function ( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = null ) {

  			// support the previous signature with just a single dst mipmap level
  			if ( dstLevel === null ) {

  				if ( srcLevel !== 0 ) {

  					// @deprecated, r171
  					warnOnce( 'WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.' );
  					dstLevel = srcLevel;
  					srcLevel = 0;

  				} else {

  					dstLevel = 0;

  				}

  			}

  			// gather the necessary dimensions to copy
  			let width, height, depth, minX, minY, minZ;
  			let dstX, dstY, dstZ;
  			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ dstLevel ] : srcTexture.image;
  			if ( srcRegion !== null ) {

  				width = srcRegion.max.x - srcRegion.min.x;
  				height = srcRegion.max.y - srcRegion.min.y;
  				depth = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
  				minX = srcRegion.min.x;
  				minY = srcRegion.min.y;
  				minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;

  			} else {

  				const levelScale = Math.pow( 2, - srcLevel );
  				width = Math.floor( image.width * levelScale );
  				height = Math.floor( image.height * levelScale );
  				if ( srcTexture.isDataArrayTexture ) {

  					depth = image.depth;

  				} else if ( srcTexture.isData3DTexture ) {

  					depth = Math.floor( image.depth * levelScale );

  				} else {

  					depth = 1;

  				}

  				minX = 0;
  				minY = 0;
  				minZ = 0;

  			}

  			if ( dstPosition !== null ) {

  				dstX = dstPosition.x;
  				dstY = dstPosition.y;
  				dstZ = dstPosition.z;

  			} else {

  				dstX = 0;
  				dstY = 0;
  				dstZ = 0;

  			}

  			// Set up the destination target
  			const glFormat = utils.convert( dstTexture.format );
  			const glType = utils.convert( dstTexture.type );
  			let glTarget;

  			if ( dstTexture.isData3DTexture ) {

  				textures.setTexture3D( dstTexture, 0 );
  				glTarget = _gl.TEXTURE_3D;

  			} else if ( dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture ) {

  				textures.setTexture2DArray( dstTexture, 0 );
  				glTarget = _gl.TEXTURE_2D_ARRAY;

  			} else {

  				textures.setTexture2D( dstTexture, 0 );
  				glTarget = _gl.TEXTURE_2D;

  			}

  			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
  			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
  			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

  			// used for copying data from cpu
  			const currentUnpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
  			const currentUnpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );
  			const currentUnpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
  			const currentUnpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );
  			const currentUnpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );

  			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );
  			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, minX );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, minY );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, minZ );

  			// set up the src texture
  			const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;
  			const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;
  			if ( srcTexture.isDepthTexture ) {

  				const srcTextureProperties = properties.get( srcTexture );
  				const dstTextureProperties = properties.get( dstTexture );
  				const srcRenderTargetProperties = properties.get( srcTextureProperties.__renderTarget );
  				const dstRenderTargetProperties = properties.get( dstTextureProperties.__renderTarget );
  				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer );
  				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer );

  				for ( let i = 0; i < depth; i ++ ) {

  					// if the source or destination are a 3d target then a layer needs to be bound
  					if ( isSrc3D ) {

  						_gl.framebufferTextureLayer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get( srcTexture ).__webglTexture, srcLevel, minZ + i );
  						_gl.framebufferTextureLayer( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get( dstTexture ).__webglTexture, dstLevel, dstZ + i );

  					}

  					_gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST );

  				}

  				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
  				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

  			} else if ( srcLevel !== 0 || srcTexture.isRenderTargetTexture || properties.has( srcTexture ) ) {

  				// get the appropriate frame buffers
  				const srcTextureProperties = properties.get( srcTexture );
  				const dstTextureProperties = properties.get( dstTexture );

  				// bind the frame buffer targets
  				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, _srcFramebuffer );
  				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, _dstFramebuffer );

  				for ( let i = 0; i < depth; i ++ ) {

  					// assign the correct layers and mip maps to the frame buffers
  					if ( isSrc3D ) {

  						_gl.framebufferTextureLayer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, srcTextureProperties.__webglTexture, srcLevel, minZ + i );

  					} else {

  						_gl.framebufferTexture2D( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, srcTextureProperties.__webglTexture, srcLevel );

  					}

  					if ( isDst3D ) {

  						_gl.framebufferTextureLayer( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, dstTextureProperties.__webglTexture, dstLevel, dstZ + i );

  					} else {

  						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, dstTextureProperties.__webglTexture, dstLevel );

  					}

  					// copy the data using the fastest function that can achieve the copy
  					if ( srcLevel !== 0 ) {

  						_gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST );

  					} else if ( isDst3D ) {

  						_gl.copyTexSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ + i, minX, minY, width, height );

  					} else {

  						_gl.copyTexSubImage2D( glTarget, dstLevel, dstX, dstY, minX, minY, width, height );

  					}

  				}

  				// unbind read, draw buffers
  				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
  				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

  			} else {

  				if ( isDst3D ) {

  					// copy data into the 3d texture
  					if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

  						_gl.texSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data );

  					} else if ( dstTexture.isCompressedArrayTexture ) {

  						_gl.compressedTexSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, image.data );

  					} else {

  						_gl.texSubImage3D( glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image );

  					}

  				} else {

  					// copy data into the 2d texture
  					if ( srcTexture.isDataTexture ) {

  						_gl.texSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data );

  					} else if ( srcTexture.isCompressedTexture ) {

  						_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data );

  					} else {

  						_gl.texSubImage2D( _gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image );

  					}

  				}

  			}

  			// reset values
  			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
  			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );
  			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );

  			// Generate mipmaps only when copying level 0
  			if ( dstLevel === 0 && dstTexture.generateMipmaps ) {

  				_gl.generateMipmap( glTarget );

  			}

  			state.unbindTexture();

  		};

  		/**
  		 * Initializes the given WebGLRenderTarget memory. Useful for initializing a render target so data
  		 * can be copied into it using {@link WebGLRenderer#copyTextureToTexture} before it has been
  		 * rendered to.
  		 *
  		 * @param {WebGLRenderTarget} target - The render target.
  		 */
  		this.initRenderTarget = function ( target ) {

  			if ( properties.get( target ).__webglFramebuffer === undefined ) {

  				textures.setupRenderTarget( target );

  			}

  		};

  		/**
  		 * Initializes the given texture. Useful for preloading a texture rather than waiting until first
  		 * render (which can cause noticeable lags due to decode and GPU upload overhead).
  		 *
  		 * @param {Texture} texture - The texture.
  		 */
  		this.initTexture = function ( texture ) {

  			if ( texture.isCubeTexture ) {

  				textures.setTextureCube( texture, 0 );

  			} else if ( texture.isData3DTexture ) {

  				textures.setTexture3D( texture, 0 );

  			} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

  				textures.setTexture2DArray( texture, 0 );

  			} else {

  				textures.setTexture2D( texture, 0 );

  			}

  			state.unbindTexture();

  		};

  		/**
  		 * Can be used to reset the internal WebGL state. This method is mostly
  		 * relevant for applications which share a single WebGL context across
  		 * multiple WebGL libraries.
  		 */
  		this.resetState = function () {

  			_currentActiveCubeFace = 0;
  			_currentActiveMipmapLevel = 0;
  			_currentRenderTarget = null;

  			state.reset();
  			bindingStates.reset();

  		};

  		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

  			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

  		}

  	}

  	/**
  	 * Defines the coordinate system of the renderer.
  	 *
  	 * In `WebGLRenderer`, the value is always `WebGLCoordinateSystem`.
  	 *
  	 * @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}
  	 * @default WebGLCoordinateSystem
  	 * @readonly
  	 */
  	get coordinateSystem() {

  		return WebGLCoordinateSystem;

  	}

  	/**
  	 * Defines the output color space of the renderer.
  	 *
  	 * @type {SRGBColorSpace|LinearSRGBColorSpace}
  	 * @default SRGBColorSpace
  	 */
  	get outputColorSpace() {

  		return this._outputColorSpace;

  	}

  	set outputColorSpace( colorSpace ) {

  		this._outputColorSpace = colorSpace;

  		const gl = this.getContext();
  		gl.drawingBufferColorSpace = ColorManagement._getDrawingBufferColorSpace( colorSpace );
  		gl.unpackColorSpace = ColorManagement._getUnpackColorSpace();

  	}

  }

  /**
   * lil-gui
   * https://lil-gui.georgealways.com
   * @version 0.20.0
   * @author George Michael Brower
   * @license MIT
   */

  /**
   * Base class for all controllers.
   */
  class Controller {

  	constructor( parent, object, property, className, elementType = 'div' ) {

  		/**
  		 * The GUI that contains this controller.
  		 * @type {GUI}
  		 */
  		this.parent = parent;

  		/**
  		 * The object this controller will modify.
  		 * @type {object}
  		 */
  		this.object = object;

  		/**
  		 * The name of the property to control.
  		 * @type {string}
  		 */
  		this.property = property;

  		/**
  		 * Used to determine if the controller is disabled.
  		 * Use `controller.disable( true|false )` to modify this value.
  		 * @type {boolean}
  		 */
  		this._disabled = false;

  		/**
  		 * Used to determine if the Controller is hidden.
  		 * Use `controller.show()` or `controller.hide()` to change this.
  		 * @type {boolean}
  		 */
  		this._hidden = false;

  		/**
  		 * The value of `object[ property ]` when the controller was created.
  		 * @type {any}
  		 */
  		this.initialValue = this.getValue();

  		/**
  		 * The outermost container DOM element for this controller.
  		 * @type {HTMLElement}
  		 */
  		this.domElement = document.createElement( elementType );
  		this.domElement.classList.add( 'controller' );
  		this.domElement.classList.add( className );

  		/**
  		 * The DOM element that contains the controller's name.
  		 * @type {HTMLElement}
  		 */
  		this.$name = document.createElement( 'div' );
  		this.$name.classList.add( 'name' );

  		Controller.nextNameID = Controller.nextNameID || 0;
  		this.$name.id = `lil-gui-name-${++Controller.nextNameID}`;

  		/**
  		 * The DOM element that contains the controller's "widget" (which differs by controller type).
  		 * @type {HTMLElement}
  		 */
  		this.$widget = document.createElement( 'div' );
  		this.$widget.classList.add( 'widget' );

  		/**
  		 * The DOM element that receives the disabled attribute when using disable().
  		 * @type {HTMLElement}
  		 */
  		this.$disable = this.$widget;

  		this.domElement.appendChild( this.$name );
  		this.domElement.appendChild( this.$widget );

  		// Don't fire global key events while typing in a controller
  		this.domElement.addEventListener( 'keydown', e => e.stopPropagation() );
  		this.domElement.addEventListener( 'keyup', e => e.stopPropagation() );

  		this.parent.children.push( this );
  		this.parent.controllers.push( this );

  		this.parent.$children.appendChild( this.domElement );

  		this._listenCallback = this._listenCallback.bind( this );

  		this.name( property );

  	}

  	/**
  	 * Sets the name of the controller and its label in the GUI.
  	 * @param {string} name
  	 * @returns {this}
  	 */
  	name( name ) {
  		/**
  		 * The controller's name. Use `controller.name( 'Name' )` to modify this value.
  		 * @type {string}
  		 */
  		this._name = name;
  		this.$name.textContent = name;
  		return this;
  	}

  	/**
  	 * Pass a function to be called whenever the value is modified by this controller.
  	 * The function receives the new value as its first parameter. The value of `this` will be the
  	 * controller.
  	 *
  	 * For function controllers, the `onChange` callback will be fired on click, after the function
  	 * executes.
  	 * @param {Function} callback
  	 * @returns {this}
  	 * @example
  	 * const controller = gui.add( object, 'property' );
  	 *
  	 * controller.onChange( function( v ) {
  	 * 	console.log( 'The value is now ' + v );
  	 * 	console.assert( this === controller );
  	 * } );
  	 */
  	onChange( callback ) {
  		/**
  		 * Used to access the function bound to `onChange` events. Don't modify this value directly.
  		 * Use the `controller.onChange( callback )` method instead.
  		 * @type {Function}
  		 */
  		this._onChange = callback;
  		return this;
  	}

  	/**
  	 * Calls the onChange methods of this controller and its parent GUI.
  	 * @protected
  	 */
  	_callOnChange() {

  		this.parent._callOnChange( this );

  		if ( this._onChange !== undefined ) {
  			this._onChange.call( this, this.getValue() );
  		}

  		this._changed = true;

  	}

  	/**
  	 * Pass a function to be called after this controller has been modified and loses focus.
  	 * @param {Function} callback
  	 * @returns {this}
  	 * @example
  	 * const controller = gui.add( object, 'property' );
  	 *
  	 * controller.onFinishChange( function( v ) {
  	 * 	console.log( 'Changes complete: ' + v );
  	 * 	console.assert( this === controller );
  	 * } );
  	 */
  	onFinishChange( callback ) {
  		/**
  		 * Used to access the function bound to `onFinishChange` events. Don't modify this value
  		 * directly. Use the `controller.onFinishChange( callback )` method instead.
  		 * @type {Function}
  		 */
  		this._onFinishChange = callback;
  		return this;
  	}

  	/**
  	 * Should be called by Controller when its widgets lose focus.
  	 * @protected
  	 */
  	_callOnFinishChange() {

  		if ( this._changed ) {

  			this.parent._callOnFinishChange( this );

  			if ( this._onFinishChange !== undefined ) {
  				this._onFinishChange.call( this, this.getValue() );
  			}

  		}

  		this._changed = false;

  	}

  	/**
  	 * Sets the controller back to its initial value.
  	 * @returns {this}
  	 */
  	reset() {
  		this.setValue( this.initialValue );
  		this._callOnFinishChange();
  		return this;
  	}

  	/**
  	 * Enables this controller.
  	 * @param {boolean} enabled
  	 * @returns {this}
  	 * @example
  	 * controller.enable();
  	 * controller.enable( false ); // disable
  	 * controller.enable( controller._disabled ); // toggle
  	 */
  	enable( enabled = true ) {
  		return this.disable( !enabled );
  	}

  	/**
  	 * Disables this controller.
  	 * @param {boolean} disabled
  	 * @returns {this}
  	 * @example
  	 * controller.disable();
  	 * controller.disable( false ); // enable
  	 * controller.disable( !controller._disabled ); // toggle
  	 */
  	disable( disabled = true ) {

  		if ( disabled === this._disabled ) return this;

  		this._disabled = disabled;

  		this.domElement.classList.toggle( 'disabled', disabled );
  		this.$disable.toggleAttribute( 'disabled', disabled );

  		return this;

  	}

  	/**
  	 * Shows the Controller after it's been hidden.
  	 * @param {boolean} show
  	 * @returns {this}
  	 * @example
  	 * controller.show();
  	 * controller.show( false ); // hide
  	 * controller.show( controller._hidden ); // toggle
  	 */
  	show( show = true ) {

  		this._hidden = !show;

  		this.domElement.style.display = this._hidden ? 'none' : '';

  		return this;

  	}

  	/**
  	 * Hides the Controller.
  	 * @returns {this}
  	 */
  	hide() {
  		return this.show( false );
  	}

  	/**
  	 * Changes this controller into a dropdown of options.
  	 *
  	 * Calling this method on an option controller will simply update the options. However, if this
  	 * controller was not already an option controller, old references to this controller are
  	 * destroyed, and a new controller is added to the end of the GUI.
  	 * @example
  	 * // safe usage
  	 *
  	 * gui.add( obj, 'prop1' ).options( [ 'a', 'b', 'c' ] );
  	 * gui.add( obj, 'prop2' ).options( { Big: 10, Small: 1 } );
  	 * gui.add( obj, 'prop3' );
  	 *
  	 * // danger
  	 *
  	 * const ctrl1 = gui.add( obj, 'prop1' );
  	 * gui.add( obj, 'prop2' );
  	 *
  	 * // calling options out of order adds a new controller to the end...
  	 * const ctrl2 = ctrl1.options( [ 'a', 'b', 'c' ] );
  	 *
  	 * // ...and ctrl1 now references a controller that doesn't exist
  	 * assert( ctrl2 !== ctrl1 )
  	 * @param {object|Array} options
  	 * @returns {Controller}
  	 */
  	options( options ) {
  		const controller = this.parent.add( this.object, this.property, options );
  		controller.name( this._name );
  		this.destroy();
  		return controller;
  	}

  	/**
  	 * Sets the minimum value. Only works on number controllers.
  	 * @param {number} min
  	 * @returns {this}
  	 */
  	min( min ) {
  		return this;
  	}

  	/**
  	 * Sets the maximum value. Only works on number controllers.
  	 * @param {number} max
  	 * @returns {this}
  	 */
  	max( max ) {
  		return this;
  	}

  	/**
  	 * Values set by this controller will be rounded to multiples of `step`. Only works on number
  	 * controllers.
  	 * @param {number} step
  	 * @returns {this}
  	 */
  	step( step ) {
  		return this;
  	}

  	/**
  	 * Rounds the displayed value to a fixed number of decimals, without affecting the actual value
  	 * like `step()`. Only works on number controllers.
  	 * @example
  	 * gui.add( object, 'property' ).listen().decimals( 4 );
  	 * @param {number} decimals
  	 * @returns {this}
  	 */
  	decimals( decimals ) {
  		return this;
  	}

  	/**
  	 * Calls `updateDisplay()` every animation frame. Pass `false` to stop listening.
  	 * @param {boolean} listen
  	 * @returns {this}
  	 */
  	listen( listen = true ) {

  		/**
  		 * Used to determine if the controller is currently listening. Don't modify this value
  		 * directly. Use the `controller.listen( true|false )` method instead.
  		 * @type {boolean}
  		 */
  		this._listening = listen;

  		if ( this._listenCallbackID !== undefined ) {
  			cancelAnimationFrame( this._listenCallbackID );
  			this._listenCallbackID = undefined;
  		}

  		if ( this._listening ) {
  			this._listenCallback();
  		}

  		return this;

  	}

  	_listenCallback() {

  		this._listenCallbackID = requestAnimationFrame( this._listenCallback );

  		// To prevent framerate loss, make sure the value has changed before updating the display.
  		// Note: save() is used here instead of getValue() only because of ColorController. The !== operator
  		// won't work for color objects or arrays, but ColorController.save() always returns a string.

  		const curValue = this.save();

  		if ( curValue !== this._listenPrevValue ) {
  			this.updateDisplay();
  		}

  		this._listenPrevValue = curValue;

  	}

  	/**
  	 * Returns `object[ property ]`.
  	 * @returns {any}
  	 */
  	getValue() {
  		return this.object[ this.property ];
  	}

  	/**
  	 * Sets the value of `object[ property ]`, invokes any `onChange` handlers and updates the display.
  	 * @param {any} value
  	 * @returns {this}
  	 */
  	setValue( value ) {

  		if ( this.getValue() !== value ) {

  			this.object[ this.property ] = value;
  			this._callOnChange();
  			this.updateDisplay();

  		}

  		return this;

  	}

  	/**
  	 * Updates the display to keep it in sync with the current value. Useful for updating your
  	 * controllers when their values have been modified outside of the GUI.
  	 * @returns {this}
  	 */
  	updateDisplay() {
  		return this;
  	}

  	load( value ) {
  		this.setValue( value );
  		this._callOnFinishChange();
  		return this;
  	}

  	save() {
  		return this.getValue();
  	}

  	/**
  	 * Destroys this controller and removes it from the parent GUI.
  	 */
  	destroy() {
  		this.listen( false );
  		this.parent.children.splice( this.parent.children.indexOf( this ), 1 );
  		this.parent.controllers.splice( this.parent.controllers.indexOf( this ), 1 );
  		this.parent.$children.removeChild( this.domElement );
  	}

  }

  class BooleanController extends Controller {

  	constructor( parent, object, property ) {

  		super( parent, object, property, 'boolean', 'label' );

  		this.$input = document.createElement( 'input' );
  		this.$input.setAttribute( 'type', 'checkbox' );
  		this.$input.setAttribute( 'aria-labelledby', this.$name.id );

  		this.$widget.appendChild( this.$input );

  		this.$input.addEventListener( 'change', () => {
  			this.setValue( this.$input.checked );
  			this._callOnFinishChange();
  		} );

  		this.$disable = this.$input;

  		this.updateDisplay();

  	}

  	updateDisplay() {
  		this.$input.checked = this.getValue();
  		return this;
  	}

  }

  function normalizeColorString( string ) {

  	let match, result;

  	if ( match = string.match( /(#|0x)?([a-f0-9]{6})/i ) ) {

  		result = match[ 2 ];

  	} else if ( match = string.match( /rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/ ) ) {

  		result = parseInt( match[ 1 ] ).toString( 16 ).padStart( 2, 0 )
  			+ parseInt( match[ 2 ] ).toString( 16 ).padStart( 2, 0 )
  			+ parseInt( match[ 3 ] ).toString( 16 ).padStart( 2, 0 );

  	} else if ( match = string.match( /^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i ) ) {

  		result = match[ 1 ] + match[ 1 ] + match[ 2 ] + match[ 2 ] + match[ 3 ] + match[ 3 ];

  	}

  	if ( result ) {
  		return '#' + result;
  	}

  	return false;

  }

  const STRING = {
  	isPrimitive: true,
  	match: v => typeof v === 'string',
  	fromHexString: normalizeColorString,
  	toHexString: normalizeColorString
  };

  const INT = {
  	isPrimitive: true,
  	match: v => typeof v === 'number',
  	fromHexString: string => parseInt( string.substring( 1 ), 16 ),
  	toHexString: value => '#' + value.toString( 16 ).padStart( 6, 0 )
  };

  const ARRAY = {
  	isPrimitive: false,

  	// The arrow function is here to appease tree shakers like esbuild or webpack.
  	// See https://esbuild.github.io/api/#tree-shaking
  	match: v => Array.isArray( v ),

  	fromHexString( string, target, rgbScale = 1 ) {

  		const int = INT.fromHexString( string );

  		target[ 0 ] = ( int >> 16 & 255 ) / 255 * rgbScale;
  		target[ 1 ] = ( int >> 8 & 255 ) / 255 * rgbScale;
  		target[ 2 ] = ( int & 255 ) / 255 * rgbScale;

  	},
  	toHexString( [ r, g, b ], rgbScale = 1 ) {

  		rgbScale = 255 / rgbScale;

  		const int = ( r * rgbScale ) << 16 ^
  			( g * rgbScale ) << 8 ^
  			( b * rgbScale ) << 0;

  		return INT.toHexString( int );

  	}
  };

  const OBJECT = {
  	isPrimitive: false,
  	match: v => Object( v ) === v,
  	fromHexString( string, target, rgbScale = 1 ) {

  		const int = INT.fromHexString( string );

  		target.r = ( int >> 16 & 255 ) / 255 * rgbScale;
  		target.g = ( int >> 8 & 255 ) / 255 * rgbScale;
  		target.b = ( int & 255 ) / 255 * rgbScale;

  	},
  	toHexString( { r, g, b }, rgbScale = 1 ) {

  		rgbScale = 255 / rgbScale;

  		const int = ( r * rgbScale ) << 16 ^
  			( g * rgbScale ) << 8 ^
  			( b * rgbScale ) << 0;

  		return INT.toHexString( int );

  	}
  };

  const FORMATS = [ STRING, INT, ARRAY, OBJECT ];

  function getColorFormat( value ) {
  	return FORMATS.find( format => format.match( value ) );
  }

  class ColorController extends Controller {

  	constructor( parent, object, property, rgbScale ) {

  		super( parent, object, property, 'color' );

  		this.$input = document.createElement( 'input' );
  		this.$input.setAttribute( 'type', 'color' );
  		this.$input.setAttribute( 'tabindex', -1 );
  		this.$input.setAttribute( 'aria-labelledby', this.$name.id );

  		this.$text = document.createElement( 'input' );
  		this.$text.setAttribute( 'type', 'text' );
  		this.$text.setAttribute( 'spellcheck', 'false' );
  		this.$text.setAttribute( 'aria-labelledby', this.$name.id );

  		this.$display = document.createElement( 'div' );
  		this.$display.classList.add( 'display' );

  		this.$display.appendChild( this.$input );
  		this.$widget.appendChild( this.$display );
  		this.$widget.appendChild( this.$text );

  		this._format = getColorFormat( this.initialValue );
  		this._rgbScale = rgbScale;

  		this._initialValueHexString = this.save();
  		this._textFocused = false;

  		this.$input.addEventListener( 'input', () => {
  			this._setValueFromHexString( this.$input.value );
  		} );

  		this.$input.addEventListener( 'blur', () => {
  			this._callOnFinishChange();
  		} );

  		this.$text.addEventListener( 'input', () => {
  			const tryParse = normalizeColorString( this.$text.value );
  			if ( tryParse ) {
  				this._setValueFromHexString( tryParse );
  			}
  		} );

  		this.$text.addEventListener( 'focus', () => {
  			this._textFocused = true;
  			this.$text.select();
  		} );

  		this.$text.addEventListener( 'blur', () => {
  			this._textFocused = false;
  			this.updateDisplay();
  			this._callOnFinishChange();
  		} );

  		this.$disable = this.$text;

  		this.updateDisplay();

  	}

  	reset() {
  		this._setValueFromHexString( this._initialValueHexString );
  		return this;
  	}

  	_setValueFromHexString( value ) {

  		if ( this._format.isPrimitive ) {

  			const newValue = this._format.fromHexString( value );
  			this.setValue( newValue );

  		} else {

  			this._format.fromHexString( value, this.getValue(), this._rgbScale );
  			this._callOnChange();
  			this.updateDisplay();

  		}

  	}

  	save() {
  		return this._format.toHexString( this.getValue(), this._rgbScale );
  	}

  	load( value ) {
  		this._setValueFromHexString( value );
  		this._callOnFinishChange();
  		return this;
  	}

  	updateDisplay() {
  		this.$input.value = this._format.toHexString( this.getValue(), this._rgbScale );
  		if ( !this._textFocused ) {
  			this.$text.value = this.$input.value.substring( 1 );
  		}
  		this.$display.style.backgroundColor = this.$input.value;
  		return this;
  	}

  }

  class FunctionController extends Controller {

  	constructor( parent, object, property ) {

  		super( parent, object, property, 'function' );

  		// Buttons are the only case where widget contains name
  		this.$button = document.createElement( 'button' );
  		this.$button.appendChild( this.$name );
  		this.$widget.appendChild( this.$button );

  		this.$button.addEventListener( 'click', e => {
  			e.preventDefault();
  			this.getValue().call( this.object );
  			this._callOnChange();
  		} );

  		// enables :active pseudo class on mobile
  		this.$button.addEventListener( 'touchstart', () => {}, { passive: true } );

  		this.$disable = this.$button;

  	}

  }

  class NumberController extends Controller {

  	constructor( parent, object, property, min, max, step ) {

  		super( parent, object, property, 'number' );

  		this._initInput();

  		this.min( min );
  		this.max( max );

  		const stepExplicit = step !== undefined;
  		this.step( stepExplicit ? step : this._getImplicitStep(), stepExplicit );

  		this.updateDisplay();

  	}

  	decimals( decimals ) {
  		this._decimals = decimals;
  		this.updateDisplay();
  		return this;
  	}

  	min( min ) {
  		this._min = min;
  		this._onUpdateMinMax();
  		return this;
  	}

  	max( max ) {
  		this._max = max;
  		this._onUpdateMinMax();
  		return this;
  	}

  	step( step, explicit = true ) {
  		this._step = step;
  		this._stepExplicit = explicit;
  		return this;
  	}

  	updateDisplay() {

  		const value = this.getValue();

  		if ( this._hasSlider ) {

  			let percent = ( value - this._min ) / ( this._max - this._min );
  			percent = Math.max( 0, Math.min( percent, 1 ) );

  			this.$fill.style.width = percent * 100 + '%';

  		}

  		if ( !this._inputFocused ) {
  			this.$input.value = this._decimals === undefined ? value : value.toFixed( this._decimals );
  		}

  		return this;

  	}

  	_initInput() {

  		this.$input = document.createElement( 'input' );
  		this.$input.setAttribute( 'type', 'text' );
  		this.$input.setAttribute( 'aria-labelledby', this.$name.id );

  		// On touch devices only, use input[type=number] to force a numeric keyboard.
  		// Ideally we could use one input type everywhere, but [type=number] has quirks
  		// on desktop, and [inputmode=decimal] has quirks on iOS.
  		// See https://github.com/georgealways/lil-gui/pull/16

  		const isTouch = window.matchMedia( '(pointer: coarse)' ).matches;

  		if ( isTouch ) {
  			this.$input.setAttribute( 'type', 'number' );
  			this.$input.setAttribute( 'step', 'any' );
  		}

  		this.$widget.appendChild( this.$input );

  		this.$disable = this.$input;

  		const onInput = () => {

  			let value = parseFloat( this.$input.value );

  			if ( isNaN( value ) ) return;

  			if ( this._stepExplicit ) {
  				value = this._snap( value );
  			}

  			this.setValue( this._clamp( value ) );

  		};

  		// Keys & mouse wheel
  		// ---------------------------------------------------------------------

  		const increment = delta => {

  			const value = parseFloat( this.$input.value );

  			if ( isNaN( value ) ) return;

  			this._snapClampSetValue( value + delta );

  			// Force the input to updateDisplay when it's focused
  			this.$input.value = this.getValue();

  		};

  		const onKeyDown = e => {
  			// Using `e.key` instead of `e.code` also catches NumpadEnter
  			if ( e.key === 'Enter' ) {
  				this.$input.blur();
  			}
  			if ( e.code === 'ArrowUp' ) {
  				e.preventDefault();
  				increment( this._step * this._arrowKeyMultiplier( e ) );
  			}
  			if ( e.code === 'ArrowDown' ) {
  				e.preventDefault();
  				increment( this._step * this._arrowKeyMultiplier( e ) * -1 );
  			}
  		};

  		const onWheel = e => {
  			if ( this._inputFocused ) {
  				e.preventDefault();
  				increment( this._step * this._normalizeMouseWheel( e ) );
  			}
  		};

  		// Vertical drag
  		// ---------------------------------------------------------------------

  		let testingForVerticalDrag = false,
  			initClientX,
  			initClientY,
  			prevClientY,
  			initValue,
  			dragDelta;

  		// Once the mouse is dragged more than DRAG_THRESH px on any axis, we decide
  		// on the user's intent: horizontal means highlight, vertical means drag.
  		const DRAG_THRESH = 5;

  		const onMouseDown = e => {

  			initClientX = e.clientX;
  			initClientY = prevClientY = e.clientY;
  			testingForVerticalDrag = true;

  			initValue = this.getValue();
  			dragDelta = 0;

  			window.addEventListener( 'mousemove', onMouseMove );
  			window.addEventListener( 'mouseup', onMouseUp );

  		};

  		const onMouseMove = e => {

  			if ( testingForVerticalDrag ) {

  				const dx = e.clientX - initClientX;
  				const dy = e.clientY - initClientY;

  				if ( Math.abs( dy ) > DRAG_THRESH ) {

  					e.preventDefault();
  					this.$input.blur();
  					testingForVerticalDrag = false;
  					this._setDraggingStyle( true, 'vertical' );

  				} else if ( Math.abs( dx ) > DRAG_THRESH ) {

  					onMouseUp();

  				}

  			}

  			// This isn't an else so that the first move counts towards dragDelta
  			if ( !testingForVerticalDrag ) {

  				const dy = e.clientY - prevClientY;

  				dragDelta -= dy * this._step * this._arrowKeyMultiplier( e );

  				// Clamp dragDelta so we don't have 'dead space' after dragging past bounds.
  				// We're okay with the fact that bounds can be undefined here.
  				if ( initValue + dragDelta > this._max ) {
  					dragDelta = this._max - initValue;
  				} else if ( initValue + dragDelta < this._min ) {
  					dragDelta = this._min - initValue;
  				}

  				this._snapClampSetValue( initValue + dragDelta );

  			}

  			prevClientY = e.clientY;

  		};

  		const onMouseUp = () => {
  			this._setDraggingStyle( false, 'vertical' );
  			this._callOnFinishChange();
  			window.removeEventListener( 'mousemove', onMouseMove );
  			window.removeEventListener( 'mouseup', onMouseUp );
  		};

  		// Focus state & onFinishChange
  		// ---------------------------------------------------------------------

  		const onFocus = () => {
  			this._inputFocused = true;
  		};

  		const onBlur = () => {
  			this._inputFocused = false;
  			this.updateDisplay();
  			this._callOnFinishChange();
  		};

  		this.$input.addEventListener( 'input', onInput );
  		this.$input.addEventListener( 'keydown', onKeyDown );
  		this.$input.addEventListener( 'wheel', onWheel, { passive: false } );
  		this.$input.addEventListener( 'mousedown', onMouseDown );
  		this.$input.addEventListener( 'focus', onFocus );
  		this.$input.addEventListener( 'blur', onBlur );

  	}

  	_initSlider() {

  		this._hasSlider = true;

  		// Build DOM
  		// ---------------------------------------------------------------------

  		this.$slider = document.createElement( 'div' );
  		this.$slider.classList.add( 'slider' );

  		this.$fill = document.createElement( 'div' );
  		this.$fill.classList.add( 'fill' );

  		this.$slider.appendChild( this.$fill );
  		this.$widget.insertBefore( this.$slider, this.$input );

  		this.domElement.classList.add( 'hasSlider' );

  		// Map clientX to value
  		// ---------------------------------------------------------------------

  		const map = ( v, a, b, c, d ) => {
  			return ( v - a ) / ( b - a ) * ( d - c ) + c;
  		};

  		const setValueFromX = clientX => {
  			const rect = this.$slider.getBoundingClientRect();
  			let value = map( clientX, rect.left, rect.right, this._min, this._max );
  			this._snapClampSetValue( value );
  		};

  		// Mouse drag
  		// ---------------------------------------------------------------------

  		const mouseDown = e => {
  			this._setDraggingStyle( true );
  			setValueFromX( e.clientX );
  			window.addEventListener( 'mousemove', mouseMove );
  			window.addEventListener( 'mouseup', mouseUp );
  		};

  		const mouseMove = e => {
  			setValueFromX( e.clientX );
  		};

  		const mouseUp = () => {
  			this._callOnFinishChange();
  			this._setDraggingStyle( false );
  			window.removeEventListener( 'mousemove', mouseMove );
  			window.removeEventListener( 'mouseup', mouseUp );
  		};

  		// Touch drag
  		// ---------------------------------------------------------------------

  		let testingForScroll = false, prevClientX, prevClientY;

  		const beginTouchDrag = e => {
  			e.preventDefault();
  			this._setDraggingStyle( true );
  			setValueFromX( e.touches[ 0 ].clientX );
  			testingForScroll = false;
  		};

  		const onTouchStart = e => {

  			if ( e.touches.length > 1 ) return;

  			// If we're in a scrollable container, we should wait for the first
  			// touchmove to see if the user is trying to slide or scroll.
  			if ( this._hasScrollBar ) {

  				prevClientX = e.touches[ 0 ].clientX;
  				prevClientY = e.touches[ 0 ].clientY;
  				testingForScroll = true;

  			} else {

  				// Otherwise, we can set the value straight away on touchstart.
  				beginTouchDrag( e );

  			}

  			window.addEventListener( 'touchmove', onTouchMove, { passive: false } );
  			window.addEventListener( 'touchend', onTouchEnd );

  		};

  		const onTouchMove = e => {

  			if ( testingForScroll ) {

  				const dx = e.touches[ 0 ].clientX - prevClientX;
  				const dy = e.touches[ 0 ].clientY - prevClientY;

  				if ( Math.abs( dx ) > Math.abs( dy ) ) {

  					// We moved horizontally, set the value and stop checking.
  					beginTouchDrag( e );

  				} else {

  					// This was, in fact, an attempt to scroll. Abort.
  					window.removeEventListener( 'touchmove', onTouchMove );
  					window.removeEventListener( 'touchend', onTouchEnd );

  				}

  			} else {

  				e.preventDefault();
  				setValueFromX( e.touches[ 0 ].clientX );

  			}

  		};

  		const onTouchEnd = () => {
  			this._callOnFinishChange();
  			this._setDraggingStyle( false );
  			window.removeEventListener( 'touchmove', onTouchMove );
  			window.removeEventListener( 'touchend', onTouchEnd );
  		};

  		// Mouse wheel
  		// ---------------------------------------------------------------------

  		// We have to use a debounced function to call onFinishChange because
  		// there's no way to tell when the user is "done" mouse-wheeling.
  		const callOnFinishChange = this._callOnFinishChange.bind( this );
  		const WHEEL_DEBOUNCE_TIME = 400;
  		let wheelFinishChangeTimeout;

  		const onWheel = e => {

  			// ignore vertical wheels if there's a scrollbar
  			const isVertical = Math.abs( e.deltaX ) < Math.abs( e.deltaY );
  			if ( isVertical && this._hasScrollBar ) return;

  			e.preventDefault();

  			// set value
  			const delta = this._normalizeMouseWheel( e ) * this._step;
  			this._snapClampSetValue( this.getValue() + delta );

  			// force the input to updateDisplay when it's focused
  			this.$input.value = this.getValue();

  			// debounce onFinishChange
  			clearTimeout( wheelFinishChangeTimeout );
  			wheelFinishChangeTimeout = setTimeout( callOnFinishChange, WHEEL_DEBOUNCE_TIME );

  		};

  		this.$slider.addEventListener( 'mousedown', mouseDown );
  		this.$slider.addEventListener( 'touchstart', onTouchStart, { passive: false } );
  		this.$slider.addEventListener( 'wheel', onWheel, { passive: false } );

  	}

  	_setDraggingStyle( active, axis = 'horizontal' ) {
  		if ( this.$slider ) {
  			this.$slider.classList.toggle( 'active', active );
  		}
  		document.body.classList.toggle( 'lil-gui-dragging', active );
  		document.body.classList.toggle( `lil-gui-${axis}`, active );
  	}

  	_getImplicitStep() {

  		if ( this._hasMin && this._hasMax ) {
  			return ( this._max - this._min ) / 1000;
  		}

  		return 0.1;

  	}

  	_onUpdateMinMax() {

  		if ( !this._hasSlider && this._hasMin && this._hasMax ) {

  			// If this is the first time we're hearing about min and max
  			// and we haven't explicitly stated what our step is, let's
  			// update that too.
  			if ( !this._stepExplicit ) {
  				this.step( this._getImplicitStep(), false );
  			}

  			this._initSlider();
  			this.updateDisplay();

  		}

  	}

  	_normalizeMouseWheel( e ) {

  		let { deltaX, deltaY } = e;

  		// Safari and Chrome report weird non-integral values for a notched wheel,
  		// but still expose actual lines scrolled via wheelDelta. Notched wheels
  		// should behave the same way as arrow keys.
  		if ( Math.floor( e.deltaY ) !== e.deltaY && e.wheelDelta ) {
  			deltaX = 0;
  			deltaY = -e.wheelDelta / 120;
  			deltaY *= this._stepExplicit ? 1 : 10;
  		}

  		const wheel = deltaX + -deltaY;

  		return wheel;

  	}

  	_arrowKeyMultiplier( e ) {

  		let mult = this._stepExplicit ? 1 : 10;

  		if ( e.shiftKey ) {
  			mult *= 10;
  		} else if ( e.altKey ) {
  			mult /= 10;
  		}

  		return mult;

  	}

  	_snap( value ) {

  		// Make the steps "start" at min or max.
  		let offset = 0;
  		if ( this._hasMin ) {
  			offset = this._min;
  		} else if ( this._hasMax ) {
  			offset = this._max;
  		}

  		value -= offset;

  		value = Math.round( value / this._step ) * this._step;

  		value += offset;

  		// Used to prevent "flyaway" decimals like 1.00000000000001
  		value = parseFloat( value.toPrecision( 15 ) );

  		return value;

  	}

  	_clamp( value ) {
  		// either condition is false if min or max is undefined
  		if ( value < this._min ) value = this._min;
  		if ( value > this._max ) value = this._max;
  		return value;
  	}

  	_snapClampSetValue( value ) {
  		this.setValue( this._clamp( this._snap( value ) ) );
  	}

  	get _hasScrollBar() {
  		const root = this.parent.root.$children;
  		return root.scrollHeight > root.clientHeight;
  	}

  	get _hasMin() {
  		return this._min !== undefined;
  	}

  	get _hasMax() {
  		return this._max !== undefined;
  	}

  }

  class OptionController extends Controller {

  	constructor( parent, object, property, options ) {

  		super( parent, object, property, 'option' );

  		this.$select = document.createElement( 'select' );
  		this.$select.setAttribute( 'aria-labelledby', this.$name.id );

  		this.$display = document.createElement( 'div' );
  		this.$display.classList.add( 'display' );

  		this.$select.addEventListener( 'change', () => {
  			this.setValue( this._values[ this.$select.selectedIndex ] );
  			this._callOnFinishChange();
  		} );

  		this.$select.addEventListener( 'focus', () => {
  			this.$display.classList.add( 'focus' );
  		} );

  		this.$select.addEventListener( 'blur', () => {
  			this.$display.classList.remove( 'focus' );
  		} );

  		this.$widget.appendChild( this.$select );
  		this.$widget.appendChild( this.$display );

  		this.$disable = this.$select;

  		this.options( options );

  	}

  	options( options ) {

  		this._values = Array.isArray( options ) ? options : Object.values( options );
  		this._names = Array.isArray( options ) ? options : Object.keys( options );

  		this.$select.replaceChildren();

  		this._names.forEach( name => {
  			const $option = document.createElement( 'option' );
  			$option.textContent = name;
  			this.$select.appendChild( $option );
  		} );

  		this.updateDisplay();

  		return this;

  	}

  	updateDisplay() {
  		const value = this.getValue();
  		const index = this._values.indexOf( value );
  		this.$select.selectedIndex = index;
  		this.$display.textContent = index === -1 ? value : this._names[ index ];
  		return this;
  	}

  }

  class StringController extends Controller {

  	constructor( parent, object, property ) {

  		super( parent, object, property, 'string' );

  		this.$input = document.createElement( 'input' );
  		this.$input.setAttribute( 'type', 'text' );
  		this.$input.setAttribute( 'spellcheck', 'false' );
  		this.$input.setAttribute( 'aria-labelledby', this.$name.id );

  		this.$input.addEventListener( 'input', () => {
  			this.setValue( this.$input.value );
  		} );

  		this.$input.addEventListener( 'keydown', e => {
  			if ( e.code === 'Enter' ) {
  				this.$input.blur();
  			}
  		} );

  		this.$input.addEventListener( 'blur', () => {
  			this._callOnFinishChange();
  		} );

  		this.$widget.appendChild( this.$input );

  		this.$disable = this.$input;

  		this.updateDisplay();

  	}

  	updateDisplay() {
  		this.$input.value = this.getValue();
  		return this;
  	}

  }

  var stylesheet = `.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
  background: var(--background-color);
}
.lil-gui.root > .title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.root > .children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.root > .children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.root > .children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-gui .controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-gui .controller.disabled {
  opacity: 0.5;
}
.lil-gui .controller.disabled, .lil-gui .controller.disabled * {
  pointer-events: none !important;
}
.lil-gui .controller > .name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-gui .controller .widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-gui .controller.string input {
  color: var(--string-color);
}
.lil-gui .controller.boolean {
  cursor: pointer;
}
.lil-gui .controller.color .display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-gui .controller.color .display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-gui .controller.color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-gui .controller.color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-gui .controller.option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-gui .controller.option .display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-gui .controller.option .display.focus {
    background: var(--focus-color);
  }
}
.lil-gui .controller.option .display.active {
  background: var(--focus-color);
}
.lil-gui .controller.option .display:after {
  font-family: "lil-gui";
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-gui .controller.option .widget,
.lil-gui .controller.option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-gui .controller.option .widget:hover .display {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number input {
  color: var(--number-color);
}
.lil-gui .controller.number.hasSlider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-gui .controller.number .slider {
  width: 100%;
  height: var(--widget-height);
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-gui .controller.number .slider:hover {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number .slider.active {
  background: var(--focus-color);
}
.lil-gui .controller.number .slider.active .fill {
  opacity: 0.95;
}
.lil-gui .controller.number .fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-gui-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-gui-dragging * {
  cursor: ew-resize !important;
}

.lil-gui-dragging.lil-gui-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .title {
  height: var(--title-height);
  font-weight: 600;
  padding: 0 var(--padding);
  width: 100%;
  text-align: left;
  background: none;
  text-decoration-skip: objects;
}
.lil-gui .title:before {
  font-family: "lil-gui";
  content: "";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-gui-dragging) .lil-gui .title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.root > .title:focus {
  text-decoration: none !important;
}
.lil-gui.closed > .title:before {
  content: "";
}
.lil-gui.closed > .children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.closed:not(.transition) > .children {
  display: none;
}
.lil-gui.transition > .children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.root > .children > .lil-gui > .title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.root > .children > .lil-gui.closed > .title {
  border-bottom-color: transparent;
}
.lil-gui + .controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .controller {
  border: none;
}

.lil-gui label, .lil-gui input, .lil-gui button {
  -webkit-tap-highlight-color: transparent;
}
.lil-gui input {
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
  -moz-appearance: textfield;
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input[type=checkbox] {
  appearance: none;
  width: var(--checkbox-size);
  height: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  border: none;
}
.lil-gui .controller button {
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
}
@media (hover: hover) {
  .lil-gui .controller button:hover {
    background: var(--hover-color);
  }
  .lil-gui .controller button:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui .controller button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");
}`;

  function _injectStyles( cssContent ) {
  	const injected = document.createElement( 'style' );
  	injected.innerHTML = cssContent;
  	const before = document.querySelector( 'head link[rel=stylesheet], head style' );
  	if ( before ) {
  		document.head.insertBefore( injected, before );
  	} else {
  		document.head.appendChild( injected );
  	}
  }


  let stylesInjected = false;

  class GUI {

  	/**
  	 * Creates a panel that holds controllers.
  	 * @example
  	 * new GUI();
  	 * new GUI( { container: document.getElementById( 'custom' ) } );
  	 *
  	 * @param {object} [options]
  	 * @param {boolean} [options.autoPlace=true]
  	 * Adds the GUI to `document.body` and fixes it to the top right of the page.
  	 *
  	 * @param {HTMLElement} [options.container]
  	 * Adds the GUI to this DOM element. Overrides `autoPlace`.
  	 *
  	 * @param {number} [options.width=245]
  	 * Width of the GUI in pixels, usually set when name labels become too long. Note that you can make
  	 * name labels wider in CSS with `.lilgui { namewidth: 55% }`.
  	 *
  	 * @param {string} [options.title=Controls]
  	 * Name to display in the title bar.
  	 *
  	 * @param {boolean} [options.closeFolders=false]
  	 * Pass `true` to close all folders in this GUI by default.
  	 *
  	 * @param {boolean} [options.injectStyles=true]
  	 * Injects the default stylesheet into the page if this is the first GUI.
  	 * Pass `false` to use your own stylesheet.
  	 *
  	 * @param {number} [options.touchStyles=true]
  	 * Makes controllers larger on touch devices. Pass `false` to disable touch styles.
  	 *
  	 * @param {GUI} [options.parent]
  	 * Adds this GUI as a child in another GUI. Usually this is done for you by `addFolder()`.
  	 */
  	constructor( {
  		parent,
  		autoPlace = parent === undefined,
  		container,
  		width,
  		title = 'Controls',
  		closeFolders = false,
  		injectStyles = true,
  		touchStyles = true
  	} = {} ) {

  		/**
  		 * The GUI containing this folder, or `undefined` if this is the root GUI.
  		 * @type {GUI}
  		 */
  		this.parent = parent;

  		/**
  		 * The top level GUI containing this folder, or `this` if this is the root GUI.
  		 * @type {GUI}
  		 */
  		this.root = parent ? parent.root : this;

  		/**
  		 * The list of controllers and folders contained by this GUI.
  		 * @type {Array<GUI|Controller>}
  		 */
  		this.children = [];

  		/**
  		 * The list of controllers contained by this GUI.
  		 * @type {Array<Controller>}
  		 */
  		this.controllers = [];

  		/**
  		 * The list of folders contained by this GUI.
  		 * @type {Array<GUI>}
  		 */
  		this.folders = [];

  		/**
  		 * Used to determine if the GUI is closed. Use `gui.open()` or `gui.close()` to change this.
  		 * @type {boolean}
  		 */
  		this._closed = false;

  		/**
  		 * Used to determine if the GUI is hidden. Use `gui.show()` or `gui.hide()` to change this.
  		 * @type {boolean}
  		 */
  		this._hidden = false;

  		/**
  		 * The outermost container element.
  		 * @type {HTMLElement}
  		 */
  		this.domElement = document.createElement( 'div' );
  		this.domElement.classList.add( 'lil-gui' );

  		/**
  		 * The DOM element that contains the title.
  		 * @type {HTMLElement}
  		 */
  		this.$title = document.createElement( 'button' );
  		this.$title.classList.add( 'title' );
  		this.$title.setAttribute( 'aria-expanded', true );

  		this.$title.addEventListener( 'click', () => this.openAnimated( this._closed ) );

  		// enables :active pseudo class on mobile
  		this.$title.addEventListener( 'touchstart', () => {}, { passive: true } );

  		/**
  		 * The DOM element that contains children.
  		 * @type {HTMLElement}
  		 */
  		this.$children = document.createElement( 'div' );
  		this.$children.classList.add( 'children' );

  		this.domElement.appendChild( this.$title );
  		this.domElement.appendChild( this.$children );

  		this.title( title );

  		if ( this.parent ) {

  			this.parent.children.push( this );
  			this.parent.folders.push( this );

  			this.parent.$children.appendChild( this.domElement );

  			// Stop the constructor early, everything onward only applies to root GUI's
  			return;

  		}

  		this.domElement.classList.add( 'root' );

  		if ( touchStyles ) {
  			this.domElement.classList.add( 'allow-touch-styles' );
  		}

  		// Inject stylesheet if we haven't done that yet
  		if ( !stylesInjected && injectStyles ) {
  			_injectStyles( stylesheet );
  			stylesInjected = true;
  		}

  		if ( container ) {

  			container.appendChild( this.domElement );

  		} else if ( autoPlace ) {

  			this.domElement.classList.add( 'autoPlace' );
  			document.body.appendChild( this.domElement );

  		}

  		if ( width ) {
  			this.domElement.style.setProperty( '--width', width + 'px' );
  		}

  		this._closeFolders = closeFolders;

  	}

  	/**
  	 * Adds a controller to the GUI, inferring controller type using the `typeof` operator.
  	 * @example
  	 * gui.add( object, 'property' );
  	 * gui.add( object, 'number', 0, 100, 1 );
  	 * gui.add( object, 'options', [ 1, 2, 3 ] );
  	 *
  	 * @param {object} object The object the controller will modify.
  	 * @param {string} property Name of the property to control.
  	 * @param {number|object|Array} [$1] Minimum value for number controllers, or the set of
  	 * selectable values for a dropdown.
  	 * @param {number} [max] Maximum value for number controllers.
  	 * @param {number} [step] Step value for number controllers.
  	 * @returns {Controller}
  	 */
  	add( object, property, $1, max, step ) {

  		if ( Object( $1 ) === $1 ) {

  			return new OptionController( this, object, property, $1 );

  		}

  		const initialValue = object[ property ];

  		switch ( typeof initialValue ) {

  			case 'number':

  				return new NumberController( this, object, property, $1, max, step );

  			case 'boolean':

  				return new BooleanController( this, object, property );

  			case 'string':

  				return new StringController( this, object, property );

  			case 'function':

  				return new FunctionController( this, object, property );

  		}

  		console.error( `gui.add failed
	property:`, property, `
	object:`, object, `
	value:`, initialValue );

  	}

  	/**
  	 * Adds a color controller to the GUI.
  	 * @example
  	 * params = {
  	 * 	cssColor: '#ff00ff',
  	 * 	rgbColor: { r: 0, g: 0.2, b: 0.4 },
  	 * 	customRange: [ 0, 127, 255 ],
  	 * };
  	 *
  	 * gui.addColor( params, 'cssColor' );
  	 * gui.addColor( params, 'rgbColor' );
  	 * gui.addColor( params, 'customRange', 255 );
  	 *
  	 * @param {object} object The object the controller will modify.
  	 * @param {string} property Name of the property to control.
  	 * @param {number} rgbScale Maximum value for a color channel when using an RGB color. You may
  	 * need to set this to 255 if your colors are too bright.
  	 * @returns {Controller}
  	 */
  	addColor( object, property, rgbScale = 1 ) {
  		return new ColorController( this, object, property, rgbScale );
  	}

  	/**
  	 * Adds a folder to the GUI, which is just another GUI. This method returns
  	 * the nested GUI so you can add controllers to it.
  	 * @example
  	 * const folder = gui.addFolder( 'Position' );
  	 * folder.add( position, 'x' );
  	 * folder.add( position, 'y' );
  	 * folder.add( position, 'z' );
  	 *
  	 * @param {string} title Name to display in the folder's title bar.
  	 * @returns {GUI}
  	 */
  	addFolder( title ) {
  		const folder = new GUI( { parent: this, title } );
  		if ( this.root._closeFolders ) folder.close();
  		return folder;
  	}

  	/**
  	 * Recalls values that were saved with `gui.save()`.
  	 * @param {object} obj
  	 * @param {boolean} recursive Pass false to exclude folders descending from this GUI.
  	 * @returns {this}
  	 */
  	load( obj, recursive = true ) {

  		if ( obj.controllers ) {

  			this.controllers.forEach( c => {

  				if ( c instanceof FunctionController ) return;

  				if ( c._name in obj.controllers ) {
  					c.load( obj.controllers[ c._name ] );
  				}

  			} );

  		}

  		if ( recursive && obj.folders ) {

  			this.folders.forEach( f => {

  				if ( f._title in obj.folders ) {
  					f.load( obj.folders[ f._title ] );
  				}

  			} );

  		}

  		return this;

  	}

  	/**
  	 * Returns an object mapping controller names to values. The object can be passed to `gui.load()` to
  	 * recall these values.
  	 * @example
  	 * {
  	 * 	controllers: {
  	 * 		prop1: 1,
  	 * 		prop2: 'value',
  	 * 		...
  	 * 	},
  	 * 	folders: {
  	 * 		folderName1: { controllers, folders },
  	 * 		folderName2: { controllers, folders }
  	 * 		...
  	 * 	}
  	 * }
  	 *
  	 * @param {boolean} recursive Pass false to exclude folders descending from this GUI.
  	 * @returns {object}
  	 */
  	save( recursive = true ) {

  		const obj = {
  			controllers: {},
  			folders: {}
  		};

  		this.controllers.forEach( c => {

  			if ( c instanceof FunctionController ) return;

  			if ( c._name in obj.controllers ) {
  				throw new Error( `Cannot save GUI with duplicate property "${c._name}"` );
  			}

  			obj.controllers[ c._name ] = c.save();

  		} );

  		if ( recursive ) {

  			this.folders.forEach( f => {

  				if ( f._title in obj.folders ) {
  					throw new Error( `Cannot save GUI with duplicate folder "${f._title}"` );
  				}

  				obj.folders[ f._title ] = f.save();

  			} );

  		}

  		return obj;

  	}

  	/**
  	 * Opens a GUI or folder. GUI and folders are open by default.
  	 * @param {boolean} open Pass false to close.
  	 * @returns {this}
  	 * @example
  	 * gui.open(); // open
  	 * gui.open( false ); // close
  	 * gui.open( gui._closed ); // toggle
  	 */
  	open( open = true ) {

  		this._setClosed( !open );

  		this.$title.setAttribute( 'aria-expanded', !this._closed );
  		this.domElement.classList.toggle( 'closed', this._closed );

  		return this;

  	}

  	/**
  	 * Closes the GUI.
  	 * @returns {this}
  	 */
  	close() {
  		return this.open( false );
  	}

  	_setClosed( closed ) {
  		if ( this._closed === closed ) return;
  		this._closed = closed;
  		this._callOnOpenClose( this );
  	}

  	/**
  	 * Shows the GUI after it's been hidden.
  	 * @param {boolean} show
  	 * @returns {this}
  	 * @example
  	 * gui.show();
  	 * gui.show( false ); // hide
  	 * gui.show( gui._hidden ); // toggle
  	 */
  	show( show = true ) {

  		this._hidden = !show;

  		this.domElement.style.display = this._hidden ? 'none' : '';

  		return this;

  	}

  	/**
  	 * Hides the GUI.
  	 * @returns {this}
  	 */
  	hide() {
  		return this.show( false );
  	}

  	openAnimated( open = true ) {

  		// set state immediately
  		this._setClosed( !open );

  		this.$title.setAttribute( 'aria-expanded', !this._closed );

  		// wait for next frame to measure $children
  		requestAnimationFrame( () => {

  			// explicitly set initial height for transition
  			const initialHeight = this.$children.clientHeight;
  			this.$children.style.height = initialHeight + 'px';

  			this.domElement.classList.add( 'transition' );

  			const onTransitionEnd = e => {
  				if ( e.target !== this.$children ) return;
  				this.$children.style.height = '';
  				this.domElement.classList.remove( 'transition' );
  				this.$children.removeEventListener( 'transitionend', onTransitionEnd );
  			};

  			this.$children.addEventListener( 'transitionend', onTransitionEnd );

  			// todo: this is wrong if children's scrollHeight makes for a gui taller than maxHeight
  			const targetHeight = !open ? 0 : this.$children.scrollHeight;

  			this.domElement.classList.toggle( 'closed', !open );

  			requestAnimationFrame( () => {
  				this.$children.style.height = targetHeight + 'px';
  			} );

  		} );

  		return this;

  	}

  	/**
  	 * Change the title of this GUI.
  	 * @param {string} title
  	 * @returns {this}
  	 */
  	title( title ) {
  		/**
  		 * Current title of the GUI. Use `gui.title( 'Title' )` to modify this value.
  		 * @type {string}
  		 */
  		this._title = title;
  		this.$title.textContent = title;
  		return this;
  	}

  	/**
  	 * Resets all controllers to their initial values.
  	 * @param {boolean} recursive Pass false to exclude folders descending from this GUI.
  	 * @returns {this}
  	 */
  	reset( recursive = true ) {
  		const controllers = recursive ? this.controllersRecursive() : this.controllers;
  		controllers.forEach( c => c.reset() );
  		return this;
  	}

  	/**
  	 * Pass a function to be called whenever a controller in this GUI changes.
  	 * @param {function({object:object, property:string, value:any, controller:Controller})} callback
  	 * @returns {this}
  	 * @example
  	 * gui.onChange( event => {
  	 * 	event.object     // object that was modified
  	 * 	event.property   // string, name of property
  	 * 	event.value      // new value of controller
  	 * 	event.controller // controller that was modified
  	 * } );
  	 */
  	onChange( callback ) {
  		/**
  		 * Used to access the function bound to `onChange` events. Don't modify this value
  		 * directly. Use the `gui.onChange( callback )` method instead.
  		 * @type {Function}
  		 */
  		this._onChange = callback;
  		return this;
  	}

  	_callOnChange( controller ) {

  		if ( this.parent ) {
  			this.parent._callOnChange( controller );
  		}

  		if ( this._onChange !== undefined ) {
  			this._onChange.call( this, {
  				object: controller.object,
  				property: controller.property,
  				value: controller.getValue(),
  				controller
  			} );
  		}
  	}

  	/**
  	 * Pass a function to be called whenever a controller in this GUI has finished changing.
  	 * @param {function({object:object, property:string, value:any, controller:Controller})} callback
  	 * @returns {this}
  	 * @example
  	 * gui.onFinishChange( event => {
  	 * 	event.object     // object that was modified
  	 * 	event.property   // string, name of property
  	 * 	event.value      // new value of controller
  	 * 	event.controller // controller that was modified
  	 * } );
  	 */
  	onFinishChange( callback ) {
  		/**
  		 * Used to access the function bound to `onFinishChange` events. Don't modify this value
  		 * directly. Use the `gui.onFinishChange( callback )` method instead.
  		 * @type {Function}
  		 */
  		this._onFinishChange = callback;
  		return this;
  	}

  	_callOnFinishChange( controller ) {

  		if ( this.parent ) {
  			this.parent._callOnFinishChange( controller );
  		}

  		if ( this._onFinishChange !== undefined ) {
  			this._onFinishChange.call( this, {
  				object: controller.object,
  				property: controller.property,
  				value: controller.getValue(),
  				controller
  			} );
  		}
  	}

  	/**
  	 * Pass a function to be called when this GUI or its descendants are opened or closed.
  	 * @param {function(GUI)} callback
  	 * @returns {this}
  	 * @example
  	 * gui.onOpenClose( changedGUI => {
  	 * 	console.log( changedGUI._closed );
  	 * } );
  	 */
  	onOpenClose( callback ) {
  		this._onOpenClose = callback;
  		return this;
  	}

  	_callOnOpenClose( changedGUI ) {
  		if ( this.parent ) {
  			this.parent._callOnOpenClose( changedGUI );
  		}

  		if ( this._onOpenClose !== undefined ) {
  			this._onOpenClose.call( this, changedGUI );
  		}
  	}

  	/**
  	 * Destroys all DOM elements and event listeners associated with this GUI.
  	 */
  	destroy() {

  		if ( this.parent ) {
  			this.parent.children.splice( this.parent.children.indexOf( this ), 1 );
  			this.parent.folders.splice( this.parent.folders.indexOf( this ), 1 );
  		}

  		if ( this.domElement.parentElement ) {
  			this.domElement.parentElement.removeChild( this.domElement );
  		}

  		Array.from( this.children ).forEach( c => c.destroy() );

  	}

  	/**
  	 * Returns an array of controllers contained by this GUI and its descendents.
  	 * @returns {Controller[]}
  	 */
  	controllersRecursive() {
  		let controllers = Array.from( this.controllers );
  		this.folders.forEach( f => {
  			controllers = controllers.concat( f.controllersRecursive() );
  		} );
  		return controllers;
  	}

  	/**
  	 * Returns an array of folders contained by this GUI and its descendents.
  	 * @returns {GUI[]}
  	 */
  	foldersRecursive() {
  		let folders = Array.from( this.folders );
  		this.folders.forEach( f => {
  			folders = folders.concat( f.foldersRecursive() );
  		} );
  		return folders;
  	}

  }

  gsapWithCSS.registerPlugin(ScrollTrigger$1);
  var GlitchText = /*#__PURE__*/function () {
    function GlitchText() {
      var _this = this;
      _classCallCheck(this, GlitchText);
      document.querySelectorAll('.jsGlitchTxt').forEach(function (el) {
        // const clone = el.cloneNode(true);
        // el.parentNode.insertBefore(clone, el.nextSibling);
        _this.draw(el);
      });
    }
    return _createClass$1(GlitchText, [{
      key: "draw",
      value: function draw(container) {
        var settings = {
          params: {
            // frequency: 15.0,
            speed: 1,
            scroll: 0.5,
            gain: 1.0,
            transition: 0.0
          }
        };
        // ======  ======
        // const container = document.getElementById('canvas_pic');

        var scene = new Scene();

        // const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
        // camera.position.set(0, 0, 5);
        var aspect = container.clientWidth / container.clientHeight;
        var frustumSize = 1;
        var camera = new OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
        camera.position.set(0, 0, 1);
        camera.lookAt(0, 0, 0);

        // 
        var renderer = new WebGLRenderer({
          antialias: true,
          alpha: true
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(container.clientWidth, container.clientHeight);

        // 
        renderer.setClearColor(0xffffff, 0);
        container.appendChild(renderer.domElement);

        // ======  ======
        var imgEl = container.querySelector("img");
        var loader = new TextureLoader();
        var texture = loader.load(imgEl.getAttribute('src'), function () {
          var _renderer$capabilitie, _renderer$capabilitie2;
          texture.wrapS = ClampToEdgeWrapping;
          texture.wrapT = ClampToEdgeWrapping;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.anisotropy = ((_renderer$capabilitie = (_renderer$capabilitie2 = renderer.capabilities).getMaxAnisotropy) === null || _renderer$capabilitie === void 0 ? void 0 : _renderer$capabilitie.call(_renderer$capabilitie2)) || 1;
        });

        // ====== R3F ======
        var uniforms = {
          u_texture: {
            value: texture
          },
          u_time: {
            value: 0
          },
          // scroll: { value: settings.params.scroll },
          // gain: { value: settings.params.gain },
          // transition: { value: settings.params.transition },

          // resolution: { value: new THREE.Vector2(container.clientWidth, container.clientHeight) },
          enterTime: {
            value: 0
          },
          delay: {
            value: 0
          }
        };
        var vertexShader = /* glsl */"\n      uniform float u_time;\n\n      varying vec2 vUv;\n      varying vec3 vPosition;\n      void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    ";
        var fragmentShader = /* glsl */"\n    precision highp float;\n    uniform sampler2D u_texture;\n    uniform vec2 resolution;\n    uniform vec2 offset;\n    uniform float u_time;\n    uniform float enterTime;\n    // uniform float leaveTime;\n    uniform float delay;\n    #define speed 0.75\n\n    // out vec4 outColor;\n\n    float nn(float y, float t) {\n        float n = (\n            sin(y * .07 + t * 8. + sin(y * .5 + t * 10.)) +\n            sin(y * .7 + t * 2. + sin(y * .3 + t * 8.)) * .7 +\n            sin(y * 1.1 + t * 2.8) * .4\n        );\n        n += sin(y * 124. + t * 100.7) * sin(y * 877. - t * 38.8) * .3;\n        return n;\n    }\n\n    vec4 readTex(sampler2D tex, vec2 uv) {\n        if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) { return vec4(0); }\n        // return texture(tex, uv);\n        return clamp(texture(tex, uv), 0.0, 1.0);\n    }\n    \n    bool isOut(vec2 u) {\n        return (u.x < 0.0 || u.x > 1.0 || u.y < 0.0 || u.y > 1.0);\n    }\n\n    vec4 glitch(vec2 uv) {\n        vec2 uvr = uv, uvg = uv, uvb = uv;\n        float t = mod(u_time, 30.);\n        float amp = 10. / resolution.x;\n        if (abs(nn(uv.y, t)) > 1.) {\n            uvr.x += nn(uv.y, t) * amp;\n            uvg.x += nn(uv.y, t + 10.) * amp;\n            uvb.x += nn(uv.y, t + 20.) * amp;\n        }\n        vec4 cr = readTex(u_texture, uvr);\n        vec4 cg = readTex(u_texture, uvg);\n        vec4 cb = readTex(u_texture, uvb);\n        \n        //vec4 color = vec4(\n        return vec4(\n            cr.r,\n            cg.g,\n            cb.b,\n            smoothstep(.0, 1., cr.a + cg.a + cb.a)\n        );\n    }\n    vec4 slitscan(vec2 uv) {\n        float t = max(u_time - delay, 0.) * speed;\n        if (t <= 0.0) {\n            return vec4(0);\n        }\n    \n        vec2 uvr = uv, uvg = uv, uvb = uv;\n        uvr.x = min(uvr.x, t);\n        uvg.x = min(uvg.x, max(t - 0.2, 0.));\n        uvb.x = min(uvb.x, max(t - 0.4, 0.));\n    \n        vec4 cr = readTex(u_texture, uvr);\n        vec4 cg = readTex(u_texture, uvg);\n        vec4 cb = readTex(u_texture, uvb);\n    \n        vec4 color = vec4(\n            cr.r, cg.g, cb.b, (cr.a + cg.a + cb.a) / 1.\n        );\n        \n        color = mix(color, vec4(cg.rgb, cg.a), cg.a);\n        color = mix(color, vec4(cb.rgb, cb.a), cb.a);\n    \n        // \u5143\u306Euv\u3068\u7570\u306A\u308B\uFF08=\u30B7\u30D5\u30C8\u3055\u308C\u305F\uFF09\u9818\u57DF\u3092\u691C\u51FA\n        float shifted = step(abs(uvr.x - uv.x) + abs(uvg.x - uv.x) + abs(uvb.x - uv.x), 0.0001);\n    \n        // shifted = 1.0 \u2192 \u5909\u5316\u306A\u3057\uFF08\u305D\u306E\u307E\u307E\uFF09\n        // shifted = 0.0 \u2192 \u305A\u308C\u3066\u3044\u308B\uFF08\u767D\u304F\uFF09\n        color.rgb = mix(vec3(1.0, 0.333, 0.169), color.rgb, shifted);\n    \n        return color;\n    }\n\n    void main (void) {\n        vec2 uv = (gl_FragCoord.xy - offset) / resolution;\n        // outColor = slitscan(uv);\n        gl_FragColor = slitscan(uv);\n        // if (leaveTime > 0.) {\n        //     float t = clamp(leaveTime - 0.5, 0., 1.);\n        //     outColor = glitch(uv) * (1. - t);\n        // } else if (enterTime < 1.0) {\n        //     outColor = slitscan(uv);\n        // } else {\n        //     outColor = glitch(uv);\n        // }\n        // float val = enterTime;\n        // val = clamp(val, 0.0, 1.0);\n        // outColor = vec4(val, 1.0 - val, 0.0, 1.0);\n    }\n    ";
        var material = new ShaderMaterial({
          uniforms: uniforms,
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          transparent: true
        });

        // ====== R3F planeGeometry args: [4, 3, 32, 32] ======
        var geometry = new PlaneGeometry(aspect, frustumSize, 32, 32);
        var mesh = new Mesh(geometry, material);
        scene.add(mesh);

        // ====== lil-gui ======
        // const gui = new GUI();
        // gui.add(settings.params, 'scroll', 0, 1.0, 0.05).name('(scroll)').onChange(v => uniforms.scroll.value = v);
        // gui.add(settings.params, 'gain', 1.0, 3.0, 0.05).name('(gain)').onChange(v => uniforms.gain.value = v);
        // gui.add(settings.params, 'transition', 0.0, 1.0, 0.05).name('(transition)').onChange(v => uniforms.transition.value = v);

        // ======  ======
        var clock = new Clock();
        function animate() {
          var elapsed = clock.getElapsedTime();
          uniforms.u_time.value = elapsed * settings.params.speed;
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }
        animate();

        // ======  ======
        function setCameraSize() {
          var frustumSize = 1;
          camera.left = -frustumSize * aspect / 2;
          camera.right = frustumSize * aspect / 2;
          camera.top = frustumSize / 2;
          camera.bottom = -frustumSize / 2;
          camera.updateProjectionMatrix();
        }

        // ======  ======
        function onResize() {
          var w = container.clientWidth;
          var h = container.clientHeight;
          setCameraSize();
          renderer.setSize(w, h);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }
        window.addEventListener('resize', onResize);
      }
    }]);
  }();

  gsapWithCSS.registerPlugin(ScrollTrigger$1);
  var Glitch = /*#__PURE__*/function () {
    function Glitch() {
      var _this = this;
      _classCallCheck(this, Glitch);
      document.querySelectorAll('.jsGlitchPic').forEach(function (el) {
        // const clone = el.cloneNode(true);
        // el.parentNode.insertBefore(clone, el.nextSibling);
        _this.draw(el);
      });
    }
    return _createClass$1(Glitch, [{
      key: "draw",
      value: function draw(container) {
        var settings = {
          params: {
            // frequency: 15.0,
            speed: 1,
            scroll: 0.5,
            gain: 1.0,
            transition: 0.0
          }
        };
        // ======  ======
        // const container = document.getElementById('canvas_pic');

        var scene = new Scene();

        // const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
        // camera.position.set(0, 0, 5);
        var aspect = container.clientWidth / container.clientHeight;
        var frustumSize = 1;
        var camera = new OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
        camera.position.set(0, 0, 1);
        camera.lookAt(0, 0, 0);

        // 
        var renderer = new WebGLRenderer({
          antialias: true,
          alpha: true
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(container.clientWidth, container.clientHeight);

        // 
        renderer.setClearColor(0xffffff, 0);
        container.appendChild(renderer.domElement);

        // ======  ======
        var imgEl = container.querySelector("img");
        var loader = new TextureLoader();
        var texture = loader.load(imgEl.getAttribute('src'), function () {
          var _renderer$capabilitie, _renderer$capabilitie2;
          texture.wrapS = ClampToEdgeWrapping;
          texture.wrapT = ClampToEdgeWrapping;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.anisotropy = ((_renderer$capabilitie = (_renderer$capabilitie2 = renderer.capabilities).getMaxAnisotropy) === null || _renderer$capabilitie === void 0 ? void 0 : _renderer$capabilitie.call(_renderer$capabilitie2)) || 1;
        });

        // ====== R3F ======
        var uniforms = {
          u_texture: {
            value: texture
          },
          u_time: {
            value: 0
          },
          scroll: {
            value: settings.params.scroll
          },
          gain: {
            value: settings.params.gain
          },
          transition: {
            value: settings.params.transition
          }
        };
        var vertexShader = /* glsl */"\n      uniform float u_time;\n\n      varying vec2 vUv;\n      varying vec3 vPosition;\n      void main() {\n        // v_uv = uv;\n        //\n        // vec3 pos = position;\n        //\n        // float wave = sin(uv.y * 15.0 + u_time) * 0.1;\n        // pos.x += wave;\n        //\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    ";
        var fragmentShader = /* glsl */"\n      precision highp float;\n      uniform float u_time;\n      uniform sampler2D u_texture;\n      uniform float scroll;\n      uniform float gain;\n      uniform float transition;\n      varying vec2 vUv;\n\n      float inside(vec2 uv) {\n        return step(abs(uv.x - 0.5), 0.5) * step(abs(uv.y - 0.5), 0.5);\n      }\n\n      vec4 readTex(vec2 uv) {\n        return texture2D(u_texture, uv) * inside(uv);\n      }\n\n      void main() {\n        vec2 uv = vUv;\n        \n        float revealThreshold = 1.0 - transition;\n        float transitionFactor = 1.0 - smoothstep(revealThreshold - 0.2, revealThreshold + 0.2, uv.y);\n        \n        float d = scroll * 0.5;\n        // d *= abs(\n        //   sin(floor(gl_FragCoord.y / 2.0) * 3.0 + u_time * 2.0) + \n        //   sin(floor(gl_FragCoord.y / 3.0) * 10.0 - u_time * 3.0)\n        // );\n         d *= abs(\n          sin(floor(gl_FragCoord.y / 5.0) * 3.0 + u_time * 2.0) + \n          sin(floor(gl_FragCoord.y / 5.0) * 10.0 - u_time * 3.0)\n        );\n        \n        vec4 cr = readTex(uv + vec2(0.0, d * 0.25 * transitionFactor));\n        vec4 cg = readTex(uv + vec2(0.0, d * 0.5 * transitionFactor));\n        vec4 cb = readTex(uv + vec2(0.0, d * 0.75 * transitionFactor));\n        \n        vec4 normalColor = readTex(uv);\n        \n        vec3 shiftedColor = vec3(cr.r, cg.g, cb.b);\n        vec3 finalColor = mix(normalColor.rgb, shiftedColor, transitionFactor) * gain;\n        float finalAlpha = mix(normalColor.a, (cr.a + cg.a + cb.a) / 3.0, transitionFactor);\n        \n        gl_FragColor = vec4(finalColor, finalAlpha);\n        // gl_FragColor = texture2D(u_texture, v_uv);\n      }\n    ";
        var material = new ShaderMaterial({
          uniforms: uniforms,
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          transparent: true
        });

        // ====== R3F planeGeometry args: [4, 3, 32, 32] ======
        var geometry = new PlaneGeometry(aspect, frustumSize, 32, 32);
        var mesh = new Mesh(geometry, material);
        scene.add(mesh);

        // ====== lil-gui ======
        // const gui = new GUI();
        // gui.add(settings.params, 'scroll', 0, 1.0, 0.05).name('(scroll)').onChange(v => uniforms.scroll.value = v);
        // gui.add(settings.params, 'gain', 1.0, 3.0, 0.05).name('(gain)').onChange(v => uniforms.gain.value = v);
        // gui.add(settings.params, 'transition', 0.0, 1.0, 0.05).name('(transition)').onChange(v => uniforms.transition.value = v);

        // ======  ======
        var clock = new Clock();
        function animate() {
          var elapsed = clock.getElapsedTime();
          uniforms.u_time.value = elapsed * settings.params.speed;
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }
        animate();

        // ====== ScrollTrigger  ======
        gsapWithCSS.to(uniforms.transition, {
          value: 1.0,
          ease: "power3.out",
          duration: 2.0,
          scrollTrigger: {
            trigger: container,
            start: "top 70%",
            end: "bottom 70%"
            // scrub: true,
            // markers: true,
          }
        });

        // ======  ======
        function setCameraSize() {
          var frustumSize = 1;
          camera.left = -frustumSize * aspect / 2;
          camera.right = frustumSize * aspect / 2;
          camera.top = frustumSize / 2;
          camera.bottom = -frustumSize / 2;
          camera.updateProjectionMatrix();
        }

        // ======  ======
        function onResize() {
          var w = container.clientWidth;
          var h = container.clientHeight;
          setCameraSize();
          renderer.setSize(w, h);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }
        window.addEventListener('resize', onResize);
      }
    }]);
  }();

  const model = { "UW3": { "": 6699, "": 3897, "": 4784, "": 3706, "": 4162, "": 5769, "": 4221, "": 2900, "": 2971, "": 2902, "": 3155, "": 2242, "": 2447, "": 3372, "": 2217, "": 1855, "": 2357, "": -1853, "": 2814, "": 1353, "": 967, "": 1790, "": 2166, "": 1899, "": 3358, "": 1013, "": 3252, "": -102, "": 2149, "": 3703, "": 2093, "": 1074, "": 2428, "": 1732, "": 992, "": -2327, "": 2573, "": -2137, "": 2675, "": -1495, "": 428, "": -1870, "": 1078, "": 1608, "": 2714, "": -1669, "": 335, "": 866, "": 2073, "": 1142, "": 2335, "": 1456, "": 475, "": 514, "": 1179, "": 1080, "": 2053, "": 1111, "": 1389, "": -1134, "": -1396, "": 998, "": 486, "": -794, "": -568, "": 938, "": -599, "": -370, "": -681, "": 752, "": -870, "": 1322, "": -1285, "": -284, "": -1434, "": -337, "": 530, "": 713, "": -901, "": 1112, "": 1224, "": 1435, "": -1196, "": 982, "": -976, "": -517, "": -725, "": -995, "": -636, "": 728, "": 902, "": 1480, "": -700, "": 1404, "": -550, "": 1000, "": 1464, "": -819, "": -718, "": 1287, "": -960, "": 1113, "": -710, "": 1294, "": 920, "": -552, "": -749, "": 584, "": 701, "": 328, "": 976, "": 672, "": 515, "": 489, "": 295, "": 680, "": 13, "": 768, "": -218, "": -477, "": 825, "": 344, "": -711, "": -463, "": -419, "": 363, "": 130, "": 275, "": -520, "": 588, "": 181, "": 159, "": -635, "": 160, "": 304, "": -352, "": 767, "": 252, "": 469, "": 257, "": 454, "": -160, "": 338, "": -102, "": -136, "": -240, "": 203, "": -50, "": 285, "": 486, "": 270, "": 398, "": 101, "": -160, "": 159, "": 215, "": -149, "": 189, "": 94, "": -111, "": 149, "": 145, "": -93, "": -76, "": 50, "": 54, "": -54, "": -29, "": 33, "": 12, "": -16 }, "UW4": { "": -7440, "": -4018, "": -3577, "": -4299, "": -3839, "": -5462, "": -7452, "": -3332, "": -4313, "": -3120, "": -4861, "": -2446, "": -2917, "": -4081, "": -1296, "": -1675, "": 501, "": -4326, "": -1928, "": 456, "": -2884, "": -2662, "": -4391, "": 591, "": -1725, "": -517, "": -2037, "": -2074, "": -1531, "": -3821, "": -2899, "": -2746, "": -1111, "": 652, "": 411, "": 1386, "": -1159, "": 2526, "": 788, "": -5393, "": -2352, "": -1257, "": -3441, "": -1867, "": -1716, "": -643, "": 2301, "": 1003, "": 695, "": 1811, "": 333, "": 576, "": 564, "": -1762, "": 2351, "": 614, "": -4205, "": -1624, "": 512, "": 1957, "": -4469, "": -1844, "": -2189, "": 384, "": -677, "": -2078, "": 710, "": -816, "": -2964, "": 270, "": 430, "": -2793, "": -1498, "": -1178, "": -2432, "": -1195, "": 1131, "": 2399, "": 180, "": -2208, "": -2265, "": -3412, "": -4207, "": -2267, "": 1291, "": 1247, "": -1619, "": -3444, "": -1249, "": -697, "": 1760, "": -2874, "": 227, "": 820, "": -1966, "": -507, "": 1002, "": -2441, "": 386, "": 792, "": 533, "": 1072, "": -716, "": -1138, "": -393, "": 441, "": 1062, "": -707, "": -1270, "": -3209, "": -1427, "": 235, "": 412, "": 744, "": -1659, "": 451, "": -1501, "": -1428, "": 34, "": 1076, "": 1409, "": -817, "": 673, "": 344, "": -1527, "": 286, "": -375, "": -374, "": -1261, "": -948, "": 724, "": -949, "": -1513, "": 736, "": 856, "": -1296, "": -1156, "": -76, "": 308, "": 475, "": 411, "": -218, "": 481, "": -582, "": 436, "": 505, "": -347, "": -356, "": -907, "": 229, "": 623, "": 413, "": 368, "": -776, "": 117, "": -935, "": 316, "": -233, "": -840, "": -625, "": 22, "": 181, "": -500, "": -489, "": 368, "": 366, "": 192, "": 443, "": 470, "": -204, "": -434, "": -176, "": -568, "": 383, "": -212, "": -278, "": 191, "": 150, "": 403, "": -157, "": -148, "": -455, "": -327, "": 174, "": -471, "": 28, "": 307, "": 179, "": 153, "": -247, "": -156, "": 254, "": 138, "": 75, "": -75, "": 101, "": 264, "": 61, "": -148, "": -256, "": -125, "": 52, "": -142, "": 159, "": -154, "": -56, "": -145, "": 63, "": 54, "": 45, "": 45, "": -45, "": -41, "": -8, "": -8, "": 4, "": 4 }, "UW5": { "": -2177, "": -955, "": -681, "": -1011, "": -608, "": -353, "": 169, "": 964, "": 175, "": -874, "": 1177, "": -394, "": 345, "": -674, "": 287, "": 500, "": 886, "": -612, "": -421, "": 219, "": 710, "": 1871, "": 637, "": 1001, "": -271, "": 198, "": 293, "": 345, "": -1082, "": -617, "": -587, "": -641, "": -360, "": -1087, "": 210, "": -338, "": 851, "": 303, "": 495, "": 1494, "": 222, "": 1173, "": -327, "": 1091, "": -472, "": 776, "": -1068, "": -285, "": 1415, "": 342, "": -272, "": 826, "": -303, "": -891, "": 572, "": 1123, "": 409, "": 876, "": -1390, "": 365, "": 791, "": -384, "": -470, "": 255, "": 15, "": -1133, "": 708, "": 159, "": -254, "": -93, "": 325, "": -341, "": -571, "": -313, "": -1085, "": 401, "": 505, "": 173, "": 171, "": -272, "": -122, "": 579, "": -461, "": 348, "": 179, "": -872, "": 458, "": -209, "": -184, "": 244, "": -180, "": -192, "": -154, "": -562, "": 40, "": -151, "": -41, "": 209, "": -123, "": 49, "": -116, "": 104, "": 95, "": -146, "": -176, "": 111, "": -30, "": 90, "": 4, "": -135, "": -67, "": 42, "": -101, "": -54, "": 46, "": 29, "": 104, "": -29, "": -37, "": 8, "": 4 }, "UW2": { "": -1401, "": -1370, "": -2403, "": -1207, "": -653, "": -1010, "": 18, "": 5, "": 269, "": 2215, "": -985, "": -489, "": 1762, "": -695, "": -534, "": -810, "": 523, "": 1668, "": 922, "": -812, "": 81, "": -751, "": -813, "": -233, "": 1197, "": -49, "": 344, "": -711, "": 981, "": -682, "": -556, "": 1671, "": 1952, "": 754, "": 676, "": 445, "": 1001, "": -118, "": 2257, "": -421, "": 577, "": 567, "": -479, "": 1341, "": 201, "": 531, "": -492, "": -482, "": -464, "": 745, "": -377, "": 694, "": -79, "": 266, "": -1004, "": 387, "": -477, "": -423, "": -246, "": -1313, "": 283, "": 848, "": 663, "": -1353, "": 956, "": 335, "": -1421, "": -207, "": -1437, "": 274, "": 567, "": 396, "": 341, "": -264, "": -551, "": 787, "": -173, "": 826, "": 435, "": 1181, "": 498, "": 276, "": 494, "": -91, "": 167, "": -109, "": -123, "": 70, "": -122, "": 315, "": -664, "": 557, "": -47, "": -793, "": 289, "": -487, "": 990, "": -195, "": -360, "": 149, "": 190, "": 161, "": -306, "": -499, "": 313, "": -361, "": 748, "": -160, "": 183, "": -210, "": 54, "": -310, "": -161, "": 93, "": 80, "": 124, "": -292, "": 154, "": 31, "": 227, "": 97, "": 159, "": -115, "": 94, "": 106, "": -50, "": -84, "": 42, "": 75, "": 58, "": 16, "": 130, "": 100, "": -16, "": -25, "": -33, "": 20, "": -12, "": -4 }, "UW6": { "": 320, "": -307, "": -16, "": 219, "": 307, "": 581, "": 621, "": 828, "": -496, "": 1589, "": 218, "": -90, "": 95, "": 1415, "": 1711, "": 555, "": -283, "": 85, "": 2064, "": 35, "": 819, "": 578, "": -864, "": 245, "": 506, "": 352, "": -17, "": 301, "": 71, "": 231, "": 365, "": 65, "": -101, "": 527, "": -213, "": -66, "": 324, "": -1272, "": -346, "": 207, "": 626, "": 240, "": 180, "": -284, "": -906, "": 611, "": -639, "": 1217, "": -361, "": 755, "": 221, "": 679, "": 85, "": 479, "": 567, "": 380, "": 415, "": -111, "": 813, "": 170, "": 239, "": -18, "": 780, "": 292, "": -896, "": -261, "": 846, "": -244, "": -725, "": -130, "": -388, "": -403, "": -248, "": 643, "": 119, "": -150, "": 216, "": 60, "": -64, "": -235, "": 33, "": 41, "": 164, "": 360, "": 129, "": -94, "": 280, "": 204, "": -18, "": 123, "": 168, "": -112, "": 275, "": 68, "": 114, "": 33, "": -20, "": -4, "": 8, "": -4 }, "UW1": { "": -273, "": 275, "": 128, "": 922, "": 890, "": 165, "": -385, "": -34, "": 210, "": -91, "": 289, "": -230, "": -127, "": 209, "": -102, "": 1464, "": -344, "": -1424, "": 241, "": 511, "": -220, "": 60, "": 1969, "": -26, "": 127, "": -1038, "": 1899, "": 72, "": -44, "": -86, "": -176, "": 137, "": 194, "": 303, "": -601, "": 113, "": -110, "": 572, "": 285, "": -428, "": -30, "": 301, "": -155, "": -96, "": 275, "": -524, "": -251, "": 134, "": 412, "": 151, "": 599, "": -164, "": 183, "": -196, "": 266, "": 134, "": 574, "": -371, "": 254, "": 318, "": -400, "": -53, "": 619, "": 211, "": -258, "": 96, "": -306, "": 173, "": 64, "": 588, "": 124, "": -248, "": -49, "": 225, "": 365, "": 137, "": -382, "": 42, "": -31, "": 170, "": -17, "": 117, "": 63, "": 178, "": -72, "": 92, "": -79, "": 76, "": 113, "": 209, "": 65, "": -182, "": 79, "": 120, "": 137, "": 144, "": -42, "": 114, "": 63, "": 50, "": 126, "": -16, "": -12, "": -8, "": -79, "": 12, "": -8, "": -29, "": 16 }, "BW2": { "": 1475, "": -3875, "": 274, "": -2003, "": -2999, "": -2622, "": -1296, "": -3302, "": -838, "": -3035, "": -2116, "": -1737, "": -2082, "": -921, "": -2119, "": -1012, "": -1213, "": -2465, "": -1810, "": -1022, "": -1771, "": -1689, "": -331, "": -1100, "": -643, "": -2518, "": -1807, "": -1351, "": -1856, "": -558, "": -2737, "": -2687, "": -1520, "": -944, "": 709, "": -935, "": -1014, "": -2039, "": -1183, "": -1524, "": -652, "": -490, "": -1248, "": -675, "": -1684, "": -820, "": -873, "": -956, "": -362, "": 1674, "": -722, "": -753, "": -421, "": 545, "": -890, "": -770, "": -1196, "": -1043, "": -1221, "": -1069, "": -1494, "": -1185, "": -1027, "": -659, "": 159, "": -681, "": 280, "": -458, "": -1227, "": -851, "": 458, "": -968, "": -145, "": 421, "": -489, "": -782, "": -64, "": -299, "": -278, "": -1003, "": 318, "": -337, "": -157, "": -402, "": -433, "": -357, "": -523, "": -230, "": -157, "": -393, "": 41, "": -359, "": -401, "": -494, "": -333, "": -524, "": -442, "": -175, "": -144, "": 476, "": -197, "": -297, "": -643, "": -151, "": 191, "": 195, "": -539, "": -137, "": -374, "": -360, "": -127, "": 186, "": -152, "": -93, "": -101, "": 80, "": -126, "": 83, "": 62, "": 96, "": -54, "": -33, "": -37, "": -20 }, "BW1": { "": 3058, "": 1223, "": 2830, "": 1723, "": 2162, "": 1494, "": 3534, "": -2703, "": 969, "": 1045, "": -1066, "": -518, "": 166, "": -948, "": -1455, "": 922, "": 1688, "": -1593, "": 513, "": -1543, "": 1277, "": 1376, "": 667, "": -1393, "": 917, "": -1290, "": 631, "": -1620, "": 471, "": 1085, "": 2456, "": 949, "": -70, "": 623, "": 1018, "": 1515, "": -1545, "": -1039, "": 816, "": 1694, "": 1178, "": -1090, "": -96, "": 1198, "": -325, "": 1343, "": 588, "": 1414, "": 1375, "": 1349, "": 1413, "": 1231, "": 936, "": 1014, "": 1427, "": 202, "": 1736, "": 1018, "": 138, "": 436, "": -725, "": -329, "": 1251, "": -1273, "": 702, "": 141, "": -196, "": 572, "": 1571, "": 356, "": -399, "": -429, "": 350, "": 242, "": 293, "": 1050, "": 1155, "": 1137, "": -369, "": -1096, "": 391, "": -522, "": 941, "": 680, "": 515, "": -781, "": -844, "": 655, "": 725, "": 57, "": 791, "": 687, "": -579, "": 310, "": 310, "": -538, "": 398, "": 482, "": 372, "": 401, "": 753, "": 626, "": 96, "": -364, "": 252, "": 444, "": -715, "": -591, "": -137, "": -698, "": 322, "": -429, "": 564, "": 304, "": 302, "": 789, "": -159, "": 625, "": 437, "": -442, "": 416, "": -619, "": 449, "": 245, "": 589, "": 524, "": 160, "": -255, "": 218, "": 149, "": 386, "": 236, "": 424, "": 254, "": 342, "": -303, "": 237, "": -302, "": -315, "": 281, "": 274, "": 199, "": 147, "": 190, "": -216, "": 180, "": -98, "": 115, "": 102, "": -71, "": 83, "": -20, "": 29, "": -24, "": 24, "": 12, "": 37, "": -4 }, "BW3": { "": 4971, "": 3479, "": 1053, "": 712, "": -404, "": 719, "": 1571, "": -943, "": 3173, "": -693, "": 1383, "": 1979, "": 1237, "": -2875, "": 3096, "": 402, "": -1016, "": 899, "": 647, "": 1643, "": 1844, "": -512, "": -1257, "": -339, "": 1656, "": 1917, "": -1050, "": 1242, "": -1223, "": 1098, "": 980, "": 2909, "": 2245, "": 481, "": 3011, "": 1986, "": 278, "": 678, "": 2538, "": 364, "": -190, "": -184, "": 1752, "": 2306, "": -397, "": -1499, "": -1463, "": -93, "": 1038, "": -1778, "": 1078, "": 832, "": 1442, "": -941, "": 813, "": -1566, "": 444, "": 727, "": 1082, "": 897, "": -807, "": 287, "": 686, "": 1075, "": 296, "": 1041, "": -152, "": 917, "": 408, "": 1283, "": -802, "": 1198, "": -519, "": 1094, "": 1264, "": 422, "": -670, "": -1304, "": 121, "": -670, "": 480, "": 589, "": 691, "": 348, "": 556, "": 742, "": 414, "": -672, "": -739, "": 821, "": -372, "": 198, "": -160, "": 680, "": -93, "": 626, "": -479, "": 732, "": 429, "": -268, "": 666, "": 296, "": -514, "": -677, "": 627, "": -520, "": 539, "": 621, "": -239, "": -596, "": -428, "": 437, "": -350, "": -238, "": 552, "": 272, "": -218, "": 128, "": -136, "": 260, "": 438, "": 128, "": 85, "": 251, "": -374, "": 233, "": -357, "": 249, "": -345, "": 8, "": 214, "": 109, "": -161, "": 329, "": 203, "": 246, "": 119, "": 46, "": 121, "": 62, "": -58, "": 71, "": -95, "": -28, "": -24, "": -24, "": 12 }, "TW3": { "": 970, "": -1899, "": -1724, "": 655, "": -2756, "": -1375, "": -473, "": -961, "": 710, "": -1361, "": -1075, "": -1539, "": -289, "": -1169, "": -1166, "": 769, "": -749, "": -293, "": -49, "": -812, "": 229, "": 574, "": 75, "": -408, "": -183, "": -535, "": -120, "": -137, "": -37, "": -66, "": 108, "": -54, "": -4 }, "TW4": { "": 2195, "": -1673, "": 1598, "": -1569, "": -1767, "": 2848, "": 2069, "": -1366, "": -2232, "": -824, "": 1066, "": 1092, "": 1258, "": -925, "": -856, "": 1697, "": 1383, "": 380, "": 191, "": -588, "": -595, "": 1130, "": -1150, "": 406, "": 683, "": 628, "": 590, "": 651, "": 256, "": -896, "": 669, "": 253, "": 438, "": 512, "": 255, "": -234, "": -824, "": 481, "": 314, "": 278, "": 397, "": 424, "": 494, "": -232, "": -390, "": 140, "": -174, "": 52, "": 116, "": -102, "": 170, "": -75, "": -63, "": 37, "": 20, "": 16 }, "TW2": { "": -4086, "": -1086, "": -1130, "": -463, "": -2306, "": -1441, "": -803, "": -406, "": -936, "": -267, "": 440, "": -757, "": -477, "": -436, "": -207, "": -59, "": 50, "": -37 }, "TW1": { "": 545, "": 1686, "": 1298, "": 1104, "": -1851, "": 2079, "": 1444, "": 1162, "": 2083, "": 1728, "": 1223, "": 1174, "": 947, "": 811, "": 1250, "": 412, "": -1039, "": -691, "": -1017, "": -418, "": 732, "": 251, "": -268, "": 267, "": 698, "": 556, "": 599, "": 676, "": 309, "": 141, "": -68, "": 196, "": 225, "": -271, "": 164, "": -86, "": 163, "": 54, "": 16, "": 4 } };

  // used in Attr to signal changes
  const CHANGED = Symbol('changed');

  // used in Element to setup once classList
  const CLASS_LIST = Symbol('classList');

  // used in Document to attach once customElements
  const CUSTOM_ELEMENTS = Symbol('CustomElements');

  // used in HTMLTemplateElement
  const CONTENT = Symbol('content');

  // used in Element for data attributes
  const DATASET = Symbol('dataset');

  // used in Document to attach the DocType
  const DOCTYPE = Symbol('doctype');

  // used in parser and Document to attach once a DOMParser
  const DOM_PARSER = Symbol('DOMParser');

  // used to reference an end node
  const END = Symbol('end');

  // used in Document to make the globalThis an event target
  const EVENT_TARGET = Symbol('EventTarget');

  // used to augment a created document defaultView
  const GLOBALS = Symbol('globals');

  // used in both Canvas and Document to provide images
  const IMAGE = Symbol('image');

  // used to define Document mime type
  const MIME = Symbol('mime');

  // used in Document to attach once MutationObserver
  const MUTATION_OBSERVER = Symbol('MutationObserver');

  // used to define next node reference
  const NEXT = Symbol('next');

  // used to define Attr owner elements
  const OWNER_ELEMENT = Symbol('ownerElement');

  // used to define previous node reference
  const PREV = Symbol('prev');

  // used to define various "private" properties
  const PRIVATE = Symbol('private');

  // used to define the CSSStyleSheet.sheet
  const SHEET = Symbol('sheet');

  // used to define start node reference
  const START = Symbol('start');

  // used to define special CSS style attribute
  const STYLE = Symbol('style');

  // used to upgrade Custom Elements
  const UPGRADE = Symbol('upgrade');

  // used to define generic values
  const VALUE = Symbol('value');

  // Generated using scripts/write-decode-map.ts
  const htmlDecodeTree = /* #__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* #__PURE__ */ "\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
      .split("")
      .map((c) => c.charCodeAt(0)));

  // Generated using scripts/write-decode-map.ts
  const xmlDecodeTree = /* #__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* #__PURE__ */ "\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
      .split("")
      .map((c) => c.charCodeAt(0)));

  // Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
  var _a;
  const decodeMap = new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376],
  ]);
  /**
   * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
   */
  const fromCodePoint = 
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
      let output = "";
      if (codePoint > 65535) {
          codePoint -= 65536;
          output += String.fromCharCode(((codePoint >>> 10) & 1023) | 55296);
          codePoint = 56320 | (codePoint & 1023);
      }
      output += String.fromCharCode(codePoint);
      return output;
  };
  /**
   * Replace the given code point with a replacement character if it is a
   * surrogate or is outside the valid range. Otherwise return the code
   * point unchanged.
   */
  function replaceCodePoint(codePoint) {
      var _a;
      if ((codePoint >= 55296 && codePoint <= 57343) ||
          codePoint > 1114111) {
          return 65533;
      }
      return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
  }

  var CharCodes$1;
  (function (CharCodes) {
      CharCodes[CharCodes["NUM"] = 35] = "NUM";
      CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
      CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
      CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
      CharCodes[CharCodes["NINE"] = 57] = "NINE";
      CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
      CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
      CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
      CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
      CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
      CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes$1 || (CharCodes$1 = {}));
  /** Bit that needs to be set to convert an upper case ASCII character to lower case */
  const TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function (BinTrieFlags) {
      BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags || (BinTrieFlags = {}));
  function isNumber(code) {
      return code >= CharCodes$1.ZERO && code <= CharCodes$1.NINE;
  }
  function isHexadecimalCharacter(code) {
      return ((code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_F) ||
          (code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_F));
  }
  function isAsciiAlphaNumeric(code) {
      return ((code >= CharCodes$1.UPPER_A && code <= CharCodes$1.UPPER_Z) ||
          (code >= CharCodes$1.LOWER_A && code <= CharCodes$1.LOWER_Z) ||
          isNumber(code));
  }
  /**
   * Checks if the given character is a valid end character for an entity in an attribute.
   *
   * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
   * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
   */
  function isEntityInAttributeInvalidEnd(code) {
      return code === CharCodes$1.EQUALS || isAsciiAlphaNumeric(code);
  }
  var EntityDecoderState;
  (function (EntityDecoderState) {
      EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function (DecodingMode) {
      /** Entities in text nodes that can end with any character. */
      DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
      /** Only allow entities terminated with a semicolon. */
      DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
      /** Entities in attributes have limitations on ending characters. */
      DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
  })(DecodingMode || (DecodingMode = {}));
  /**
   * Token decoder with support of writing partial entities.
   */
  class EntityDecoder {
      constructor(
      /** The tree used to decode entities. */
      decodeTree, 
      /**
       * The function that is called when a codepoint is decoded.
       *
       * For multi-byte named entities, this will be called multiple times,
       * with the second codepoint, and the same `consumed` value.
       *
       * @param codepoint The decoded codepoint.
       * @param consumed The number of bytes consumed by the decoder.
       */
      emitCodePoint, 
      /** An object that is used to produce errors. */
      errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          /** The current state of the decoder. */
          this.state = EntityDecoderState.EntityStart;
          /** Characters that were consumed while parsing an entity. */
          this.consumed = 1;
          /**
           * The result of the entity.
           *
           * Either the result index of a numeric entity, or the codepoint of a
           * numeric entity.
           */
          this.result = 0;
          /** The current index in the decode tree. */
          this.treeIndex = 0;
          /** The number of characters that were consumed in excess. */
          this.excess = 1;
          /** The mode in which the decoder is operating. */
          this.decodeMode = DecodingMode.Strict;
      }
      /** Resets the instance to make it reusable. */
      startEntity(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
      }
      /**
       * Write an entity to the decoder. This can be called multiple times with partial entities.
       * If the entity is incomplete, the decoder will return -1.
       *
       * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
       * entity is incomplete, and resume when the next string is written.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      write(input, offset) {
          switch (this.state) {
              case EntityDecoderState.EntityStart: {
                  if (input.charCodeAt(offset) === CharCodes$1.NUM) {
                      this.state = EntityDecoderState.NumericStart;
                      this.consumed += 1;
                      return this.stateNumericStart(input, offset + 1);
                  }
                  this.state = EntityDecoderState.NamedEntity;
                  return this.stateNamedEntity(input, offset);
              }
              case EntityDecoderState.NumericStart: {
                  return this.stateNumericStart(input, offset);
              }
              case EntityDecoderState.NumericDecimal: {
                  return this.stateNumericDecimal(input, offset);
              }
              case EntityDecoderState.NumericHex: {
                  return this.stateNumericHex(input, offset);
              }
              case EntityDecoderState.NamedEntity: {
                  return this.stateNamedEntity(input, offset);
              }
          }
      }
      /**
       * Switches between the numeric decimal and hexadecimal states.
       *
       * Equivalent to the `Numeric character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericStart(input, offset) {
          if (offset >= input.length) {
              return -1;
          }
          if ((input.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes$1.LOWER_X) {
              this.state = EntityDecoderState.NumericHex;
              this.consumed += 1;
              return this.stateNumericHex(input, offset + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(input, offset);
      }
      addToNumericResult(input, start, end, base) {
          if (start !== end) {
              const digitCount = end - start;
              this.result =
                  this.result * Math.pow(base, digitCount) +
                      Number.parseInt(input.substr(start, digitCount), base);
              this.consumed += digitCount;
          }
      }
      /**
       * Parses a hexadecimal numeric entity.
       *
       * Equivalent to the `Hexademical character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericHex(input, offset) {
          const startIndex = offset;
          while (offset < input.length) {
              const char = input.charCodeAt(offset);
              if (isNumber(char) || isHexadecimalCharacter(char)) {
                  offset += 1;
              }
              else {
                  this.addToNumericResult(input, startIndex, offset, 16);
                  return this.emitNumericEntity(char, 3);
              }
          }
          this.addToNumericResult(input, startIndex, offset, 16);
          return -1;
      }
      /**
       * Parses a decimal numeric entity.
       *
       * Equivalent to the `Decimal character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNumericDecimal(input, offset) {
          const startIndex = offset;
          while (offset < input.length) {
              const char = input.charCodeAt(offset);
              if (isNumber(char)) {
                  offset += 1;
              }
              else {
                  this.addToNumericResult(input, startIndex, offset, 10);
                  return this.emitNumericEntity(char, 2);
              }
          }
          this.addToNumericResult(input, startIndex, offset, 10);
          return -1;
      }
      /**
       * Validate and emit a numeric entity.
       *
       * Implements the logic from the `Hexademical character reference start
       * state` and `Numeric character reference end state` in the HTML spec.
       *
       * @param lastCp The last code point of the entity. Used to see if the
       *               entity was terminated with a semicolon.
       * @param expectedLength The minimum number of characters that should be
       *                       consumed. Used to validate that at least one digit
       *                       was consumed.
       * @returns The number of characters that were consumed.
       */
      emitNumericEntity(lastCp, expectedLength) {
          var _a;
          // Ensure we consumed at least one digit.
          if (this.consumed <= expectedLength) {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
          }
          // Figure out if this is a legit end of the entity
          if (lastCp === CharCodes$1.SEMI) {
              this.consumed += 1;
          }
          else if (this.decodeMode === DecodingMode.Strict) {
              return 0;
          }
          this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
          if (this.errors) {
              if (lastCp !== CharCodes$1.SEMI) {
                  this.errors.missingSemicolonAfterCharacterReference();
              }
              this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
      }
      /**
       * Parses a named entity.
       *
       * Equivalent to the `Named character reference state` in the HTML spec.
       *
       * @param input The string containing the entity (or a continuation of the entity).
       * @param offset The current offset.
       * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
       */
      stateNamedEntity(input, offset) {
          const { decodeTree } = this;
          let current = decodeTree[this.treeIndex];
          // The mask is the number of bytes of the value, including the current byte.
          let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset < input.length; offset++, this.excess++) {
              const char = input.charCodeAt(offset);
              this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
              if (this.treeIndex < 0) {
                  return this.result === 0 ||
                      // If we are parsing an attribute
                      (this.decodeMode === DecodingMode.Attribute &&
                          // We shouldn't have consumed any characters after the entity,
                          (valueLength === 0 ||
                              // And there should be no invalid characters.
                              isEntityInAttributeInvalidEnd(char)))
                      ? 0
                      : this.emitNotTerminatedNamedEntity();
              }
              current = decodeTree[this.treeIndex];
              valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
              // If the branch is a value, store it and continue
              if (valueLength !== 0) {
                  // If the entity is terminated by a semicolon, we are done.
                  if (char === CharCodes$1.SEMI) {
                      return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                  }
                  // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
                  if (this.decodeMode !== DecodingMode.Strict) {
                      this.result = this.treeIndex;
                      this.consumed += this.excess;
                      this.excess = 0;
                  }
              }
          }
          return -1;
      }
      /**
       * Emit a named entity that was not terminated with a semicolon.
       *
       * @returns The number of characters consumed.
       */
      emitNotTerminatedNamedEntity() {
          var _a;
          const { result, decodeTree } = this;
          const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
      }
      /**
       * Emit a named entity.
       *
       * @param result The index of the entity in the decode tree.
       * @param valueLength The number of bytes in the entity.
       * @param consumed The number of characters consumed.
       *
       * @returns The number of characters consumed.
       */
      emitNamedEntityData(result, valueLength, consumed) {
          const { decodeTree } = this;
          this.emitCodePoint(valueLength === 1
              ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
              : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
              // For multi-byte values, we need to emit the second byte.
              this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
      }
      /**
       * Signal to the parser that the end of the input was reached.
       *
       * Remaining data will be emitted and relevant errors will be produced.
       *
       * @returns The number of characters consumed.
       */
      end() {
          var _a;
          switch (this.state) {
              case EntityDecoderState.NamedEntity: {
                  // Emit a named entity if we have one.
                  return this.result !== 0 &&
                      (this.decodeMode !== DecodingMode.Attribute ||
                          this.result === this.treeIndex)
                      ? this.emitNotTerminatedNamedEntity()
                      : 0;
              }
              // Otherwise, emit a numeric entity if we have one.
              case EntityDecoderState.NumericDecimal: {
                  return this.emitNumericEntity(0, 2);
              }
              case EntityDecoderState.NumericHex: {
                  return this.emitNumericEntity(0, 3);
              }
              case EntityDecoderState.NumericStart: {
                  (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                  return 0;
              }
              case EntityDecoderState.EntityStart: {
                  // Return 0 if we have no entity.
                  return 0;
              }
          }
      }
  }
  /**
   * Determines the branch of the current node that is taken given the current
   * character. This function is used to traverse the trie.
   *
   * @param decodeTree The trie.
   * @param current The current node.
   * @param nodeIdx The index right after the current node and its value.
   * @param char The current character.
   * @returns The index of the next node, or -1 if no branch is taken.
   */
  function determineBranch(decodeTree, current, nodeIndex, char) {
      const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      // Case 1: Single branch encoded in jump offset
      if (branchCount === 0) {
          return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
      }
      // Case 2: Multiple branches encoded in jump table
      if (jumpOffset) {
          const value = char - jumpOffset;
          return value < 0 || value >= branchCount
              ? -1
              : decodeTree[nodeIndex + value] - 1;
      }
      // Case 3: Multiple branches encoded in dictionary
      // Binary search for the character.
      let lo = nodeIndex;
      let hi = lo + branchCount - 1;
      while (lo <= hi) {
          const mid = (lo + hi) >>> 1;
          const midValue = decodeTree[mid];
          if (midValue < char) {
              lo = mid + 1;
          }
          else if (midValue > char) {
              hi = mid - 1;
          }
          else {
              return decodeTree[mid + branchCount];
          }
      }
      return -1;
  }

  var CharCodes;
  (function (CharCodes) {
      CharCodes[CharCodes["Tab"] = 9] = "Tab";
      CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
      CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
      CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
      CharCodes[CharCodes["Space"] = 32] = "Space";
      CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
      CharCodes[CharCodes["Number"] = 35] = "Number";
      CharCodes[CharCodes["Amp"] = 38] = "Amp";
      CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
      CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
      CharCodes[CharCodes["Dash"] = 45] = "Dash";
      CharCodes[CharCodes["Slash"] = 47] = "Slash";
      CharCodes[CharCodes["Zero"] = 48] = "Zero";
      CharCodes[CharCodes["Nine"] = 57] = "Nine";
      CharCodes[CharCodes["Semi"] = 59] = "Semi";
      CharCodes[CharCodes["Lt"] = 60] = "Lt";
      CharCodes[CharCodes["Eq"] = 61] = "Eq";
      CharCodes[CharCodes["Gt"] = 62] = "Gt";
      CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
      CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
      CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
      CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
      CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
      CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
      CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
      CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
      CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes || (CharCodes = {}));
  /** All the states the tokenizer can be in. */
  var State;
  (function (State) {
      State[State["Text"] = 1] = "Text";
      State[State["BeforeTagName"] = 2] = "BeforeTagName";
      State[State["InTagName"] = 3] = "InTagName";
      State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
      State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
      State[State["InClosingTagName"] = 6] = "InClosingTagName";
      State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
      // Attributes
      State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
      State[State["InAttributeName"] = 9] = "InAttributeName";
      State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
      State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
      State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
      State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
      State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
      // Declarations
      State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
      State[State["InDeclaration"] = 16] = "InDeclaration";
      // Processing instructions
      State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
      // Comments & CDATA
      State[State["BeforeComment"] = 18] = "BeforeComment";
      State[State["CDATASequence"] = 19] = "CDATASequence";
      State[State["InSpecialComment"] = 20] = "InSpecialComment";
      State[State["InCommentLike"] = 21] = "InCommentLike";
      // Special tags
      State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
      State[State["BeforeSpecialT"] = 23] = "BeforeSpecialT";
      State[State["SpecialStartSequence"] = 24] = "SpecialStartSequence";
      State[State["InSpecialTag"] = 25] = "InSpecialTag";
      State[State["InEntity"] = 26] = "InEntity";
  })(State || (State = {}));
  function isWhitespace$1(c) {
      return (c === CharCodes.Space ||
          c === CharCodes.NewLine ||
          c === CharCodes.Tab ||
          c === CharCodes.FormFeed ||
          c === CharCodes.CarriageReturn);
  }
  function isEndOfTagSection(c) {
      return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace$1(c);
  }
  function isASCIIAlpha(c) {
      return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||
          (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));
  }
  var QuoteType;
  (function (QuoteType) {
      QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
      QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
      QuoteType[QuoteType["Single"] = 2] = "Single";
      QuoteType[QuoteType["Double"] = 3] = "Double";
  })(QuoteType || (QuoteType = {}));
  /**
   * Sequences used to match longer strings.
   *
   * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
   * sequences with an increased offset.
   */
  const Sequences = {
      Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]), // CDATA[
      CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]), // ]]>
      CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]), // `-->`
      ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]), // `</script`
      StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]), // `</style`
      TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`
      TextareaEnd: new Uint8Array([
          0x3c, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x61, 0x72, 0x65, 0x61,
      ]), // `</textarea`
      XmpEnd: new Uint8Array([0x3c, 0x2f, 0x78, 0x6d, 0x70]), // `</xmp`
  };
  class Tokenizer {
      constructor({ xmlMode = false, decodeEntities = true, }, cbs) {
          this.cbs = cbs;
          /** The current state the tokenizer is in. */
          this.state = State.Text;
          /** The read buffer. */
          this.buffer = "";
          /** The beginning of the section that is currently being read. */
          this.sectionStart = 0;
          /** The index within the buffer that we are currently looking at. */
          this.index = 0;
          /** The start of the last entity. */
          this.entityStart = 0;
          /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
          this.baseState = State.Text;
          /** For special parsing behavior inside of script and style tags. */
          this.isSpecial = false;
          /** Indicates whether the tokenizer has been paused. */
          this.running = true;
          /** The offset of the current buffer. */
          this.offset = 0;
          this.currentSequence = undefined;
          this.sequenceIndex = 0;
          this.xmlMode = xmlMode;
          this.decodeEntities = decodeEntities;
          this.entityDecoder = new EntityDecoder(xmlMode ? xmlDecodeTree : htmlDecodeTree, (cp, consumed) => this.emitCodePoint(cp, consumed));
      }
      reset() {
          this.state = State.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State.Text;
          this.currentSequence = undefined;
          this.running = true;
          this.offset = 0;
      }
      write(chunk) {
          this.offset += this.buffer.length;
          this.buffer = chunk;
          this.parse();
      }
      end() {
          if (this.running)
              this.finish();
      }
      pause() {
          this.running = false;
      }
      resume() {
          this.running = true;
          if (this.index < this.buffer.length + this.offset) {
              this.parse();
          }
      }
      stateText(c) {
          if (c === CharCodes.Lt ||
              (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {
              if (this.index > this.sectionStart) {
                  this.cbs.ontext(this.sectionStart, this.index);
              }
              this.state = State.BeforeTagName;
              this.sectionStart = this.index;
          }
          else if (this.decodeEntities && c === CharCodes.Amp) {
              this.startEntity();
          }
      }
      stateSpecialStartSequence(c) {
          const isEnd = this.sequenceIndex === this.currentSequence.length;
          const isMatch = isEnd
              ? // If we are at the end of the sequence, make sure the tag name has ended
                  isEndOfTagSection(c)
              : // Otherwise, do a case-insensitive comparison
                  (c | 0x20) === this.currentSequence[this.sequenceIndex];
          if (!isMatch) {
              this.isSpecial = false;
          }
          else if (!isEnd) {
              this.sequenceIndex++;
              return;
          }
          this.sequenceIndex = 0;
          this.state = State.InTagName;
          this.stateInTagName(c);
      }
      /** Look for an end tag. For <title> tags, also decode entities. */
      stateInSpecialTag(c) {
          if (this.sequenceIndex === this.currentSequence.length) {
              if (c === CharCodes.Gt || isWhitespace$1(c)) {
                  const endOfText = this.index - this.currentSequence.length;
                  if (this.sectionStart < endOfText) {
                      // Spoof the index so that reported locations match up.
                      const actualIndex = this.index;
                      this.index = endOfText;
                      this.cbs.ontext(this.sectionStart, endOfText);
                      this.index = actualIndex;
                  }
                  this.isSpecial = false;
                  this.sectionStart = endOfText + 2; // Skip over the `</`
                  this.stateInClosingTagName(c);
                  return; // We are done; skip the rest of the function.
              }
              this.sequenceIndex = 0;
          }
          if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
              this.sequenceIndex += 1;
          }
          else if (this.sequenceIndex === 0) {
              if (this.currentSequence === Sequences.TitleEnd) {
                  // We have to parse entities in <title> tags.
                  if (this.decodeEntities && c === CharCodes.Amp) {
                      this.startEntity();
                  }
              }
              else if (this.fastForwardTo(CharCodes.Lt)) {
                  // Outside of <title> tags, we can fast-forward.
                  this.sequenceIndex = 1;
              }
          }
          else {
              // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
              this.sequenceIndex = Number(c === CharCodes.Lt);
          }
      }
      stateCDATASequence(c) {
          if (c === Sequences.Cdata[this.sequenceIndex]) {
              if (++this.sequenceIndex === Sequences.Cdata.length) {
                  this.state = State.InCommentLike;
                  this.currentSequence = Sequences.CdataEnd;
                  this.sequenceIndex = 0;
                  this.sectionStart = this.index + 1;
              }
          }
          else {
              this.sequenceIndex = 0;
              this.state = State.InDeclaration;
              this.stateInDeclaration(c); // Reconsume the character
          }
      }
      /**
       * When we wait for one specific character, we can speed things up
       * by skipping through the buffer until we find it.
       *
       * @returns Whether the character was found.
       */
      fastForwardTo(c) {
          while (++this.index < this.buffer.length + this.offset) {
              if (this.buffer.charCodeAt(this.index - this.offset) === c) {
                  return true;
              }
          }
          /*
           * We increment the index at the end of the `parse` loop,
           * so set it to `buffer.length - 1` here.
           *
           * TODO: Refactor `parse` to increment index before calling states.
           */
          this.index = this.buffer.length + this.offset - 1;
          return false;
      }
      /**
       * Comments and CDATA end with `-->` and `]]>`.
       *
       * Their common qualities are:
       * - Their end sequences have a distinct character they start with.
       * - That character is then repeated, so we have to check multiple repeats.
       * - All characters but the start character of the sequence can be skipped.
       */
      stateInCommentLike(c) {
          if (c === this.currentSequence[this.sequenceIndex]) {
              if (++this.sequenceIndex === this.currentSequence.length) {
                  if (this.currentSequence === Sequences.CdataEnd) {
                      this.cbs.oncdata(this.sectionStart, this.index, 2);
                  }
                  else {
                      this.cbs.oncomment(this.sectionStart, this.index, 2);
                  }
                  this.sequenceIndex = 0;
                  this.sectionStart = this.index + 1;
                  this.state = State.Text;
              }
          }
          else if (this.sequenceIndex === 0) {
              // Fast-forward to the first character of the sequence
              if (this.fastForwardTo(this.currentSequence[0])) {
                  this.sequenceIndex = 1;
              }
          }
          else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
              // Allow long sequences, eg. --->, ]]]>
              this.sequenceIndex = 0;
          }
      }
      /**
       * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
       *
       * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
       * We allow anything that wouldn't end the tag.
       */
      isTagStartChar(c) {
          return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
      }
      startSpecial(sequence, offset) {
          this.isSpecial = true;
          this.currentSequence = sequence;
          this.sequenceIndex = offset;
          this.state = State.SpecialStartSequence;
      }
      stateBeforeTagName(c) {
          if (c === CharCodes.ExclamationMark) {
              this.state = State.BeforeDeclaration;
              this.sectionStart = this.index + 1;
          }
          else if (c === CharCodes.Questionmark) {
              this.state = State.InProcessingInstruction;
              this.sectionStart = this.index + 1;
          }
          else if (this.isTagStartChar(c)) {
              const lower = c | 0x20;
              this.sectionStart = this.index;
              if (this.xmlMode) {
                  this.state = State.InTagName;
              }
              else if (lower === Sequences.ScriptEnd[2]) {
                  this.state = State.BeforeSpecialS;
              }
              else if (lower === Sequences.TitleEnd[2] ||
                  lower === Sequences.XmpEnd[2]) {
                  this.state = State.BeforeSpecialT;
              }
              else {
                  this.state = State.InTagName;
              }
          }
          else if (c === CharCodes.Slash) {
              this.state = State.BeforeClosingTagName;
          }
          else {
              this.state = State.Text;
              this.stateText(c);
          }
      }
      stateInTagName(c) {
          if (isEndOfTagSection(c)) {
              this.cbs.onopentagname(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
          }
      }
      stateBeforeClosingTagName(c) {
          if (isWhitespace$1(c)) ;
          else if (c === CharCodes.Gt) {
              this.state = State.Text;
          }
          else {
              this.state = this.isTagStartChar(c)
                  ? State.InClosingTagName
                  : State.InSpecialComment;
              this.sectionStart = this.index;
          }
      }
      stateInClosingTagName(c) {
          if (c === CharCodes.Gt || isWhitespace$1(c)) {
              this.cbs.onclosetag(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.state = State.AfterClosingTagName;
              this.stateAfterClosingTagName(c);
          }
      }
      stateAfterClosingTagName(c) {
          // Skip everything until ">"
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.state = State.Text;
              this.sectionStart = this.index + 1;
          }
      }
      stateBeforeAttributeName(c) {
          if (c === CharCodes.Gt) {
              this.cbs.onopentagend(this.index);
              if (this.isSpecial) {
                  this.state = State.InSpecialTag;
                  this.sequenceIndex = 0;
              }
              else {
                  this.state = State.Text;
              }
              this.sectionStart = this.index + 1;
          }
          else if (c === CharCodes.Slash) {
              this.state = State.InSelfClosingTag;
          }
          else if (!isWhitespace$1(c)) {
              this.state = State.InAttributeName;
              this.sectionStart = this.index;
          }
      }
      stateInSelfClosingTag(c) {
          if (c === CharCodes.Gt) {
              this.cbs.onselfclosingtag(this.index);
              this.state = State.Text;
              this.sectionStart = this.index + 1;
              this.isSpecial = false; // Reset special state, in case of self-closing special tags
          }
          else if (!isWhitespace$1(c)) {
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
          }
      }
      stateInAttributeName(c) {
          if (c === CharCodes.Eq || isEndOfTagSection(c)) {
              this.cbs.onattribname(this.sectionStart, this.index);
              this.sectionStart = this.index;
              this.state = State.AfterAttributeName;
              this.stateAfterAttributeName(c);
          }
      }
      stateAfterAttributeName(c) {
          if (c === CharCodes.Eq) {
              this.state = State.BeforeAttributeValue;
          }
          else if (c === CharCodes.Slash || c === CharCodes.Gt) {
              this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
              this.sectionStart = -1;
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
          }
          else if (!isWhitespace$1(c)) {
              this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);
              this.state = State.InAttributeName;
              this.sectionStart = this.index;
          }
      }
      stateBeforeAttributeValue(c) {
          if (c === CharCodes.DoubleQuote) {
              this.state = State.InAttributeValueDq;
              this.sectionStart = this.index + 1;
          }
          else if (c === CharCodes.SingleQuote) {
              this.state = State.InAttributeValueSq;
              this.sectionStart = this.index + 1;
          }
          else if (!isWhitespace$1(c)) {
              this.sectionStart = this.index;
              this.state = State.InAttributeValueNq;
              this.stateInAttributeValueNoQuotes(c); // Reconsume token
          }
      }
      handleInAttributeValue(c, quote) {
          if (c === quote ||
              (!this.decodeEntities && this.fastForwardTo(quote))) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.cbs.onattribend(quote === CharCodes.DoubleQuote
                  ? QuoteType.Double
                  : QuoteType.Single, this.index + 1);
              this.state = State.BeforeAttributeName;
          }
          else if (this.decodeEntities && c === CharCodes.Amp) {
              this.startEntity();
          }
      }
      stateInAttributeValueDoubleQuotes(c) {
          this.handleInAttributeValue(c, CharCodes.DoubleQuote);
      }
      stateInAttributeValueSingleQuotes(c) {
          this.handleInAttributeValue(c, CharCodes.SingleQuote);
      }
      stateInAttributeValueNoQuotes(c) {
          if (isWhitespace$1(c) || c === CharCodes.Gt) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = -1;
              this.cbs.onattribend(QuoteType.Unquoted, this.index);
              this.state = State.BeforeAttributeName;
              this.stateBeforeAttributeName(c);
          }
          else if (this.decodeEntities && c === CharCodes.Amp) {
              this.startEntity();
          }
      }
      stateBeforeDeclaration(c) {
          if (c === CharCodes.OpeningSquareBracket) {
              this.state = State.CDATASequence;
              this.sequenceIndex = 0;
          }
          else {
              this.state =
                  c === CharCodes.Dash
                      ? State.BeforeComment
                      : State.InDeclaration;
          }
      }
      stateInDeclaration(c) {
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.cbs.ondeclaration(this.sectionStart, this.index);
              this.state = State.Text;
              this.sectionStart = this.index + 1;
          }
      }
      stateInProcessingInstruction(c) {
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.cbs.onprocessinginstruction(this.sectionStart, this.index);
              this.state = State.Text;
              this.sectionStart = this.index + 1;
          }
      }
      stateBeforeComment(c) {
          if (c === CharCodes.Dash) {
              this.state = State.InCommentLike;
              this.currentSequence = Sequences.CommentEnd;
              // Allow short comments (eg. <!-->)
              this.sequenceIndex = 2;
              this.sectionStart = this.index + 1;
          }
          else {
              this.state = State.InDeclaration;
          }
      }
      stateInSpecialComment(c) {
          if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
              this.cbs.oncomment(this.sectionStart, this.index, 0);
              this.state = State.Text;
              this.sectionStart = this.index + 1;
          }
      }
      stateBeforeSpecialS(c) {
          const lower = c | 0x20;
          if (lower === Sequences.ScriptEnd[3]) {
              this.startSpecial(Sequences.ScriptEnd, 4);
          }
          else if (lower === Sequences.StyleEnd[3]) {
              this.startSpecial(Sequences.StyleEnd, 4);
          }
          else {
              this.state = State.InTagName;
              this.stateInTagName(c); // Consume the token again
          }
      }
      stateBeforeSpecialT(c) {
          const lower = c | 0x20;
          switch (lower) {
              case Sequences.TitleEnd[3]: {
                  this.startSpecial(Sequences.TitleEnd, 4);
                  break;
              }
              case Sequences.TextareaEnd[3]: {
                  this.startSpecial(Sequences.TextareaEnd, 4);
                  break;
              }
              case Sequences.XmpEnd[3]: {
                  this.startSpecial(Sequences.XmpEnd, 4);
                  break;
              }
              default: {
                  this.state = State.InTagName;
                  this.stateInTagName(c); // Consume the token again
              }
          }
      }
      startEntity() {
          this.baseState = this.state;
          this.state = State.InEntity;
          this.entityStart = this.index;
          this.entityDecoder.startEntity(this.xmlMode
              ? DecodingMode.Strict
              : this.baseState === State.Text ||
                  this.baseState === State.InSpecialTag
                  ? DecodingMode.Legacy
                  : DecodingMode.Attribute);
      }
      stateInEntity() {
          const length = this.entityDecoder.write(this.buffer, this.index - this.offset);
          // If `length` is positive, we are done with the entity.
          if (length >= 0) {
              this.state = this.baseState;
              if (length === 0) {
                  this.index = this.entityStart;
              }
          }
          else {
              // Mark buffer as consumed.
              this.index = this.offset + this.buffer.length - 1;
          }
      }
      /**
       * Remove data that has already been consumed from the buffer.
       */
      cleanup() {
          // If we are inside of text or attributes, emit what we already have.
          if (this.running && this.sectionStart !== this.index) {
              if (this.state === State.Text ||
                  (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {
                  this.cbs.ontext(this.sectionStart, this.index);
                  this.sectionStart = this.index;
              }
              else if (this.state === State.InAttributeValueDq ||
                  this.state === State.InAttributeValueSq ||
                  this.state === State.InAttributeValueNq) {
                  this.cbs.onattribdata(this.sectionStart, this.index);
                  this.sectionStart = this.index;
              }
          }
      }
      shouldContinue() {
          return this.index < this.buffer.length + this.offset && this.running;
      }
      /**
       * Iterates through the buffer, calling the function corresponding to the current state.
       *
       * States that are more likely to be hit are higher up, as a performance improvement.
       */
      parse() {
          while (this.shouldContinue()) {
              const c = this.buffer.charCodeAt(this.index - this.offset);
              switch (this.state) {
                  case State.Text: {
                      this.stateText(c);
                      break;
                  }
                  case State.SpecialStartSequence: {
                      this.stateSpecialStartSequence(c);
                      break;
                  }
                  case State.InSpecialTag: {
                      this.stateInSpecialTag(c);
                      break;
                  }
                  case State.CDATASequence: {
                      this.stateCDATASequence(c);
                      break;
                  }
                  case State.InAttributeValueDq: {
                      this.stateInAttributeValueDoubleQuotes(c);
                      break;
                  }
                  case State.InAttributeName: {
                      this.stateInAttributeName(c);
                      break;
                  }
                  case State.InCommentLike: {
                      this.stateInCommentLike(c);
                      break;
                  }
                  case State.InSpecialComment: {
                      this.stateInSpecialComment(c);
                      break;
                  }
                  case State.BeforeAttributeName: {
                      this.stateBeforeAttributeName(c);
                      break;
                  }
                  case State.InTagName: {
                      this.stateInTagName(c);
                      break;
                  }
                  case State.InClosingTagName: {
                      this.stateInClosingTagName(c);
                      break;
                  }
                  case State.BeforeTagName: {
                      this.stateBeforeTagName(c);
                      break;
                  }
                  case State.AfterAttributeName: {
                      this.stateAfterAttributeName(c);
                      break;
                  }
                  case State.InAttributeValueSq: {
                      this.stateInAttributeValueSingleQuotes(c);
                      break;
                  }
                  case State.BeforeAttributeValue: {
                      this.stateBeforeAttributeValue(c);
                      break;
                  }
                  case State.BeforeClosingTagName: {
                      this.stateBeforeClosingTagName(c);
                      break;
                  }
                  case State.AfterClosingTagName: {
                      this.stateAfterClosingTagName(c);
                      break;
                  }
                  case State.BeforeSpecialS: {
                      this.stateBeforeSpecialS(c);
                      break;
                  }
                  case State.BeforeSpecialT: {
                      this.stateBeforeSpecialT(c);
                      break;
                  }
                  case State.InAttributeValueNq: {
                      this.stateInAttributeValueNoQuotes(c);
                      break;
                  }
                  case State.InSelfClosingTag: {
                      this.stateInSelfClosingTag(c);
                      break;
                  }
                  case State.InDeclaration: {
                      this.stateInDeclaration(c);
                      break;
                  }
                  case State.BeforeDeclaration: {
                      this.stateBeforeDeclaration(c);
                      break;
                  }
                  case State.BeforeComment: {
                      this.stateBeforeComment(c);
                      break;
                  }
                  case State.InProcessingInstruction: {
                      this.stateInProcessingInstruction(c);
                      break;
                  }
                  case State.InEntity: {
                      this.stateInEntity();
                      break;
                  }
              }
              this.index++;
          }
          this.cleanup();
      }
      finish() {
          if (this.state === State.InEntity) {
              this.entityDecoder.end();
              this.state = this.baseState;
          }
          this.handleTrailingData();
          this.cbs.onend();
      }
      /** Handle any trailing data. */
      handleTrailingData() {
          const endIndex = this.buffer.length + this.offset;
          // If there is no remaining data, we are done.
          if (this.sectionStart >= endIndex) {
              return;
          }
          if (this.state === State.InCommentLike) {
              if (this.currentSequence === Sequences.CdataEnd) {
                  this.cbs.oncdata(this.sectionStart, endIndex, 0);
              }
              else {
                  this.cbs.oncomment(this.sectionStart, endIndex, 0);
              }
          }
          else if (this.state === State.InTagName ||
              this.state === State.BeforeAttributeName ||
              this.state === State.BeforeAttributeValue ||
              this.state === State.AfterAttributeName ||
              this.state === State.InAttributeName ||
              this.state === State.InAttributeValueSq ||
              this.state === State.InAttributeValueDq ||
              this.state === State.InAttributeValueNq ||
              this.state === State.InClosingTagName) ;
          else {
              this.cbs.ontext(this.sectionStart, endIndex);
          }
      }
      emitCodePoint(cp, consumed) {
          if (this.baseState !== State.Text &&
              this.baseState !== State.InSpecialTag) {
              if (this.sectionStart < this.entityStart) {
                  this.cbs.onattribdata(this.sectionStart, this.entityStart);
              }
              this.sectionStart = this.entityStart + consumed;
              this.index = this.sectionStart - 1;
              this.cbs.onattribentity(cp);
          }
          else {
              if (this.sectionStart < this.entityStart) {
                  this.cbs.ontext(this.sectionStart, this.entityStart);
              }
              this.sectionStart = this.entityStart + consumed;
              this.index = this.sectionStart - 1;
              this.cbs.ontextentity(cp, this.sectionStart);
          }
      }
  }

  const formTags = new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea",
  ]);
  const pTag = new Set(["p"]);
  const tableSectionTags = new Set(["thead", "tbody"]);
  const ddtTags = new Set(["dd", "dt"]);
  const rtpTags = new Set(["rt", "rp"]);
  const openImpliesClose = new Map([
      ["tr", new Set(["tr", "th", "td"])],
      ["th", new Set(["th"])],
      ["td", new Set(["thead", "th", "td"])],
      ["body", new Set(["head", "link", "script"])],
      ["li", new Set(["li"])],
      ["p", pTag],
      ["h1", pTag],
      ["h2", pTag],
      ["h3", pTag],
      ["h4", pTag],
      ["h5", pTag],
      ["h6", pTag],
      ["select", formTags],
      ["input", formTags],
      ["output", formTags],
      ["button", formTags],
      ["datalist", formTags],
      ["textarea", formTags],
      ["option", new Set(["option"])],
      ["optgroup", new Set(["optgroup", "option"])],
      ["dd", ddtTags],
      ["dt", ddtTags],
      ["address", pTag],
      ["article", pTag],
      ["aside", pTag],
      ["blockquote", pTag],
      ["details", pTag],
      ["div", pTag],
      ["dl", pTag],
      ["fieldset", pTag],
      ["figcaption", pTag],
      ["figure", pTag],
      ["footer", pTag],
      ["form", pTag],
      ["header", pTag],
      ["hr", pTag],
      ["main", pTag],
      ["nav", pTag],
      ["ol", pTag],
      ["pre", pTag],
      ["section", pTag],
      ["table", pTag],
      ["ul", pTag],
      ["rt", rtpTags],
      ["rp", rtpTags],
      ["tbody", tableSectionTags],
      ["tfoot", tableSectionTags],
  ]);
  const voidElements$1 = new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
  ]);
  const foreignContextElements = new Set(["math", "svg"]);
  const htmlIntegrationElements = new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignobject",
      "desc",
      "title",
  ]);
  const reNameEnd = /\s|\//;
  let Parser$2 = class Parser {
      constructor(cbs, options = {}) {
          var _a, _b, _c, _d, _e, _f;
          this.options = options;
          /** The start index of the last event. */
          this.startIndex = 0;
          /** The end index of the last event. */
          this.endIndex = 0;
          /**
           * Store the start index of the current open tag,
           * so we can update the start index for attributes.
           */
          this.openTagStart = 0;
          this.tagname = "";
          this.attribname = "";
          this.attribvalue = "";
          this.attribs = null;
          this.stack = [];
          this.buffers = [];
          this.bufferOffset = 0;
          /** The index of the last written buffer. Used when resuming after a `pause()`. */
          this.writeIndex = 0;
          /** Indicates whether the parser has finished running / `.end` has been called. */
          this.ended = false;
          this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
          this.htmlMode = !this.options.xmlMode;
          this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : this.htmlMode;
          this.lowerCaseAttributeNames =
              (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;
          this.recognizeSelfClosing =
              (_c = options.recognizeSelfClosing) !== null && _c !== void 0 ? _c : !this.htmlMode;
          this.tokenizer = new ((_d = options.Tokenizer) !== null && _d !== void 0 ? _d : Tokenizer)(this.options, this);
          this.foreignContext = [!this.htmlMode];
          (_f = (_e = this.cbs).onparserinit) === null || _f === void 0 ? void 0 : _f.call(_e, this);
      }
      // Tokenizer event handlers
      /** @internal */
      ontext(start, endIndex) {
          var _a, _b;
          const data = this.getSlice(start, endIndex);
          this.endIndex = endIndex - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
          this.startIndex = endIndex;
      }
      /** @internal */
      ontextentity(cp, endIndex) {
          var _a, _b;
          this.endIndex = endIndex - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, fromCodePoint(cp));
          this.startIndex = endIndex;
      }
      /**
       * Checks if the current tag is a void element. Override this if you want
       * to specify your own additional void elements.
       */
      isVoidElement(name) {
          return this.htmlMode && voidElements$1.has(name);
      }
      /** @internal */
      onopentagname(start, endIndex) {
          this.endIndex = endIndex;
          let name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
          }
          this.emitOpenTag(name);
      }
      emitOpenTag(name) {
          var _a, _b, _c, _d;
          this.openTagStart = this.startIndex;
          this.tagname = name;
          const impliesClose = this.htmlMode && openImpliesClose.get(name);
          if (impliesClose) {
              while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {
                  const element = this.stack.shift();
                  (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
              }
          }
          if (!this.isVoidElement(name)) {
              this.stack.unshift(name);
              if (this.htmlMode) {
                  if (foreignContextElements.has(name)) {
                      this.foreignContext.unshift(true);
                  }
                  else if (htmlIntegrationElements.has(name)) {
                      this.foreignContext.unshift(false);
                  }
              }
          }
          (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
          if (this.cbs.onopentag)
              this.attribs = {};
      }
      endOpenTag(isImplied) {
          var _a, _b;
          this.startIndex = this.openTagStart;
          if (this.attribs) {
              (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
              this.attribs = null;
          }
          if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
              this.cbs.onclosetag(this.tagname, true);
          }
          this.tagname = "";
      }
      /** @internal */
      onopentagend(endIndex) {
          this.endIndex = endIndex;
          this.endOpenTag(false);
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      onclosetag(start, endIndex) {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          this.endIndex = endIndex;
          let name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
          }
          if (this.htmlMode &&
              (foreignContextElements.has(name) ||
                  htmlIntegrationElements.has(name))) {
              this.foreignContext.shift();
          }
          if (!this.isVoidElement(name)) {
              const pos = this.stack.indexOf(name);
              if (pos !== -1) {
                  for (let index = 0; index <= pos; index++) {
                      const element = this.stack.shift();
                      // We know the stack has sufficient elements.
                      (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, index !== pos);
                  }
              }
              else if (this.htmlMode && name === "p") {
                  // Implicit open before close
                  this.emitOpenTag("p");
                  this.closeCurrentTag(true);
              }
          }
          else if (this.htmlMode && name === "br") {
              // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
              (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, "br");
              (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", {}, true);
              (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, "br", false);
          }
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      onselfclosingtag(endIndex) {
          this.endIndex = endIndex;
          if (this.recognizeSelfClosing || this.foreignContext[0]) {
              this.closeCurrentTag(false);
              // Set `startIndex` for next node
              this.startIndex = endIndex + 1;
          }
          else {
              // Ignore the fact that the tag is self-closing.
              this.onopentagend(endIndex);
          }
      }
      closeCurrentTag(isOpenImplied) {
          var _a, _b;
          const name = this.tagname;
          this.endOpenTag(isOpenImplied);
          // Self-closing tags will be on the top of the stack
          if (this.stack[0] === name) {
              // If the opening tag isn't implied, the closing tag has to be implied.
              (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
              this.stack.shift();
          }
      }
      /** @internal */
      onattribname(start, endIndex) {
          this.startIndex = start;
          const name = this.getSlice(start, endIndex);
          this.attribname = this.lowerCaseAttributeNames
              ? name.toLowerCase()
              : name;
      }
      /** @internal */
      onattribdata(start, endIndex) {
          this.attribvalue += this.getSlice(start, endIndex);
      }
      /** @internal */
      onattribentity(cp) {
          this.attribvalue += fromCodePoint(cp);
      }
      /** @internal */
      onattribend(quote, endIndex) {
          var _a, _b;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === QuoteType.Double
              ? '"'
              : quote === QuoteType.Single
                  ? "'"
                  : quote === QuoteType.NoValue
                      ? undefined
                      : null);
          if (this.attribs &&
              !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
              this.attribs[this.attribname] = this.attribvalue;
          }
          this.attribvalue = "";
      }
      getInstructionName(value) {
          const index = value.search(reNameEnd);
          let name = index < 0 ? value : value.substr(0, index);
          if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
          }
          return name;
      }
      /** @internal */
      ondeclaration(start, endIndex) {
          this.endIndex = endIndex;
          const value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
              const name = this.getInstructionName(value);
              this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
          }
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      onprocessinginstruction(start, endIndex) {
          this.endIndex = endIndex;
          const value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
              const name = this.getInstructionName(value);
              this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
          }
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      oncomment(start, endIndex, offset) {
          var _a, _b, _c, _d;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
          (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      oncdata(start, endIndex, offset) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
          this.endIndex = endIndex;
          const value = this.getSlice(start, endIndex - offset);
          if (!this.htmlMode || this.options.recognizeCDATA) {
              (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
              (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
              (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
          }
          else {
              (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
              (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
          }
          // Set `startIndex` for next node
          this.startIndex = endIndex + 1;
      }
      /** @internal */
      onend() {
          var _a, _b;
          if (this.cbs.onclosetag) {
              // Set the end index for all remaining tags
              this.endIndex = this.startIndex;
              for (let index = 0; index < this.stack.length; index++) {
                  this.cbs.onclosetag(this.stack[index], true);
              }
          }
          (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      /**
       * Resets the parser to a blank state, ready to parse a new HTML document
       */
      reset() {
          var _a, _b, _c, _d;
          (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
          this.tokenizer.reset();
          this.tagname = "";
          this.attribname = "";
          this.attribs = null;
          this.stack.length = 0;
          this.startIndex = 0;
          this.endIndex = 0;
          (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
          this.buffers.length = 0;
          this.foreignContext.length = 0;
          this.foreignContext.unshift(!this.htmlMode);
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
      }
      /**
       * Resets the parser, then parses a complete document and
       * pushes it to the handler.
       *
       * @param data Document to parse.
       */
      parseComplete(data) {
          this.reset();
          this.end(data);
      }
      getSlice(start, end) {
          while (start - this.bufferOffset >= this.buffers[0].length) {
              this.shiftBuffer();
          }
          let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
          while (end - this.bufferOffset > this.buffers[0].length) {
              this.shiftBuffer();
              slice += this.buffers[0].slice(0, end - this.bufferOffset);
          }
          return slice;
      }
      shiftBuffer() {
          this.bufferOffset += this.buffers[0].length;
          this.writeIndex--;
          this.buffers.shift();
      }
      /**
       * Parses a chunk of data and calls the corresponding callbacks.
       *
       * @param chunk Chunk to parse.
       */
      write(chunk) {
          var _a, _b;
          if (this.ended) {
              (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
              return;
          }
          this.buffers.push(chunk);
          if (this.tokenizer.running) {
              this.tokenizer.write(chunk);
              this.writeIndex++;
          }
      }
      /**
       * Parses the end of the buffer and clears the stack, calls onend.
       *
       * @param chunk Optional final chunk to parse.
       */
      end(chunk) {
          var _a, _b;
          if (this.ended) {
              (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
              return;
          }
          if (chunk)
              this.write(chunk);
          this.ended = true;
          this.tokenizer.end();
      }
      /**
       * Pauses parsing. The parser won't emit events until `resume` is called.
       */
      pause() {
          this.tokenizer.pause();
      }
      /**
       * Resumes parsing after `pause` was called.
       */
      resume() {
          this.tokenizer.resume();
          while (this.tokenizer.running &&
              this.writeIndex < this.buffers.length) {
              this.tokenizer.write(this.buffers[this.writeIndex++]);
          }
          if (this.ended)
              this.tokenizer.end();
      }
      /**
       * Alias of `write`, for backwards compatibility.
       *
       * @param chunk Chunk to parse.
       * @deprecated
       */
      parseChunk(chunk) {
          this.write(chunk);
      }
      /**
       * Alias of `end`, for backwards compatibility.
       *
       * @param chunk Optional final chunk to parse.
       * @deprecated
       */
      done(chunk) {
          this.end(chunk);
      }
  };

  /** Types of elements found in htmlparser2's DOM */
  var ElementType;
  (function (ElementType) {
      /** Type for the root element of a document */
      ElementType["Root"] = "root";
      /** Type for Text */
      ElementType["Text"] = "text";
      /** Type for <? ... ?> */
      ElementType["Directive"] = "directive";
      /** Type for <!-- ... --> */
      ElementType["Comment"] = "comment";
      /** Type for <script> tags */
      ElementType["Script"] = "script";
      /** Type for <style> tags */
      ElementType["Style"] = "style";
      /** Type for Any tag */
      ElementType["Tag"] = "tag";
      /** Type for <![CDATA[ ... ]]> */
      ElementType["CDATA"] = "cdata";
      /** Type for <!doctype ...> */
      ElementType["Doctype"] = "doctype";
  })(ElementType || (ElementType = {}));
  /**
   * Tests whether an element is a tag or not.
   *
   * @param elem Element to test
   */
  function isTag$2(elem) {
      return (elem.type === ElementType.Tag ||
          elem.type === ElementType.Script ||
          elem.type === ElementType.Style);
  }
  // Exports for backwards compatibility
  /** Type for the root element of a document */
  const Root = ElementType.Root;
  /** Type for Text */
  const Text$3 = ElementType.Text;
  /** Type for <? ... ?> */
  const Directive = ElementType.Directive;
  /** Type for <!-- ... --> */
  const Comment$3 = ElementType.Comment;
  /** Type for <script> tags */
  const Script = ElementType.Script;
  /** Type for <style> tags */
  const Style = ElementType.Style;
  /** Type for Any tag */
  const Tag = ElementType.Tag;
  /** Type for <![CDATA[ ... ]]> */
  const CDATA$1 = ElementType.CDATA;
  /** Type for <!doctype ...> */
  const Doctype = ElementType.Doctype;

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CDATA: CDATA$1,
    Comment: Comment$3,
    Directive: Directive,
    Doctype: Doctype,
    get ElementType () { return ElementType; },
    Root: Root,
    Script: Script,
    Style: Style,
    Tag: Tag,
    Text: Text$3,
    isTag: isTag$2
  });

  /**
   * This object will be used as the prototype for Nodes when creating a
   * DOM-Level-1-compliant structure.
   */
  let Node$2 = class Node {
      constructor() {
          /** Parent of the node */
          this.parent = null;
          /** Previous sibling */
          this.prev = null;
          /** Next sibling */
          this.next = null;
          /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
          this.startIndex = null;
          /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
          this.endIndex = null;
      }
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get parentNode() {
          return this.parent;
      }
      set parentNode(parent) {
          this.parent = parent;
      }
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get previousSibling() {
          return this.prev;
      }
      set previousSibling(prev) {
          this.prev = prev;
      }
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get nextSibling() {
          return this.next;
      }
      set nextSibling(next) {
          this.next = next;
      }
      /**
       * Clone this node, and optionally its children.
       *
       * @param recursive Clone child nodes as well.
       * @returns A clone of the node.
       */
      cloneNode(recursive = false) {
          return cloneNode(this, recursive);
      }
  };
  /**
   * A node that contains some data.
   */
  class DataNode extends Node$2 {
      /**
       * @param data The content of the data node
       */
      constructor(data) {
          super();
          this.data = data;
      }
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get nodeValue() {
          return this.data;
      }
      set nodeValue(data) {
          this.data = data;
      }
  }
  /**
   * Text within the document.
   */
  let Text$2 = class Text extends DataNode {
      constructor() {
          super(...arguments);
          this.type = ElementType.Text;
      }
      get nodeType() {
          return 3;
      }
  };
  /**
   * Comments within the document.
   */
  let Comment$2 = class Comment extends DataNode {
      constructor() {
          super(...arguments);
          this.type = ElementType.Comment;
      }
      get nodeType() {
          return 8;
      }
  };
  /**
   * Processing instructions, including doc types.
   */
  class ProcessingInstruction extends DataNode {
      constructor(name, data) {
          super(data);
          this.name = name;
          this.type = ElementType.Directive;
      }
      get nodeType() {
          return 1;
      }
  }
  /**
   * A `Node` that can have children.
   */
  class NodeWithChildren extends Node$2 {
      /**
       * @param children Children of the node. Only certain node types can have children.
       */
      constructor(children) {
          super();
          this.children = children;
      }
      // Aliases
      /** First child of the node. */
      get firstChild() {
          var _a;
          return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      }
      /** Last child of the node. */
      get lastChild() {
          return this.children.length > 0
              ? this.children[this.children.length - 1]
              : null;
      }
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get childNodes() {
          return this.children;
      }
      set childNodes(children) {
          this.children = children;
      }
  }
  class CDATA extends NodeWithChildren {
      constructor() {
          super(...arguments);
          this.type = ElementType.CDATA;
      }
      get nodeType() {
          return 4;
      }
  }
  /**
   * The root node of the document.
   */
  let Document$2 = class Document extends NodeWithChildren {
      constructor() {
          super(...arguments);
          this.type = ElementType.Root;
      }
      get nodeType() {
          return 9;
      }
  };
  /**
   * An element within the DOM.
   */
  let Element$3 = class Element extends NodeWithChildren {
      /**
       * @param name Name of the tag, eg. `div`, `span`.
       * @param attribs Object mapping attribute names to attribute values.
       * @param children Children of the node.
       */
      constructor(name, attribs, children = [], type = name === "script"
          ? ElementType.Script
          : name === "style"
              ? ElementType.Style
              : ElementType.Tag) {
          super(children);
          this.name = name;
          this.attribs = attribs;
          this.type = type;
      }
      get nodeType() {
          return 1;
      }
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get tagName() {
          return this.name;
      }
      set tagName(name) {
          this.name = name;
      }
      get attributes() {
          return Object.keys(this.attribs).map((name) => {
              var _a, _b;
              return ({
                  name,
                  value: this.attribs[name],
                  namespace: (_a = this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                  prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
              });
          });
      }
  };
  /**
   * @param node Node to check.
   * @returns `true` if the node is a `Element`, `false` otherwise.
   */
  function isTag$1(node) {
      return isTag$2(node);
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has the type `CDATA`, `false` otherwise.
   */
  function isCDATA(node) {
      return node.type === ElementType.CDATA;
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has the type `Text`, `false` otherwise.
   */
  function isText(node) {
      return node.type === ElementType.Text;
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has the type `Comment`, `false` otherwise.
   */
  function isComment(node) {
      return node.type === ElementType.Comment;
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
   */
  function isDirective(node) {
      return node.type === ElementType.Directive;
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
   */
  function isDocument(node) {
      return node.type === ElementType.Root;
  }
  /**
   * @param node Node to check.
   * @returns `true` if the node has children, `false` otherwise.
   */
  function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
  }
  /**
   * Clone a node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  function cloneNode(node, recursive = false) {
      let result;
      if (isText(node)) {
          result = new Text$2(node.data);
      }
      else if (isComment(node)) {
          result = new Comment$2(node.data);
      }
      else if (isTag$1(node)) {
          const children = recursive ? cloneChildren(node.children) : [];
          const clone = new Element$3(node.name, { ...node.attribs }, children);
          children.forEach((child) => (child.parent = clone));
          if (node.namespace != null) {
              clone.namespace = node.namespace;
          }
          if (node["x-attribsNamespace"]) {
              clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
          }
          if (node["x-attribsPrefix"]) {
              clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
          }
          result = clone;
      }
      else if (isCDATA(node)) {
          const children = recursive ? cloneChildren(node.children) : [];
          const clone = new CDATA(children);
          children.forEach((child) => (child.parent = clone));
          result = clone;
      }
      else if (isDocument(node)) {
          const children = recursive ? cloneChildren(node.children) : [];
          const clone = new Document$2(children);
          children.forEach((child) => (child.parent = clone));
          if (node["x-mode"]) {
              clone["x-mode"] = node["x-mode"];
          }
          result = clone;
      }
      else if (isDirective(node)) {
          const instruction = new ProcessingInstruction(node.name, node.data);
          if (node["x-name"] != null) {
              instruction["x-name"] = node["x-name"];
              instruction["x-publicId"] = node["x-publicId"];
              instruction["x-systemId"] = node["x-systemId"];
          }
          result = instruction;
      }
      else {
          throw new Error(`Not implemented yet: ${node.type}`);
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
          result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
  }
  function cloneChildren(childs) {
      const children = childs.map((child) => cloneNode(child, true));
      for (let i = 1; i < children.length; i++) {
          children[i].prev = children[i - 1];
          children[i - 1].next = children[i];
      }
      return children;
  }

  // Default options
  const defaultOpts = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false,
  };
  class DomHandler {
      /**
       * @param callback Called once parsing has completed.
       * @param options Settings for the handler.
       * @param elementCB Callback whenever a tag is closed.
       */
      constructor(callback, options, elementCB) {
          /** The elements of the DOM */
          this.dom = [];
          /** The root element for the DOM */
          this.root = new Document$2(this.dom);
          /** Indicated whether parsing has been completed. */
          this.done = false;
          /** Stack of open tags. */
          this.tagStack = [this.root];
          /** A data node that is still being written to. */
          this.lastNode = null;
          /** Reference to the parser instance. Used for location information. */
          this.parser = null;
          // Make it possible to skip arguments, for backwards-compatibility
          if (typeof options === "function") {
              elementCB = options;
              options = defaultOpts;
          }
          if (typeof callback === "object") {
              options = callback;
              callback = undefined;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      onparserinit(parser) {
          this.parser = parser;
      }
      // Resets the handler back to starting state
      onreset() {
          this.dom = [];
          this.root = new Document$2(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
      }
      // Signals the handler that parsing is done
      onend() {
          if (this.done)
              return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
      }
      onerror(error) {
          this.handleCallback(error);
      }
      onclosetag() {
          this.lastNode = null;
          const elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
              elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
              this.elementCB(elem);
      }
      onopentag(name, attribs) {
          const type = this.options.xmlMode ? ElementType.Tag : undefined;
          const element = new Element$3(name, attribs, undefined, type);
          this.addNode(element);
          this.tagStack.push(element);
      }
      ontext(data) {
          const { lastNode } = this;
          if (lastNode && lastNode.type === ElementType.Text) {
              lastNode.data += data;
              if (this.options.withEndIndices) {
                  lastNode.endIndex = this.parser.endIndex;
              }
          }
          else {
              const node = new Text$2(data);
              this.addNode(node);
              this.lastNode = node;
          }
      }
      oncomment(data) {
          if (this.lastNode && this.lastNode.type === ElementType.Comment) {
              this.lastNode.data += data;
              return;
          }
          const node = new Comment$2(data);
          this.addNode(node);
          this.lastNode = node;
      }
      oncommentend() {
          this.lastNode = null;
      }
      oncdatastart() {
          const text = new Text$2("");
          const node = new CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
      }
      oncdataend() {
          this.lastNode = null;
      }
      onprocessinginstruction(name, data) {
          const node = new ProcessingInstruction(name, data);
          this.addNode(node);
      }
      handleCallback(error) {
          if (typeof this.callback === "function") {
              this.callback(error, this.dom);
          }
          else if (error) {
              throw error;
          }
      }
      addNode(node) {
          const parent = this.tagStack[this.tagStack.length - 1];
          const previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
              node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
              node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
              node.prev = previousSibling;
              previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
      }
  }

  const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  const xmlCodeMap = new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"],
  ]);
  // For compatibility with node < 4, we wrap `codePointAt`
  const getCodePoint = 
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null
      ? (str, index) => str.codePointAt(index)
      : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          (c, index) => (c.charCodeAt(index) & 0xfc00) === 0xd800
              ? (c.charCodeAt(index) - 0xd800) * 0x400 +
                  c.charCodeAt(index + 1) -
                  0xdc00 +
                  0x10000
              : c.charCodeAt(index);
  /**
   * Encodes all non-ASCII characters, as well as characters not valid in XML
   * documents using XML entities.
   *
   * If a character has no equivalent entity, a
   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
   */
  function encodeXML(str) {
      let ret = "";
      let lastIdx = 0;
      let match;
      while ((match = xmlReplacer.exec(str)) !== null) {
          const i = match.index;
          const char = str.charCodeAt(i);
          const next = xmlCodeMap.get(char);
          if (next !== undefined) {
              ret += str.substring(lastIdx, i) + next;
              lastIdx = i + 1;
          }
          else {
              ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
              // Increase by 1 if we have a surrogate pair
              lastIdx = xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
          }
      }
      return ret + str.substr(lastIdx);
  }
  /**
   * Creates a function that escapes all characters matched by the given regular
   * expression using the given map of characters to escape to their entities.
   *
   * @param regex Regular expression to match characters to escape.
   * @param map Map of characters to escape to their entities.
   *
   * @returns Function that escapes all characters matched by the given regular
   * expression using the given map of characters to escape to their entities.
   */
  function getEscaper(regex, map) {
      return function escape(data) {
          let match;
          let lastIdx = 0;
          let result = "";
          while ((match = regex.exec(data))) {
              if (lastIdx !== match.index) {
                  result += data.substring(lastIdx, match.index);
              }
              // We know that this character will be in the map.
              result += map.get(match[0].charCodeAt(0));
              // Every match will be of length 1
              lastIdx = match.index + 1;
          }
          return result + data.substring(lastIdx);
      };
  }
  /**
   * Encodes all characters that have to be escaped in HTML attributes,
   * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
   *
   * @param data String to escape.
   */
  const escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"],
  ]));
  /**
   * Encodes all characters that have to be escaped in HTML text,
   * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
   *
   * @param data String to escape.
   */
  const escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"],
  ]));

  const elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath",
  ].map((val) => [val.toLowerCase(), val]));
  const attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan",
  ].map((val) => [val.toLowerCase(), val]));

  /*
   * Module dependencies
   */
  const unencodedElements = new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript",
  ]);
  function replaceQuotes(value) {
      return value.replace(/"/g, "&quot;");
  }
  /**
   * Format attributes
   */
  function formatAttributes(attributes, opts) {
      var _a;
      if (!attributes)
          return;
      const encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false
          ? replaceQuotes
          : opts.xmlMode || opts.encodeEntities !== "utf8"
              ? encodeXML
              : escapeAttribute;
      return Object.keys(attributes)
          .map((key) => {
          var _a, _b;
          const value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
          if (opts.xmlMode === "foreign") {
              /* Fix up mixed-case attribute names */
              key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
          }
          if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
              return key;
          }
          return `${key}="${encode(value)}"`;
      })
          .join(" ");
  }
  /**
   * Self-enclosing tags
   */
  const singleTag = new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
  ]);
  /**
   * Renders a DOM node or an array of DOM nodes to a string.
   *
   * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
   *
   * @param node Node to be rendered.
   * @param options Changes serialization behavior
   */
  function render(node, options = {}) {
      const nodes = "length" in node ? node : [node];
      let output = "";
      for (let i = 0; i < nodes.length; i++) {
          output += renderNode(nodes[i], options);
      }
      return output;
  }
  function renderNode(node, options) {
      switch (node.type) {
          case Root:
              return render(node.children, options);
          // @ts-expect-error We don't use `Doctype` yet
          case Doctype:
          case Directive:
              return renderDirective(node);
          case Comment$3:
              return renderComment(node);
          case CDATA$1:
              return renderCdata(node);
          case Script:
          case Style:
          case Tag:
              return renderTag(node, options);
          case Text$3:
              return renderText(node, options);
      }
  }
  const foreignModeIntegrationPoints = new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title",
  ]);
  const foreignElements = new Set(["svg", "math"]);
  function renderTag(elem, opts) {
      var _a;
      // Handle SVG / MathML in HTML
      if (opts.xmlMode === "foreign") {
          /* Fix up mixed-case element names */
          elem.name = (_a = elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
          /* Exit foreign mode at integration points */
          if (elem.parent &&
              foreignModeIntegrationPoints.has(elem.parent.name)) {
              opts = { ...opts, xmlMode: false };
          }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
          opts = { ...opts, xmlMode: "foreign" };
      }
      let tag = `<${elem.name}`;
      const attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
          tag += ` ${attribs}`;
      }
      if (elem.children.length === 0 &&
          (opts.xmlMode
              ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                  opts.selfClosingTags !== false
              : // User explicitly asked for self-closing tags, even in HTML mode
                  opts.selfClosingTags && singleTag.has(elem.name))) {
          if (!opts.xmlMode)
              tag += " ";
          tag += "/>";
      }
      else {
          tag += ">";
          if (elem.children.length > 0) {
              tag += render(elem.children, opts);
          }
          if (opts.xmlMode || !singleTag.has(elem.name)) {
              tag += `</${elem.name}>`;
          }
      }
      return tag;
  }
  function renderDirective(elem) {
      return `<${elem.data}>`;
  }
  function renderText(elem, opts) {
      var _a;
      let data = elem.data || "";
      // If entities weren't decoded, no need to encode them back
      if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false &&
          !(!opts.xmlMode &&
              elem.parent &&
              unencodedElements.has(elem.parent.name))) {
          data =
              opts.xmlMode || opts.encodeEntities !== "utf8"
                  ? encodeXML(data)
                  : escapeText(data);
      }
      return data;
  }
  function renderCdata(elem) {
      return `<![CDATA[${elem.children[0].data}]]>`;
  }
  function renderComment(elem) {
      return `<!--${elem.data}-->`;
  }

  /**
   * @category Stringify
   * @deprecated Use the `dom-serializer` module directly.
   * @param node Node to get the outer HTML of.
   * @param options Options for serialization.
   * @returns `node`'s outer HTML.
   */
  function getOuterHTML(node, options) {
      return render(node, options);
  }
  /**
   * @category Stringify
   * @deprecated Use the `dom-serializer` module directly.
   * @param node Node to get the inner HTML of.
   * @param options Options for serialization.
   * @returns `node`'s inner HTML.
   */
  function getInnerHTML(node, options) {
      return hasChildren(node)
          ? node.children.map((node) => getOuterHTML(node, options)).join("")
          : "";
  }
  /**
   * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.
   *
   * @category Stringify
   * @deprecated Use `textContent` instead.
   * @param node Node to get the inner text of.
   * @returns `node`'s inner text.
   */
  function getText$1(node) {
      if (Array.isArray(node))
          return node.map(getText$1).join("");
      if (isTag$1(node))
          return node.name === "br" ? "\n" : getText$1(node.children);
      if (isCDATA(node))
          return getText$1(node.children);
      if (isText(node))
          return node.data;
      return "";
  }
  /**
   * Get a node's text content. Ignores comments.
   *
   * @category Stringify
   * @param node Node to get the text content of.
   * @returns `node`'s text content.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
   */
  function textContent(node) {
      if (Array.isArray(node))
          return node.map(textContent).join("");
      if (hasChildren(node) && !isComment(node)) {
          return textContent(node.children);
      }
      if (isText(node))
          return node.data;
      return "";
  }
  /**
   * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.
   *
   * @category Stringify
   * @param node Node to get the inner text of.
   * @returns `node`'s inner text.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
   */
  function innerText(node) {
      if (Array.isArray(node))
          return node.map(innerText).join("");
      if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
          return innerText(node.children);
      }
      if (isText(node))
          return node.data;
      return "";
  }

  /**
   * Get a node's children.
   *
   * @category Traversal
   * @param elem Node to get the children of.
   * @returns `elem`'s children, or an empty array.
   */
  function getChildren$1(elem) {
      return hasChildren(elem) ? elem.children : [];
  }
  /**
   * Get a node's parent.
   *
   * @category Traversal
   * @param elem Node to get the parent of.
   * @returns `elem`'s parent node, or `null` if `elem` is a root node.
   */
  function getParent$1(elem) {
      return elem.parent || null;
  }
  /**
   * Gets an elements siblings, including the element itself.
   *
   * Attempts to get the children through the element's parent first. If we don't
   * have a parent (the element is a root node), we walk the element's `prev` &
   * `next` to get all remaining nodes.
   *
   * @category Traversal
   * @param elem Element to get the siblings of.
   * @returns `elem`'s siblings, including `elem`.
   */
  function getSiblings$1(elem) {
      const parent = getParent$1(elem);
      if (parent != null)
          return getChildren$1(parent);
      const siblings = [elem];
      let { prev, next } = elem;
      while (prev != null) {
          siblings.unshift(prev);
          ({ prev } = prev);
      }
      while (next != null) {
          siblings.push(next);
          ({ next } = next);
      }
      return siblings;
  }
  /**
   * Gets an attribute from an element.
   *
   * @category Traversal
   * @param elem Element to check.
   * @param name Attribute name to retrieve.
   * @returns The element's attribute value, or `undefined`.
   */
  function getAttributeValue$1(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
  }
  /**
   * Checks whether an element has an attribute.
   *
   * @category Traversal
   * @param elem Element to check.
   * @param name Attribute name to look for.
   * @returns Returns whether `elem` has the attribute `name`.
   */
  function hasAttrib$1(elem, name) {
      return (elem.attribs != null &&
          Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
          elem.attribs[name] != null);
  }
  /**
   * Get the tag name of an element.
   *
   * @category Traversal
   * @param elem The element to get the name for.
   * @returns The tag name of `elem`.
   */
  function getName$1(elem) {
      return elem.name;
  }
  /**
   * Returns the next element sibling of a node.
   *
   * @category Traversal
   * @param elem The element to get the next sibling of.
   * @returns `elem`'s next sibling that is a tag, or `null` if there is no next
   * sibling.
   */
  function nextElementSibling$1(elem) {
      let { next } = elem;
      while (next !== null && !isTag$1(next))
          ({ next } = next);
      return next;
  }
  /**
   * Returns the previous element sibling of a node.
   *
   * @category Traversal
   * @param elem The element to get the previous sibling of.
   * @returns `elem`'s previous sibling that is a tag, or `null` if there is no
   * previous sibling.
   */
  function prevElementSibling(elem) {
      let { prev } = elem;
      while (prev !== null && !isTag$1(prev))
          ({ prev } = prev);
      return prev;
  }

  /**
   * Remove an element from the dom
   *
   * @category Manipulation
   * @param elem The element to be removed
   */
  function removeElement(elem) {
      if (elem.prev)
          elem.prev.next = elem.next;
      if (elem.next)
          elem.next.prev = elem.prev;
      if (elem.parent) {
          const childs = elem.parent.children;
          const childsIndex = childs.lastIndexOf(elem);
          if (childsIndex >= 0) {
              childs.splice(childsIndex, 1);
          }
      }
      elem.next = null;
      elem.prev = null;
      elem.parent = null;
  }
  /**
   * Replace an element in the dom
   *
   * @category Manipulation
   * @param elem The element to be replaced
   * @param replacement The element to be added
   */
  function replaceElement(elem, replacement) {
      const prev = (replacement.prev = elem.prev);
      if (prev) {
          prev.next = replacement;
      }
      const next = (replacement.next = elem.next);
      if (next) {
          next.prev = replacement;
      }
      const parent = (replacement.parent = elem.parent);
      if (parent) {
          const childs = parent.children;
          childs[childs.lastIndexOf(elem)] = replacement;
          elem.parent = null;
      }
  }
  /**
   * Append a child to an element.
   *
   * @category Manipulation
   * @param parent The element to append to.
   * @param child The element to be added as a child.
   */
  function appendChild(parent, child) {
      removeElement(child);
      child.next = null;
      child.parent = parent;
      if (parent.children.push(child) > 1) {
          const sibling = parent.children[parent.children.length - 2];
          sibling.next = child;
          child.prev = sibling;
      }
      else {
          child.prev = null;
      }
  }
  /**
   * Append an element after another.
   *
   * @category Manipulation
   * @param elem The element to append after.
   * @param next The element be added.
   */
  function append$1(elem, next) {
      removeElement(next);
      const { parent } = elem;
      const currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
          currNext.prev = next;
          if (parent) {
              const childs = parent.children;
              childs.splice(childs.lastIndexOf(currNext), 0, next);
          }
      }
      else if (parent) {
          parent.children.push(next);
      }
  }
  /**
   * Prepend a child to an element.
   *
   * @category Manipulation
   * @param parent The element to prepend before.
   * @param child The element to be added as a child.
   */
  function prependChild(parent, child) {
      removeElement(child);
      child.parent = parent;
      child.prev = null;
      if (parent.children.unshift(child) !== 1) {
          const sibling = parent.children[1];
          sibling.prev = child;
          child.next = sibling;
      }
      else {
          child.next = null;
      }
  }
  /**
   * Prepend an element before another.
   *
   * @category Manipulation
   * @param elem The element to prepend before.
   * @param prev The element be added.
   */
  function prepend(elem, prev) {
      removeElement(prev);
      const { parent } = elem;
      if (parent) {
          const childs = parent.children;
          childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
          elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
  }

  /**
   * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param node Node to search. Will be included in the result set if it matches.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes passing `test`.
   */
  function filter(test, node, recurse = true, limit = Infinity) {
      return find(test, Array.isArray(node) ? node : [node], recurse, limit);
  }
  /**
   * Search an array of nodes and their children for nodes passing a test function.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param nodes Array of nodes to search.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes passing `test`.
   */
  function find(test, nodes, recurse, limit) {
      const result = [];
      /** Stack of the arrays we are looking at. */
      const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
      /** Stack of the indices within the arrays. */
      const indexStack = [0];
      for (;;) {
          // First, check if the current array has any more elements to look at.
          if (indexStack[0] >= nodeStack[0].length) {
              // If we have no more arrays to look at, we are done.
              if (indexStack.length === 1) {
                  return result;
              }
              // Otherwise, remove the current array from the stack.
              nodeStack.shift();
              indexStack.shift();
              // Loop back to the start to continue with the next array.
              continue;
          }
          const elem = nodeStack[0][indexStack[0]++];
          if (test(elem)) {
              result.push(elem);
              if (--limit <= 0)
                  return result;
          }
          if (recurse && hasChildren(elem) && elem.children.length > 0) {
              /*
               * Add the children to the stack. We are depth-first, so this is
               * the next array we look at.
               */
              indexStack.unshift(0);
              nodeStack.unshift(elem.children);
          }
      }
  }
  /**
   * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param nodes Array of nodes to search.
   * @returns The first node in the array that passes `test`.
   * @deprecated Use `Array.prototype.find` directly.
   */
  function findOneChild(test, nodes) {
      return nodes.find(test);
  }
  /**
   * Finds one element in a tree that passes a test.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param nodes Node or array of nodes to search.
   * @param recurse Also consider child nodes.
   * @returns The first node that passes `test`.
   */
  function findOne$1(test, nodes, recurse = true) {
      const searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
      for (let i = 0; i < searchedNodes.length; i++) {
          const node = searchedNodes[i];
          if (isTag$1(node) && test(node)) {
              return node;
          }
          if (recurse && hasChildren(node) && node.children.length > 0) {
              const found = findOne$1(test, node.children, true);
              if (found)
                  return found;
          }
      }
      return null;
  }
  /**
   * Checks if a tree of nodes contains at least one node passing a test.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param nodes Array of nodes to search.
   * @returns Whether a tree of nodes contains at least one node passing the test.
   */
  function existsOne$1(test, nodes) {
      return (Array.isArray(nodes) ? nodes : [nodes]).some((node) => (isTag$1(node) && test(node)) ||
          (hasChildren(node) && existsOne$1(test, node.children)));
  }
  /**
   * Search an array of nodes and their children for elements passing a test function.
   *
   * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
   *
   * @category Querying
   * @param test Function to test nodes on.
   * @param nodes Array of nodes to search.
   * @returns All nodes passing `test`.
   */
  function findAll$1(test, nodes) {
      const result = [];
      const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
      const indexStack = [0];
      for (;;) {
          if (indexStack[0] >= nodeStack[0].length) {
              if (nodeStack.length === 1) {
                  return result;
              }
              // Otherwise, remove the current array from the stack.
              nodeStack.shift();
              indexStack.shift();
              // Loop back to the start to continue with the next array.
              continue;
          }
          const elem = nodeStack[0][indexStack[0]++];
          if (isTag$1(elem) && test(elem))
              result.push(elem);
          if (hasChildren(elem) && elem.children.length > 0) {
              indexStack.unshift(0);
              nodeStack.unshift(elem.children);
          }
      }
  }

  /**
   * A map of functions to check nodes against.
   */
  const Checks = {
      tag_name(name) {
          if (typeof name === "function") {
              return (elem) => isTag$1(elem) && name(elem.name);
          }
          else if (name === "*") {
              return isTag$1;
          }
          return (elem) => isTag$1(elem) && elem.name === name;
      },
      tag_type(type) {
          if (typeof type === "function") {
              return (elem) => type(elem.type);
          }
          return (elem) => elem.type === type;
      },
      tag_contains(data) {
          if (typeof data === "function") {
              return (elem) => isText(elem) && data(elem.data);
          }
          return (elem) => isText(elem) && elem.data === data;
      },
  };
  /**
   * Returns a function to check whether a node has an attribute with a particular
   * value.
   *
   * @param attrib Attribute to check.
   * @param value Attribute value to look for.
   * @returns A function to check whether the a node has an attribute with a
   *   particular value.
   */
  function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
          return (elem) => isTag$1(elem) && value(elem.attribs[attrib]);
      }
      return (elem) => isTag$1(elem) && elem.attribs[attrib] === value;
  }
  /**
   * Returns a function that returns `true` if either of the input functions
   * returns `true` for a node.
   *
   * @param a First function to combine.
   * @param b Second function to combine.
   * @returns A function taking a node and returning `true` if either of the input
   *   functions returns `true` for the node.
   */
  function combineFuncs(a, b) {
      return (elem) => a(elem) || b(elem);
  }
  /**
   * Returns a function that executes all checks in `options` and returns `true`
   * if any of them match a node.
   *
   * @param options An object describing nodes to look for.
   * @returns A function that executes all checks in `options` and returns `true`
   *   if any of them match a node.
   */
  function compileTest(options) {
      const funcs = Object.keys(options).map((key) => {
          const value = options[key];
          return Object.prototype.hasOwnProperty.call(Checks, key)
              ? Checks[key](value)
              : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
  }
  /**
   * Checks whether a node matches the description in `options`.
   *
   * @category Legacy Query Functions
   * @param options An object describing nodes to look for.
   * @param node The element to test.
   * @returns Whether the element matches the description in `options`.
   */
  function testElement(options, node) {
      const test = compileTest(options);
      return test ? test(node) : true;
  }
  /**
   * Returns all nodes that match `options`.
   *
   * @category Legacy Query Functions
   * @param options An object describing nodes to look for.
   * @param nodes Nodes to search through.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes that match `options`.
   */
  function getElements(options, nodes, recurse, limit = Infinity) {
      const test = compileTest(options);
      return test ? filter(test, nodes, recurse, limit) : [];
  }
  /**
   * Returns the node with the supplied ID.
   *
   * @category Legacy Query Functions
   * @param id The unique ID attribute value to look for.
   * @param nodes Nodes to search through.
   * @param recurse Also consider child nodes.
   * @returns The node with the supplied ID.
   */
  function getElementById(id, nodes, recurse = true) {
      if (!Array.isArray(nodes))
          nodes = [nodes];
      return findOne$1(getAttribCheck("id", id), nodes, recurse);
  }
  /**
   * Returns all nodes with the supplied `tagName`.
   *
   * @category Legacy Query Functions
   * @param tagName Tag name to search for.
   * @param nodes Nodes to search through.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes with the supplied `tagName`.
   */
  function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
      return filter(Checks["tag_name"](tagName), nodes, recurse, limit);
  }
  /**
   * Returns all nodes with the supplied `className`.
   *
   * @category Legacy Query Functions
   * @param className Class name to search for.
   * @param nodes Nodes to search through.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes with the supplied `className`.
   */
  function getElementsByClassName(className, nodes, recurse = true, limit = Infinity) {
      return filter(getAttribCheck("class", className), nodes, recurse, limit);
  }
  /**
   * Returns all nodes with the supplied `type`.
   *
   * @category Legacy Query Functions
   * @param type Element type to look for.
   * @param nodes Nodes to search through.
   * @param recurse Also consider child nodes.
   * @param limit Maximum number of nodes to return.
   * @returns All nodes with the supplied `type`.
   */
  function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
      return filter(Checks["tag_type"](type), nodes, recurse, limit);
  }

  /**
   * Given an array of nodes, remove any member that is contained by another
   * member.
   *
   * @category Helpers
   * @param nodes Nodes to filter.
   * @returns Remaining nodes that aren't contained by other nodes.
   */
  function removeSubsets$1(nodes) {
      let idx = nodes.length;
      /*
       * Check if each node (or one of its ancestors) is already contained in the
       * array.
       */
      while (--idx >= 0) {
          const node = nodes[idx];
          /*
           * Remove the node if it is not unique.
           * We are going through the array from the end, so we only
           * have to check nodes that preceed the node under consideration in the array.
           */
          if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
              nodes.splice(idx, 1);
              continue;
          }
          for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
              if (nodes.includes(ancestor)) {
                  nodes.splice(idx, 1);
                  break;
              }
          }
      }
      return nodes;
  }
  /**
   * @category Helpers
   * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
   */
  var DocumentPosition;
  (function (DocumentPosition) {
      DocumentPosition[DocumentPosition["DISCONNECTED"] = 1] = "DISCONNECTED";
      DocumentPosition[DocumentPosition["PRECEDING"] = 2] = "PRECEDING";
      DocumentPosition[DocumentPosition["FOLLOWING"] = 4] = "FOLLOWING";
      DocumentPosition[DocumentPosition["CONTAINS"] = 8] = "CONTAINS";
      DocumentPosition[DocumentPosition["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition || (DocumentPosition = {}));
  /**
   * Compare the position of one node against another node in any other document,
   * returning a bitmask with the values from {@link DocumentPosition}.
   *
   * Document order:
   * > There is an ordering, document order, defined on all the nodes in the
   * > document corresponding to the order in which the first character of the
   * > XML representation of each node occurs in the XML representation of the
   * > document after expansion of general entities. Thus, the document element
   * > node will be the first node. Element nodes occur before their children.
   * > Thus, document order orders element nodes in order of the occurrence of
   * > their start-tag in the XML (after expansion of entities). The attribute
   * > nodes of an element occur after the element and before its children. The
   * > relative order of attribute nodes is implementation-dependent.
   *
   * Source:
   * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
   *
   * @category Helpers
   * @param nodeA The first node to use in the comparison
   * @param nodeB The second node to use in the comparison
   * @returns A bitmask describing the input nodes' relative position.
   *
   * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
   * a description of these values.
   */
  function compareDocumentPosition(nodeA, nodeB) {
      const aParents = [];
      const bParents = [];
      if (nodeA === nodeB) {
          return 0;
      }
      let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
      while (current) {
          aParents.unshift(current);
          current = current.parent;
      }
      current = hasChildren(nodeB) ? nodeB : nodeB.parent;
      while (current) {
          bParents.unshift(current);
          current = current.parent;
      }
      const maxIdx = Math.min(aParents.length, bParents.length);
      let idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
          idx++;
      }
      if (idx === 0) {
          return DocumentPosition.DISCONNECTED;
      }
      const sharedParent = aParents[idx - 1];
      const siblings = sharedParent.children;
      const aSibling = aParents[idx];
      const bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
          if (sharedParent === nodeB) {
              return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
          }
          return DocumentPosition.FOLLOWING;
      }
      if (sharedParent === nodeA) {
          return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
      }
      return DocumentPosition.PRECEDING;
  }
  /**
   * Sort an array of nodes based on their relative position in the document,
   * removing any duplicate nodes. If the array contains nodes that do not belong
   * to the same document, sort order is unspecified.
   *
   * @category Helpers
   * @param nodes Array of DOM nodes.
   * @returns Collection of unique nodes, sorted in document order.
   */
  function uniqueSort(nodes) {
      nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
      nodes.sort((a, b) => {
          const relative = compareDocumentPosition(a, b);
          if (relative & DocumentPosition.PRECEDING) {
              return -1;
          }
          else if (relative & DocumentPosition.FOLLOWING) {
              return 1;
          }
          return 0;
      });
      return nodes;
  }

  /**
   * Get the feed object from the root of a DOM tree.
   *
   * @category Feeds
   * @param doc - The DOM to to extract the feed from.
   * @returns The feed.
   */
  function getFeed(doc) {
      const feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot
          ? null
          : feedRoot.name === "feed"
              ? getAtomFeed(feedRoot)
              : getRssFeed(feedRoot);
  }
  /**
   * Parse an Atom feed.
   *
   * @param feedRoot The root of the feed.
   * @returns The parsed feed.
   */
  function getAtomFeed(feedRoot) {
      var _a;
      const childs = feedRoot.children;
      const feed = {
          type: "atom",
          items: getElementsByTagName("entry", childs).map((item) => {
              var _a;
              const { children } = item;
              const entry = { media: getMediaElements(children) };
              addConditionally(entry, "id", "id", children);
              addConditionally(entry, "title", "title", children);
              const href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
              if (href) {
                  entry.link = href;
              }
              const description = fetch$1("summary", children) || fetch$1("content", children);
              if (description) {
                  entry.description = description;
              }
              const pubDate = fetch$1("updated", children);
              if (pubDate) {
                  entry.pubDate = new Date(pubDate);
              }
              return entry;
          }),
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      const href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
      if (href) {
          feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      const updated = fetch$1("updated", childs);
      if (updated) {
          feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
  }
  /**
   * Parse a RSS feed.
   *
   * @param feedRoot The root of the feed.
   * @returns The parsed feed.
   */
  function getRssFeed(feedRoot) {
      var _a, _b;
      const childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      const feed = {
          type: feedRoot.name.substr(0, 3),
          id: "",
          items: getElementsByTagName("item", feedRoot.children).map((item) => {
              const { children } = item;
              const entry = { media: getMediaElements(children) };
              addConditionally(entry, "id", "guid", children);
              addConditionally(entry, "title", "title", children);
              addConditionally(entry, "link", "link", children);
              addConditionally(entry, "description", "description", children);
              const pubDate = fetch$1("pubDate", children) || fetch$1("dc:date", children);
              if (pubDate)
                  entry.pubDate = new Date(pubDate);
              return entry;
          }),
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      const updated = fetch$1("lastBuildDate", childs);
      if (updated) {
          feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
  }
  const MEDIA_KEYS_STRING = ["url", "type", "lang"];
  const MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width",
  ];
  /**
   * Get all media elements of a feed item.
   *
   * @param where Nodes to search in.
   * @returns Media elements.
   */
  function getMediaElements(where) {
      return getElementsByTagName("media:content", where).map((elem) => {
          const { attribs } = elem;
          const media = {
              medium: attribs["medium"],
              isDefault: !!attribs["isDefault"],
          };
          for (const attrib of MEDIA_KEYS_STRING) {
              if (attribs[attrib]) {
                  media[attrib] = attribs[attrib];
              }
          }
          for (const attrib of MEDIA_KEYS_INT) {
              if (attribs[attrib]) {
                  media[attrib] = parseInt(attribs[attrib], 10);
              }
          }
          if (attribs["expression"]) {
              media.expression = attribs["expression"];
          }
          return media;
      });
  }
  /**
   * Get one element by tag name.
   *
   * @param tagName Tag name to look for
   * @param node Node to search in
   * @returns The element or null
   */
  function getOneElement(tagName, node) {
      return getElementsByTagName(tagName, node, true, 1)[0];
  }
  /**
   * Get the text content of an element with a certain tag name.
   *
   * @param tagName Tag name to look for.
   * @param where Node to search in.
   * @param recurse Whether to recurse into child nodes.
   * @returns The text content of the element.
   */
  function fetch$1(tagName, where, recurse = false) {
      return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
  }
  /**
   * Adds a property to an object if it has a value.
   *
   * @param obj Object to be extended
   * @param prop Property name
   * @param tagName Tag name that contains the conditionally added property
   * @param where Element to search for the property
   * @param recurse Whether to recurse into child nodes.
   */
  function addConditionally(obj, prop, tagName, where, recurse = false) {
      const val = fetch$1(tagName, where, recurse);
      if (val)
          obj[prop] = val;
  }
  /**
   * Checks if an element is a feed root node.
   *
   * @param value The name of the element to check.
   * @returns Whether an element is a feed root node.
   */
  function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
  }

  var DomUtils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get DocumentPosition () { return DocumentPosition; },
    append: append$1,
    appendChild: appendChild,
    compareDocumentPosition: compareDocumentPosition,
    existsOne: existsOne$1,
    filter: filter,
    find: find,
    findAll: findAll$1,
    findOne: findOne$1,
    findOneChild: findOneChild,
    getAttributeValue: getAttributeValue$1,
    getChildren: getChildren$1,
    getElementById: getElementById,
    getElements: getElements,
    getElementsByClassName: getElementsByClassName,
    getElementsByTagName: getElementsByTagName,
    getElementsByTagType: getElementsByTagType,
    getFeed: getFeed,
    getInnerHTML: getInnerHTML,
    getName: getName$1,
    getOuterHTML: getOuterHTML,
    getParent: getParent$1,
    getSiblings: getSiblings$1,
    getText: getText$1,
    hasAttrib: hasAttrib$1,
    hasChildren: hasChildren,
    innerText: innerText,
    isCDATA: isCDATA,
    isComment: isComment,
    isDocument: isDocument,
    isTag: isTag$1,
    isText: isText,
    nextElementSibling: nextElementSibling$1,
    prepend: prepend,
    prependChild: prependChild,
    prevElementSibling: prevElementSibling,
    removeElement: removeElement,
    removeSubsets: removeSubsets$1,
    replaceElement: replaceElement,
    testElement: testElement,
    textContent: textContent,
    uniqueSort: uniqueSort
  });

  // Helper methods
  /**
   * Parses the data, returns the resulting document.
   *
   * @param data The data that should be parsed.
   * @param options Optional options for the parser and DOM handler.
   */
  function parseDocument(data, options) {
      const handler = new DomHandler(undefined, options);
      new Parser$2(handler, options).end(data);
      return handler.root;
  }
  /**
   * Parses data, returns an array of the root nodes.
   *
   * Note that the root nodes still have a `Document` node as their parent.
   * Use `parseDocument` to get the `Document` node instead.
   *
   * @param data The data that should be parsed.
   * @param options Optional options for the parser and DOM handler.
   * @deprecated Use `parseDocument` instead.
   */
  function parseDOM(data, options) {
      return parseDocument(data, options).children;
  }
  /**
   * Creates a parser instance, with an attached DOM handler.
   *
   * @param callback A callback that will be called once parsing has been completed, with the resulting document.
   * @param options Optional options for the parser and DOM handler.
   * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
   */
  function createDocumentStream(callback, options, elementCallback) {
      const handler = new DomHandler((error) => callback(error, handler.root), options, elementCallback);
      return new Parser$2(handler, options);
  }
  /**
   * Creates a parser instance, with an attached DOM handler.
   *
   * @param callback A callback that will be called once parsing has been completed, with an array of root nodes.
   * @param options Optional options for the parser and DOM handler.
   * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
   * @deprecated Use `createDocumentStream` instead.
   */
  function createDomStream(callback, options, elementCallback) {
      const handler = new DomHandler(callback, options, elementCallback);
      return new Parser$2(handler, options);
  }
  const parseFeedDefaultOptions = { xmlMode: true };
  /**
   * Parse a feed.
   *
   * @param feed The feed that should be parsed, as a string.
   * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.
   */
  function parseFeed(feed, options = parseFeedDefaultOptions) {
      return getFeed(parseDOM(feed, options));
  }

  var HTMLParser2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DefaultHandler: DomHandler,
    DomHandler: DomHandler,
    DomUtils: DomUtils,
    ElementType: index,
    Parser: Parser$2,
    get QuoteType () { return QuoteType; },
    Tokenizer: Tokenizer,
    createDocumentStream: createDocumentStream,
    createDomStream: createDomStream,
    getFeed: getFeed,
    parseDOM: parseDOM,
    parseDocument: parseDocument,
    parseFeed: parseFeed
  });

  // Internal
  const NODE_END = -1;

  // Node
  const ELEMENT_NODE = 1;
  const ATTRIBUTE_NODE = 2;
  const TEXT_NODE = 3;
  const CDATA_SECTION_NODE = 4;
  const COMMENT_NODE = 8;
  const DOCUMENT_NODE = 9;
  const DOCUMENT_TYPE_NODE = 10;
  const DOCUMENT_FRAGMENT_NODE = 11;

  // Elements
  const BLOCK_ELEMENTS = new Set(['ARTICLE', 'ASIDE', 'BLOCKQUOTE', 'BODY', 'BR', 'BUTTON', 'CANVAS', 'CAPTION', 'COL', 'COLGROUP', 'DD', 'DIV', 'DL', 'DT', 'EMBED', 'FIELDSET', 'FIGCAPTION', 'FIGURE', 'FOOTER', 'FORM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'LI', 'UL', 'OL', 'P']);

  // TreeWalker
  const SHOW_ALL = -1;
  const SHOW_ELEMENT = 1;
  const SHOW_TEXT = 4;
  const SHOW_CDATA_SECTION = 8;
  const SHOW_COMMENT = 128;

  // Document position
  const DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const DOCUMENT_POSITION_PRECEDING = 0x02;
  const DOCUMENT_POSITION_FOLLOWING = 0x04;
  const DOCUMENT_POSITION_CONTAINS = 0x08;
  const DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

  // SVG
  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

  const {
    assign,
    create: create$1,
    defineProperties,
    entries,
    getOwnPropertyDescriptors,
    keys,
    setPrototypeOf
  } = Object;

  const $String = String;

  const getEnd = node => node.nodeType === ELEMENT_NODE ? node[END] : node;

  const ignoreCase = ({ownerDocument}) => ownerDocument[MIME].ignoreCase;

  const knownAdjacent = (prev, next) => {
    prev[NEXT] = next;
    next[PREV] = prev;
  };

  const knownBoundaries = (prev, current, next) => {
    knownAdjacent(prev, current);
    knownAdjacent(getEnd(current), next);
  };

  const knownSegment = (prev, start, end, next) => {
    knownAdjacent(prev, start);
    knownAdjacent(getEnd(end), next);
  };

  const knownSiblings = (prev, current, next) => {
    knownAdjacent(prev, current);
    knownAdjacent(current, next);
  };

  const localCase = ({localName, ownerDocument}) => {
    return ownerDocument[MIME].ignoreCase ? localName.toUpperCase() : localName;
  };

  const setAdjacent = (prev, next) => {
    if (prev)
      prev[NEXT] = next;
    if (next)
      next[PREV] = prev;
  };

  /**
   * @param {import("../interface/document.js").Document} ownerDocument
   * @param {string} html
   * @return {import("../interface/document-fragment.js").DocumentFragment}
   */
  const htmlToFragment = (ownerDocument, html) => {
    const fragment = ownerDocument.createDocumentFragment();

    const elem = ownerDocument.createElement('');
    elem.innerHTML = html;
    const { firstChild, lastChild } = elem;

    if (firstChild) {
      knownSegment(fragment, firstChild, lastChild, fragment[END]);

      let child = firstChild;
      do {
        child.parentNode = fragment;
      } while (child !== lastChild && (child = getEnd(child)[NEXT]));
    }

    return fragment;
  };

  const shadowRoots = new WeakMap;

  let reactive = false;

  const Classes = new WeakMap;

  const customElements = new WeakMap;

  const attributeChangedCallback$1 = (element, attributeName, oldValue, newValue) => {
    if (
      reactive &&
      customElements.has(element) &&
      element.attributeChangedCallback &&
      element.constructor.observedAttributes.includes(attributeName)
    ) {
      element.attributeChangedCallback(attributeName, oldValue, newValue);
    }
  };

  const createTrigger = (method, isConnected) => element => {
    if (customElements.has(element)) {
      const info = customElements.get(element);
      if (info.connected !== isConnected && element.isConnected === isConnected) {
        info.connected = isConnected;
        if (method in element)
          element[method]();
      }
    }
  };

  const triggerConnected = createTrigger('connectedCallback', true);
  const connectedCallback = element => {
    if (reactive) {
      triggerConnected(element);
      if (shadowRoots.has(element))
        element = shadowRoots.get(element).shadowRoot;
      let {[NEXT]: next, [END]: end} = element;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE)
          triggerConnected(next);
        next = next[NEXT];
      }
    }
  };

  const triggerDisconnected = createTrigger('disconnectedCallback', false);
  const disconnectedCallback = element => {
    if (reactive) {
      triggerDisconnected(element);
      if (shadowRoots.has(element))
        element = shadowRoots.get(element).shadowRoot;
      let {[NEXT]: next, [END]: end} = element;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE)
          triggerDisconnected(next);
        next = next[NEXT];
      }
    }
  };

  /**
   * @implements globalThis.CustomElementRegistry
   */
  class CustomElementRegistry {

    /**
     * @param {Document} ownerDocument
     */
    constructor(ownerDocument) {
      /**
       * @private
       */
      this.ownerDocument = ownerDocument;

      /**
       * @private
       */
      this.registry = new Map;

      /**
       * @private
       */
      this.waiting = new Map;

      /**
       * @private
       */
      this.active = false;
    }

    /**
     * @param {string} localName the custom element definition name
     * @param {Function} Class the custom element **Class** definition
     * @param {object?} options the optional object with an `extends` property
     */
    define(localName, Class, options = {}) {
      const {ownerDocument, registry, waiting} = this;

      if (registry.has(localName))
        throw new Error('unable to redefine ' + localName);

      if (Classes.has(Class))
        throw new Error('unable to redefine the same class: ' + Class);

      this.active = (reactive = true);

      const {extends: extend} = options;

      Classes.set(Class, {
        ownerDocument,
        options: {is: extend ? localName : ''},
        localName: extend || localName
      });

      const check = extend ?
        element => {
          return element.localName === extend &&
                 element.getAttribute('is') === localName;
        } :
        element => element.localName === localName;
      registry.set(localName, {Class, check});
      if (waiting.has(localName)) {
        for (const resolve of waiting.get(localName))
          resolve(Class);
        waiting.delete(localName);
      }
      ownerDocument.querySelectorAll(
        extend ? `${extend}[is="${localName}"]` : localName
      ).forEach(this.upgrade, this);
    }

    /**
     * @param {Element} element
     */
    upgrade(element) {
      if (customElements.has(element))
        return;
      const {ownerDocument, registry} = this;
      const ce = element.getAttribute('is') || element.localName;
      if (registry.has(ce)) {
        const {Class, check} = registry.get(ce);
        if (check(element)) {
          const {attributes, isConnected} = element;
          for (const attr of attributes)
            element.removeAttributeNode(attr);

          const values = entries(element);
          for (const [key] of values)
            delete element[key];

          setPrototypeOf(element, Class.prototype);
          ownerDocument[UPGRADE] = {element, values};
          new Class(ownerDocument, ce);

          customElements.set(element, {connected: isConnected});

          for (const attr of attributes)
            element.setAttributeNode(attr);

          if (isConnected && element.connectedCallback)
            element.connectedCallback();
        }
      }
    }

    /**
     * @param {string} localName the custom element definition name
     */
    whenDefined(localName) {
      const {registry, waiting} = this;
      return new Promise(resolve => {
        if (registry.has(localName))
          resolve(registry.get(localName).Class);
        else {
          if (!waiting.has(localName))
            waiting.set(localName, []);
          waiting.get(localName).push(resolve);
        }
      });
    }

    /**
     * @param {string} localName the custom element definition name
     * @returns {Function?} the custom element **Class**, if any
     */
    get(localName) {
      const info = this.registry.get(localName);
      return info && info.Class;
    }

    /**
     * @param {Function} Class **Class** of custom element
     * @returns {string?} found tag name or null
     */
    getName(Class) {
      if (Classes.has(Class)) {
        const { localName } = Classes.get(Class);
        return localName;
      }
      return null;
    }
  }

  const {Parser: Parser$1} = HTMLParser2;

  const append = (self, node, active) => {
    const end = self[END];
    node.parentNode = self;
    knownBoundaries(end[PREV], node, end);
    if (active && node.nodeType === ELEMENT_NODE)
      connectedCallback(node);
    return node;
  };

  const attribute = (element, end, attribute, value, active) => {
    attribute[VALUE] = value;
    attribute.ownerElement = element;
    knownSiblings(end[PREV], attribute, end);
    if (attribute.name === 'class')
      element.className = value;
    if (active)
      attributeChangedCallback$1(element, attribute.name, null, value);
  };

  const parseFromString$1 = (document, isHTML, markupLanguage) => {
    const {active, registry} = document[CUSTOM_ELEMENTS];

    let node = document;
    let ownerSVGElement = null;
    let parsingCData = false;

    const content = new Parser$1({
      // <!DOCTYPE ...>
      onprocessinginstruction(name, data) {
        if (name.toLowerCase() === '!doctype')
          document.doctype = data.slice(name.length).trim();
      },

      // <tagName>
      onopentag(name, attributes) {
        let create = true;
        if (isHTML) {
          if (ownerSVGElement) {
            node = append(node, document.createElementNS(SVG_NAMESPACE, name), active);
            node.ownerSVGElement = ownerSVGElement;
            create = false;
          }
          else if (name === 'svg' || name === 'SVG') {
            ownerSVGElement = document.createElementNS(SVG_NAMESPACE, name);
            node = append(node, ownerSVGElement, active);
            create = false;
          }
          else if (active) {
            const ce = name.includes('-') ? name : (attributes.is || '');
            if (ce && registry.has(ce)) {
              const {Class} = registry.get(ce);
              node = append(node, new Class, active);
              delete attributes.is;
              create = false;
            }
          }
        }

        if (create)
          node = append(node, document.createElement(name), false);

        let end = node[END];
        for (const name of keys(attributes))
          attribute(node, end, document.createAttribute(name), attributes[name], active);
      },

      // #text, #comment
      oncomment(data) { append(node, document.createComment(data), active); },
      ontext(text) {
        if (parsingCData) {
          append(node, document.createCDATASection(text), active);
        } else {
          append(node, document.createTextNode(text), active);
        }
      },

      // #cdata
      oncdatastart() { parsingCData = true; },
      oncdataend() { parsingCData = false; },

      // </tagName>
      onclosetag() {
        if (isHTML && node === ownerSVGElement)
          ownerSVGElement = null;
        node = node.parentNode;
      }
    }, {
      lowerCaseAttributeNames: false,
      decodeEntities: true,
      xmlMode: !isHTML
    });

    content.write(markupLanguage);
    content.end();

    return document;
  };

  const htmlClasses = new Map;

  const registerHTMLClass = (names, Class) => {
    for (const name of [].concat(names)) {
      htmlClasses.set(name, Class);
      htmlClasses.set(name.toUpperCase(), Class);
    }
  };

  const loopSegment = ({[NEXT]: next, [END]: end}, json) => {
    while (next !== end) {
      switch (next.nodeType) {
        case ATTRIBUTE_NODE:
          attrAsJSON(next, json);
          break;
        case TEXT_NODE:
        case COMMENT_NODE:
        case CDATA_SECTION_NODE:
          characterDataAsJSON(next, json);
          break;
        case ELEMENT_NODE:
          elementAsJSON(next, json);
          next = getEnd(next);
          break;
        case DOCUMENT_TYPE_NODE:
          documentTypeAsJSON(next, json);
          break;
      }
      next = next[NEXT];
    }
    const last = json.length - 1;
    const value = json[last];
    if (typeof value === 'number' && value < 0)
      json[last] += NODE_END;
    else
      json.push(NODE_END);
  };

  const attrAsJSON = (attr, json) => {
    json.push(ATTRIBUTE_NODE, attr.name);
    const value = attr[VALUE].trim();
    if (value)
      json.push(value);
  };

  const characterDataAsJSON = (node, json) => {
    const value = node[VALUE];
    if (value.trim())
      json.push(node.nodeType, value);
  };

  const nonElementAsJSON = (node, json) => {
    json.push(node.nodeType);
    loopSegment(node, json);
  };

  const documentTypeAsJSON = ({name, publicId, systemId}, json) => {
    json.push(DOCUMENT_TYPE_NODE, name);
    if (publicId)
      json.push(publicId);
    if (systemId)
      json.push(systemId);
  };

  const elementAsJSON = (element, json) => {
    json.push(ELEMENT_NODE, element.localName);
    loopSegment(element, json);
  };

  const createRecord =
    (type, target, element, addedNodes, removedNodes, attributeName, oldValue) =>
   ({
    type,
    target,
    addedNodes,
    removedNodes,
    attributeName,
    oldValue,
    previousSibling: element?.previousSibling || null,
    nextSibling: element?.nextSibling || null,
  });

  const queueAttribute = (
    observer, target, attributeName, attributeFilter, attributeOldValue, oldValue
  ) => {
    if ((!attributeFilter || attributeFilter.includes(attributeName))) {
      const {callback, records, scheduled} = observer;
      records.push(createRecord(
        'attributes', target, null,
        [], [],
        attributeName, attributeOldValue ? oldValue : void 0
      ));
      if (!scheduled) {
        observer.scheduled = true;
        Promise.resolve().then(() => {
          observer.scheduled = false;
          callback(records.splice(0), observer);
        });
      }
    }
  };

  const attributeChangedCallback = (element, attributeName, oldValue) => {
    const {ownerDocument} = element;
    const {active, observers} = ownerDocument[MUTATION_OBSERVER];
    if (active) {
      for (const observer of observers) {
        for (const [
          target,
          {
            childList,
            subtree,
            attributes,
            attributeFilter,
            attributeOldValue
          }
        ] of observer.nodes) {
          if (childList) {
            if (
              (subtree && (target === ownerDocument || target.contains(element))) ||
              (!subtree && target.children.includes(element))
            ) {
              queueAttribute(
                observer, element,
                attributeName, attributeFilter, attributeOldValue, oldValue
              );
              break;
            }
          }
          else if (
            attributes &&
            target === element
          ) {
            queueAttribute(
              observer, element,
              attributeName, attributeFilter, attributeOldValue, oldValue
            );
            break;
          }
        }
      }
    }
  };

  const moCallback = (element, parentNode) => {
    const {ownerDocument} = element;
    const {active, observers} = ownerDocument[MUTATION_OBSERVER];
    if (active) {
      for (const observer of observers) {
        for (const [target, {subtree, childList, characterData}] of observer.nodes) {
          if (childList) {
            if (
              (parentNode && (target === parentNode || /* c8 ignore next */(subtree && target.contains(parentNode)))) ||
              (!parentNode && ((subtree && (target === ownerDocument || /* c8 ignore next */target.contains(element))) ||
                              (!subtree && target[characterData ? 'childNodes' : 'children'].includes(element))))
            ) {
              const {callback, records, scheduled} = observer;
              records.push(createRecord(
                'childList', target, element,
                parentNode ? [] : [element], parentNode ? [element] : []
              ));
              if (!scheduled) {
                observer.scheduled = true;
                Promise.resolve().then(() => {
                  observer.scheduled = false;
                  callback(records.splice(0), observer);
                });
              }
              break;
            }
          }
        }
      }
    }
  };

  class MutationObserverClass {
    constructor(ownerDocument) {
      const observers = new Set;
      this.observers = observers;
      this.active = false;

      /**
       * @implements globalThis.MutationObserver
       */
      this.class = class MutationObserver {

        constructor(callback) {
          /**
           * @private
           */
          this.callback = callback;

          /**
           * @private
           */
          this.nodes = new Map;

          /**
           * @private
           */
          this.records = [];

          /**
           * @private
           */
          this.scheduled = false;
        }

        disconnect() {
          this.records.splice(0);
          this.nodes.clear();
          observers.delete(this);
          ownerDocument[MUTATION_OBSERVER].active = !!observers.size;
        }

        /**
         * @param {Element} target
         * @param {MutationObserverInit} options
         */
        observe(target, options = {
          subtree: false,
          childList: false,
          attributes: false,
          attributeFilter: null,
          attributeOldValue: false,
          characterData: false,
          // TODO: not implemented yet
          // characterDataOldValue: false
        }) {
          if (('attributeOldValue' in options) || ('attributeFilter' in options))
            options.attributes = true;
          // if ('characterDataOldValue' in options)
          //   options.characterData = true;
          options.childList = !!options.childList;
          options.subtree = !!options.subtree;
          this.nodes.set(target, options);
          observers.add(this);
          ownerDocument[MUTATION_OBSERVER].active = true;
        }

        /**
         * @returns {MutationRecord[]}
         */
        takeRecords() { return this.records.splice(0); }
      };
    }
  }

  const emptyAttributes = new Set([
    'allowfullscreen',
    'allowpaymentrequest',
    'async',
    'autofocus',
    'autoplay',
    'checked',
    'class',
    'contenteditable',
    'controls',
    'default',
    'defer',
    'disabled',
    'draggable',
    'formnovalidate',
    'hidden',
    'id',
    'ismap',
    'itemscope',
    'loop',
    'multiple',
    'muted',
    'nomodule',
    'novalidate',
    'open',
    'playsinline',
    'readonly',
    'required',
    'reversed',
    'selected',
    'style',
    'truespeed'
  ]);

  const setAttribute = (element, attribute) => {
    const {[VALUE]: value, name} = attribute;
    attribute.ownerElement = element;
    knownSiblings(element, attribute, element[NEXT]);
    if (name === 'class')
      element.className = value;
    attributeChangedCallback(element, name, null);
    attributeChangedCallback$1(element, name, null, value);
  };

  const removeAttribute = (element, attribute) => {
    const {[VALUE]: value, name} = attribute;
    knownAdjacent(attribute[PREV], attribute[NEXT]);
    attribute.ownerElement = attribute[PREV] = attribute[NEXT] = null;
    if (name === 'class')
      element[CLASS_LIST] = null;
    attributeChangedCallback(element, name, value);
    attributeChangedCallback$1(element, name, value, null);
  };

  const booleanAttribute = {
    get(element, name) {
      return element.hasAttribute(name);
    },
    set(element, name, value) {
      if (value)
        element.setAttribute(name, '');
      else
        element.removeAttribute(name);
    }
  };

  const numericAttribute = {
    get(element, name) {
      return parseFloat(element.getAttribute(name) || 0);
    },
    set(element, name, value) {
      element.setAttribute(name, value);
    }
  };

  const stringAttribute = {
    get(element, name) {
      return element.getAttribute(name) || '';
    },
    set(element, name, value) {
      element.setAttribute(name, value);
    }
  };

  /* oddly enough, this apparently is not a thing
  export const nullableAttribute = {
    get(element, name) {
      return element.getAttribute(name);
    },
    set(element, name, value) {
      if (value === null)
        element.removeAttribute(name);
      else
        element.setAttribute(name, value);
    }
  };
  */

  // https://dom.spec.whatwg.org/#interface-eventtarget

  const wm = new WeakMap();

  function dispatch(event, listener) {
    if (typeof listener === 'function')
      listener.call(event.target, event);
    else
      listener.handleEvent(event);
    return event._stopImmediatePropagationFlag;
  }

  function invokeListeners({currentTarget, target}) {
    const map = wm.get(currentTarget);
    if (map && map.has(this.type)) {
      const listeners = map.get(this.type);
      if (currentTarget === target) {
        this.eventPhase = this.AT_TARGET;
      } else {
        this.eventPhase = this.BUBBLING_PHASE;
      }

      this.currentTarget = currentTarget;
      this.target = target;
      for (const [listener, options] of listeners) {
        if (options && options.once)
          listeners.delete(listener);
        if (dispatch(this, listener))
          break;
      }
      delete this.currentTarget;
      delete this.target;
      return this.cancelBubble;
    }
  }


  /**
   * @implements globalThis.EventTarget
   */
  class DOMEventTarget {

    constructor() {
      wm.set(this, new Map);
    }

    /**
     * @protected
     */
    _getParent() {
      return null;
    }

    addEventListener(type, listener, options) {
      const map = wm.get(this);
      if (!map.has(type)) 
        map.set(type, new Map);
      map.get(type).set(listener, options);
    }

    removeEventListener(type, listener) {
      const map = wm.get(this);
      if (map.has(type)) {
        const listeners = map.get(type);
        if (listeners.delete(listener) && !listeners.size)
          map.delete(type);
      }
    }

    dispatchEvent(event) {
      let node = this;
      event.eventPhase = event.CAPTURING_PHASE;

      // intentionally simplified, specs imply way more code: https://dom.spec.whatwg.org/#event-path
      while (node) {
        if (node.dispatchEvent)
          event._path.push({currentTarget: node, target: this});
        node = event.bubbles && node._getParent && node._getParent();
      }
      event._path.some(invokeListeners, event);
      event._path = [];
      event.eventPhase = event.NONE;
      return !event.defaultPrevented;
    }

  }

  // https://dom.spec.whatwg.org/#interface-nodelist

  /**
   * @implements globalThis.NodeList
   */
  class NodeList extends Array {
    item(i) { return i < this.length ? this[i] : null; }
  }

  // https://dom.spec.whatwg.org/#node


  const getParentNodeCount = ({parentNode}) => {
    let count = 0;
    while (parentNode) {
      count++;
      parentNode = parentNode.parentNode;
    }
    return count;
  };

  /**
   * @implements globalThis.Node
   */
  let Node$1 = class Node extends DOMEventTarget {

    static get ELEMENT_NODE() { return ELEMENT_NODE; }
    static get ATTRIBUTE_NODE() { return ATTRIBUTE_NODE; }
    static get TEXT_NODE() { return TEXT_NODE; }
    static get CDATA_SECTION_NODE() { return CDATA_SECTION_NODE; }
    static get COMMENT_NODE() { return COMMENT_NODE; }
    static get DOCUMENT_NODE() { return DOCUMENT_NODE; }
    static get DOCUMENT_FRAGMENT_NODE() { return DOCUMENT_FRAGMENT_NODE; }
    static get DOCUMENT_TYPE_NODE() { return DOCUMENT_TYPE_NODE; }

    constructor(ownerDocument, localName, nodeType) {
      super();
      this.ownerDocument = ownerDocument;
      this.localName = localName;
      this.nodeType = nodeType;
      this.parentNode = null;
      this[NEXT] = null;
      this[PREV] = null;
    }

    get ELEMENT_NODE() { return ELEMENT_NODE; }
    get ATTRIBUTE_NODE() { return ATTRIBUTE_NODE; }
    get TEXT_NODE() { return TEXT_NODE; }
    get CDATA_SECTION_NODE() { return CDATA_SECTION_NODE; }
    get COMMENT_NODE() { return COMMENT_NODE; }
    get DOCUMENT_NODE() { return DOCUMENT_NODE; }
    get DOCUMENT_FRAGMENT_NODE() { return DOCUMENT_FRAGMENT_NODE; }
    get DOCUMENT_TYPE_NODE() { return DOCUMENT_TYPE_NODE; }

    get baseURI() {
      const ownerDocument = this.nodeType === DOCUMENT_NODE ?
                              this : this.ownerDocument;
      if (ownerDocument) {
        const base = ownerDocument.querySelector('base');
        if (base)
          return base.getAttribute('href');

        const {location} = ownerDocument.defaultView;
        if (location)
          return location.href;
      }

      return null;
    }

    /* c8 ignore start */
    // mixin: node
    get isConnected() { return false; }
    get nodeName() { return this.localName; }
    get parentElement() { return null; }
    get previousSibling() { return null; }
    get previousElementSibling() { return null; }
    get nextSibling() { return null; }
    get nextElementSibling() { return null; }
    get childNodes() { return new NodeList; }
    get firstChild() { return null; }
    get lastChild() { return null; }

    // default values
    get nodeValue() { return null; }
    set nodeValue(value) {}
    get textContent() { return null; }
    set textContent(value) {}
    normalize() {}
    cloneNode() { return null; }
    contains() { return false; }
    /**
     * Inserts a node before a reference node as a child of this parent node.
     * @param {Node} newNode The node to be inserted.
     * @param {Node} referenceNode The node before which newNode is inserted. If this is null, then newNode is inserted at the end of node's child nodes.
     * @returns The added child
     */
    // eslint-disable-next-line no-unused-vars
    insertBefore(newNode, referenceNode) { return newNode }
    /**
     * Adds a node to the end of the list of children of this node.
     * @param {Node} child The node to append to the given parent node.
     * @returns The appended child.
     */
    appendChild(child) { return child }
    /**
     * Replaces a child node within this node
     * @param {Node} newChild The new node to replace oldChild.
     * @param {Node} oldChild The child to be replaced.
     * @returns The replaced Node. This is the same node as oldChild.
     */
    replaceChild(newChild, oldChild) { return oldChild }
    /**
     * Removes a child node from the DOM.
     * @param {Node} child A Node that is the child node to be removed from the DOM.
     * @returns The removed node.
     */
    removeChild(child) { return child }
    toString() { return ''; }
    /* c8 ignore stop */

    hasChildNodes() { return !!this.lastChild; }
    isSameNode(node) { return this === node; }

    // TODO: attributes?
    compareDocumentPosition(target) {
      let result = 0;
      if (this !== target) {
        let self = getParentNodeCount(this);
        let other = getParentNodeCount(target);
        if (self < other) {
          result += DOCUMENT_POSITION_FOLLOWING;
          if (this.contains(target))
            result += DOCUMENT_POSITION_CONTAINED_BY;
        }
        else if (other < self) {
          result += DOCUMENT_POSITION_PRECEDING;
          if (target.contains(this))
            result += DOCUMENT_POSITION_CONTAINS;
        }
        else if (self && other) {
          const {childNodes} = this.parentNode;
          if (childNodes.indexOf(this) < childNodes.indexOf(target))
            result += DOCUMENT_POSITION_FOLLOWING;
          else
            result += DOCUMENT_POSITION_PRECEDING;
        }
        if (!self || !other) {
          result += DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          result += DOCUMENT_POSITION_DISCONNECTED;
        }
      }
      return result;
    }

    isEqualNode(node) {
      if (this === node)
        return true;
      if (this.nodeType === node.nodeType) {
        switch (this.nodeType) {
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE: {
            const aNodes = this.childNodes;
            const bNodes = node.childNodes;
            return aNodes.length === bNodes.length && aNodes.every((node, i) => node.isEqualNode(bNodes[i]));
          }
        }
        return this.toString() === node.toString();
      }
      return false;
    }

    /**
     * @protected
     */
    _getParent() {
      return this.parentNode;
    }

    /**
     * Calling it on an element inside a standard web page will return an HTMLDocument object representing the entire page (or <iframe>).
     * Calling it on an element inside a shadow DOM will return the associated ShadowRoot.
     * @return {ShadowRoot | HTMLDocument}
     */
    getRootNode() {
      let root = this;
      while (root.parentNode)
        root = root.parentNode;
      return root;
    }
  };

  const {replace} = '';

  // escape
  const ca = /[<>&\xA0]/g;

  const esca = {
    '\xA0': '&#160;',
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
  };

  const pe = m => esca[m];

  /**
   * Safely escape HTML entities such as `&`, `<`, `>` only.
   * @param {string} es the input to safely escape
   * @returns {string} the escaped input, and it **throws** an error if
   *  the input type is unexpected, except for boolean and numbers,
   *  converted as string.
   */
  const escape = es => replace.call(es, ca, pe);

  const QUOTE = /"/g;

  /**
   * @implements globalThis.Attr
   */
  let Attr$1 = class Attr extends Node$1 {
    constructor(ownerDocument, name, value = '') {
      super(ownerDocument, name, ATTRIBUTE_NODE);
      this.ownerElement = null;
      this.name = $String(name);
      this[VALUE] = $String(value);
      this[CHANGED] = false;
    }

    get value() { return this[VALUE]; }
    set value(newValue) {
      const {[VALUE]: oldValue, name, ownerElement} = this;
      this[VALUE] = $String(newValue);
      this[CHANGED] = true;
      if (ownerElement) {
        attributeChangedCallback(ownerElement, name, oldValue);
        attributeChangedCallback$1(ownerElement, name, oldValue, this[VALUE]);
      }
    }

    cloneNode() {
      const {ownerDocument, name, [VALUE]: value} = this;
      return new Attr(ownerDocument, name, value);
    }

    toString() {
      const {name, [VALUE]: value} = this;
      if (emptyAttributes.has(name) && !value) {
        return ignoreCase(this) ? name : `${name}=""`;
      }
      const escapedValue = (ignoreCase(this) ? value : escape(value)).replace(QUOTE, '&quot;');
      return `${name}="${escapedValue}"`;
    }

    toJSON() {
      const json = [];
      attrAsJSON(this, json);
      return json;
    }
  };

  const isConnected = ({ownerDocument, parentNode}) => {
    while (parentNode) {
      if (parentNode === ownerDocument)
        return true;
      parentNode = parentNode.parentNode || parentNode.host;
    }
    return false;
  };

  const parentElement = ({parentNode}) => {
    if (parentNode) {
      switch (parentNode.nodeType) {
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          return null;
      }
    }
    return parentNode;
  };

  const previousSibling = ({[PREV]: prev}) => {
    switch (prev ? prev.nodeType : 0) {
      case NODE_END:
        return prev[START];
      case TEXT_NODE:
      case COMMENT_NODE:
      case CDATA_SECTION_NODE:
        return prev;
    }
    return null;
  };

  const nextSibling = node => {
    const next = getEnd(node)[NEXT];
    return next && (next.nodeType === NODE_END ? null : next);
  };

  // https://dom.spec.whatwg.org/#nondocumenttypechildnode
  // CharacterData, Element


  const nextElementSibling = node => {
    let next = nextSibling(node);
    while (next && next.nodeType !== ELEMENT_NODE)
      next = nextSibling(next);
    return next;
  };

  const previousElementSibling = node => {
    let prev = previousSibling(node);
    while (prev && prev.nodeType !== ELEMENT_NODE)
      prev = previousSibling(prev);
    return prev;
  };

  // https://dom.spec.whatwg.org/#childnode
  // CharacterData, DocumentType, Element


  const asFragment = (ownerDocument, nodes) => {
    const fragment = ownerDocument.createDocumentFragment();
    fragment.append(...nodes);
    return fragment;
  };

  const before = (node, nodes) => {
    const {ownerDocument, parentNode} = node;
    if (parentNode)
      parentNode.insertBefore(
        asFragment(ownerDocument, nodes),
        node
      );
  };

  const after = (node, nodes) => {
    const {ownerDocument, parentNode} = node;
    if (parentNode)
      parentNode.insertBefore(
        asFragment(ownerDocument, nodes),
        getEnd(node)[NEXT]
      );
  };

  const replaceWith = (node, nodes) => {
    const {ownerDocument, parentNode} = node;
    if (parentNode) {
      if (nodes.includes(node))
        replaceWith(node, [node = node.cloneNode()]);
      parentNode.insertBefore(
        asFragment(ownerDocument, nodes),
        node
      );
      node.remove();
    }
  };

  const remove = (prev, current, next) => {
    const {parentNode, nodeType} = current;
    if (prev || next) {
      setAdjacent(prev, next);
      current[PREV] = null;
      getEnd(current)[NEXT] = null;
    }
    if (parentNode) {
      current.parentNode = null;
      moCallback(current, parentNode);
      if (nodeType === ELEMENT_NODE)
        disconnectedCallback(current);
    }
  };

  // https://dom.spec.whatwg.org/#interface-characterdata


  /**
   * @implements globalThis.CharacterData
   */
  let CharacterData$1 = class CharacterData extends Node$1 {

    constructor(ownerDocument, localName, nodeType, data) {
      super(ownerDocument, localName, nodeType);
      this[VALUE] = $String(data);
    }

    // <Mixins>
    get isConnected() { return isConnected(this); }
    get parentElement() { return parentElement(this); }
    get previousSibling() { return previousSibling(this); }
    get nextSibling() { return nextSibling(this); }

    get previousElementSibling() { return previousElementSibling(this); }
    get nextElementSibling() { return nextElementSibling(this); }

    before(...nodes) { before(this, nodes); }
    after(...nodes) { after(this, nodes); }
    replaceWith(...nodes) { replaceWith(this, nodes); }
    remove() { remove(this[PREV], this, this[NEXT]); }
    // </Mixins>

    // CharacterData only
    /* c8 ignore start */
    get data() { return this[VALUE]; }
    set data(value) {
      this[VALUE] = $String(value);
      moCallback(this, this.parentNode);
    }

    get nodeValue() { return this.data; }
    set nodeValue(value) { this.data = value; }

    get textContent() { return this.data; }
    set textContent(value) { this.data = value; }

    get length() { return this.data.length; }

    substringData(offset, count) {
      return this.data.substr(offset, count);
    }

    appendData(data) {
      this.data += data;
    }

    insertData(offset, data) {
      const {data: t} = this;
      this.data = t.slice(0, offset) + data + t.slice(offset);
    }

    deleteData(offset, count) {
      const {data: t} = this;
      this.data = t.slice(0, offset) + t.slice(offset + count);
    }

    replaceData(offset, count, data) {
      const {data: t} = this;
      this.data = t.slice(0, offset) + data + t.slice(offset + count);
    }
    /* c8 ignore stop */

    toJSON() {
      const json = [];
      characterDataAsJSON(this, json);
      return json;
    }
  };

  /**
   * @implements globalThis.CDATASection
   */
  let CDATASection$1 = class CDATASection extends CharacterData$1 {
    constructor(ownerDocument, data = '') {
      super(ownerDocument, '#cdatasection', CDATA_SECTION_NODE, data);
    }

    cloneNode() {
      const {ownerDocument, [VALUE]: data} = this;
      return new CDATASection(ownerDocument, data);
    }

    toString() { return `<![CDATA[${this[VALUE]}]]>`; }
  };

  /**
   * @implements globalThis.Comment
   */
  let Comment$1 = class Comment extends CharacterData$1 {
    constructor(ownerDocument, data = '') {
      super(ownerDocument, '#comment', COMMENT_NODE, data);
    }

    cloneNode() {
      const {ownerDocument, [VALUE]: data} = this;
      return new Comment(ownerDocument, data);
    }

    toString() { return `<!--${this[VALUE]}-->`; }
  };

  var boolbase = {
  	trueFunc: function trueFunc(){
  		return true;
  	},
  	falseFunc: function falseFunc(){
  		return false;
  	}
  };

  var boolbase$1 = /*@__PURE__*/getDefaultExportFromCjs(boolbase);

  var SelectorType;
  (function (SelectorType) {
      SelectorType["Attribute"] = "attribute";
      SelectorType["Pseudo"] = "pseudo";
      SelectorType["PseudoElement"] = "pseudo-element";
      SelectorType["Tag"] = "tag";
      SelectorType["Universal"] = "universal";
      // Traversals
      SelectorType["Adjacent"] = "adjacent";
      SelectorType["Child"] = "child";
      SelectorType["Descendant"] = "descendant";
      SelectorType["Parent"] = "parent";
      SelectorType["Sibling"] = "sibling";
      SelectorType["ColumnCombinator"] = "column-combinator";
  })(SelectorType || (SelectorType = {}));
  var AttributeAction;
  (function (AttributeAction) {
      AttributeAction["Any"] = "any";
      AttributeAction["Element"] = "element";
      AttributeAction["End"] = "end";
      AttributeAction["Equals"] = "equals";
      AttributeAction["Exists"] = "exists";
      AttributeAction["Hyphen"] = "hyphen";
      AttributeAction["Not"] = "not";
      AttributeAction["Start"] = "start";
  })(AttributeAction || (AttributeAction = {}));

  const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
  const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
  const actionTypes = new Map([
      [126 /* Tilde */, AttributeAction.Element],
      [94 /* Circumflex */, AttributeAction.Start],
      [36 /* Dollar */, AttributeAction.End],
      [42 /* Asterisk */, AttributeAction.Any],
      [33 /* ExclamationMark */, AttributeAction.Not],
      [124 /* Pipe */, AttributeAction.Hyphen],
  ]);
  // Pseudos, whose data property is parsed as well.
  const unpackPseudos = new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context",
  ]);
  /**
   * Checks whether a specific selector is a traversal.
   * This is useful eg. in swapping the order of elements that
   * are not traversals.
   *
   * @param selector Selector to check.
   */
  function isTraversal$1(selector) {
      switch (selector.type) {
          case SelectorType.Adjacent:
          case SelectorType.Child:
          case SelectorType.Descendant:
          case SelectorType.Parent:
          case SelectorType.Sibling:
          case SelectorType.ColumnCombinator:
              return true;
          default:
              return false;
      }
  }
  const stripQuotesFromPseudos = new Set(["contains", "icontains"]);
  // Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
  function funescape(_, escaped, escapedWhitespace) {
      const high = parseInt(escaped, 16) - 0x10000;
      // NaN means non-codepoint
      return high !== high || escapedWhitespace
          ? escaped
          : high < 0
              ? // BMP codepoint
                  String.fromCharCode(high + 0x10000)
              : // Supplemental Plane codepoint (surrogate pair)
                  String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
  }
  function unescapeCSS(str) {
      return str.replace(reEscape, funescape);
  }
  function isQuote(c) {
      return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;
  }
  function isWhitespace(c) {
      return (c === 32 /* Space */ ||
          c === 9 /* Tab */ ||
          c === 10 /* NewLine */ ||
          c === 12 /* FormFeed */ ||
          c === 13 /* CarriageReturn */);
  }
  /**
   * Parses `selector`, optionally with the passed `options`.
   *
   * @param selector Selector to parse.
   * @param options Options for parsing.
   * @returns Returns a two-dimensional array.
   * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
   * the second contains the relevant tokens for that selector.
   */
  function parse$3(selector) {
      const subselects = [];
      const endIndex = parseSelector(subselects, `${selector}`, 0);
      if (endIndex < selector.length) {
          throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
      }
      return subselects;
  }
  function parseSelector(subselects, selector, selectorIndex) {
      let tokens = [];
      function getName(offset) {
          const match = selector.slice(selectorIndex + offset).match(reName);
          if (!match) {
              throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
          }
          const [name] = match;
          selectorIndex += offset + name.length;
          return unescapeCSS(name);
      }
      function stripWhitespace(offset) {
          selectorIndex += offset;
          while (selectorIndex < selector.length &&
              isWhitespace(selector.charCodeAt(selectorIndex))) {
              selectorIndex++;
          }
      }
      function readValueWithParenthesis() {
          selectorIndex += 1;
          const start = selectorIndex;
          let counter = 1;
          for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
              if (selector.charCodeAt(selectorIndex) ===
                  40 /* LeftParenthesis */ &&
                  !isEscaped(selectorIndex)) {
                  counter++;
              }
              else if (selector.charCodeAt(selectorIndex) ===
                  41 /* RightParenthesis */ &&
                  !isEscaped(selectorIndex)) {
                  counter--;
              }
          }
          if (counter) {
              throw new Error("Parenthesis not matched");
          }
          return unescapeCSS(selector.slice(start, selectorIndex - 1));
      }
      function isEscaped(pos) {
          let slashCount = 0;
          while (selector.charCodeAt(--pos) === 92 /* BackSlash */)
              slashCount++;
          return (slashCount & 1) === 1;
      }
      function ensureNotTraversal() {
          if (tokens.length > 0 && isTraversal$1(tokens[tokens.length - 1])) {
              throw new Error("Did not expect successive traversals.");
          }
      }
      function addTraversal(type) {
          if (tokens.length > 0 &&
              tokens[tokens.length - 1].type === SelectorType.Descendant) {
              tokens[tokens.length - 1].type = type;
              return;
          }
          ensureNotTraversal();
          tokens.push({ type });
      }
      function addSpecialAttribute(name, action) {
          tokens.push({
              type: SelectorType.Attribute,
              name,
              action,
              value: getName(1),
              namespace: null,
              ignoreCase: "quirks",
          });
      }
      /**
       * We have finished parsing the current part of the selector.
       *
       * Remove descendant tokens at the end if they exist,
       * and return the last index, so that parsing can be
       * picked up from here.
       */
      function finalizeSubselector() {
          if (tokens.length &&
              tokens[tokens.length - 1].type === SelectorType.Descendant) {
              tokens.pop();
          }
          if (tokens.length === 0) {
              throw new Error("Empty sub-selector");
          }
          subselects.push(tokens);
      }
      stripWhitespace(0);
      if (selector.length === selectorIndex) {
          return selectorIndex;
      }
      loop: while (selectorIndex < selector.length) {
          const firstChar = selector.charCodeAt(selectorIndex);
          switch (firstChar) {
              // Whitespace
              case 32 /* Space */:
              case 9 /* Tab */:
              case 10 /* NewLine */:
              case 12 /* FormFeed */:
              case 13 /* CarriageReturn */: {
                  if (tokens.length === 0 ||
                      tokens[0].type !== SelectorType.Descendant) {
                      ensureNotTraversal();
                      tokens.push({ type: SelectorType.Descendant });
                  }
                  stripWhitespace(1);
                  break;
              }
              // Traversals
              case 62 /* GreaterThan */: {
                  addTraversal(SelectorType.Child);
                  stripWhitespace(1);
                  break;
              }
              case 60 /* LessThan */: {
                  addTraversal(SelectorType.Parent);
                  stripWhitespace(1);
                  break;
              }
              case 126 /* Tilde */: {
                  addTraversal(SelectorType.Sibling);
                  stripWhitespace(1);
                  break;
              }
              case 43 /* Plus */: {
                  addTraversal(SelectorType.Adjacent);
                  stripWhitespace(1);
                  break;
              }
              // Special attribute selectors: .class, #id
              case 46 /* Period */: {
                  addSpecialAttribute("class", AttributeAction.Element);
                  break;
              }
              case 35 /* Hash */: {
                  addSpecialAttribute("id", AttributeAction.Equals);
                  break;
              }
              case 91 /* LeftSquareBracket */: {
                  stripWhitespace(1);
                  // Determine attribute name and namespace
                  let name;
                  let namespace = null;
                  if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {
                      // Equivalent to no namespace
                      name = getName(1);
                  }
                  else if (selector.startsWith("*|", selectorIndex)) {
                      namespace = "*";
                      name = getName(2);
                  }
                  else {
                      name = getName(0);
                      if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                          selector.charCodeAt(selectorIndex + 1) !==
                              61 /* Equal */) {
                          namespace = name;
                          name = getName(1);
                      }
                  }
                  stripWhitespace(0);
                  // Determine comparison operation
                  let action = AttributeAction.Exists;
                  const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
                  if (possibleAction) {
                      action = possibleAction;
                      if (selector.charCodeAt(selectorIndex + 1) !==
                          61 /* Equal */) {
                          throw new Error("Expected `=`");
                      }
                      stripWhitespace(2);
                  }
                  else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {
                      action = AttributeAction.Equals;
                      stripWhitespace(1);
                  }
                  // Determine value
                  let value = "";
                  let ignoreCase = null;
                  if (action !== "exists") {
                      if (isQuote(selector.charCodeAt(selectorIndex))) {
                          const quote = selector.charCodeAt(selectorIndex);
                          let sectionEnd = selectorIndex + 1;
                          while (sectionEnd < selector.length &&
                              (selector.charCodeAt(sectionEnd) !== quote ||
                                  isEscaped(sectionEnd))) {
                              sectionEnd += 1;
                          }
                          if (selector.charCodeAt(sectionEnd) !== quote) {
                              throw new Error("Attribute value didn't end");
                          }
                          value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                          selectorIndex = sectionEnd + 1;
                      }
                      else {
                          const valueStart = selectorIndex;
                          while (selectorIndex < selector.length &&
                              ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&
                                  selector.charCodeAt(selectorIndex) !==
                                      93 /* RightSquareBracket */) ||
                                  isEscaped(selectorIndex))) {
                              selectorIndex += 1;
                          }
                          value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                      }
                      stripWhitespace(0);
                      // See if we have a force ignore flag
                      const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;
                      // If the forceIgnore flag is set (either `i` or `s`), use that value
                      if (forceIgnore === 115 /* LowerS */) {
                          ignoreCase = false;
                          stripWhitespace(1);
                      }
                      else if (forceIgnore === 105 /* LowerI */) {
                          ignoreCase = true;
                          stripWhitespace(1);
                      }
                  }
                  if (selector.charCodeAt(selectorIndex) !==
                      93 /* RightSquareBracket */) {
                      throw new Error("Attribute selector didn't terminate");
                  }
                  selectorIndex += 1;
                  const attributeSelector = {
                      type: SelectorType.Attribute,
                      name,
                      action,
                      value,
                      namespace,
                      ignoreCase,
                  };
                  tokens.push(attributeSelector);
                  break;
              }
              case 58 /* Colon */: {
                  if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {
                      tokens.push({
                          type: SelectorType.PseudoElement,
                          name: getName(2).toLowerCase(),
                          data: selector.charCodeAt(selectorIndex) ===
                              40 /* LeftParenthesis */
                              ? readValueWithParenthesis()
                              : null,
                      });
                      continue;
                  }
                  const name = getName(1).toLowerCase();
                  let data = null;
                  if (selector.charCodeAt(selectorIndex) ===
                      40 /* LeftParenthesis */) {
                      if (unpackPseudos.has(name)) {
                          if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                              throw new Error(`Pseudo-selector ${name} cannot be quoted`);
                          }
                          data = [];
                          selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                          if (selector.charCodeAt(selectorIndex) !==
                              41 /* RightParenthesis */) {
                              throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
                          }
                          selectorIndex += 1;
                      }
                      else {
                          data = readValueWithParenthesis();
                          if (stripQuotesFromPseudos.has(name)) {
                              const quot = data.charCodeAt(0);
                              if (quot === data.charCodeAt(data.length - 1) &&
                                  isQuote(quot)) {
                                  data = data.slice(1, -1);
                              }
                          }
                          data = unescapeCSS(data);
                      }
                  }
                  tokens.push({ type: SelectorType.Pseudo, name, data });
                  break;
              }
              case 44 /* Comma */: {
                  finalizeSubselector();
                  tokens = [];
                  stripWhitespace(1);
                  break;
              }
              default: {
                  if (selector.startsWith("/*", selectorIndex)) {
                      const endIndex = selector.indexOf("*/", selectorIndex + 2);
                      if (endIndex < 0) {
                          throw new Error("Comment was not terminated");
                      }
                      selectorIndex = endIndex + 2;
                      // Remove leading whitespace
                      if (tokens.length === 0) {
                          stripWhitespace(0);
                      }
                      break;
                  }
                  let namespace = null;
                  let name;
                  if (firstChar === 42 /* Asterisk */) {
                      selectorIndex += 1;
                      name = "*";
                  }
                  else if (firstChar === 124 /* Pipe */) {
                      name = "";
                      if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {
                          addTraversal(SelectorType.ColumnCombinator);
                          stripWhitespace(2);
                          break;
                      }
                  }
                  else if (reName.test(selector.slice(selectorIndex))) {
                      name = getName(0);
                  }
                  else {
                      break loop;
                  }
                  if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                      selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {
                      namespace = name;
                      if (selector.charCodeAt(selectorIndex + 1) ===
                          42 /* Asterisk */) {
                          name = "*";
                          selectorIndex += 2;
                      }
                      else {
                          name = getName(1);
                      }
                  }
                  tokens.push(name === "*"
                      ? { type: SelectorType.Universal, namespace }
                      : { type: SelectorType.Tag, name, namespace });
              }
          }
      }
      finalizeSubselector();
      return selectorIndex;
  }

  const procedure = new Map([
      [SelectorType.Universal, 50],
      [SelectorType.Tag, 30],
      [SelectorType.Attribute, 1],
      [SelectorType.Pseudo, 0],
  ]);
  function isTraversal(token) {
      return !procedure.has(token.type);
  }
  const attributes = new Map([
      [AttributeAction.Exists, 10],
      [AttributeAction.Equals, 8],
      [AttributeAction.Not, 7],
      [AttributeAction.Start, 6],
      [AttributeAction.End, 6],
      [AttributeAction.Any, 5],
  ]);
  /**
   * Sort the parts of the passed selector,
   * as there is potential for optimization
   * (some types of selectors are faster than others)
   *
   * @param arr Selector to sort
   */
  function sortByProcedure(arr) {
      const procs = arr.map(getProcedure);
      for (let i = 1; i < arr.length; i++) {
          const procNew = procs[i];
          if (procNew < 0)
              continue;
          for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {
              const token = arr[j + 1];
              arr[j + 1] = arr[j];
              arr[j] = token;
              procs[j + 1] = procs[j];
              procs[j] = procNew;
          }
      }
  }
  function getProcedure(token) {
      var _a, _b;
      let proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
      if (token.type === SelectorType.Attribute) {
          proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
          if (token.action === AttributeAction.Equals && token.name === "id") {
              // Prefer ID selectors (eg. #ID)
              proc = 9;
          }
          if (token.ignoreCase) {
              /*
               * IgnoreCase adds some overhead, prefer "normal" token
               * this is a binary operation, to ensure it's still an int
               */
              proc >>= 1;
          }
      }
      else if (token.type === SelectorType.Pseudo) {
          if (!token.data) {
              proc = 3;
          }
          else if (token.name === "has" || token.name === "contains") {
              proc = 0; // Expensive in any case
          }
          else if (Array.isArray(token.data)) {
              // Eg. :matches, :not
              proc = Math.min(...token.data.map((d) => Math.min(...d.map(getProcedure))));
              // If we have traversals, try to avoid executing this selector
              if (proc < 0) {
                  proc = 0;
              }
          }
          else {
              proc = 2;
          }
      }
      return proc;
  }

  /**
   * All reserved characters in a regex, used for escaping.
   *
   * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
   * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
   */
  const reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
  function escapeRegex(value) {
      return value.replace(reChars, "\\$&");
  }
  /**
   * Attributes that are case-insensitive in HTML.
   *
   * @private
   * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
   */
  const caseInsensitiveAttributes = new Set([
      "accept",
      "accept-charset",
      "align",
      "alink",
      "axis",
      "bgcolor",
      "charset",
      "checked",
      "clear",
      "codetype",
      "color",
      "compact",
      "declare",
      "defer",
      "dir",
      "direction",
      "disabled",
      "enctype",
      "face",
      "frame",
      "hreflang",
      "http-equiv",
      "lang",
      "language",
      "link",
      "media",
      "method",
      "multiple",
      "nohref",
      "noresize",
      "noshade",
      "nowrap",
      "readonly",
      "rel",
      "rev",
      "rules",
      "scope",
      "scrolling",
      "selected",
      "shape",
      "target",
      "text",
      "type",
      "valign",
      "valuetype",
      "vlink",
  ]);
  function shouldIgnoreCase(selector, options) {
      return typeof selector.ignoreCase === "boolean"
          ? selector.ignoreCase
          : selector.ignoreCase === "quirks"
              ? !!options.quirksMode
              : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
  }
  /**
   * Attribute selectors
   */
  const attributeRules = {
      equals(next, data, options) {
          const { adapter } = options;
          const { name } = data;
          let { value } = data;
          if (shouldIgnoreCase(data, options)) {
              value = value.toLowerCase();
              return (elem) => {
                  const attr = adapter.getAttributeValue(elem, name);
                  return (attr != null &&
                      attr.length === value.length &&
                      attr.toLowerCase() === value &&
                      next(elem));
              };
          }
          return (elem) => adapter.getAttributeValue(elem, name) === value && next(elem);
      },
      hyphen(next, data, options) {
          const { adapter } = options;
          const { name } = data;
          let { value } = data;
          const len = value.length;
          if (shouldIgnoreCase(data, options)) {
              value = value.toLowerCase();
              return function hyphenIC(elem) {
                  const attr = adapter.getAttributeValue(elem, name);
                  return (attr != null &&
                      (attr.length === len || attr.charAt(len) === "-") &&
                      attr.substr(0, len).toLowerCase() === value &&
                      next(elem));
              };
          }
          return function hyphen(elem) {
              const attr = adapter.getAttributeValue(elem, name);
              return (attr != null &&
                  (attr.length === len || attr.charAt(len) === "-") &&
                  attr.substr(0, len) === value &&
                  next(elem));
          };
      },
      element(next, data, options) {
          const { adapter } = options;
          const { name, value } = data;
          if (/\s/.test(value)) {
              return boolbase$1.falseFunc;
          }
          const regex = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data, options) ? "i" : "");
          return function element(elem) {
              const attr = adapter.getAttributeValue(elem, name);
              return (attr != null &&
                  attr.length >= value.length &&
                  regex.test(attr) &&
                  next(elem));
          };
      },
      exists(next, { name }, { adapter }) {
          return (elem) => adapter.hasAttrib(elem, name) && next(elem);
      },
      start(next, data, options) {
          const { adapter } = options;
          const { name } = data;
          let { value } = data;
          const len = value.length;
          if (len === 0) {
              return boolbase$1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
              value = value.toLowerCase();
              return (elem) => {
                  const attr = adapter.getAttributeValue(elem, name);
                  return (attr != null &&
                      attr.length >= len &&
                      attr.substr(0, len).toLowerCase() === value &&
                      next(elem));
              };
          }
          return (elem) => {
              var _a;
              return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
                  next(elem);
          };
      },
      end(next, data, options) {
          const { adapter } = options;
          const { name } = data;
          let { value } = data;
          const len = -value.length;
          if (len === 0) {
              return boolbase$1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
              value = value.toLowerCase();
              return (elem) => {
                  var _a;
                  return ((_a = adapter
                      .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
              };
          }
          return (elem) => {
              var _a;
              return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
                  next(elem);
          };
      },
      any(next, data, options) {
          const { adapter } = options;
          const { name, value } = data;
          if (value === "") {
              return boolbase$1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
              const regex = new RegExp(escapeRegex(value), "i");
              return function anyIC(elem) {
                  const attr = adapter.getAttributeValue(elem, name);
                  return (attr != null &&
                      attr.length >= value.length &&
                      regex.test(attr) &&
                      next(elem));
              };
          }
          return (elem) => {
              var _a;
              return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
                  next(elem);
          };
      },
      not(next, data, options) {
          const { adapter } = options;
          const { name } = data;
          let { value } = data;
          if (value === "") {
              return (elem) => !!adapter.getAttributeValue(elem, name) && next(elem);
          }
          else if (shouldIgnoreCase(data, options)) {
              value = value.toLowerCase();
              return (elem) => {
                  const attr = adapter.getAttributeValue(elem, name);
                  return ((attr == null ||
                      attr.length !== value.length ||
                      attr.toLowerCase() !== value) &&
                      next(elem));
              };
          }
          return (elem) => adapter.getAttributeValue(elem, name) !== value && next(elem);
      },
  };

  // Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
  // Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
  const whitespace = new Set([9, 10, 12, 13, 32]);
  const ZERO = "0".charCodeAt(0);
  const NINE = "9".charCodeAt(0);
  /**
   * Parses an expression.
   *
   * @throws An `Error` if parsing fails.
   * @returns An array containing the integer step size and the integer offset of the nth rule.
   * @example nthCheck.parse("2n+3"); // returns [2, 3]
   */
  function parse$2(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
          return [2, 0];
      }
      else if (formula === "odd") {
          return [2, 1];
      }
      // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
      let idx = 0;
      let a = 0;
      let sign = readSign();
      let number = readNumber();
      if (idx < formula.length && formula.charAt(idx) === "n") {
          idx++;
          a = sign * (number !== null && number !== void 0 ? number : 1);
          skipWhitespace();
          if (idx < formula.length) {
              sign = readSign();
              skipWhitespace();
              number = readNumber();
          }
          else {
              sign = number = 0;
          }
      }
      // Throw if there is anything else
      if (number === null || idx < formula.length) {
          throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
      }
      return [a, sign * number];
      function readSign() {
          if (formula.charAt(idx) === "-") {
              idx++;
              return -1;
          }
          if (formula.charAt(idx) === "+") {
              idx++;
          }
          return 1;
      }
      function readNumber() {
          const start = idx;
          let value = 0;
          while (idx < formula.length &&
              formula.charCodeAt(idx) >= ZERO &&
              formula.charCodeAt(idx) <= NINE) {
              value = value * 10 + (formula.charCodeAt(idx) - ZERO);
              idx++;
          }
          // Return `null` if we didn't read anything.
          return idx === start ? null : value;
      }
      function skipWhitespace() {
          while (idx < formula.length &&
              whitespace.has(formula.charCodeAt(idx))) {
              idx++;
          }
      }
  }

  /**
   * Returns a function that checks if an elements index matches the given rule
   * highly optimized to return the fastest solution.
   *
   * @param parsed A tuple [a, b], as returned by `parse`.
   * @returns A highly optimized function that returns whether an index matches the nth-check.
   * @example
   *
   * ```js
   * const check = nthCheck.compile([2, 3]);
   *
   * check(0); // `false`
   * check(1); // `false`
   * check(2); // `true`
   * check(3); // `false`
   * check(4); // `true`
   * check(5); // `false`
   * check(6); // `true`
   * ```
   */
  function compile$2(parsed) {
      const a = parsed[0];
      // Subtract 1 from `b`, to convert from one- to zero-indexed.
      const b = parsed[1] - 1;
      /*
       * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
       * Besides, the specification states that no elements are
       * matched when `a` and `b` are 0.
       *
       * `b < 0` here as we subtracted 1 from `b` above.
       */
      if (b < 0 && a <= 0)
          return boolbase$1.falseFunc;
      // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
      if (a === -1)
          return (index) => index <= b;
      if (a === 0)
          return (index) => index === b;
      // When `b <= 0` and `a === 1`, they match any element.
      if (a === 1)
          return b < 0 ? boolbase$1.trueFunc : (index) => index >= b;
      /*
       * Otherwise, modulo can be used to check if there is a match.
       *
       * Modulo doesn't care about the sign, so let's use `a`s absolute value.
       */
      const absA = Math.abs(a);
      // Get `b mod a`, + a if this is negative.
      const bMod = ((b % absA) + absA) % absA;
      return a > 1
          ? (index) => index >= b && index % absA === bMod
          : (index) => index <= b && index % absA === bMod;
  }

  /**
   * Parses and compiles a formula to a highly optimized function.
   * Combination of {@link parse} and {@link compile}.
   *
   * If the formula doesn't match any elements,
   * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
   * Otherwise, a function accepting an _index_ is returned, which returns
   * whether or not the passed _index_ matches the formula.
   *
   * Note: The nth-rule starts counting at `1`, the returned function at `0`.
   *
   * @param formula The formula to compile.
   * @example
   * const check = nthCheck("2n+3");
   *
   * check(0); // `false`
   * check(1); // `false`
   * check(2); // `true`
   * check(3); // `false`
   * check(4); // `true`
   * check(5); // `false`
   * check(6); // `true`
   */
  function nthCheck(formula) {
      return compile$2(parse$2(formula));
  }

  function getChildFunc(next, adapter) {
      return (elem) => {
          const parent = adapter.getParent(elem);
          return parent != null && adapter.isTag(parent) && next(elem);
      };
  }
  const filters = {
      contains(next, text, { adapter }) {
          return function contains(elem) {
              return next(elem) && adapter.getText(elem).includes(text);
          };
      },
      icontains(next, text, { adapter }) {
          const itext = text.toLowerCase();
          return function icontains(elem) {
              return (next(elem) &&
                  adapter.getText(elem).toLowerCase().includes(itext));
          };
      },
      // Location specific methods
      "nth-child"(next, rule, { adapter, equals }) {
          const func = nthCheck(rule);
          if (func === boolbase$1.falseFunc)
              return boolbase$1.falseFunc;
          if (func === boolbase$1.trueFunc)
              return getChildFunc(next, adapter);
          return function nthChild(elem) {
              const siblings = adapter.getSiblings(elem);
              let pos = 0;
              for (let i = 0; i < siblings.length; i++) {
                  if (equals(elem, siblings[i]))
                      break;
                  if (adapter.isTag(siblings[i])) {
                      pos++;
                  }
              }
              return func(pos) && next(elem);
          };
      },
      "nth-last-child"(next, rule, { adapter, equals }) {
          const func = nthCheck(rule);
          if (func === boolbase$1.falseFunc)
              return boolbase$1.falseFunc;
          if (func === boolbase$1.trueFunc)
              return getChildFunc(next, adapter);
          return function nthLastChild(elem) {
              const siblings = adapter.getSiblings(elem);
              let pos = 0;
              for (let i = siblings.length - 1; i >= 0; i--) {
                  if (equals(elem, siblings[i]))
                      break;
                  if (adapter.isTag(siblings[i])) {
                      pos++;
                  }
              }
              return func(pos) && next(elem);
          };
      },
      "nth-of-type"(next, rule, { adapter, equals }) {
          const func = nthCheck(rule);
          if (func === boolbase$1.falseFunc)
              return boolbase$1.falseFunc;
          if (func === boolbase$1.trueFunc)
              return getChildFunc(next, adapter);
          return function nthOfType(elem) {
              const siblings = adapter.getSiblings(elem);
              let pos = 0;
              for (let i = 0; i < siblings.length; i++) {
                  const currentSibling = siblings[i];
                  if (equals(elem, currentSibling))
                      break;
                  if (adapter.isTag(currentSibling) &&
                      adapter.getName(currentSibling) === adapter.getName(elem)) {
                      pos++;
                  }
              }
              return func(pos) && next(elem);
          };
      },
      "nth-last-of-type"(next, rule, { adapter, equals }) {
          const func = nthCheck(rule);
          if (func === boolbase$1.falseFunc)
              return boolbase$1.falseFunc;
          if (func === boolbase$1.trueFunc)
              return getChildFunc(next, adapter);
          return function nthLastOfType(elem) {
              const siblings = adapter.getSiblings(elem);
              let pos = 0;
              for (let i = siblings.length - 1; i >= 0; i--) {
                  const currentSibling = siblings[i];
                  if (equals(elem, currentSibling))
                      break;
                  if (adapter.isTag(currentSibling) &&
                      adapter.getName(currentSibling) === adapter.getName(elem)) {
                      pos++;
                  }
              }
              return func(pos) && next(elem);
          };
      },
      // TODO determine the actual root element
      root(next, _rule, { adapter }) {
          return (elem) => {
              const parent = adapter.getParent(elem);
              return (parent == null || !adapter.isTag(parent)) && next(elem);
          };
      },
      scope(next, rule, options, context) {
          const { equals } = options;
          if (!context || context.length === 0) {
              // Equivalent to :root
              return filters["root"](next, rule, options);
          }
          if (context.length === 1) {
              // NOTE: can't be unpacked, as :has uses this for side-effects
              return (elem) => equals(context[0], elem) && next(elem);
          }
          return (elem) => context.includes(elem) && next(elem);
      },
      hover: dynamicStatePseudo("isHovered"),
      visited: dynamicStatePseudo("isVisited"),
      active: dynamicStatePseudo("isActive"),
  };
  /**
   * Dynamic state pseudos. These depend on optional Adapter methods.
   *
   * @param name The name of the adapter method to call.
   * @returns Pseudo for the `filters` object.
   */
  function dynamicStatePseudo(name) {
      return function dynamicPseudo(next, _rule, { adapter }) {
          const func = adapter[name];
          if (typeof func !== "function") {
              return boolbase$1.falseFunc;
          }
          return function active(elem) {
              return func(elem) && next(elem);
          };
      };
  }

  // While filters are precompiled, pseudos get called when they are needed
  const pseudos = {
      empty(elem, { adapter }) {
          return !adapter.getChildren(elem).some((elem) => 
          // FIXME: `getText` call is potentially expensive.
          adapter.isTag(elem) || adapter.getText(elem) !== "");
      },
      "first-child"(elem, { adapter, equals }) {
          if (adapter.prevElementSibling) {
              return adapter.prevElementSibling(elem) == null;
          }
          const firstChild = adapter
              .getSiblings(elem)
              .find((elem) => adapter.isTag(elem));
          return firstChild != null && equals(elem, firstChild);
      },
      "last-child"(elem, { adapter, equals }) {
          const siblings = adapter.getSiblings(elem);
          for (let i = siblings.length - 1; i >= 0; i--) {
              if (equals(elem, siblings[i]))
                  return true;
              if (adapter.isTag(siblings[i]))
                  break;
          }
          return false;
      },
      "first-of-type"(elem, { adapter, equals }) {
          const siblings = adapter.getSiblings(elem);
          const elemName = adapter.getName(elem);
          for (let i = 0; i < siblings.length; i++) {
              const currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                  return true;
              if (adapter.isTag(currentSibling) &&
                  adapter.getName(currentSibling) === elemName) {
                  break;
              }
          }
          return false;
      },
      "last-of-type"(elem, { adapter, equals }) {
          const siblings = adapter.getSiblings(elem);
          const elemName = adapter.getName(elem);
          for (let i = siblings.length - 1; i >= 0; i--) {
              const currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                  return true;
              if (adapter.isTag(currentSibling) &&
                  adapter.getName(currentSibling) === elemName) {
                  break;
              }
          }
          return false;
      },
      "only-of-type"(elem, { adapter, equals }) {
          const elemName = adapter.getName(elem);
          return adapter
              .getSiblings(elem)
              .every((sibling) => equals(elem, sibling) ||
              !adapter.isTag(sibling) ||
              adapter.getName(sibling) !== elemName);
      },
      "only-child"(elem, { adapter, equals }) {
          return adapter
              .getSiblings(elem)
              .every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling));
      },
  };
  function verifyPseudoArgs(func, name, subselect, argIndex) {
      if (subselect === null) {
          if (func.length > argIndex) {
              throw new Error(`Pseudo-class :${name} requires an argument`);
          }
      }
      else if (func.length === argIndex) {
          throw new Error(`Pseudo-class :${name} doesn't have any arguments`);
      }
  }

  /**
   * Aliases are pseudos that are expressed as selectors.
   */
  const aliases = {
      // Links
      "any-link": ":is(a, area, link)[href]",
      link: ":any-link:not(:visited)",
      // Forms
      // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
      disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
      enabled: ":not(:disabled)",
      checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
      required: ":is(input, select, textarea)[required]",
      optional: ":is(input, select, textarea):not([required])",
      // JQuery extensions
      // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
      selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
      checkbox: "[type=checkbox]",
      file: "[type=file]",
      password: "[type=password]",
      radio: "[type=radio]",
      reset: "[type=reset]",
      image: "[type=image]",
      submit: "[type=submit]",
      parent: ":not(:empty)",
      header: ":is(h1, h2, h3, h4, h5, h6)",
      button: ":is(button, input[type=button])",
      input: ":is(input, textarea, select, button)",
      text: "input:is(:not([type!='']), [type=text])",
  };

  /** Used as a placeholder for :has. Will be replaced with the actual element. */
  const PLACEHOLDER_ELEMENT = {};
  function ensureIsTag(next, adapter) {
      if (next === boolbase$1.falseFunc)
          return boolbase$1.falseFunc;
      return (elem) => adapter.isTag(elem) && next(elem);
  }
  function getNextSiblings(elem, adapter) {
      const siblings = adapter.getSiblings(elem);
      if (siblings.length <= 1)
          return [];
      const elemIndex = siblings.indexOf(elem);
      if (elemIndex < 0 || elemIndex === siblings.length - 1)
          return [];
      return siblings.slice(elemIndex + 1).filter(adapter.isTag);
  }
  function copyOptions(options) {
      // Not copied: context, rootFunc
      return {
          xmlMode: !!options.xmlMode,
          lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
          lowerCaseTags: !!options.lowerCaseTags,
          quirksMode: !!options.quirksMode,
          cacheResults: !!options.cacheResults,
          pseudos: options.pseudos,
          adapter: options.adapter,
          equals: options.equals,
      };
  }
  const is$1 = (next, token, options, context, compileToken) => {
      const func = compileToken(token, copyOptions(options), context);
      return func === boolbase$1.trueFunc
          ? next
          : func === boolbase$1.falseFunc
              ? boolbase$1.falseFunc
              : (elem) => func(elem) && next(elem);
  };
  /*
   * :not, :has, :is, :matches and :where have to compile selectors
   * doing this in src/pseudos.ts would lead to circular dependencies,
   * so we add them here
   */
  const subselects = {
      is: is$1,
      /**
       * `:matches` and `:where` are aliases for `:is`.
       */
      matches: is$1,
      where: is$1,
      not(next, token, options, context, compileToken) {
          const func = compileToken(token, copyOptions(options), context);
          return func === boolbase$1.falseFunc
              ? next
              : func === boolbase$1.trueFunc
                  ? boolbase$1.falseFunc
                  : (elem) => !func(elem) && next(elem);
      },
      has(next, subselect, options, _context, compileToken) {
          const { adapter } = options;
          const opts = copyOptions(options);
          opts.relativeSelector = true;
          const context = subselect.some((s) => s.some(isTraversal))
              ? // Used as a placeholder. Will be replaced with the actual element.
                  [PLACEHOLDER_ELEMENT]
              : undefined;
          const compiled = compileToken(subselect, opts, context);
          if (compiled === boolbase$1.falseFunc)
              return boolbase$1.falseFunc;
          const hasElement = ensureIsTag(compiled, adapter);
          // If `compiled` is `trueFunc`, we can skip this.
          if (context && compiled !== boolbase$1.trueFunc) {
              /*
               * `shouldTestNextSiblings` will only be true if the query starts with
               * a traversal (sibling or adjacent). That means we will always have a context.
               */
              const { shouldTestNextSiblings = false } = compiled;
              return (elem) => {
                  if (!next(elem))
                      return false;
                  context[0] = elem;
                  const childs = adapter.getChildren(elem);
                  const nextElements = shouldTestNextSiblings
                      ? [...childs, ...getNextSiblings(elem, adapter)]
                      : childs;
                  return adapter.existsOne(hasElement, nextElements);
              };
          }
          return (elem) => next(elem) &&
              adapter.existsOne(hasElement, adapter.getChildren(elem));
      },
  };

  function compilePseudoSelector(next, selector, options, context, compileToken) {
      var _a;
      const { name, data } = selector;
      if (Array.isArray(data)) {
          if (!(name in subselects)) {
              throw new Error(`Unknown pseudo-class :${name}(${data})`);
          }
          return subselects[name](next, data, options, context, compileToken);
      }
      const userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
      const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name];
      if (typeof stringPseudo === "string") {
          if (data != null) {
              throw new Error(`Pseudo ${name} doesn't have any arguments`);
          }
          // The alias has to be parsed here, to make sure options are respected.
          const alias = parse$3(stringPseudo);
          return subselects["is"](next, alias, options, context, compileToken);
      }
      if (typeof userPseudo === "function") {
          verifyPseudoArgs(userPseudo, name, data, 1);
          return (elem) => userPseudo(elem, data) && next(elem);
      }
      if (name in filters) {
          return filters[name](next, data, options, context);
      }
      if (name in pseudos) {
          const pseudo = pseudos[name];
          verifyPseudoArgs(pseudo, name, data, 2);
          return (elem) => pseudo(elem, options, data) && next(elem);
      }
      throw new Error(`Unknown pseudo-class :${name}`);
  }

  function getElementParent(node, adapter) {
      const parent = adapter.getParent(node);
      if (parent && adapter.isTag(parent)) {
          return parent;
      }
      return null;
  }
  /*
   * All available rules
   */
  function compileGeneralSelector(next, selector, options, context, compileToken) {
      const { adapter, equals } = options;
      switch (selector.type) {
          case SelectorType.PseudoElement: {
              throw new Error("Pseudo-elements are not supported by css-select");
          }
          case SelectorType.ColumnCombinator: {
              throw new Error("Column combinators are not yet supported by css-select");
          }
          case SelectorType.Attribute: {
              if (selector.namespace != null) {
                  throw new Error("Namespaced attributes are not yet supported by css-select");
              }
              if (!options.xmlMode || options.lowerCaseAttributeNames) {
                  selector.name = selector.name.toLowerCase();
              }
              return attributeRules[selector.action](next, selector, options);
          }
          case SelectorType.Pseudo: {
              return compilePseudoSelector(next, selector, options, context, compileToken);
          }
          // Tags
          case SelectorType.Tag: {
              if (selector.namespace != null) {
                  throw new Error("Namespaced tag names are not yet supported by css-select");
              }
              let { name } = selector;
              if (!options.xmlMode || options.lowerCaseTags) {
                  name = name.toLowerCase();
              }
              return function tag(elem) {
                  return adapter.getName(elem) === name && next(elem);
              };
          }
          // Traversal
          case SelectorType.Descendant: {
              if (options.cacheResults === false ||
                  typeof WeakSet === "undefined") {
                  return function descendant(elem) {
                      let current = elem;
                      while ((current = getElementParent(current, adapter))) {
                          if (next(current)) {
                              return true;
                          }
                      }
                      return false;
                  };
              }
              // @ts-expect-error `ElementNode` is not extending object
              const isFalseCache = new WeakSet();
              return function cachedDescendant(elem) {
                  let current = elem;
                  while ((current = getElementParent(current, adapter))) {
                      if (!isFalseCache.has(current)) {
                          if (adapter.isTag(current) && next(current)) {
                              return true;
                          }
                          isFalseCache.add(current);
                      }
                  }
                  return false;
              };
          }
          case "_flexibleDescendant": {
              // Include element itself, only used while querying an array
              return function flexibleDescendant(elem) {
                  let current = elem;
                  do {
                      if (next(current))
                          return true;
                  } while ((current = getElementParent(current, adapter)));
                  return false;
              };
          }
          case SelectorType.Parent: {
              return function parent(elem) {
                  return adapter
                      .getChildren(elem)
                      .some((elem) => adapter.isTag(elem) && next(elem));
              };
          }
          case SelectorType.Child: {
              return function child(elem) {
                  const parent = adapter.getParent(elem);
                  return parent != null && adapter.isTag(parent) && next(parent);
              };
          }
          case SelectorType.Sibling: {
              return function sibling(elem) {
                  const siblings = adapter.getSiblings(elem);
                  for (let i = 0; i < siblings.length; i++) {
                      const currentSibling = siblings[i];
                      if (equals(elem, currentSibling))
                          break;
                      if (adapter.isTag(currentSibling) && next(currentSibling)) {
                          return true;
                      }
                  }
                  return false;
              };
          }
          case SelectorType.Adjacent: {
              if (adapter.prevElementSibling) {
                  return function adjacent(elem) {
                      const previous = adapter.prevElementSibling(elem);
                      return previous != null && next(previous);
                  };
              }
              return function adjacent(elem) {
                  const siblings = adapter.getSiblings(elem);
                  let lastElement;
                  for (let i = 0; i < siblings.length; i++) {
                      const currentSibling = siblings[i];
                      if (equals(elem, currentSibling))
                          break;
                      if (adapter.isTag(currentSibling)) {
                          lastElement = currentSibling;
                      }
                  }
                  return !!lastElement && next(lastElement);
              };
          }
          case SelectorType.Universal: {
              if (selector.namespace != null && selector.namespace !== "*") {
                  throw new Error("Namespaced universal selectors are not yet supported by css-select");
              }
              return next;
          }
      }
  }

  /**
   * Compiles a selector to an executable function.
   *
   * @param selector Selector to compile.
   * @param options Compilation options.
   * @param context Optional context for the selector.
   */
  function compile$1(selector, options, context) {
      const next = compileUnsafe(selector, options, context);
      return ensureIsTag(next, options.adapter);
  }
  function compileUnsafe(selector, options, context) {
      const token = typeof selector === "string" ? parse$3(selector) : selector;
      return compileToken(token, options, context);
  }
  function includesScopePseudo(t) {
      return (t.type === SelectorType.Pseudo &&
          (t.name === "scope" ||
              (Array.isArray(t.data) &&
                  t.data.some((data) => data.some(includesScopePseudo)))));
  }
  const DESCENDANT_TOKEN = { type: SelectorType.Descendant };
  const FLEXIBLE_DESCENDANT_TOKEN = {
      type: "_flexibleDescendant",
  };
  const SCOPE_TOKEN = {
      type: SelectorType.Pseudo,
      name: "scope",
      data: null,
  };
  /*
   * CSS 4 Spec (Draft): 3.4.1. Absolutizing a Relative Selector
   * http://www.w3.org/TR/selectors4/#absolutizing
   */
  function absolutize(token, { adapter }, context) {
      // TODO Use better check if the context is a document
      const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
          const parent = adapter.isTag(e) && adapter.getParent(e);
          return e === PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
      }));
      for (const t of token) {
          if (t.length > 0 &&
              isTraversal(t[0]) &&
              t[0].type !== SelectorType.Descendant) ;
          else if (hasContext && !t.some(includesScopePseudo)) {
              t.unshift(DESCENDANT_TOKEN);
          }
          else {
              continue;
          }
          t.unshift(SCOPE_TOKEN);
      }
  }
  function compileToken(token, options, context) {
      var _a;
      token.forEach(sortByProcedure);
      context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
      const isArrayContext = Array.isArray(context);
      const finalContext = context && (Array.isArray(context) ? context : [context]);
      // Check if the selector is relative
      if (options.relativeSelector !== false) {
          absolutize(token, options, finalContext);
      }
      else if (token.some((t) => t.length > 0 && isTraversal(t[0]))) {
          throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
      }
      let shouldTestNextSiblings = false;
      const query = token
          .map((rules) => {
          if (rules.length >= 2) {
              const [first, second] = rules;
              if (first.type !== SelectorType.Pseudo ||
                  first.name !== "scope") ;
              else if (isArrayContext &&
                  second.type === SelectorType.Descendant) {
                  rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
              }
              else if (second.type === SelectorType.Adjacent ||
                  second.type === SelectorType.Sibling) {
                  shouldTestNextSiblings = true;
              }
          }
          return compileRules(rules, options, finalContext);
      })
          .reduce(reduceRules, boolbase$1.falseFunc);
      query.shouldTestNextSiblings = shouldTestNextSiblings;
      return query;
  }
  function compileRules(rules, options, context) {
      var _a;
      return rules.reduce((previous, rule) => previous === boolbase$1.falseFunc
          ? boolbase$1.falseFunc
          : compileGeneralSelector(previous, rule, options, context, compileToken), (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase$1.trueFunc);
  }
  function reduceRules(a, b) {
      if (b === boolbase$1.falseFunc || a === boolbase$1.trueFunc) {
          return a;
      }
      if (a === boolbase$1.falseFunc || b === boolbase$1.trueFunc) {
          return b;
      }
      return function combine(elem) {
          return a(elem) || b(elem);
      };
  }

  const defaultEquals = (a, b) => a === b;
  const defaultOptions = {
      adapter: DomUtils,
      equals: defaultEquals,
  };
  function convertOptionFormats(options) {
      var _a, _b, _c, _d;
      /*
       * We force one format of options to the other one.
       */
      // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
      const opts = options !== null && options !== void 0 ? options : defaultOptions;
      // @ts-expect-error Same as above.
      (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
      // @ts-expect-error `equals` does not exist on `Options`
      (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
      return opts;
  }
  function wrapCompile(func) {
      return function addAdapter(selector, options, context) {
          const opts = convertOptionFormats(options);
          return func(selector, opts, context);
      };
  }
  /**
   * Compiles the query, returns a function.
   */
  const compile = wrapCompile(compile$1);
  /**
   * Tests whether or not an element is matched by query.
   *
   * @template Node The generic Node type for the DOM adapter being used.
   * @template ElementNode The Node type for elements for the DOM adapter being used.
   * @param elem The element to test if it matches the query.
   * @param query can be either a CSS selector string or a compiled query function.
   * @param [options] options for querying the document.
   * @see compile for supported selector queries.
   * @returns
   */
  function is(elem, query, options) {
      const opts = convertOptionFormats(options);
      return (typeof query === "function" ? query : compile$1(query, opts))(elem);
  }

  const {isArray} = Array;

  /* c8 ignore start */
  const isTag = ({nodeType}) => nodeType === ELEMENT_NODE;

  const existsOne = (test, elements) => elements.some(
    element => isTag(element) && (
      test(element) ||
      existsOne(test, getChildren(element))
    )
  );

  const getAttributeValue = (element, name) => name === 'class' ?
                              element.classList.value : element.getAttribute(name);

  const getChildren = ({childNodes}) => childNodes;

  const getName = (element) => {
    const {localName} = element;
    return ignoreCase(element) ? localName.toLowerCase() : localName;
  };

  const getParent = ({parentNode}) => parentNode;

  const getSiblings = element => {
    const {parentNode} = element;
    return parentNode ? getChildren(parentNode) : element;
  };

  const getText = node => {
    if (isArray(node))
      return node.map(getText).join('');
    if (isTag(node))
      return getText(getChildren(node));
    if (node.nodeType === TEXT_NODE)
      return node.data;
    return '';
  };

  const hasAttrib = (element, name) => element.hasAttribute(name);

  const removeSubsets = nodes => {
    let {length} = nodes;
    while (length--) {
      const node = nodes[length];
      if (length && -1 < nodes.lastIndexOf(node, length - 1)) {
        nodes.splice(length, 1);
        continue;
      }
      for (let {parentNode} = node; parentNode; parentNode = parentNode.parentNode) {
        if (nodes.includes(parentNode)) {
          nodes.splice(length, 1);
          break;
        }
      }
    }
    return nodes;
  };

  const findAll = (test, nodes) => {
    const matches = [];
    for (const node of nodes) {
      if (isTag(node)) {
        if (test(node))
          matches.push(node);
        matches.push(...findAll(test, getChildren(node)));
      }
    }
    return matches;
  };

  const findOne = (test, nodes) => {
    for (let node of nodes)
      if (test(node) || (node = findOne(test, getChildren(node))))
        return node;
    return null;
  };
  /* c8 ignore stop */

  const adapter = {
    isTag,
    existsOne,
    getAttributeValue,
    getChildren,
    getName,
    getParent,
    getSiblings,
    getText,
    hasAttrib,
    removeSubsets,
    findAll,
    findOne
  };

  const prepareMatch = (element, selectors) => compile(
    selectors,
    {
      context: selectors.includes(':scope') ? element : void 0,
      xmlMode: !ignoreCase(element),
      adapter
    }
  );

  const matches = (element, selectors) => is(
    element,
    selectors,
    {
      strict: true,
      context: selectors.includes(':scope') ? element : void 0,
      xmlMode: !ignoreCase(element),
      adapter
    }
  );

  /**
   * @implements globalThis.Text
   */
  let Text$1 = class Text extends CharacterData$1 {
    constructor(ownerDocument, data = '') {
      super(ownerDocument, '#text', TEXT_NODE, data);
    }

    get wholeText() {
      const text = [];
      let {previousSibling, nextSibling} = this;
      while (previousSibling) {
        if (previousSibling.nodeType === TEXT_NODE)
          text.unshift(previousSibling[VALUE]);
        else
          break;
        previousSibling = previousSibling.previousSibling;
      }
      text.push(this[VALUE]);
      while (nextSibling) {
        if (nextSibling.nodeType === TEXT_NODE)
          text.push(nextSibling[VALUE]);
        else
          break;
        nextSibling = nextSibling.nextSibling;
      }
      return text.join('');
    }

    cloneNode() {
      const {ownerDocument, [VALUE]: data} = this;
      return new Text(ownerDocument, data);
    }

    toString() { return escape(this[VALUE]); }
  };

  // https://dom.spec.whatwg.org/#interface-parentnode
  // Document, DocumentFragment, Element


  const isNode = node => node instanceof Node$1;

  const insert = (parentNode, child, nodes) => {
    const {ownerDocument} = parentNode;
    for (const node of nodes)
      parentNode.insertBefore(
        isNode(node) ? node : new Text$1(ownerDocument, node),
        child
      );
  };

  /** @typedef { import('../interface/element.js').Element & {
      [typeof NEXT]: NodeStruct,
      [typeof PREV]: NodeStruct,
      [typeof START]: NodeStruct,
      nodeType: typeof ATTRIBUTE_NODE | typeof DOCUMENT_FRAGMENT_NODE | typeof ELEMENT_NODE | typeof TEXT_NODE | typeof NODE_END | typeof COMMENT_NODE | typeof CDATA_SECTION_NODE,
      ownerDocument: Document,
      parentNode: ParentNode,
  }} NodeStruct */

  class ParentNode extends Node$1 {
    constructor(ownerDocument, localName, nodeType) {
      super(ownerDocument, localName, nodeType);
      this[PRIVATE] = null;
      /** @type {NodeStruct} */
      this[NEXT] = this[END] = {
        [NEXT]: null,
        [PREV]: this,
        [START]: this,
        nodeType: NODE_END,
        ownerDocument: this.ownerDocument,
        parentNode: null
      };
    }

    get childNodes() {
      const childNodes = new NodeList;
      let {firstChild} = this;
      while (firstChild) {
        childNodes.push(firstChild);
        firstChild = nextSibling(firstChild);
      }
      return childNodes;
    }

    get children() {
      const children = new NodeList;
      let {firstElementChild} = this;
      while (firstElementChild) {
        children.push(firstElementChild);
        firstElementChild = nextElementSibling(firstElementChild);
      }
      return children;
    }

    /**
     * @returns {NodeStruct | null}
     */
    get firstChild() {
      let {[NEXT]: next, [END]: end} = this;
      while (next.nodeType === ATTRIBUTE_NODE)
        next = next[NEXT];
      return next === end ? null : next;
    }

    /**
     * @returns {NodeStruct | null}
     */
    get firstElementChild() {
      let {firstChild} = this;
      while (firstChild) {
        if (firstChild.nodeType === ELEMENT_NODE)
          return firstChild;
        firstChild = nextSibling(firstChild);
      }
      return null;
    }

    get lastChild() {
      const prev = this[END][PREV];
      switch (prev.nodeType) {
        case NODE_END:
          return prev[START];
        case ATTRIBUTE_NODE:
          return null;
      }
      return prev === this ? null : prev;
    }

    get lastElementChild() {
      let {lastChild} = this;
      while (lastChild) {
        if (lastChild.nodeType === ELEMENT_NODE)
          return lastChild;
        lastChild = previousSibling(lastChild);
      }
      return null;
    }

    get childElementCount() {
      return this.children.length;
    }

    prepend(...nodes) {
      insert(this, this.firstChild, nodes);
    }

    append(...nodes) {
      insert(this, this[END], nodes);
    }

    replaceChildren(...nodes) {
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end && next.nodeType === ATTRIBUTE_NODE)
        next = next[NEXT];
      while (next !== end) {
        const after = getEnd(next)[NEXT];
        next.remove();
        next = after;
      }
      if (nodes.length)
        insert(this, end, nodes);
    }

    getElementsByClassName(className) {
      const elements = new NodeList;
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (
          next.nodeType === ELEMENT_NODE &&
          next.hasAttribute('class') &&
          next.classList.has(className)
        )
          elements.push(next);
        next = next[NEXT];
      }
      return elements;
    }

    getElementsByTagName(tagName) {
      const elements = new NodeList;
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE && (
          next.localName === tagName ||
          localCase(next) === tagName
        ))
          elements.push(next);
        next = next[NEXT];
      }
      return elements;
    }

    querySelector(selectors) {
      const matches = prepareMatch(this, selectors);
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE && matches(next))
          return next;
        next = next.nodeType === ELEMENT_NODE && next.localName === 'template' ? next[END] : next[NEXT];
      }
      return null;
    }

    querySelectorAll(selectors) {
      const matches = prepareMatch(this, selectors);
      const elements = new NodeList;
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE && matches(next))
          elements.push(next);
        next = next.nodeType === ELEMENT_NODE && next.localName === 'template' ? next[END] : next[NEXT];
      }
      return elements;
    }

    appendChild(node) {
      return this.insertBefore(node, this[END]);
    }

    contains(node) {
      let parentNode = node;
      while (parentNode && parentNode !== this)
        parentNode = parentNode.parentNode;
      return parentNode === this;
    }

    insertBefore(node, before = null) {
      if (node === before)
        return node;
      if (node === this)
        throw new Error('unable to append a node to itself');
      const next = before || this[END];
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node.remove();
          node.parentNode = this;
          knownBoundaries(next[PREV], node, next);
          moCallback(node, null);
          connectedCallback(node);
          break;
        case DOCUMENT_FRAGMENT_NODE: {
          let {[PRIVATE]: parentNode, firstChild, lastChild} = node;
          if (firstChild) {
            knownSegment(next[PREV], firstChild, lastChild, next);
            knownAdjacent(node, node[END]);
            if (parentNode)
              parentNode.replaceChildren();
            do {
              firstChild.parentNode = this;
              moCallback(firstChild, null);
              if (firstChild.nodeType === ELEMENT_NODE)
                connectedCallback(firstChild);
            } while (
              firstChild !== lastChild &&
              (firstChild = nextSibling(firstChild))
            );
          }
          break;
        }
        case TEXT_NODE:
        case COMMENT_NODE:
        case CDATA_SECTION_NODE:
          node.remove();
        /* eslint no-fallthrough:0 */
        // this covers DOCUMENT_TYPE_NODE too
        default:
          node.parentNode = this;
          knownSiblings(next[PREV], node, next);
          moCallback(node, null);
          break;
      }
      return node;
    }

    normalize() {
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        const {[NEXT]: $next, [PREV]: $prev, nodeType} = next;
        if (nodeType === TEXT_NODE) {
          if (!next[VALUE])
            next.remove();
          else if ($prev && $prev.nodeType === TEXT_NODE) {
            $prev.textContent += next.textContent;
            next.remove();
          }
        }
        next = $next;
      }
    }

    removeChild(node) {
      if (node.parentNode !== this)
        throw new Error('node is not a child');
      node.remove();
      return node;
    }

    replaceChild(node, replaced) {
      const next = getEnd(replaced)[NEXT];
      replaced.remove();
      this.insertBefore(node, next);
      return replaced;
    }
  }

  // https://dom.spec.whatwg.org/#interface-nonelementparentnode
  // Document, DocumentFragment


  class NonElementParentNode extends ParentNode {
    getElementById(id) {
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (next.nodeType === ELEMENT_NODE && next.id === id)
          return next;
        next = next[NEXT];
      }
      return null;
    }

    cloneNode(deep) {
      const {ownerDocument, constructor} = this;
      const nonEPN = new constructor(ownerDocument);
      if (deep) {
        const {[END]: end} = nonEPN;
        for (const node of this.childNodes)
          nonEPN.insertBefore(node.cloneNode(deep), end);
      }
      return nonEPN; 
    }

    toString() {
      const {childNodes, localName} = this;
      return `<${localName}>${childNodes.join('')}</${localName}>`;
    }

    toJSON() {
      const json = [];
      nonElementAsJSON(this, json);
      return json;
    }
  }

  /**
   * @implements globalThis.DocumentFragment
   */
  let DocumentFragment$1 = class DocumentFragment extends NonElementParentNode {
    constructor(ownerDocument) {
      super(ownerDocument, '#document-fragment', DOCUMENT_FRAGMENT_NODE);
    }
  };

  /**
   * @implements globalThis.DocumentType
   */
  let DocumentType$1 = class DocumentType extends Node$1 {
    constructor(ownerDocument, name, publicId = '', systemId = '') {
      super(ownerDocument, '#document-type', DOCUMENT_TYPE_NODE);
      this.name = name;
      this.publicId = publicId;
      this.systemId = systemId;
    }

    cloneNode() {
      const {ownerDocument, name, publicId, systemId} = this;
      return new DocumentType(ownerDocument, name, publicId, systemId);
    }

    toString() {
      const {name, publicId, systemId} = this;
      const hasPublic = 0 < publicId.length;
      const str = [name];
      if (hasPublic)
        str.push('PUBLIC', `"${publicId}"`);
      if (systemId.length) {
        if (!hasPublic)
          str.push('SYSTEM');
        str.push(`"${systemId}"`);
      }
      return `<!DOCTYPE ${str.join(' ')}>`;
    }

    toJSON() {
      const json = [];
      documentTypeAsJSON(this, json);
      return json;
    }
  };

  /**
   * @param {Node} node
   * @returns {String}
   */
  const getInnerHtml = node => node.childNodes.join('');

  /**
   * @param {Node} node
   * @param {String} html
   */
  const setInnerHtml = (node, html) => {
    const {ownerDocument} = node;
    const {constructor} = ownerDocument;
    const document = new constructor;
    document[CUSTOM_ELEMENTS] = ownerDocument[CUSTOM_ELEMENTS];
    const {childNodes} = parseFromString$1(document, ignoreCase(node), html);

    node.replaceChildren(...childNodes.map(setOwnerDocument, ownerDocument));
  };

  function setOwnerDocument(node) {
    node.ownerDocument = this;
    switch (node.nodeType) {
      case ELEMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        node.childNodes.forEach(setOwnerDocument, this);
        break;
    }
    return node;
  }

  var uhyphen = camel => camel.replace(/(([A-Z0-9])([A-Z0-9][a-z]))|(([a-z0-9]+)([A-Z]))/g, '$2$5-$3$6')
                               .toLowerCase();

  const refs$1 = new WeakMap;

  const key = name => `data-${uhyphen(name)}`;
  const prop = name => name.slice(5).replace(/-([a-z])/g, (_, $1) => $1.toUpperCase());

  const handler$2 = {
    get(dataset, name) {
      if (name in dataset)
        return refs$1.get(dataset).getAttribute(key(name));
    },

    set(dataset, name, value) {
      dataset[name] = value;
      refs$1.get(dataset).setAttribute(key(name), value);
      return true;
    },

    deleteProperty(dataset, name) {
      if (name in dataset)
        refs$1.get(dataset).removeAttribute(key(name));
      return delete dataset[name];
    }
  };

  /**
   * @implements globalThis.DOMStringMap
   */
  class DOMStringMap {
    /**
     * @param {Element} ref
     */
    constructor(ref) {
      for (const {name, value} of ref.attributes) {
        if (/^data-/.test(name))
          this[prop(name)] = value;
      }
      refs$1.set(this, ref);
      return new Proxy(this, handler$2);
    }
  }

  setPrototypeOf(DOMStringMap.prototype, null);

  const {add} = Set.prototype;
  const addTokens = (self, tokens) => {
    for (const token of tokens) {
      if (token)
        add.call(self, token);
    }
  };

  const update = ({[OWNER_ELEMENT]: ownerElement, value}) => {
    const attribute = ownerElement.getAttributeNode('class');
    if (attribute)
      attribute.value = value;
    else
      setAttribute(
        ownerElement,
        new Attr$1(ownerElement.ownerDocument, 'class', value)
      );
  };

  /**
   * @implements globalThis.DOMTokenList
   */
  class DOMTokenList extends Set {

    constructor(ownerElement) {
      super();
      this[OWNER_ELEMENT] = ownerElement;
      const attribute = ownerElement.getAttributeNode('class');
      if (attribute)
        addTokens(this, attribute.value.split(/\s+/));
    }

    get length() { return this.size; }

    get value() { return [...this].join(' '); }

    /**
     * @param  {...string} tokens
     */
    add(...tokens) {
      addTokens(this, tokens);
      update(this);
    }

    /**
     * @param {string} token
     */
    contains(token) { return this.has(token); }

    /**
     * @param  {...string} tokens
     */
    remove(...tokens) {
      for (const token of tokens)
        this.delete(token);
      update(this);
    }

    /**
     * @param {string} token
     * @param {boolean?} force
     */
    toggle(token, force) {
      if (this.has(token)) {
        if (force)
          return true;
        this.delete(token);
        update(this);
      }
      else if (force || arguments.length === 1) {
        super.add(token);
        update(this);
        return true;
      }
      return false;
    }

    /**
     * @param {string} token
     * @param {string} newToken
     */
    replace(token, newToken) {
      if (this.has(token)) {
        this.delete(token);
        super.add(newToken);
        update(this);
        return true;
      }
      return false;
    }

    /**
     * @param {string} token
     */
    supports() { return true; }
  }

  const refs = new WeakMap;

  const getKeys = style => [...style.keys()].filter(key => key !== PRIVATE);

  const updateKeys = style => {
    const attr = refs.get(style).getAttributeNode('style');
    if (!attr || attr[CHANGED] || style.get(PRIVATE) !== attr) {
      style.clear();
      if (attr) {
        style.set(PRIVATE, attr);
        for (const rule of attr[VALUE].split(/\s*;\s*/)) {
          let [key, ...rest] = rule.split(':');
          if (rest.length > 0) {
            key = key.trim();
            const value = rest.join(':').trim();
            if (key && value)
              style.set(key, value);
          }
        }
      }
    }
    return attr;
  };

  const handler$1 = {
    get(style, name) {
      if (name in prototype)
        return style[name];
      updateKeys(style);
      if (name === 'length')
        return getKeys(style).length;
      if (/^\d+$/.test(name))
        return getKeys(style)[name];
      return style.get(uhyphen(name));
    },

    set(style, name, value) {
      if (name === 'cssText')
        style[name] = value;
      else {
        let attr = updateKeys(style);
        if (value == null)
          style.delete(uhyphen(name));
        else
          style.set(uhyphen(name), value);
        if (!attr) {
          const element = refs.get(style);
          attr = element.ownerDocument.createAttribute('style');
          element.setAttributeNode(attr);
          style.set(PRIVATE, attr);
        }
        attr[CHANGED] = false;
        attr[VALUE] = style.toString();
      }
      return true;
    }
  };

  /**
   * @implements globalThis.CSSStyleDeclaration
   */
  let CSSStyleDeclaration$1 = class CSSStyleDeclaration extends Map {
    constructor(element) {
      super();
      refs.set(this, element);
      /* c8 ignore start */
      return new Proxy(this, handler$1);
      /* c8 ignore stop */
    }

    get cssText() {
      return this.toString();
    }

    set cssText(value) {
      refs.get(this).setAttribute('style', value);
    }

    getPropertyValue(name) {
      const self = this[PRIVATE];
      return handler$1.get(self, name);
    }

    setProperty(name, value) {
      const self = this[PRIVATE];
      handler$1.set(self, name, value);
    }

    removeProperty(name) {
      const self = this[PRIVATE];
      handler$1.set(self, name, null);
    }

    [Symbol.iterator]() {
      const self = this[PRIVATE];
      updateKeys(self);
      const keys = getKeys(self);
      const {length} = keys;
      let i = 0;
      return {
        next() {
          const done = i === length;
          return {done, value: done ? null : keys[i++]};
        }
      };
    }

    get[PRIVATE]() { return this; }

    toString() {
      const self = this[PRIVATE];
      updateKeys(self);
      const cssText = [];
      self.forEach(push, cssText);
      return cssText.join(';');
    }
  };

  const {prototype} = CSSStyleDeclaration$1;

  function push(value, key) {
    if (key !== PRIVATE)
      this.push(`${key}:${value}`);
  }

  // https://dom.spec.whatwg.org/#interface-event

  /* c8 ignore start */

  // Node 15 has Event but 14 and 12 don't
  const BUBBLING_PHASE = 3;
  const AT_TARGET = 2;
  const CAPTURING_PHASE = 1;
  const NONE = 0;

  function getCurrentTarget(ev) {
    return ev.currentTarget;
  }

  /**
   * @implements globalThis.Event
   */
  class GlobalEvent {
      static get BUBBLING_PHASE() { return BUBBLING_PHASE; }
      static get AT_TARGET() { return AT_TARGET; }
      static get CAPTURING_PHASE() { return CAPTURING_PHASE; }
      static get NONE() { return NONE; }

      constructor(type, eventInitDict = {}) {
        this.type = type;
        this.bubbles = !!eventInitDict.bubbles;
        this.cancelBubble = false;
        this._stopImmediatePropagationFlag = false;
        this.cancelable = !!eventInitDict.cancelable;
        this.eventPhase = this.NONE;
        this.timeStamp = Date.now();
        this.defaultPrevented = false;
        this.originalTarget = null;
        this.returnValue = null;
        this.srcElement = null;
        this.target = null;
        this._path = [];
      }

      get BUBBLING_PHASE() { return BUBBLING_PHASE; }
      get AT_TARGET() { return AT_TARGET; }
      get CAPTURING_PHASE() { return CAPTURING_PHASE; }
      get NONE() { return NONE; }

      preventDefault() { this.defaultPrevented = true; }

      // simplified implementation, should be https://dom.spec.whatwg.org/#dom-event-composedpath
      composedPath() {
        return this._path.map(getCurrentTarget);
      }

      stopPropagation() {
        this.cancelBubble = true;
      }
      
      stopImmediatePropagation() {
        this.stopPropagation();
        this._stopImmediatePropagationFlag = true;
      }
    }

  /* c8 ignore stop */

  /**
   * @implements globalThis.NamedNodeMap
   */
  class NamedNodeMap extends Array {
    constructor(ownerElement) {
      super();
      this.ownerElement = ownerElement;
    }

    getNamedItem(name) {
      return this.ownerElement.getAttributeNode(name);
    }

    setNamedItem(attr) {
      this.ownerElement.setAttributeNode(attr);
      this.unshift(attr);
    }

    removeNamedItem(name) {
      const item = this.getNamedItem(name);
      this.ownerElement.removeAttribute(name);
      this.splice(this.indexOf(item), 1);
    }

    item(index) {
      return index < this.length ? this[index] : null;
    }

    /* c8 ignore start */
    getNamedItemNS(_, name) {
      return this.getNamedItem(name);
    }

    setNamedItemNS(_, attr) {
      return this.setNamedItem(attr);
    }

    removeNamedItemNS(_, name) {
      return this.removeNamedItem(name);
    }
    /* c8 ignore stop */
  }

  /**
   * @implements globalThis.ShadowRoot
   */
  let ShadowRoot$1 = class ShadowRoot extends NonElementParentNode {
    constructor(host) {
      super(host.ownerDocument, '#shadow-root', DOCUMENT_FRAGMENT_NODE);
      this.host = host;
    }

    get innerHTML() {
      return getInnerHtml(this);
    }
    set innerHTML(html) {
      setInnerHtml(this, html);
    }
  };

  // https://dom.spec.whatwg.org/#interface-element


  // <utils>
  const attributesHandler = {
    get(target, key) {
      return key in target ? target[key] : target.find(({name}) => name === key);
    }
  };

  const create = (ownerDocument, element, localName)  => {
    if ('ownerSVGElement' in element) {
      const svg = ownerDocument.createElementNS(SVG_NAMESPACE, localName);
      svg.ownerSVGElement = element.ownerSVGElement;
      return svg;
    }
    return ownerDocument.createElement(localName);
  };

  const isVoid = ({localName, ownerDocument}) => {
    return ownerDocument[MIME].voidElements.test(localName);
  };

  // </utils>

  /**
   * @implements globalThis.Element
   */
  let Element$2 = class Element extends ParentNode {
    constructor(ownerDocument, localName) {
      super(ownerDocument, localName, ELEMENT_NODE);
      this[CLASS_LIST] = null;
      this[DATASET] = null;
      this[STYLE] = null;
    }

    // <Mixins>
    get isConnected() { return isConnected(this); }
    get parentElement() { return parentElement(this); }
    get previousSibling() { return previousSibling(this); }
    get nextSibling() { return nextSibling(this); }
    get namespaceURI() {
      return 'http://www.w3.org/1999/xhtml';
    }

    get previousElementSibling() { return previousElementSibling(this); }
    get nextElementSibling() { return nextElementSibling(this); }

    before(...nodes) { before(this, nodes); }
    after(...nodes) { after(this, nodes); }
    replaceWith(...nodes) { replaceWith(this, nodes); }
    remove() { remove(this[PREV], this, this[END][NEXT]); }
    // </Mixins>

    // <specialGetters>
    get id() { return stringAttribute.get(this, 'id'); }
    set id(value) { stringAttribute.set(this, 'id', value); }

    get className() { return this.classList.value; }
    set className(value) {
      const {classList} = this;
      classList.clear();
      classList.add(...($String(value).split(/\s+/)));
    }

    get nodeName() { return localCase(this); }
    get tagName() { return localCase(this); }

    get classList() {
      return this[CLASS_LIST] || (
        this[CLASS_LIST] = new DOMTokenList(this)
      );
    }

    get dataset() {
      return this[DATASET] || (
        this[DATASET] = new DOMStringMap(this)
      );
    }

    getBoundingClientRect() {
      return {
        x: 0,
        y: 0,
        bottom: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0,
        width: 0
      };
    }

    get nonce() { return stringAttribute.get(this, 'nonce'); }
    set nonce(value) { stringAttribute.set(this, 'nonce', value); }

    get style() {
      return this[STYLE] || (
        this[STYLE] = new CSSStyleDeclaration$1(this)
      );
    }

    get tabIndex() { return numericAttribute.get(this, 'tabindex') || -1; }
    set tabIndex(value) { numericAttribute.set(this, 'tabindex', value); }

    get slot() { return stringAttribute.get(this, 'slot'); }
    set slot(value) { stringAttribute.set(this, 'slot', value); }
    // </specialGetters>


    // <contentRelated>
    get innerText() {
      const text = [];
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        if (next.nodeType === TEXT_NODE) {
          text.push(next.textContent.replace(/\s+/g, ' '));
        } else if(
          text.length && next[NEXT] != end &&
          BLOCK_ELEMENTS.has(next.tagName)
        ) {
          text.push('\n');
        }
        next = next[NEXT];
      }
      return text.join('');
    }

    /**
     * @returns {String}
     */
    get textContent() {
      const text = [];
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        const nodeType = next.nodeType;
        if (nodeType === TEXT_NODE || nodeType === CDATA_SECTION_NODE)
          text.push(next.textContent);
        next = next[NEXT];
      }
      return text.join('');
    }

    set textContent(text) {
      this.replaceChildren();
      if (text != null && text !== '')
        this.appendChild(new Text$1(this.ownerDocument, text));
    }

    get innerHTML() {
      return getInnerHtml(this);
    }
    set innerHTML(html) {
      setInnerHtml(this, html);
    }

    get outerHTML() { return this.toString(); }
    set outerHTML(html) {
      const template = this.ownerDocument.createElement('');
      template.innerHTML = html;
      this.replaceWith(...template.childNodes);
    }
    // </contentRelated>

    // <attributes>
    get attributes() {
      const attributes = new NamedNodeMap(this);
      let next = this[NEXT];
      while (next.nodeType === ATTRIBUTE_NODE) {
        attributes.push(next);
        next = next[NEXT];
      }
      return new Proxy(attributes, attributesHandler);
    }

    focus() { this.dispatchEvent(new GlobalEvent('focus')); }

    getAttribute(name) {
      if (name === 'class')
        return this.className;
      const attribute = this.getAttributeNode(name);
      return attribute && (ignoreCase(this) ? attribute.value : escape(attribute.value));
    }

    getAttributeNode(name) {
      let next = this[NEXT];
      while (next.nodeType === ATTRIBUTE_NODE) {
        if (next.name === name)
          return next;
        next = next[NEXT];
      }
      return null;
    }

    getAttributeNames() {
      const attributes = new NodeList;
      let next = this[NEXT];
      while (next.nodeType === ATTRIBUTE_NODE) {
        attributes.push(next.name);
        next = next[NEXT];
      }
      return attributes;
    }

    hasAttribute(name) { return !!this.getAttributeNode(name); }
    hasAttributes() { return this[NEXT].nodeType === ATTRIBUTE_NODE; }

    removeAttribute(name) {
      if (name === 'class' && this[CLASS_LIST])
          this[CLASS_LIST].clear();
      let next = this[NEXT];
      while (next.nodeType === ATTRIBUTE_NODE) {
        if (next.name === name) {
          removeAttribute(this, next);
          return;
        }
        next = next[NEXT];
      }
    }

    removeAttributeNode(attribute) {
      let next = this[NEXT];
      while (next.nodeType === ATTRIBUTE_NODE) {
        if (next === attribute) {
          removeAttribute(this, next);
          return;
        }
        next = next[NEXT];
      }
    }

    setAttribute(name, value) {
      if (name === 'class')
        this.className = value;
      else {
        const attribute = this.getAttributeNode(name);
        if (attribute)
          attribute.value = value;
        else
          setAttribute(this, new Attr$1(this.ownerDocument, name, value));
      }
    }

    setAttributeNode(attribute) {
      const {name} = attribute;
      const previously = this.getAttributeNode(name);
      if (previously !== attribute) {
        if (previously)
          this.removeAttributeNode(previously);
        const {ownerElement} = attribute;
        if (ownerElement)
          ownerElement.removeAttributeNode(attribute);
        setAttribute(this, attribute);
      }
      return previously;
    }

    toggleAttribute(name, force) {
      if (this.hasAttribute(name)) {
        if (!force) {
          this.removeAttribute(name);
          return false;
        }
        return true;
      }
      else if (force || arguments.length === 1) {
        this.setAttribute(name, '');
        return true;
      }
      return false;
    }
    // </attributes>

    // <ShadowDOM>
    get shadowRoot() {
      if (shadowRoots.has(this)) {
        const {mode, shadowRoot} = shadowRoots.get(this);
        if (mode === 'open')
          return shadowRoot;
      }
      return null;
    }

    attachShadow(init) {
      if (shadowRoots.has(this))
        throw new Error('operation not supported');
      // TODO: shadowRoot should be likely a specialized class that extends DocumentFragment
      //       but until DSD is out, I am not sure I should spend time on this.
      const shadowRoot = new ShadowRoot$1(this);
      shadowRoots.set(this, {
        mode: init.mode,
        shadowRoot
      });
      return shadowRoot;
    }
    // </ShadowDOM>

    // <selectors>
    matches(selectors) { return matches(this, selectors); }
    closest(selectors) {
      let parentElement = this;
      const matches = prepareMatch(parentElement, selectors);
      while (parentElement && !matches(parentElement))
        parentElement = parentElement.parentElement;
      return parentElement;
    }
    // </selectors>

    // <insertAdjacent>
    insertAdjacentElement(position, element) {
      const {parentElement} = this;
      switch (position) {
        case 'beforebegin':
          if (parentElement) {
            parentElement.insertBefore(element, this);
            break;
          }
          return null;
        case 'afterbegin':
          this.insertBefore(element, this.firstChild);
          break;
        case 'beforeend':
          this.insertBefore(element, null);
          break;
        case 'afterend':
          if (parentElement) {
            parentElement.insertBefore(element, this.nextSibling);
            break;
          }
          return null;
      }
      return element;
    }

    insertAdjacentHTML(position, html) {
      this.insertAdjacentElement(position, htmlToFragment(this.ownerDocument, html));
    }

    insertAdjacentText(position, text) {
      const node = this.ownerDocument.createTextNode(text);
      this.insertAdjacentElement(position, node);
    }
    // </insertAdjacent>

    cloneNode(deep = false) {
      const {ownerDocument, localName} = this;
      const addNext = next => {
        next.parentNode = parentNode;
        knownAdjacent($next, next);
        $next = next;
      };
      const clone = create(ownerDocument, this, localName);
      let parentNode = clone, $next = clone;
      let {[NEXT]: next, [END]: prev} = this;
      while (next !== prev && (deep || next.nodeType === ATTRIBUTE_NODE)) {
        switch (next.nodeType) {
          case NODE_END:
            knownAdjacent($next, parentNode[END]);
            $next = parentNode[END];
            parentNode = parentNode.parentNode;
            break;
          case ELEMENT_NODE: {
            const node = create(ownerDocument, next, next.localName);
            addNext(node);
            parentNode = node;
            break;
          }
          case ATTRIBUTE_NODE: {
            const attr = next.cloneNode(deep);
            attr.ownerElement = parentNode;
            addNext(attr);
            break;
          }
          case TEXT_NODE:
          case COMMENT_NODE:
          case CDATA_SECTION_NODE:
            addNext(next.cloneNode(deep));
            break;
        }
        next = next[NEXT];
      }
      knownAdjacent($next, clone[END]);
      return clone;
    }

    // <custom>
    toString() {
      const out = [];
      const {[END]: end} = this;
      let next = {[NEXT]: this};
      let isOpened = false;
      do {
        next = next[NEXT];
        switch (next.nodeType) {
          case ATTRIBUTE_NODE: {
            const attr = ' ' + next;
            switch (attr) {
              case ' id':
              case ' class':
              case ' style':
                break;
              default:
                out.push(attr);
            }
            break;
          }
          case NODE_END: {
            const start = next[START];
            if (isOpened) {
              if ('ownerSVGElement' in start)
                out.push(' />');
              else if (isVoid(start))
                out.push(ignoreCase(start) ? '>' : ' />');
              else
                out.push(`></${start.localName}>`);
              isOpened = false;
            }
            else
              out.push(`</${start.localName}>`);
            break;
          }
          case ELEMENT_NODE:
            if (isOpened)
              out.push('>');
            if (next.toString !== this.toString) {
              out.push(next.toString());
              next = next[END];
              isOpened = false;
            }
            else {
              out.push(`<${next.localName}`);
              isOpened = true;
            }
            break;
          case TEXT_NODE:
          case COMMENT_NODE:
          case CDATA_SECTION_NODE:
            out.push((isOpened ? '>' : '') + next);
            isOpened = false;
            break;
        }
      } while (next !== end);
      return out.join('');
    }

    toJSON() {
      const json = [];
      elementAsJSON(this, json);
      return json;
    }
    // </custom>


    /* c8 ignore start */
    getAttributeNS(_, name) { return this.getAttribute(name); }
    getElementsByTagNameNS(_, name) { return this.getElementsByTagName(name); }
    hasAttributeNS(_, name) { return this.hasAttribute(name); }
    removeAttributeNS(_, name) { this.removeAttribute(name); }
    setAttributeNS(_, name, value) { this.setAttribute(name, value); }
    setAttributeNodeNS(attr) { return this.setAttributeNode(attr); }
    /* c8 ignore stop */
  };

  const classNames = new WeakMap;

  const handler = {
    get(target, name) {
      return target[name];
    },
    set(target, name, value) {
      target[name] = value;
      return true;
    }
  };

  /**
   * @implements globalThis.SVGElement
   */
  let SVGElement$1 = class SVGElement extends Element$2 {
    constructor(ownerDocument, localName, ownerSVGElement = null) {
      super(ownerDocument, localName);
      this.ownerSVGElement = ownerSVGElement;
    }

    get className() {
      if (!classNames.has(this))
        classNames.set(this, new Proxy({baseVal: '', animVal: ''}, handler));
      return classNames.get(this);
    }

    /* c8 ignore start */
    set className(value) {
      const {classList} = this;
      classList.clear();
      classList.add(...($String(value).split(/\s+/)));
    }
    /* c8 ignore stop */

    get namespaceURI() {
      return 'http://www.w3.org/2000/svg';
    }

    getAttribute(name) {
      return name === 'class' ?
        [...this.classList].join(' ') :
        super.getAttribute(name);
    }

    setAttribute(name, value) {
      if (name === 'class')
        this.className = value;
      else if (name === 'style') {
        const {className} = this;
        className.baseVal = className.animVal = value;
      }
      super.setAttribute(name, value);
    }
  };

  /* c8 ignore start */
  const illegalConstructor = () => {
    throw new TypeError('Illegal constructor');
  };

  function Attr() { illegalConstructor(); }
  setPrototypeOf(Attr, Attr$1);
  Attr.prototype = Attr$1.prototype;

  function CDATASection() { illegalConstructor(); }
  setPrototypeOf(CDATASection, CDATASection$1);
  CDATASection.prototype = CDATASection$1.prototype;

  function CharacterData() { illegalConstructor(); }
  setPrototypeOf(CharacterData, CharacterData$1);
  CharacterData.prototype = CharacterData$1.prototype;

  function Comment() { illegalConstructor(); }
  setPrototypeOf(Comment, Comment$1);
  Comment.prototype = Comment$1.prototype;

  function DocumentFragment() { illegalConstructor(); }
  setPrototypeOf(DocumentFragment, DocumentFragment$1);
  DocumentFragment.prototype = DocumentFragment$1.prototype;

  function DocumentType() { illegalConstructor(); }
  setPrototypeOf(DocumentType, DocumentType$1);
  DocumentType.prototype = DocumentType$1.prototype;

  function Element$1() { illegalConstructor(); }
  setPrototypeOf(Element$1, Element$2);
  Element$1.prototype = Element$2.prototype;

  function Node() { illegalConstructor(); }
  setPrototypeOf(Node, Node$1);
  Node.prototype = Node$1.prototype;

  function ShadowRoot() { illegalConstructor(); }
  setPrototypeOf(ShadowRoot, ShadowRoot$1);
  ShadowRoot.prototype = ShadowRoot$1.prototype;

  function Text() { illegalConstructor(); }
  setPrototypeOf(Text, Text$1);
  Text.prototype = Text$1.prototype;

  function SVGElement() { illegalConstructor(); }
  setPrototypeOf(SVGElement, SVGElement$1);
  SVGElement.prototype = SVGElement$1.prototype;
  /* c8 ignore stop */

  const Facades = {
    Attr,
    CDATASection,
    CharacterData,
    Comment,
    DocumentFragment,
    DocumentType,
    Element: Element$1,
    Node,
    ShadowRoot,
    Text,
    SVGElement
  };

  const Level0 = new WeakMap;
  const level0 = {
    get(element, name) {
      return Level0.has(element) && Level0.get(element)[name] || null;
    },
    set(element, name, value) {
      if (!Level0.has(element))
        Level0.set(element, {});
      const handlers = Level0.get(element);
      const type = name.slice(2);
      if (handlers[name])
        element.removeEventListener(type, handlers[name], false);
      if ((handlers[name] = value))
        element.addEventListener(type, value, false);
    }
  };

  /**
   * @implements globalThis.HTMLElement
   */
  let HTMLElement$1 = class HTMLElement extends Element$2 {

    static get observedAttributes() { return []; }

    constructor(ownerDocument = null, localName = '') {
      super(ownerDocument, localName);

      const ownerLess = !ownerDocument;
      let options;

      if (ownerLess) {
        const {constructor: Class} = this;
        if (!Classes.has(Class))
          throw new Error('unable to initialize this Custom Element');
        ({ownerDocument, localName, options} = Classes.get(Class));
      }

      if (ownerDocument[UPGRADE]) {
        const {element, values} = ownerDocument[UPGRADE];
        ownerDocument[UPGRADE] = null;
        for (const [key, value] of values)
          element[key] = value;
        return element;
      }

      if (ownerLess) {
        this.ownerDocument = this[END].ownerDocument = ownerDocument;
        this.localName = localName;
        customElements.set(this, {connected: false});
        if (options.is)
          this.setAttribute('is', options.is);
      }
    }

    /* c8 ignore start */

    /* TODO: what about these?
    offsetHeight
    offsetLeft
    offsetParent
    offsetTop
    offsetWidth
    */

    blur() { this.dispatchEvent(new GlobalEvent('blur')); }
    click() {
      const clickEvent = new GlobalEvent('click', {bubbles: true, cancelable: true});
      clickEvent.button = 0;

      this.dispatchEvent(clickEvent);
    }

    // Boolean getters
    get accessKeyLabel() {
      const {accessKey} = this;
      return accessKey && `Alt+Shift+${accessKey}`;
    }
    get isContentEditable() { return this.hasAttribute('contenteditable'); }

    // Boolean Accessors
    get contentEditable() { return booleanAttribute.get(this, 'contenteditable'); }
    set contentEditable(value) { booleanAttribute.set(this, 'contenteditable', value); }
    get draggable() { return booleanAttribute.get(this, 'draggable'); }
    set draggable(value) { booleanAttribute.set(this, 'draggable', value); }
    get hidden() { return booleanAttribute.get(this, 'hidden'); }
    set hidden(value) { booleanAttribute.set(this, 'hidden', value); }
    get spellcheck() { return booleanAttribute.get(this, 'spellcheck'); }
    set spellcheck(value) { booleanAttribute.set(this, 'spellcheck', value); }

    // String Accessors
    get accessKey() { return stringAttribute.get(this, 'accesskey'); }
    set accessKey(value) { stringAttribute.set(this, 'accesskey', value); }
    get dir() { return stringAttribute.get(this, 'dir'); }
    set dir(value) { stringAttribute.set(this, 'dir', value); }
    get lang() { return stringAttribute.get(this, 'lang'); }
    set lang(value) { stringAttribute.set(this, 'lang', value); }
    get title() { return stringAttribute.get(this, 'title'); }
    set title(value) { stringAttribute.set(this, 'title', value); }

    // DOM Level 0
    get onabort() { return level0.get(this, 'onabort'); }
    set onabort(value) { level0.set(this, 'onabort', value); }

    get onblur() { return level0.get(this, 'onblur'); }
    set onblur(value) { level0.set(this, 'onblur', value); }

    get oncancel() { return level0.get(this, 'oncancel'); }
    set oncancel(value) { level0.set(this, 'oncancel', value); }

    get oncanplay() { return level0.get(this, 'oncanplay'); }
    set oncanplay(value) { level0.set(this, 'oncanplay', value); }

    get oncanplaythrough() { return level0.get(this, 'oncanplaythrough'); }
    set oncanplaythrough(value) { level0.set(this, 'oncanplaythrough', value); }

    get onchange() { return level0.get(this, 'onchange'); }
    set onchange(value) { level0.set(this, 'onchange', value); }

    get onclick() { return level0.get(this, 'onclick'); }
    set onclick(value) { level0.set(this, 'onclick', value); }

    get onclose() { return level0.get(this, 'onclose'); }
    set onclose(value) { level0.set(this, 'onclose', value); }

    get oncontextmenu() { return level0.get(this, 'oncontextmenu'); }
    set oncontextmenu(value) { level0.set(this, 'oncontextmenu', value); }

    get oncuechange() { return level0.get(this, 'oncuechange'); }
    set oncuechange(value) { level0.set(this, 'oncuechange', value); }

    get ondblclick() { return level0.get(this, 'ondblclick'); }
    set ondblclick(value) { level0.set(this, 'ondblclick', value); }

    get ondrag() { return level0.get(this, 'ondrag'); }
    set ondrag(value) { level0.set(this, 'ondrag', value); }

    get ondragend() { return level0.get(this, 'ondragend'); }
    set ondragend(value) { level0.set(this, 'ondragend', value); }

    get ondragenter() { return level0.get(this, 'ondragenter'); }
    set ondragenter(value) { level0.set(this, 'ondragenter', value); }

    get ondragleave() { return level0.get(this, 'ondragleave'); }
    set ondragleave(value) { level0.set(this, 'ondragleave', value); }

    get ondragover() { return level0.get(this, 'ondragover'); }
    set ondragover(value) { level0.set(this, 'ondragover', value); }

    get ondragstart() { return level0.get(this, 'ondragstart'); }
    set ondragstart(value) { level0.set(this, 'ondragstart', value); }

    get ondrop() { return level0.get(this, 'ondrop'); }
    set ondrop(value) { level0.set(this, 'ondrop', value); }

    get ondurationchange() { return level0.get(this, 'ondurationchange'); }
    set ondurationchange(value) { level0.set(this, 'ondurationchange', value); }

    get onemptied() { return level0.get(this, 'onemptied'); }
    set onemptied(value) { level0.set(this, 'onemptied', value); }

    get onended() { return level0.get(this, 'onended'); }
    set onended(value) { level0.set(this, 'onended', value); }

    get onerror() { return level0.get(this, 'onerror'); }
    set onerror(value) { level0.set(this, 'onerror', value); }

    get onfocus() { return level0.get(this, 'onfocus'); }
    set onfocus(value) { level0.set(this, 'onfocus', value); }

    get oninput() { return level0.get(this, 'oninput'); }
    set oninput(value) { level0.set(this, 'oninput', value); }

    get oninvalid() { return level0.get(this, 'oninvalid'); }
    set oninvalid(value) { level0.set(this, 'oninvalid', value); }

    get onkeydown() { return level0.get(this, 'onkeydown'); }
    set onkeydown(value) { level0.set(this, 'onkeydown', value); }

    get onkeypress() { return level0.get(this, 'onkeypress'); }
    set onkeypress(value) { level0.set(this, 'onkeypress', value); }

    get onkeyup() { return level0.get(this, 'onkeyup'); }
    set onkeyup(value) { level0.set(this, 'onkeyup', value); }

    get onload() { return level0.get(this, 'onload'); }
    set onload(value) { level0.set(this, 'onload', value); }

    get onloadeddata() { return level0.get(this, 'onloadeddata'); }
    set onloadeddata(value) { level0.set(this, 'onloadeddata', value); }

    get onloadedmetadata() { return level0.get(this, 'onloadedmetadata'); }
    set onloadedmetadata(value) { level0.set(this, 'onloadedmetadata', value); }

    get onloadstart() { return level0.get(this, 'onloadstart'); }
    set onloadstart(value) { level0.set(this, 'onloadstart', value); }

    get onmousedown() { return level0.get(this, 'onmousedown'); }
    set onmousedown(value) { level0.set(this, 'onmousedown', value); }

    get onmouseenter() { return level0.get(this, 'onmouseenter'); }
    set onmouseenter(value) { level0.set(this, 'onmouseenter', value); }

    get onmouseleave() { return level0.get(this, 'onmouseleave'); }
    set onmouseleave(value) { level0.set(this, 'onmouseleave', value); }

    get onmousemove() { return level0.get(this, 'onmousemove'); }
    set onmousemove(value) { level0.set(this, 'onmousemove', value); }

    get onmouseout() { return level0.get(this, 'onmouseout'); }
    set onmouseout(value) { level0.set(this, 'onmouseout', value); }

    get onmouseover() { return level0.get(this, 'onmouseover'); }
    set onmouseover(value) { level0.set(this, 'onmouseover', value); }

    get onmouseup() { return level0.get(this, 'onmouseup'); }
    set onmouseup(value) { level0.set(this, 'onmouseup', value); }

    get onmousewheel() { return level0.get(this, 'onmousewheel'); }
    set onmousewheel(value) { level0.set(this, 'onmousewheel', value); }

    get onpause() { return level0.get(this, 'onpause'); }
    set onpause(value) { level0.set(this, 'onpause', value); }

    get onplay() { return level0.get(this, 'onplay'); }
    set onplay(value) { level0.set(this, 'onplay', value); }

    get onplaying() { return level0.get(this, 'onplaying'); }
    set onplaying(value) { level0.set(this, 'onplaying', value); }

    get onprogress() { return level0.get(this, 'onprogress'); }
    set onprogress(value) { level0.set(this, 'onprogress', value); }

    get onratechange() { return level0.get(this, 'onratechange'); }
    set onratechange(value) { level0.set(this, 'onratechange', value); }

    get onreset() { return level0.get(this, 'onreset'); }
    set onreset(value) { level0.set(this, 'onreset', value); }

    get onresize() { return level0.get(this, 'onresize'); }
    set onresize(value) { level0.set(this, 'onresize', value); }

    get onscroll() { return level0.get(this, 'onscroll'); }
    set onscroll(value) { level0.set(this, 'onscroll', value); }

    get onseeked() { return level0.get(this, 'onseeked'); }
    set onseeked(value) { level0.set(this, 'onseeked', value); }

    get onseeking() { return level0.get(this, 'onseeking'); }
    set onseeking(value) { level0.set(this, 'onseeking', value); }

    get onselect() { return level0.get(this, 'onselect'); }
    set onselect(value) { level0.set(this, 'onselect', value); }

    get onshow() { return level0.get(this, 'onshow'); }
    set onshow(value) { level0.set(this, 'onshow', value); }

    get onstalled() { return level0.get(this, 'onstalled'); }
    set onstalled(value) { level0.set(this, 'onstalled', value); }

    get onsubmit() { return level0.get(this, 'onsubmit'); }
    set onsubmit(value) { level0.set(this, 'onsubmit', value); }

    get onsuspend() { return level0.get(this, 'onsuspend'); }
    set onsuspend(value) { level0.set(this, 'onsuspend', value); }

    get ontimeupdate() { return level0.get(this, 'ontimeupdate'); }
    set ontimeupdate(value) { level0.set(this, 'ontimeupdate', value); }

    get ontoggle() { return level0.get(this, 'ontoggle'); }
    set ontoggle(value) { level0.set(this, 'ontoggle', value); }

    get onvolumechange() { return level0.get(this, 'onvolumechange'); }
    set onvolumechange(value) { level0.set(this, 'onvolumechange', value); }

    get onwaiting() { return level0.get(this, 'onwaiting'); }
    set onwaiting(value) { level0.set(this, 'onwaiting', value); }

    get onauxclick() { return level0.get(this, 'onauxclick'); }
    set onauxclick(value) { level0.set(this, 'onauxclick', value); }

    get ongotpointercapture() { return level0.get(this, 'ongotpointercapture'); }
    set ongotpointercapture(value) { level0.set(this, 'ongotpointercapture', value); }

    get onlostpointercapture() { return level0.get(this, 'onlostpointercapture'); }
    set onlostpointercapture(value) { level0.set(this, 'onlostpointercapture', value); }

    get onpointercancel() { return level0.get(this, 'onpointercancel'); }
    set onpointercancel(value) { level0.set(this, 'onpointercancel', value); }

    get onpointerdown() { return level0.get(this, 'onpointerdown'); }
    set onpointerdown(value) { level0.set(this, 'onpointerdown', value); }

    get onpointerenter() { return level0.get(this, 'onpointerenter'); }
    set onpointerenter(value) { level0.set(this, 'onpointerenter', value); }

    get onpointerleave() { return level0.get(this, 'onpointerleave'); }
    set onpointerleave(value) { level0.set(this, 'onpointerleave', value); }

    get onpointermove() { return level0.get(this, 'onpointermove'); }
    set onpointermove(value) { level0.set(this, 'onpointermove', value); }

    get onpointerout() { return level0.get(this, 'onpointerout'); }
    set onpointerout(value) { level0.set(this, 'onpointerout', value); }

    get onpointerover() { return level0.get(this, 'onpointerover'); }
    set onpointerover(value) { level0.set(this, 'onpointerover', value); }

    get onpointerup() { return level0.get(this, 'onpointerup'); }
    set onpointerup(value) { level0.set(this, 'onpointerup', value); }
    /* c8 ignore stop */

  };

  const tagName$h = 'template';

  /**
   * @implements globalThis.HTMLTemplateElement
   */
  class HTMLTemplateElement extends HTMLElement$1 {
    constructor(ownerDocument) {
      super(ownerDocument, tagName$h);
      const content = this.ownerDocument.createDocumentFragment();
      (this[CONTENT] = content)[PRIVATE] = this;
    }

    get content() {
      if (this.hasChildNodes() && !this[CONTENT].hasChildNodes()) {
        for (const node of this.childNodes)
          this[CONTENT].appendChild(node.cloneNode(true));
      }
      return this[CONTENT];
    }
  }

  registerHTMLClass(tagName$h, HTMLTemplateElement);

  /**
   * @implements globalThis.HTMLHtmlElement
   */
  class HTMLHtmlElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'html') {
      super(ownerDocument, localName);
    }
  }

  const {toString} = HTMLElement$1.prototype;

  class TextElement extends HTMLElement$1 {

    get innerHTML() { return this.textContent; }
    set innerHTML(html) { this.textContent = html; }

    toString() {
      const outerHTML = toString.call(this.cloneNode());
      return outerHTML.replace('><', () => `>${this.textContent}<`);
    }
  }

  const tagName$g = 'script';

  /**
   * @implements globalThis.HTMLScriptElement
   */
  class HTMLScriptElement extends TextElement {
    constructor(ownerDocument, localName = tagName$g) {
      super(ownerDocument, localName);
    }

    get type() {
      return stringAttribute.get(this, 'type');
    }
    set type(value) {
      stringAttribute.set(this, 'type', value);
    }

    get src() {
      return stringAttribute.get(this, 'src');
    }
    set src(value) {
      stringAttribute.set(this, 'src', value);
    }

    get defer() {
      return booleanAttribute.get(this, 'defer');
    }

    set defer(value) {
      booleanAttribute.set(this, 'defer', value);
    }

    get crossOrigin() {
      return stringAttribute.get(this, 'crossorigin');
    }
    set crossOrigin(value) {
      stringAttribute.set(this, 'crossorigin', value);
    }

    get nomodule() {
      return booleanAttribute.get(this, 'nomodule');
    }
    set nomodule(value) {
      booleanAttribute.set(this, 'nomodule', value);
    }

    get referrerPolicy() {
      return stringAttribute.get(this, 'referrerpolicy');
    }
    set referrerPolicy(value) {
      stringAttribute.set(this, 'referrerpolicy', value);
    }

    get nonce() {
      return stringAttribute.get(this, 'nonce');
    }
    set nonce(value) {
      stringAttribute.set(this, 'nonce', value);
    }

    get async() {
      return booleanAttribute.get(this, 'async');
    }
    set async(value) {
      booleanAttribute.set(this, 'async', value);
    }

    get text() { return this.textContent; }
    set text(content) { this.textContent = content; }
  }

  registerHTMLClass(tagName$g, HTMLScriptElement);

  /**
   * @implements globalThis.HTMLFrameElement
   */
  class HTMLFrameElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'frame') {
      super(ownerDocument, localName);
    }
  }

  const tagName$f = 'iframe';

  /**
   * @implements globalThis.HTMLIFrameElement
   */
  class HTMLIFrameElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$f) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get src() { return stringAttribute.get(this, 'src'); }
    set src(value) { stringAttribute.set(this, 'src', value); }

    get srcdoc() { return stringAttribute.get(this, "srcdoc"); }
    set srcdoc(value) { stringAttribute.set(this, "srcdoc", value); }

    get name() { return stringAttribute.get(this, "name"); }
    set name(value) { stringAttribute.set(this, "name", value); }

    get allow() { return stringAttribute.get(this, "allow"); }
    set allow(value) { stringAttribute.set(this, "allow", value); }

    get allowFullscreen() { return booleanAttribute.get(this, "allowfullscreen"); }
    set allowFullscreen(value) { booleanAttribute.set(this, "allowfullscreen", value); }
    
    get referrerPolicy() { return stringAttribute.get(this, "referrerpolicy"); }
    set referrerPolicy(value) { stringAttribute.set(this, "referrerpolicy", value); }
    
    get loading() { return stringAttribute.get(this, "loading"); }
    set loading(value) { stringAttribute.set(this, "loading", value); }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName$f, HTMLIFrameElement);

  /**
   * @implements globalThis.HTMLObjectElement
   */
  class HTMLObjectElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'object') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLHeadElement
   */
  class HTMLHeadElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'head') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLBodyElement
   */
  class HTMLBodyElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'body') {
      super(ownerDocument, localName);
    }
  }

  var CSSStyleDeclaration = {};

  var parse$1 = {};

  var CSSStyleSheet = {};

  var StyleSheet = {};

  //.CommonJS
  var CSSOM$c = {};
  ///CommonJS


  /**
   * @constructor
   * @see http://dev.w3.org/csswg/cssom/#the-stylesheet-interface
   */
  CSSOM$c.StyleSheet = function StyleSheet() {
  	this.parentStyleSheet = null;
  };


  //.CommonJS
  StyleSheet.StyleSheet = CSSOM$c.StyleSheet;

  var CSSStyleRule = {};

  var CSSRule = {};

  //.CommonJS
  var CSSOM$b = {};
  ///CommonJS


  /**
   * @constructor
   * @see http://dev.w3.org/csswg/cssom/#the-cssrule-interface
   * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSRule
   */
  CSSOM$b.CSSRule = function CSSRule() {
  	this.parentRule = null;
  	this.parentStyleSheet = null;
  };

  CSSOM$b.CSSRule.UNKNOWN_RULE = 0;                 // obsolete
  CSSOM$b.CSSRule.STYLE_RULE = 1;
  CSSOM$b.CSSRule.CHARSET_RULE = 2;                 // obsolete
  CSSOM$b.CSSRule.IMPORT_RULE = 3;
  CSSOM$b.CSSRule.MEDIA_RULE = 4;
  CSSOM$b.CSSRule.FONT_FACE_RULE = 5;
  CSSOM$b.CSSRule.PAGE_RULE = 6;
  CSSOM$b.CSSRule.KEYFRAMES_RULE = 7;
  CSSOM$b.CSSRule.KEYFRAME_RULE = 8;
  CSSOM$b.CSSRule.MARGIN_RULE = 9;
  CSSOM$b.CSSRule.NAMESPACE_RULE = 10;
  CSSOM$b.CSSRule.COUNTER_STYLE_RULE = 11;
  CSSOM$b.CSSRule.SUPPORTS_RULE = 12;
  CSSOM$b.CSSRule.DOCUMENT_RULE = 13;
  CSSOM$b.CSSRule.FONT_FEATURE_VALUES_RULE = 14;
  CSSOM$b.CSSRule.VIEWPORT_RULE = 15;
  CSSOM$b.CSSRule.REGION_STYLE_RULE = 16;


  CSSOM$b.CSSRule.prototype = {
  	constructor: CSSOM$b.CSSRule
  	//FIXME
  };


  //.CommonJS
  CSSRule.CSSRule = CSSOM$b.CSSRule;

  var hasRequiredCSSStyleRule;

  function requireCSSStyleRule () {
  	if (hasRequiredCSSStyleRule) return CSSStyleRule;
  	hasRequiredCSSStyleRule = 1;
  	//.CommonJS
  	var CSSOM = {
  		CSSStyleDeclaration: requireCSSStyleDeclaration().CSSStyleDeclaration,
  		CSSRule: CSSRule.CSSRule
  	};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://dev.w3.org/csswg/cssom/#cssstylerule
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleRule
  	 */
  	CSSOM.CSSStyleRule = function CSSStyleRule() {
  		CSSOM.CSSRule.call(this);
  		this.selectorText = "";
  		this.style = new CSSOM.CSSStyleDeclaration();
  		this.style.parentRule = this;
  	};

  	CSSOM.CSSStyleRule.prototype = new CSSOM.CSSRule();
  	CSSOM.CSSStyleRule.prototype.constructor = CSSOM.CSSStyleRule;
  	CSSOM.CSSStyleRule.prototype.type = 1;

  	Object.defineProperty(CSSOM.CSSStyleRule.prototype, "cssText", {
  		get: function() {
  			var text;
  			if (this.selectorText) {
  				text = this.selectorText + " {" + this.style.cssText + "}";
  			} else {
  				text = "";
  			}
  			return text;
  		},
  		set: function(cssText) {
  			var rule = CSSOM.CSSStyleRule.parse(cssText);
  			this.style = rule.style;
  			this.selectorText = rule.selectorText;
  		}
  	});


  	/**
  	 * NON-STANDARD
  	 * lightweight version of parse.js.
  	 * @param {string} ruleText
  	 * @return CSSStyleRule
  	 */
  	CSSOM.CSSStyleRule.parse = function(ruleText) {
  		var i = 0;
  		var state = "selector";
  		var index;
  		var j = i;
  		var buffer = "";

  		var SIGNIFICANT_WHITESPACE = {
  			"selector": true,
  			"value": true
  		};

  		var styleRule = new CSSOM.CSSStyleRule();
  		var name, priority="";

  		for (var character; (character = ruleText.charAt(i)); i++) {

  			switch (character) {

  			case " ":
  			case "\t":
  			case "\r":
  			case "\n":
  			case "\f":
  				if (SIGNIFICANT_WHITESPACE[state]) {
  					// Squash 2 or more white-spaces in the row into 1
  					switch (ruleText.charAt(i - 1)) {
  						case " ":
  						case "\t":
  						case "\r":
  						case "\n":
  						case "\f":
  							break;
  						default:
  							buffer += " ";
  							break;
  					}
  				}
  				break;

  			// String
  			case '"':
  				j = i + 1;
  				index = ruleText.indexOf('"', j) + 1;
  				if (!index) {
  					throw '" is missing';
  				}
  				buffer += ruleText.slice(i, index);
  				i = index - 1;
  				break;

  			case "'":
  				j = i + 1;
  				index = ruleText.indexOf("'", j) + 1;
  				if (!index) {
  					throw "' is missing";
  				}
  				buffer += ruleText.slice(i, index);
  				i = index - 1;
  				break;

  			// Comment
  			case "/":
  				if (ruleText.charAt(i + 1) === "*") {
  					i += 2;
  					index = ruleText.indexOf("*/", i);
  					if (index === -1) {
  						throw new SyntaxError("Missing */");
  					} else {
  						i = index + 1;
  					}
  				} else {
  					buffer += character;
  				}
  				break;

  			case "{":
  				if (state === "selector") {
  					styleRule.selectorText = buffer.trim();
  					buffer = "";
  					state = "name";
  				}
  				break;

  			case ":":
  				if (state === "name") {
  					name = buffer.trim();
  					buffer = "";
  					state = "value";
  				} else {
  					buffer += character;
  				}
  				break;

  			case "!":
  				if (state === "value" && ruleText.indexOf("!important", i) === i) {
  					priority = "important";
  					i += "important".length;
  				} else {
  					buffer += character;
  				}
  				break;

  			case ";":
  				if (state === "value") {
  					styleRule.style.setProperty(name, buffer.trim(), priority);
  					priority = "";
  					buffer = "";
  					state = "name";
  				} else {
  					buffer += character;
  				}
  				break;

  			case "}":
  				if (state === "value") {
  					styleRule.style.setProperty(name, buffer.trim(), priority);
  					priority = "";
  					buffer = "";
  				} else if (state === "name") {
  					break;
  				} else {
  					buffer += character;
  				}
  				state = "selector";
  				break;

  			default:
  				buffer += character;
  				break;

  			}
  		}

  		return styleRule;

  	};


  	//.CommonJS
  	CSSStyleRule.CSSStyleRule = CSSOM.CSSStyleRule;
  	///CommonJS
  	return CSSStyleRule;
  }

  var hasRequiredCSSStyleSheet;

  function requireCSSStyleSheet () {
  	if (hasRequiredCSSStyleSheet) return CSSStyleSheet;
  	hasRequiredCSSStyleSheet = 1;
  	//.CommonJS
  	var CSSOM = {
  		StyleSheet: StyleSheet.StyleSheet,
  		CSSStyleRule: requireCSSStyleRule().CSSStyleRule
  	};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet
  	 */
  	CSSOM.CSSStyleSheet = function CSSStyleSheet() {
  		CSSOM.StyleSheet.call(this);
  		this.cssRules = [];
  	};


  	CSSOM.CSSStyleSheet.prototype = new CSSOM.StyleSheet();
  	CSSOM.CSSStyleSheet.prototype.constructor = CSSOM.CSSStyleSheet;


  	/**
  	 * Used to insert a new rule into the style sheet. The new rule now becomes part of the cascade.
  	 *
  	 *   sheet = new Sheet("body {margin: 0}")
  	 *   sheet.toString()
  	 *   -> "body{margin:0;}"
  	 *   sheet.insertRule("img {border: none}", 0)
  	 *   -> 0
  	 *   sheet.toString()
  	 *   -> "img{border:none;}body{margin:0;}"
  	 *
  	 * @param {string} rule
  	 * @param {number} index
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet-insertRule
  	 * @return {number} The index within the style sheet's rule collection of the newly inserted rule.
  	 */
  	CSSOM.CSSStyleSheet.prototype.insertRule = function(rule, index) {
  		if (index < 0 || index > this.cssRules.length) {
  			throw new RangeError("INDEX_SIZE_ERR");
  		}
  		var cssRule = CSSOM.parse(rule).cssRules[0];
  		cssRule.parentStyleSheet = this;
  		this.cssRules.splice(index, 0, cssRule);
  		return index;
  	};


  	/**
  	 * Used to delete a rule from the style sheet.
  	 *
  	 *   sheet = new Sheet("img{border:none} body{margin:0}")
  	 *   sheet.toString()
  	 *   -> "img{border:none;}body{margin:0;}"
  	 *   sheet.deleteRule(0)
  	 *   sheet.toString()
  	 *   -> "body{margin:0;}"
  	 *
  	 * @param {number} index within the style sheet's rule list of the rule to remove.
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleSheet-deleteRule
  	 */
  	CSSOM.CSSStyleSheet.prototype.deleteRule = function(index) {
  		if (index < 0 || index >= this.cssRules.length) {
  			throw new RangeError("INDEX_SIZE_ERR");
  		}
  		this.cssRules.splice(index, 1);
  	};


  	/**
  	 * NON-STANDARD
  	 * @return {string} serialize stylesheet
  	 */
  	CSSOM.CSSStyleSheet.prototype.toString = function() {
  		var result = "";
  		var rules = this.cssRules;
  		for (var i=0; i<rules.length; i++) {
  			result += rules[i].cssText + "\n";
  		}
  		return result;
  	};


  	//.CommonJS
  	CSSStyleSheet.CSSStyleSheet = CSSOM.CSSStyleSheet;
  	CSSOM.parse = requireParse().parse; // Cannot be included sooner due to the mutual dependency between parse.js and CSSStyleSheet.js
  	///CommonJS
  	return CSSStyleSheet;
  }

  var CSSImportRule = {};

  var MediaList = {};

  //.CommonJS
  var CSSOM$a = {};
  ///CommonJS


  /**
   * @constructor
   * @see http://dev.w3.org/csswg/cssom/#the-medialist-interface
   */
  CSSOM$a.MediaList = function MediaList(){
  	this.length = 0;
  };

  CSSOM$a.MediaList.prototype = {

  	constructor: CSSOM$a.MediaList,

  	/**
  	 * @return {string}
  	 */
  	get mediaText() {
  		return Array.prototype.join.call(this, ", ");
  	},

  	/**
  	 * @param {string} value
  	 */
  	set mediaText(value) {
  		var values = value.split(",");
  		var length = this.length = values.length;
  		for (var i=0; i<length; i++) {
  			this[i] = values[i].trim();
  		}
  	},

  	/**
  	 * @param {string} medium
  	 */
  	appendMedium: function(medium) {
  		if (Array.prototype.indexOf.call(this, medium) === -1) {
  			this[this.length] = medium;
  			this.length++;
  		}
  	},

  	/**
  	 * @param {string} medium
  	 */
  	deleteMedium: function(medium) {
  		var index = Array.prototype.indexOf.call(this, medium);
  		if (index !== -1) {
  			Array.prototype.splice.call(this, index, 1);
  		}
  	}

  };


  //.CommonJS
  MediaList.MediaList = CSSOM$a.MediaList;

  var hasRequiredCSSImportRule;

  function requireCSSImportRule () {
  	if (hasRequiredCSSImportRule) return CSSImportRule;
  	hasRequiredCSSImportRule = 1;
  	//.CommonJS
  	var CSSOM = {
  		CSSRule: CSSRule.CSSRule,
  		CSSStyleSheet: requireCSSStyleSheet().CSSStyleSheet,
  		MediaList: MediaList.MediaList
  	};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://dev.w3.org/csswg/cssom/#cssimportrule
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSImportRule
  	 */
  	CSSOM.CSSImportRule = function CSSImportRule() {
  		CSSOM.CSSRule.call(this);
  		this.href = "";
  		this.media = new CSSOM.MediaList();
  		this.styleSheet = new CSSOM.CSSStyleSheet();
  	};

  	CSSOM.CSSImportRule.prototype = new CSSOM.CSSRule();
  	CSSOM.CSSImportRule.prototype.constructor = CSSOM.CSSImportRule;
  	CSSOM.CSSImportRule.prototype.type = 3;

  	Object.defineProperty(CSSOM.CSSImportRule.prototype, "cssText", {
  	  get: function() {
  	    var mediaText = this.media.mediaText;
  	    return "@import url(" + this.href + ")" + (mediaText ? " " + mediaText : "") + ";";
  	  },
  	  set: function(cssText) {
  	    var i = 0;

  	    /**
  	     * @import url(partial.css) screen, handheld;
  	     *        ||               |
  	     *        after-import     media
  	     *         |
  	     *         url
  	     */
  	    var state = '';

  	    var buffer = '';
  	    var index;
  	    for (var character; (character = cssText.charAt(i)); i++) {

  	      switch (character) {
  	        case ' ':
  	        case '\t':
  	        case '\r':
  	        case '\n':
  	        case '\f':
  	          if (state === 'after-import') {
  	            state = 'url';
  	          } else {
  	            buffer += character;
  	          }
  	          break;

  	        case '@':
  	          if (!state && cssText.indexOf('@import', i) === i) {
  	            state = 'after-import';
  	            i += 'import'.length;
  	            buffer = '';
  	          }
  	          break;

  	        case 'u':
  	          if (state === 'url' && cssText.indexOf('url(', i) === i) {
  	            index = cssText.indexOf(')', i + 1);
  	            if (index === -1) {
  	              throw i + ': ")" not found';
  	            }
  	            i += 'url('.length;
  	            var url = cssText.slice(i, index);
  	            if (url[0] === url[url.length - 1]) {
  	              if (url[0] === '"' || url[0] === "'") {
  	                url = url.slice(1, -1);
  	              }
  	            }
  	            this.href = url;
  	            i = index;
  	            state = 'media';
  	          }
  	          break;

  	        case '"':
  	          if (state === 'url') {
  	            index = cssText.indexOf('"', i + 1);
  	            if (!index) {
  	              throw i + ": '\"' not found";
  	            }
  	            this.href = cssText.slice(i + 1, index);
  	            i = index;
  	            state = 'media';
  	          }
  	          break;

  	        case "'":
  	          if (state === 'url') {
  	            index = cssText.indexOf("'", i + 1);
  	            if (!index) {
  	              throw i + ': "\'" not found';
  	            }
  	            this.href = cssText.slice(i + 1, index);
  	            i = index;
  	            state = 'media';
  	          }
  	          break;

  	        case ';':
  	          if (state === 'media') {
  	            if (buffer) {
  	              this.media.mediaText = buffer.trim();
  	            }
  	          }
  	          break;

  	        default:
  	          if (state === 'media') {
  	            buffer += character;
  	          }
  	          break;
  	      }
  	    }
  	  }
  	});


  	//.CommonJS
  	CSSImportRule.CSSImportRule = CSSOM.CSSImportRule;
  	///CommonJS
  	return CSSImportRule;
  }

  var CSSGroupingRule = {};

  //.CommonJS
  var CSSOM$9 = {
  	CSSRule: CSSRule.CSSRule
  };
  ///CommonJS


  /**
   * @constructor
   * @see https://drafts.csswg.org/cssom/#the-cssgroupingrule-interface
   */
  CSSOM$9.CSSGroupingRule = function CSSGroupingRule() {
  	CSSOM$9.CSSRule.call(this);
  	this.cssRules = [];
  };

  CSSOM$9.CSSGroupingRule.prototype = new CSSOM$9.CSSRule();
  CSSOM$9.CSSGroupingRule.prototype.constructor = CSSOM$9.CSSGroupingRule;


  /**
   * Used to insert a new CSS rule to a list of CSS rules.
   *
   * @example
   *   cssGroupingRule.cssText
   *   -> "body{margin:0;}"
   *   cssGroupingRule.insertRule("img{border:none;}", 1)
   *   -> 1
   *   cssGroupingRule.cssText
   *   -> "body{margin:0;}img{border:none;}"
   *
   * @param {string} rule
   * @param {number} [index]
   * @see https://www.w3.org/TR/cssom-1/#dom-cssgroupingrule-insertrule
   * @return {number} The index within the grouping rule's collection of the newly inserted rule.
   */
   CSSOM$9.CSSGroupingRule.prototype.insertRule = function insertRule(rule, index) {
  	if (index < 0 || index > this.cssRules.length) {
  		throw new RangeError("INDEX_SIZE_ERR");
  	}
  	var cssRule = CSSOM$9.parse(rule).cssRules[0];
  	cssRule.parentRule = this;
  	this.cssRules.splice(index, 0, cssRule);
  	return index;
  };

  /**
   * Used to delete a rule from the grouping rule.
   *
   *   cssGroupingRule.cssText
   *   -> "img{border:none;}body{margin:0;}"
   *   cssGroupingRule.deleteRule(0)
   *   cssGroupingRule.cssText
   *   -> "body{margin:0;}"
   *
   * @param {number} index within the grouping rule's rule list of the rule to remove.
   * @see https://www.w3.org/TR/cssom-1/#dom-cssgroupingrule-deleterule
   */
   CSSOM$9.CSSGroupingRule.prototype.deleteRule = function deleteRule(index) {
  	if (index < 0 || index >= this.cssRules.length) {
  		throw new RangeError("INDEX_SIZE_ERR");
  	}
  	this.cssRules.splice(index, 1)[0].parentRule = null;
  };

  //.CommonJS
  CSSGroupingRule.CSSGroupingRule = CSSOM$9.CSSGroupingRule;

  var CSSMediaRule = {};

  var CSSConditionRule = {};

  //.CommonJS
  var CSSOM$8 = {
    CSSRule: CSSRule.CSSRule,
    CSSGroupingRule: CSSGroupingRule.CSSGroupingRule
  };
  ///CommonJS


  /**
   * @constructor
   * @see https://www.w3.org/TR/css-conditional-3/#the-cssconditionrule-interface
   */
  CSSOM$8.CSSConditionRule = function CSSConditionRule() {
    CSSOM$8.CSSGroupingRule.call(this);
    this.cssRules = [];
  };

  CSSOM$8.CSSConditionRule.prototype = new CSSOM$8.CSSGroupingRule();
  CSSOM$8.CSSConditionRule.prototype.constructor = CSSOM$8.CSSConditionRule;
  CSSOM$8.CSSConditionRule.prototype.conditionText = '';
  CSSOM$8.CSSConditionRule.prototype.cssText = '';

  //.CommonJS
  CSSConditionRule.CSSConditionRule = CSSOM$8.CSSConditionRule;

  //.CommonJS
  var CSSOM$7 = {
  	CSSRule: CSSRule.CSSRule,
  	CSSGroupingRule: CSSGroupingRule.CSSGroupingRule,
  	CSSConditionRule: CSSConditionRule.CSSConditionRule,
  	MediaList: MediaList.MediaList
  };
  ///CommonJS


  /**
   * @constructor
   * @see http://dev.w3.org/csswg/cssom/#cssmediarule
   * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSMediaRule
   */
  CSSOM$7.CSSMediaRule = function CSSMediaRule() {
  	CSSOM$7.CSSConditionRule.call(this);
  	this.media = new CSSOM$7.MediaList();
  };

  CSSOM$7.CSSMediaRule.prototype = new CSSOM$7.CSSConditionRule();
  CSSOM$7.CSSMediaRule.prototype.constructor = CSSOM$7.CSSMediaRule;
  CSSOM$7.CSSMediaRule.prototype.type = 4;

  // https://opensource.apple.com/source/WebCore/WebCore-7611.1.21.161.3/css/CSSMediaRule.cpp
  Object.defineProperties(CSSOM$7.CSSMediaRule.prototype, {
    "conditionText": {
      get: function() {
        return this.media.mediaText;
      },
      set: function(value) {
        this.media.mediaText = value;
      },
      configurable: true,
      enumerable: true
    },
    "cssText": {
      get: function() {
        var cssTexts = [];
        for (var i=0, length=this.cssRules.length; i < length; i++) {
          cssTexts.push(this.cssRules[i].cssText);
        }
        return "@media " + this.media.mediaText + " {" + cssTexts.join("") + "}";
      },
      configurable: true,
      enumerable: true
    }
  });


  //.CommonJS
  CSSMediaRule.CSSMediaRule = CSSOM$7.CSSMediaRule;

  var CSSSupportsRule = {};

  //.CommonJS
  var CSSOM$6 = {
    CSSRule: CSSRule.CSSRule,
    CSSGroupingRule: CSSGroupingRule.CSSGroupingRule,
    CSSConditionRule: CSSConditionRule.CSSConditionRule
  };
  ///CommonJS


  /**
   * @constructor
   * @see https://drafts.csswg.org/css-conditional-3/#the-csssupportsrule-interface
   */
  CSSOM$6.CSSSupportsRule = function CSSSupportsRule() {
    CSSOM$6.CSSConditionRule.call(this);
  };

  CSSOM$6.CSSSupportsRule.prototype = new CSSOM$6.CSSConditionRule();
  CSSOM$6.CSSSupportsRule.prototype.constructor = CSSOM$6.CSSSupportsRule;
  CSSOM$6.CSSSupportsRule.prototype.type = 12;

  Object.defineProperty(CSSOM$6.CSSSupportsRule.prototype, "cssText", {
    get: function() {
      var cssTexts = [];

      for (var i = 0, length = this.cssRules.length; i < length; i++) {
        cssTexts.push(this.cssRules[i].cssText);
      }

      return "@supports " + this.conditionText + " {" + cssTexts.join("") + "}";
    }
  });

  //.CommonJS
  CSSSupportsRule.CSSSupportsRule = CSSOM$6.CSSSupportsRule;

  var CSSFontFaceRule = {};

  var hasRequiredCSSFontFaceRule;

  function requireCSSFontFaceRule () {
  	if (hasRequiredCSSFontFaceRule) return CSSFontFaceRule;
  	hasRequiredCSSFontFaceRule = 1;
  	//.CommonJS
  	var CSSOM = {
  		CSSStyleDeclaration: requireCSSStyleDeclaration().CSSStyleDeclaration,
  		CSSRule: CSSRule.CSSRule
  	};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://dev.w3.org/csswg/cssom/#css-font-face-rule
  	 */
  	CSSOM.CSSFontFaceRule = function CSSFontFaceRule() {
  		CSSOM.CSSRule.call(this);
  		this.style = new CSSOM.CSSStyleDeclaration();
  		this.style.parentRule = this;
  	};

  	CSSOM.CSSFontFaceRule.prototype = new CSSOM.CSSRule();
  	CSSOM.CSSFontFaceRule.prototype.constructor = CSSOM.CSSFontFaceRule;
  	CSSOM.CSSFontFaceRule.prototype.type = 5;
  	//FIXME
  	//CSSOM.CSSFontFaceRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
  	//CSSOM.CSSFontFaceRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

  	// http://www.opensource.apple.com/source/WebCore/WebCore-955.66.1/css/WebKitCSSFontFaceRule.cpp
  	Object.defineProperty(CSSOM.CSSFontFaceRule.prototype, "cssText", {
  	  get: function() {
  	    return "@font-face {" + this.style.cssText + "}";
  	  }
  	});


  	//.CommonJS
  	CSSFontFaceRule.CSSFontFaceRule = CSSOM.CSSFontFaceRule;
  	///CommonJS
  	return CSSFontFaceRule;
  }

  var CSSHostRule = {};

  //.CommonJS
  var CSSOM$5 = {
  	CSSRule: CSSRule.CSSRule
  };
  ///CommonJS


  /**
   * @constructor
   * @see http://www.w3.org/TR/shadow-dom/#host-at-rule
   */
  CSSOM$5.CSSHostRule = function CSSHostRule() {
  	CSSOM$5.CSSRule.call(this);
  	this.cssRules = [];
  };

  CSSOM$5.CSSHostRule.prototype = new CSSOM$5.CSSRule();
  CSSOM$5.CSSHostRule.prototype.constructor = CSSOM$5.CSSHostRule;
  CSSOM$5.CSSHostRule.prototype.type = 1001;
  //FIXME
  //CSSOM.CSSHostRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
  //CSSOM.CSSHostRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

  Object.defineProperty(CSSOM$5.CSSHostRule.prototype, "cssText", {
  	get: function() {
  		var cssTexts = [];
  		for (var i=0, length=this.cssRules.length; i < length; i++) {
  			cssTexts.push(this.cssRules[i].cssText);
  		}
  		return "@host {" + cssTexts.join("") + "}";
  	}
  });


  //.CommonJS
  CSSHostRule.CSSHostRule = CSSOM$5.CSSHostRule;

  var CSSKeyframeRule = {};

  var hasRequiredCSSKeyframeRule;

  function requireCSSKeyframeRule () {
  	if (hasRequiredCSSKeyframeRule) return CSSKeyframeRule;
  	hasRequiredCSSKeyframeRule = 1;
  	//.CommonJS
  	var CSSOM = {
  		CSSRule: CSSRule.CSSRule,
  		CSSStyleDeclaration: requireCSSStyleDeclaration().CSSStyleDeclaration
  	};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://www.w3.org/TR/css3-animations/#DOM-CSSKeyframeRule
  	 */
  	CSSOM.CSSKeyframeRule = function CSSKeyframeRule() {
  		CSSOM.CSSRule.call(this);
  		this.keyText = '';
  		this.style = new CSSOM.CSSStyleDeclaration();
  		this.style.parentRule = this;
  	};

  	CSSOM.CSSKeyframeRule.prototype = new CSSOM.CSSRule();
  	CSSOM.CSSKeyframeRule.prototype.constructor = CSSOM.CSSKeyframeRule;
  	CSSOM.CSSKeyframeRule.prototype.type = 8;
  	//FIXME
  	//CSSOM.CSSKeyframeRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
  	//CSSOM.CSSKeyframeRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

  	// http://www.opensource.apple.com/source/WebCore/WebCore-955.66.1/css/WebKitCSSKeyframeRule.cpp
  	Object.defineProperty(CSSOM.CSSKeyframeRule.prototype, "cssText", {
  	  get: function() {
  	    return this.keyText + " {" + this.style.cssText + "} ";
  	  }
  	});


  	//.CommonJS
  	CSSKeyframeRule.CSSKeyframeRule = CSSOM.CSSKeyframeRule;
  	///CommonJS
  	return CSSKeyframeRule;
  }

  var CSSKeyframesRule = {};

  //.CommonJS
  var CSSOM$4 = {
  	CSSRule: CSSRule.CSSRule
  };
  ///CommonJS


  /**
   * @constructor
   * @see http://www.w3.org/TR/css3-animations/#DOM-CSSKeyframesRule
   */
  CSSOM$4.CSSKeyframesRule = function CSSKeyframesRule() {
  	CSSOM$4.CSSRule.call(this);
  	this.name = '';
  	this.cssRules = [];
  };

  CSSOM$4.CSSKeyframesRule.prototype = new CSSOM$4.CSSRule();
  CSSOM$4.CSSKeyframesRule.prototype.constructor = CSSOM$4.CSSKeyframesRule;
  CSSOM$4.CSSKeyframesRule.prototype.type = 7;
  //FIXME
  //CSSOM.CSSKeyframesRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
  //CSSOM.CSSKeyframesRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

  // http://www.opensource.apple.com/source/WebCore/WebCore-955.66.1/css/WebKitCSSKeyframesRule.cpp
  Object.defineProperty(CSSOM$4.CSSKeyframesRule.prototype, "cssText", {
    get: function() {
      var cssTexts = [];
      for (var i=0, length=this.cssRules.length; i < length; i++) {
        cssTexts.push("  " + this.cssRules[i].cssText);
      }
      return "@" + (this._vendorPrefix || '') + "keyframes " + this.name + " { \n" + cssTexts.join("\n") + "\n}";
    }
  });


  //.CommonJS
  CSSKeyframesRule.CSSKeyframesRule = CSSOM$4.CSSKeyframesRule;

  var CSSValueExpression = {};

  var CSSValue = {};

  //.CommonJS
  var CSSOM$3 = {};
  ///CommonJS


  /**
   * @constructor
   * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSValue
   *
   * TODO: add if needed
   */
  CSSOM$3.CSSValue = function CSSValue() {
  };

  CSSOM$3.CSSValue.prototype = {
  	constructor: CSSOM$3.CSSValue,

  	// @see: http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSValue
  	set cssText(text) {
  		var name = this._getConstructorName();

  		throw new Error('DOMException: property "cssText" of "' + name + '" is readonly and can not be replaced with "' + text + '"!');
  	},

  	get cssText() {
  		var name = this._getConstructorName();

  		throw new Error('getter "cssText" of "' + name + '" is not implemented!');
  	},

  	_getConstructorName: function() {
  		var s = this.constructor.toString(),
  				c = s.match(/function\s([^\(]+)/),
  				name = c[1];

  		return name;
  	}
  };


  //.CommonJS
  CSSValue.CSSValue = CSSOM$3.CSSValue;

  //.CommonJS
  var CSSOM$2 = {
  	CSSValue: CSSValue.CSSValue
  };
  ///CommonJS


  /**
   * @constructor
   * @see http://msdn.microsoft.com/en-us/library/ms537634(v=vs.85).aspx
   *
   */
  CSSOM$2.CSSValueExpression = function CSSValueExpression(token, idx) {
  	this._token = token;
  	this._idx = idx;
  };

  CSSOM$2.CSSValueExpression.prototype = new CSSOM$2.CSSValue();
  CSSOM$2.CSSValueExpression.prototype.constructor = CSSOM$2.CSSValueExpression;

  /**
   * parse css expression() value
   *
   * @return {Object}
   *         - error:
   *         or
   *         - idx:
   *         - expression:
   *
   * Example:
   *
   * .selector {
   *		zoom: expression(documentElement.clientWidth > 1000 ? '1000px' : 'auto');
   * }
   */
  CSSOM$2.CSSValueExpression.prototype.parse = function() {
  	var token = this._token,
  			idx = this._idx;

  	var character = '',
  			expression = '',
  			error = '',
  			info,
  			paren = [];


  	for (; ; ++idx) {
  		character = token.charAt(idx);

  		// end of token
  		if (character === '') {
  			error = 'css expression error: unfinished expression!';
  			break;
  		}

  		switch(character) {
  			case '(':
  				paren.push(character);
  				expression += character;
  				break;

  			case ')':
  				paren.pop(character);
  				expression += character;
  				break;

  			case '/':
  				if ((info = this._parseJSComment(token, idx))) { // comment?
  					if (info.error) {
  						error = 'css expression error: unfinished comment in expression!';
  					} else {
  						idx = info.idx;
  						// ignore the comment
  					}
  				} else if ((info = this._parseJSRexExp(token, idx))) { // regexp
  					idx = info.idx;
  					expression += info.text;
  				} else { // other
  					expression += character;
  				}
  				break;

  			case "'":
  			case '"':
  				info = this._parseJSString(token, idx, character);
  				if (info) { // string
  					idx = info.idx;
  					expression += info.text;
  				} else {
  					expression += character;
  				}
  				break;

  			default:
  				expression += character;
  				break;
  		}

  		if (error) {
  			break;
  		}

  		// end of expression
  		if (paren.length === 0) {
  			break;
  		}
  	}

  	var ret;
  	if (error) {
  		ret = {
  			error: error
  		};
  	} else {
  		ret = {
  			idx: idx,
  			expression: expression
  		};
  	}

  	return ret;
  };


  /**
   *
   * @return {Object|false}
   *          - idx:
   *          - text:
   *          or
   *          - error:
   *          or
   *          false
   *
   */
  CSSOM$2.CSSValueExpression.prototype._parseJSComment = function(token, idx) {
  	var nextChar = token.charAt(idx + 1),
  			text;

  	if (nextChar === '/' || nextChar === '*') {
  		var startIdx = idx,
  				endIdx,
  				commentEndChar;

  		if (nextChar === '/') { // line comment
  			commentEndChar = '\n';
  		} else if (nextChar === '*') { // block comment
  			commentEndChar = '*/';
  		}

  		endIdx = token.indexOf(commentEndChar, startIdx + 1 + 1);
  		if (endIdx !== -1) {
  			endIdx = endIdx + commentEndChar.length - 1;
  			text = token.substring(idx, endIdx + 1);
  			return {
  				idx: endIdx,
  				text: text
  			};
  		} else {
  			var error = 'css expression error: unfinished comment in expression!';
  			return {
  				error: error
  			};
  		}
  	} else {
  		return false;
  	}
  };


  /**
   *
   * @return {Object|false}
   *					- idx:
   *					- text:
   *					or 
   *					false
   *
   */
  CSSOM$2.CSSValueExpression.prototype._parseJSString = function(token, idx, sep) {
  	var endIdx = this._findMatchedIdx(token, idx, sep),
  			text;

  	if (endIdx === -1) {
  		return false;
  	} else {
  		text = token.substring(idx, endIdx + sep.length);

  		return {
  			idx: endIdx,
  			text: text
  		};
  	}
  };


  /**
   * parse regexp in css expression
   *
   * @return {Object|false}
   *				- idx:
   *				- regExp:
   *				or 
   *				false
   */

  /*

  all legal RegExp
   
  /a/
  (/a/)
  [/a/]
  [12, /a/]

  !/a/

  +/a/
  -/a/
  * /a/
  / /a/
  %/a/

  ===/a/
  !==/a/
  ==/a/
  !=/a/
  >/a/
  >=/a/
  </a/
  <=/a/

  &/a/
  |/a/
  ^/a/
  ~/a/
  <</a/
  >>/a/
  >>>/a/

  &&/a/
  ||/a/
  ?/a/
  =/a/
  ,/a/

  		delete /a/
  				in /a/
  instanceof /a/
  				new /a/
  		typeof /a/
  			void /a/

  */
  CSSOM$2.CSSValueExpression.prototype._parseJSRexExp = function(token, idx) {
  	var before = token.substring(0, idx).replace(/\s+$/, ""),
  			legalRegx = [
  				/^$/,
  				/\($/,
  				/\[$/,
  				/\!$/,
  				/\+$/,
  				/\-$/,
  				/\*$/,
  				/\/\s+/,
  				/\%$/,
  				/\=$/,
  				/\>$/,
  				/<$/,
  				/\&$/,
  				/\|$/,
  				/\^$/,
  				/\~$/,
  				/\?$/,
  				/\,$/,
  				/delete$/,
  				/in$/,
  				/instanceof$/,
  				/new$/,
  				/typeof$/,
  				/void$/
  			];

  	var isLegal = legalRegx.some(function(reg) {
  		return reg.test(before);
  	});

  	if (!isLegal) {
  		return false;
  	} else {
  		var sep = '/';

  		// same logic as string
  		return this._parseJSString(token, idx, sep);
  	}
  };


  /**
   *
   * find next sep(same line) index in `token`
   *
   * @return {Number}
   *
   */
  CSSOM$2.CSSValueExpression.prototype._findMatchedIdx = function(token, idx, sep) {
  	var startIdx = idx,
  			endIdx;

  	var NOT_FOUND = -1;

  	while(true) {
  		endIdx = token.indexOf(sep, startIdx + 1);

  		if (endIdx === -1) { // not found
  			endIdx = NOT_FOUND;
  			break;
  		} else {
  			var text = token.substring(idx + 1, endIdx),
  					matched = text.match(/\\+$/);
  			if (!matched || matched[0] % 2 === 0) { // not escaped
  				break;
  			} else {
  				startIdx = endIdx;
  			}
  		}
  	}

  	// boundary must be in the same line(js sting or regexp)
  	var nextNewLineIdx = token.indexOf('\n', idx + 1);
  	if (nextNewLineIdx < endIdx) {
  		endIdx = NOT_FOUND;
  	}


  	return endIdx;
  };




  //.CommonJS
  CSSValueExpression.CSSValueExpression = CSSOM$2.CSSValueExpression;

  var CSSDocumentRule = {};

  var MatcherList = {};

  //.CommonJS
  var CSSOM$1 = {};
  ///CommonJS


  /**
   * @constructor
   * @see https://developer.mozilla.org/en/CSS/@-moz-document
   */
  CSSOM$1.MatcherList = function MatcherList(){
      this.length = 0;
  };

  CSSOM$1.MatcherList.prototype = {

      constructor: CSSOM$1.MatcherList,

      /**
       * @return {string}
       */
      get matcherText() {
          return Array.prototype.join.call(this, ", ");
      },

      /**
       * @param {string} value
       */
      set matcherText(value) {
          // just a temporary solution, actually it may be wrong by just split the value with ',', because a url can include ','.
          var values = value.split(",");
          var length = this.length = values.length;
          for (var i=0; i<length; i++) {
              this[i] = values[i].trim();
          }
      },

      /**
       * @param {string} matcher
       */
      appendMatcher: function(matcher) {
          if (Array.prototype.indexOf.call(this, matcher) === -1) {
              this[this.length] = matcher;
              this.length++;
          }
      },

      /**
       * @param {string} matcher
       */
      deleteMatcher: function(matcher) {
          var index = Array.prototype.indexOf.call(this, matcher);
          if (index !== -1) {
              Array.prototype.splice.call(this, index, 1);
          }
      }

  };


  //.CommonJS
  MatcherList.MatcherList = CSSOM$1.MatcherList;

  //.CommonJS
  var CSSOM = {
      CSSRule: CSSRule.CSSRule,
      MatcherList: MatcherList.MatcherList
  };
  ///CommonJS


  /**
   * @constructor
   * @see https://developer.mozilla.org/en/CSS/@-moz-document
   */
  CSSOM.CSSDocumentRule = function CSSDocumentRule() {
      CSSOM.CSSRule.call(this);
      this.matcher = new CSSOM.MatcherList();
      this.cssRules = [];
  };

  CSSOM.CSSDocumentRule.prototype = new CSSOM.CSSRule();
  CSSOM.CSSDocumentRule.prototype.constructor = CSSOM.CSSDocumentRule;
  CSSOM.CSSDocumentRule.prototype.type = 10;
  //FIXME
  //CSSOM.CSSDocumentRule.prototype.insertRule = CSSStyleSheet.prototype.insertRule;
  //CSSOM.CSSDocumentRule.prototype.deleteRule = CSSStyleSheet.prototype.deleteRule;

  Object.defineProperty(CSSOM.CSSDocumentRule.prototype, "cssText", {
    get: function() {
      var cssTexts = [];
      for (var i=0, length=this.cssRules.length; i < length; i++) {
          cssTexts.push(this.cssRules[i].cssText);
      }
      return "@-moz-document " + this.matcher.matcherText + " {" + cssTexts.join("") + "}";
    }
  });


  //.CommonJS
  CSSDocumentRule.CSSDocumentRule = CSSOM.CSSDocumentRule;

  var hasRequiredParse;

  function requireParse () {
  	if (hasRequiredParse) return parse$1;
  	hasRequiredParse = 1;
  	//.CommonJS
  	var CSSOM = {};
  	///CommonJS


  	/**
  	 * @param {string} token
  	 */
  	CSSOM.parse = function parse(token) {

  		var i = 0;

  		/**
  			"before-selector" or
  			"selector" or
  			"atRule" or
  			"atBlock" or
  			"conditionBlock" or
  			"before-name" or
  			"name" or
  			"before-value" or
  			"value"
  		*/
  		var state = "before-selector";

  		var index;
  		var buffer = "";
  		var valueParenthesisDepth = 0;

  		var SIGNIFICANT_WHITESPACE = {
  			"selector": true,
  			"value": true,
  			"value-parenthesis": true,
  			"atRule": true,
  			"importRule-begin": true,
  			"importRule": true,
  			"atBlock": true,
  			"conditionBlock": true,
  			'documentRule-begin': true
  		};

  		var styleSheet = new CSSOM.CSSStyleSheet();

  		// @type CSSStyleSheet|CSSMediaRule|CSSSupportsRule|CSSFontFaceRule|CSSKeyframesRule|CSSDocumentRule
  		var currentScope = styleSheet;

  		// @type CSSMediaRule|CSSSupportsRule|CSSKeyframesRule|CSSDocumentRule
  		var parentRule;

  		var ancestorRules = [];
  		var hasAncestors = false;
  		var prevScope;

  		var name, priority="", styleRule, mediaRule, supportsRule, importRule, fontFaceRule, keyframesRule, documentRule, hostRule;

  		var atKeyframesRegExp = /@(-(?:\w+-)+)?keyframes/g;

  		var parseError = function(message) {
  			var lines = token.substring(0, i).split('\n');
  			var lineCount = lines.length;
  			var charCount = lines.pop().length + 1;
  			var error = new Error(message + ' (line ' + lineCount + ', char ' + charCount + ')');
  			error.line = lineCount;
  			/* jshint sub : true */
  			error['char'] = charCount;
  			error.styleSheet = styleSheet;
  			throw error;
  		};

  		for (var character; (character = token.charAt(i)); i++) {

  			switch (character) {

  			case " ":
  			case "\t":
  			case "\r":
  			case "\n":
  			case "\f":
  				if (SIGNIFICANT_WHITESPACE[state]) {
  					buffer += character;
  				}
  				break;

  			// String
  			case '"':
  				index = i + 1;
  				do {
  					index = token.indexOf('"', index) + 1;
  					if (!index) {
  						parseError('Unmatched "');
  					}
  				} while (token[index - 2] === '\\');
  				buffer += token.slice(i, index);
  				i = index - 1;
  				switch (state) {
  					case 'before-value':
  						state = 'value';
  						break;
  					case 'importRule-begin':
  						state = 'importRule';
  						break;
  				}
  				break;

  			case "'":
  				index = i + 1;
  				do {
  					index = token.indexOf("'", index) + 1;
  					if (!index) {
  						parseError("Unmatched '");
  					}
  				} while (token[index - 2] === '\\');
  				buffer += token.slice(i, index);
  				i = index - 1;
  				switch (state) {
  					case 'before-value':
  						state = 'value';
  						break;
  					case 'importRule-begin':
  						state = 'importRule';
  						break;
  				}
  				break;

  			// Comment
  			case "/":
  				if (token.charAt(i + 1) === "*") {
  					i += 2;
  					index = token.indexOf("*/", i);
  					if (index === -1) {
  						parseError("Missing */");
  					} else {
  						i = index + 1;
  					}
  				} else {
  					buffer += character;
  				}
  				if (state === "importRule-begin") {
  					buffer += " ";
  					state = "importRule";
  				}
  				break;

  			// At-rule
  			case "@":
  				if (token.indexOf("@-moz-document", i) === i) {
  					state = "documentRule-begin";
  					documentRule = new CSSOM.CSSDocumentRule();
  					documentRule.__starts = i;
  					i += "-moz-document".length;
  					buffer = "";
  					break;
  				} else if (token.indexOf("@media", i) === i) {
  					state = "atBlock";
  					mediaRule = new CSSOM.CSSMediaRule();
  					mediaRule.__starts = i;
  					i += "media".length;
  					buffer = "";
  					break;
  				} else if (token.indexOf("@supports", i) === i) {
  					state = "conditionBlock";
  					supportsRule = new CSSOM.CSSSupportsRule();
  					supportsRule.__starts = i;
  					i += "supports".length;
  					buffer = "";
  					break;
  				} else if (token.indexOf("@host", i) === i) {
  					state = "hostRule-begin";
  					i += "host".length;
  					hostRule = new CSSOM.CSSHostRule();
  					hostRule.__starts = i;
  					buffer = "";
  					break;
  				} else if (token.indexOf("@import", i) === i) {
  					state = "importRule-begin";
  					i += "import".length;
  					buffer += "@import";
  					break;
  				} else if (token.indexOf("@font-face", i) === i) {
  					state = "fontFaceRule-begin";
  					i += "font-face".length;
  					fontFaceRule = new CSSOM.CSSFontFaceRule();
  					fontFaceRule.__starts = i;
  					buffer = "";
  					break;
  				} else {
  					atKeyframesRegExp.lastIndex = i;
  					var matchKeyframes = atKeyframesRegExp.exec(token);
  					if (matchKeyframes && matchKeyframes.index === i) {
  						state = "keyframesRule-begin";
  						keyframesRule = new CSSOM.CSSKeyframesRule();
  						keyframesRule.__starts = i;
  						keyframesRule._vendorPrefix = matchKeyframes[1]; // Will come out as undefined if no prefix was found
  						i += matchKeyframes[0].length - 1;
  						buffer = "";
  						break;
  					} else if (state === "selector") {
  						state = "atRule";
  					}
  				}
  				buffer += character;
  				break;

  			case "{":
  				if (state === "selector" || state === "atRule") {
  					styleRule.selectorText = buffer.trim();
  					styleRule.style.__starts = i;
  					buffer = "";
  					state = "before-name";
  				} else if (state === "atBlock") {
  					mediaRule.media.mediaText = buffer.trim();

  					if (parentRule) {
  						ancestorRules.push(parentRule);
  					}

  					currentScope = parentRule = mediaRule;
  					mediaRule.parentStyleSheet = styleSheet;
  					buffer = "";
  					state = "before-selector";
  				} else if (state === "conditionBlock") {
  					supportsRule.conditionText = buffer.trim();

  					if (parentRule) {
  						ancestorRules.push(parentRule);
  					}

  					currentScope = parentRule = supportsRule;
  					supportsRule.parentStyleSheet = styleSheet;
  					buffer = "";
  					state = "before-selector";
  				} else if (state === "hostRule-begin") {
  					if (parentRule) {
  						ancestorRules.push(parentRule);
  					}

  					currentScope = parentRule = hostRule;
  					hostRule.parentStyleSheet = styleSheet;
  					buffer = "";
  					state = "before-selector";
  				} else if (state === "fontFaceRule-begin") {
  					if (parentRule) {
  						fontFaceRule.parentRule = parentRule;
  					}
  					fontFaceRule.parentStyleSheet = styleSheet;
  					styleRule = fontFaceRule;
  					buffer = "";
  					state = "before-name";
  				} else if (state === "keyframesRule-begin") {
  					keyframesRule.name = buffer.trim();
  					if (parentRule) {
  						ancestorRules.push(parentRule);
  						keyframesRule.parentRule = parentRule;
  					}
  					keyframesRule.parentStyleSheet = styleSheet;
  					currentScope = parentRule = keyframesRule;
  					buffer = "";
  					state = "keyframeRule-begin";
  				} else if (state === "keyframeRule-begin") {
  					styleRule = new CSSOM.CSSKeyframeRule();
  					styleRule.keyText = buffer.trim();
  					styleRule.__starts = i;
  					buffer = "";
  					state = "before-name";
  				} else if (state === "documentRule-begin") {
  					// FIXME: what if this '{' is in the url text of the match function?
  					documentRule.matcher.matcherText = buffer.trim();
  					if (parentRule) {
  						ancestorRules.push(parentRule);
  						documentRule.parentRule = parentRule;
  					}
  					currentScope = parentRule = documentRule;
  					documentRule.parentStyleSheet = styleSheet;
  					buffer = "";
  					state = "before-selector";
  				}
  				break;

  			case ":":
  				if (state === "name") {
  					name = buffer.trim();
  					buffer = "";
  					state = "before-value";
  				} else {
  					buffer += character;
  				}
  				break;

  			case "(":
  				if (state === 'value') {
  					// ie css expression mode
  					if (buffer.trim() === 'expression') {
  						var info = (new CSSOM.CSSValueExpression(token, i)).parse();

  						if (info.error) {
  							parseError(info.error);
  						} else {
  							buffer += info.expression;
  							i = info.idx;
  						}
  					} else {
  						state = 'value-parenthesis';
  						//always ensure this is reset to 1 on transition
  						//from value to value-parenthesis
  						valueParenthesisDepth = 1;
  						buffer += character;
  					}
  				} else if (state === 'value-parenthesis') {
  					valueParenthesisDepth++;
  					buffer += character;
  				} else {
  					buffer += character;
  				}
  				break;

  			case ")":
  				if (state === 'value-parenthesis') {
  					valueParenthesisDepth--;
  					if (valueParenthesisDepth === 0) state = 'value';
  				}
  				buffer += character;
  				break;

  			case "!":
  				if (state === "value" && token.indexOf("!important", i) === i) {
  					priority = "important";
  					i += "important".length;
  				} else {
  					buffer += character;
  				}
  				break;

  			case ";":
  				switch (state) {
  					case "value":
  						styleRule.style.setProperty(name, buffer.trim(), priority);
  						priority = "";
  						buffer = "";
  						state = "before-name";
  						break;
  					case "atRule":
  						buffer = "";
  						state = "before-selector";
  						break;
  					case "importRule":
  						importRule = new CSSOM.CSSImportRule();
  						importRule.parentStyleSheet = importRule.styleSheet.parentStyleSheet = styleSheet;
  						importRule.cssText = buffer + character;
  						styleSheet.cssRules.push(importRule);
  						buffer = "";
  						state = "before-selector";
  						break;
  					default:
  						buffer += character;
  						break;
  				}
  				break;

  			case "}":
  				switch (state) {
  					case "value":
  						styleRule.style.setProperty(name, buffer.trim(), priority);
  						priority = "";
  						/* falls through */
  					case "before-name":
  					case "name":
  						styleRule.__ends = i + 1;
  						if (parentRule) {
  							styleRule.parentRule = parentRule;
  						}
  						styleRule.parentStyleSheet = styleSheet;
  						currentScope.cssRules.push(styleRule);
  						buffer = "";
  						if (currentScope.constructor === CSSOM.CSSKeyframesRule) {
  							state = "keyframeRule-begin";
  						} else {
  							state = "before-selector";
  						}
  						break;
  					case "keyframeRule-begin":
  					case "before-selector":
  					case "selector":
  						// End of media/supports/document rule.
  						if (!parentRule) {
  							parseError("Unexpected }");
  						}

  						// Handle rules nested in @media or @supports
  						hasAncestors = ancestorRules.length > 0;

  						while (ancestorRules.length > 0) {
  							parentRule = ancestorRules.pop();

  							if (
  								parentRule.constructor.name === "CSSMediaRule"
  								|| parentRule.constructor.name === "CSSSupportsRule"
  							) {
  								prevScope = currentScope;
  								currentScope = parentRule;
  								currentScope.cssRules.push(prevScope);
  								break;
  							}

  							if (ancestorRules.length === 0) {
  								hasAncestors = false;
  							}
  						}
  						
  						if (!hasAncestors) {
  							currentScope.__ends = i + 1;
  							styleSheet.cssRules.push(currentScope);
  							currentScope = styleSheet;
  							parentRule = null;
  						}

  						buffer = "";
  						state = "before-selector";
  						break;
  				}
  				break;

  			default:
  				switch (state) {
  					case "before-selector":
  						state = "selector";
  						styleRule = new CSSOM.CSSStyleRule();
  						styleRule.__starts = i;
  						break;
  					case "before-name":
  						state = "name";
  						break;
  					case "before-value":
  						state = "value";
  						break;
  					case "importRule-begin":
  						state = "importRule";
  						break;
  				}
  				buffer += character;
  				break;
  			}
  		}

  		return styleSheet;
  	};


  	//.CommonJS
  	parse$1.parse = CSSOM.parse;
  	// The following modules cannot be included sooner due to the mutual dependency with parse.js
  	CSSOM.CSSStyleSheet = requireCSSStyleSheet().CSSStyleSheet;
  	CSSOM.CSSStyleRule = requireCSSStyleRule().CSSStyleRule;
  	CSSOM.CSSImportRule = requireCSSImportRule().CSSImportRule;
  	CSSOM.CSSGroupingRule = CSSGroupingRule.CSSGroupingRule;
  	CSSOM.CSSMediaRule = CSSMediaRule.CSSMediaRule;
  	CSSOM.CSSConditionRule = CSSConditionRule.CSSConditionRule;
  	CSSOM.CSSSupportsRule = CSSSupportsRule.CSSSupportsRule;
  	CSSOM.CSSFontFaceRule = requireCSSFontFaceRule().CSSFontFaceRule;
  	CSSOM.CSSHostRule = CSSHostRule.CSSHostRule;
  	CSSOM.CSSStyleDeclaration = requireCSSStyleDeclaration().CSSStyleDeclaration;
  	CSSOM.CSSKeyframeRule = requireCSSKeyframeRule().CSSKeyframeRule;
  	CSSOM.CSSKeyframesRule = CSSKeyframesRule.CSSKeyframesRule;
  	CSSOM.CSSValueExpression = CSSValueExpression.CSSValueExpression;
  	CSSOM.CSSDocumentRule = CSSDocumentRule.CSSDocumentRule;
  	///CommonJS
  	return parse$1;
  }

  var hasRequiredCSSStyleDeclaration;

  function requireCSSStyleDeclaration () {
  	if (hasRequiredCSSStyleDeclaration) return CSSStyleDeclaration;
  	hasRequiredCSSStyleDeclaration = 1;
  	//.CommonJS
  	var CSSOM = {};
  	///CommonJS


  	/**
  	 * @constructor
  	 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration
  	 */
  	CSSOM.CSSStyleDeclaration = function CSSStyleDeclaration(){
  		this.length = 0;
  		this.parentRule = null;

  		// NON-STANDARD
  		this._importants = {};
  	};


  	CSSOM.CSSStyleDeclaration.prototype = {

  		constructor: CSSOM.CSSStyleDeclaration,

  		/**
  		 *
  		 * @param {string} name
  		 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-getPropertyValue
  		 * @return {string} the value of the property if it has been explicitly set for this declaration block.
  		 * Returns the empty string if the property has not been set.
  		 */
  		getPropertyValue: function(name) {
  			return this[name] || "";
  		},

  		/**
  		 *
  		 * @param {string} name
  		 * @param {string} value
  		 * @param {string} [priority=null] "important" or null
  		 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-setProperty
  		 */
  		setProperty: function(name, value, priority) {
  			if (this[name]) {
  				// Property already exist. Overwrite it.
  				var index = Array.prototype.indexOf.call(this, name);
  				if (index < 0) {
  					this[this.length] = name;
  					this.length++;
  				}
  			} else {
  				// New property.
  				this[this.length] = name;
  				this.length++;
  			}
  			this[name] = value + "";
  			this._importants[name] = priority;
  		},

  		/**
  		 *
  		 * @param {string} name
  		 * @see http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration-removeProperty
  		 * @return {string} the value of the property if it has been explicitly set for this declaration block.
  		 * Returns the empty string if the property has not been set or the property name does not correspond to a known CSS property.
  		 */
  		removeProperty: function(name) {
  			if (!(name in this)) {
  				return "";
  			}
  			var index = Array.prototype.indexOf.call(this, name);
  			if (index < 0) {
  				return "";
  			}
  			var prevValue = this[name];
  			this[name] = "";

  			// That's what WebKit and Opera do
  			Array.prototype.splice.call(this, index, 1);

  			// That's what Firefox does
  			//this[index] = ""

  			return prevValue;
  		},

  		getPropertyCSSValue: function() {
  			//FIXME
  		},

  		/**
  		 *
  		 * @param {String} name
  		 */
  		getPropertyPriority: function(name) {
  			return this._importants[name] || "";
  		},


  		/**
  		 *   element.style.overflow = "auto"
  		 *   element.style.getPropertyShorthand("overflow-x")
  		 *   -> "overflow"
  		 */
  		getPropertyShorthand: function() {
  			//FIXME
  		},

  		isPropertyImplicit: function() {
  			//FIXME
  		},

  		// Doesn't work in IE < 9
  		get cssText(){
  			var properties = [];
  			for (var i=0, length=this.length; i < length; ++i) {
  				var name = this[i];
  				var value = this.getPropertyValue(name);
  				var priority = this.getPropertyPriority(name);
  				if (priority) {
  					priority = " !" + priority;
  				}
  				properties[i] = name + ": " + value + priority + ";";
  			}
  			return properties.join(" ");
  		},

  		set cssText(text){
  			var i, name;
  			for (i = this.length; i--;) {
  				name = this[i];
  				this[name] = "";
  			}
  			Array.prototype.splice.call(this, 0, this.length);
  			this._importants = {};

  			var dummyRule = CSSOM.parse('#bogus{' + text + '}').cssRules[0].style;
  			var length = dummyRule.length;
  			for (i = 0; i < length; ++i) {
  				name = dummyRule[i];
  				this.setProperty(dummyRule[i], dummyRule.getPropertyValue(name), dummyRule.getPropertyPriority(name));
  			}
  		}
  	};


  	//.CommonJS
  	CSSStyleDeclaration.CSSStyleDeclaration = CSSOM.CSSStyleDeclaration;
  	CSSOM.parse = requireParse().parse; // Cannot be included sooner due to the mutual dependency between parse.js and CSSStyleDeclaration.js
  	///CommonJS
  	return CSSStyleDeclaration;
  }

  //.CommonJS
  ({
  	CSSStyleSheet: requireCSSStyleSheet().CSSStyleSheet,
  	CSSRule: CSSRule.CSSRule,
  	CSSStyleRule: requireCSSStyleRule().CSSStyleRule,
  	CSSGroupingRule: CSSGroupingRule.CSSGroupingRule,
  	CSSConditionRule: CSSConditionRule.CSSConditionRule,
  	CSSMediaRule: CSSMediaRule.CSSMediaRule,
  	CSSSupportsRule: CSSSupportsRule.CSSSupportsRule,
  	CSSStyleDeclaration: requireCSSStyleDeclaration().CSSStyleDeclaration,
  	CSSKeyframeRule: requireCSSKeyframeRule().CSSKeyframeRule,
  	CSSKeyframesRule: CSSKeyframesRule.CSSKeyframesRule
  });

  requireCSSStyleDeclaration().CSSStyleDeclaration;
  requireCSSStyleRule().CSSStyleRule;
  requireCSSImportRule().CSSImportRule;
  requireCSSFontFaceRule().CSSFontFaceRule;
  requireCSSStyleSheet().CSSStyleSheet;
  requireCSSKeyframeRule().CSSKeyframeRule;
  var parse = requireParse().parse;

  const tagName$e = 'style';

  /**
   * @implements globalThis.HTMLStyleElement
   */
  class HTMLStyleElement extends TextElement {
    constructor(ownerDocument, localName = tagName$e) {
      super(ownerDocument, localName);
      this[SHEET] = null;
    }

    get sheet() {
      const sheet = this[SHEET];
      if (sheet !== null) {
        return sheet;
      }
      return this[SHEET] = parse(this.textContent);
    }

    get innerHTML() {
      return super.innerHTML || '';
    }
    set innerHTML(value) {
      super.textContent = value;
      this[SHEET] = null;
    }
    get innerText() {
      return super.innerText || '';
    }
    set innerText(value) {
      super.textContent = value;
      this[SHEET] = null;
    }
    get textContent() {
      return super.textContent || '';
    }
    set textContent(value) {
      super.textContent = value;
      this[SHEET] = null;
    }
  }

  registerHTMLClass(tagName$e, HTMLStyleElement);

  /**
   * @implements globalThis.HTMLTimeElement
   */
  class HTMLTimeElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'time') {
      super(ownerDocument, localName);
    }

    /**
     * @type {string}
     */
    get dateTime() { return stringAttribute.get(this, 'datetime'); }
    set dateTime(value) { stringAttribute.set(this, 'datetime', value); }
  }

  registerHTMLClass('time', HTMLTimeElement);

  /**
   * @implements globalThis.HTMLFieldSetElement
   */
  class HTMLFieldSetElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'fieldset') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLEmbedElement
   */
  class HTMLEmbedElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'embed') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLHRElement
   */
  class HTMLHRElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'hr') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLProgressElement
   */
  class HTMLProgressElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'progress') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLParagraphElement
   */
  class HTMLParagraphElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'p') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLTableElement
   */
  class HTMLTableElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'table') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLFrameSetElement
   */
  class HTMLFrameSetElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'frameset') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLLIElement
   */
  class HTMLLIElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'li') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLBaseElement
   */
  class HTMLBaseElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'base') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLDataListElement
   */
  class HTMLDataListElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'datalist') {
      super(ownerDocument, localName);
    }
  }

  const tagName$d = 'input';

  /**
   * @implements globalThis.HTMLInputElement
   */
  class HTMLInputElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$d) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get autofocus() { return booleanAttribute.get(this, 'autofocus') || -1; }
    set autofocus(value) { booleanAttribute.set(this, 'autofocus', value); }

    get disabled() { return booleanAttribute.get(this, 'disabled'); }
    set disabled(value) { booleanAttribute.set(this, 'disabled', value); }

    get name() { return this.getAttribute('name'); }
    set name(value) { this.setAttribute('name', value); }

    get placeholder() { return this.getAttribute('placeholder'); }
    set placeholder(value) { this.setAttribute('placeholder', value); }

    get type() { return this.getAttribute('type'); }
    set type(value) { this.setAttribute('type', value); }

    get value() { return stringAttribute.get(this, 'value'); }
    set value(value) { stringAttribute.set(this, 'value', value); }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName$d, HTMLInputElement);

  /**
   * @implements globalThis.HTMLParamElement
   */
  class HTMLParamElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'param') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLMediaElement
   */
  class HTMLMediaElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'media') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLAudioElement
   */
  class HTMLAudioElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'audio') {
      super(ownerDocument, localName);
    }
  }

  const tagName$c = 'h1';

  /**
   * @implements globalThis.HTMLHeadingElement
   */
  class HTMLHeadingElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$c) {
      super(ownerDocument, localName);
    }
  }

  registerHTMLClass([tagName$c, 'h2', 'h3', 'h4', 'h5', 'h6'], HTMLHeadingElement);

  /**
   * @implements globalThis.HTMLDirectoryElement
   */
  class HTMLDirectoryElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'dir') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLQuoteElement
   */
  class HTMLQuoteElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'quote') {
      super(ownerDocument, localName);
    }
  }

  var canvas = {exports: {}};

  var canvasShim;
  var hasRequiredCanvasShim;

  function requireCanvasShim () {
  	if (hasRequiredCanvasShim) return canvasShim;
  	hasRequiredCanvasShim = 1;
  	class Canvas {
  	  constructor(width, height) {
  	    this.width = width;
  	    this.height = height;
  	  }
  	  getContext() {
  	    return null;
  	  }
  	  toDataURL() {
  	    return '';
  	  }
  	}

  	canvasShim = {
  	  createCanvas: (width, height) => new Canvas(width, height),
  	};
  	return canvasShim;
  }

  /* c8 ignore start */

  try {
    canvas.exports = require('canvas');
  } catch (fallback) {
    canvas.exports = requireCanvasShim();
  }
  /* c8 ignore stop */

  var canvasExports = canvas.exports;
  var Canvas = /*@__PURE__*/getDefaultExportFromCjs(canvasExports);

  const {createCanvas} = Canvas;

  const tagName$b = 'canvas';

  /**
   * @implements globalThis.HTMLCanvasElement
   */
  let HTMLCanvasElement$1 = class HTMLCanvasElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$b) {
      super(ownerDocument, localName);
      this[IMAGE] = createCanvas(300, 150);
    }

    get width() {
      return this[IMAGE].width;
    }

    set width(value) {
      numericAttribute.set(this, 'width', value);
      this[IMAGE].width = value;
    }

    get height() {
      return this[IMAGE].height;
    }

    set height(value) {
      numericAttribute.set(this, 'height', value);
      this[IMAGE].height = value;
    }

    getContext(type) {
      return this[IMAGE].getContext(type);
    }

    toDataURL(...args) {
      return this[IMAGE].toDataURL(...args);
    }
  };

  registerHTMLClass(tagName$b, HTMLCanvasElement$1);

  /**
   * @implements globalThis.HTMLLegendElement
   */
  class HTMLLegendElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'legend') {
      super(ownerDocument, localName);
    }
  }

  const tagName$a = 'option';

  /**
   * @implements globalThis.HTMLOptionElement
   */
  class HTMLOptionElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$a) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get value() { return stringAttribute.get(this, 'value'); }
    set value(value) { stringAttribute.set(this, 'value', value); }
    /* c8 ignore stop */

    get selected() { return booleanAttribute.get(this, 'selected'); }
    set selected(value) {
      const option = this.parentElement?.querySelector('option[selected]');
      if (option && option !== this)
        option.selected = false;
      booleanAttribute.set(this, 'selected', value);
    }
  }

  registerHTMLClass(tagName$a, HTMLOptionElement);

  /**
   * @implements globalThis.HTMLSpanElement
   */
  class HTMLSpanElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'span') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLMeterElement
   */
  class HTMLMeterElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'meter') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLVideoElement
   */
  let HTMLVideoElement$1 = class HTMLVideoElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'video') {
      super(ownerDocument, localName);
    }
  };

  /**
   * @implements globalThis.HTMLTableCellElement
   */
  class HTMLTableCellElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'td') {
      super(ownerDocument, localName);
    }
  }

  const tagName$9 = 'title';

  /**
   * @implements globalThis.HTMLTitleElement
   */
  class HTMLTitleElement extends TextElement {
    constructor(ownerDocument, localName = tagName$9) {
      super(ownerDocument, localName);
    }
  }

  registerHTMLClass(tagName$9, HTMLTitleElement);

  /**
   * @implements globalThis.HTMLOutputElement
   */
  class HTMLOutputElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'output') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLTableRowElement
   */
  class HTMLTableRowElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'tr') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLDataElement
   */
  class HTMLDataElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'data') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLMenuElement
   */
  class HTMLMenuElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'menu') {
      super(ownerDocument, localName);
    }
  }

  const tagName$8 = 'select';

  /**
   * @implements globalThis.HTMLSelectElement
   */
  class HTMLSelectElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$8) {
      super(ownerDocument, localName);
    }

    get options() {
      let children = new NodeList;
      let {firstElementChild} = this;
      while (firstElementChild) {
        if (firstElementChild.tagName === 'OPTGROUP')
          children.push(...firstElementChild.children);
        else
          children.push(firstElementChild);
        firstElementChild = firstElementChild.nextElementSibling;
      }
      return children;
    }

    /* c8 ignore start */
    get disabled() { return booleanAttribute.get(this, 'disabled'); }
    set disabled(value) { booleanAttribute.set(this, 'disabled', value); }

    get name() { return this.getAttribute('name'); }
    set name(value) { this.setAttribute('name', value); }
    /* c8 ignore stop */

    get value() { return this.querySelector('option[selected]')?.value; }
  }

  registerHTMLClass(tagName$8, HTMLSelectElement);

  /**
   * @implements globalThis.HTMLBRElement
   */
  class HTMLBRElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'br') {
      super(ownerDocument, localName);
    }
  }

  const tagName$7 = 'button';

  /**
   * @implements globalThis.HTMLButtonElement
   */
  class HTMLButtonElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$7) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get disabled() { return booleanAttribute.get(this, 'disabled'); }
    set disabled(value) { booleanAttribute.set(this, 'disabled', value); }

    get name() { return this.getAttribute('name'); }
    set name(value) { this.setAttribute('name', value); }

    get type() { return this.getAttribute('type'); }
    set type(value) { this.setAttribute('type', value); }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName$7, HTMLButtonElement);

  /**
   * @implements globalThis.HTMLMapElement
   */
  class HTMLMapElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'map') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLOptGroupElement
   */
  class HTMLOptGroupElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'optgroup') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLDListElement
   */
  class HTMLDListElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'dl') {
      super(ownerDocument, localName);
    }
  }

  const tagName$6 = 'textarea';

  /**
   * @implements globalThis.HTMLTextAreaElement
   */
  class HTMLTextAreaElement extends TextElement {
    constructor(ownerDocument, localName = tagName$6) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get disabled() { return booleanAttribute.get(this, 'disabled'); }
    set disabled(value) { booleanAttribute.set(this, 'disabled', value); }

    get name() { return this.getAttribute('name'); }
    set name(value) { this.setAttribute('name', value); }

    get placeholder() { return this.getAttribute('placeholder'); }
    set placeholder(value) { this.setAttribute('placeholder', value); }

    get type() { return this.getAttribute('type'); }
    set type(value) { this.setAttribute('type', value); }

    get value() { return this.textContent; }
    set value(content) { this.textContent = content; }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName$6, HTMLTextAreaElement);

  /**
   * @implements globalThis.HTMLFontElement
   */
  class HTMLFontElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'font') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLDivElement
   */
  class HTMLDivElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'div') {
      super(ownerDocument, localName);
    }
  }

  const tagName$5 = 'link';

  /**
   * @implements globalThis.HTMLLinkElement
   */
  class HTMLLinkElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$5) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */ // copy paste from img.src, already covered
    get disabled() { return booleanAttribute.get(this, 'disabled'); }
    set disabled(value) { booleanAttribute.set(this, 'disabled', value); }

    get href() { return stringAttribute.get(this, 'href').trim(); }
    set href(value) { stringAttribute.set(this, 'href', value); }

    get hreflang() { return stringAttribute.get(this, 'hreflang'); }
    set hreflang(value) { stringAttribute.set(this, 'hreflang', value); }

    get media() { return stringAttribute.get(this, 'media'); }
    set media(value) { stringAttribute.set(this, 'media', value); }

    get rel() { return stringAttribute.get(this, 'rel'); }
    set rel(value) { stringAttribute.set(this, 'rel', value); }

    get type() { return stringAttribute.get(this, 'type'); }
    set type(value) { stringAttribute.set(this, 'type', value); }
    /* c8 ignore stop */

  }

  registerHTMLClass(tagName$5, HTMLLinkElement);

  const tagName$4 = 'slot';

  /**
   * @implements globalThis.HTMLSlotElement
   */
  class HTMLSlotElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$4) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get name() { return this.getAttribute('name'); }
    set name(value) { this.setAttribute('name', value); }

    assign() {}

    assignedNodes(options) {
      const isNamedSlot = !!this.name;
      const hostChildNodes = this.getRootNode().host?.childNodes ?? [];
      let slottables;

      if (isNamedSlot) {
        slottables = [...hostChildNodes].filter(node => node.slot === this.name);
      } else {
        slottables = [...hostChildNodes].filter(node => !node.slot);
      }

      if (options?.flatten) {
        const result = [];

        // Element and Text nodes are slottables. A slot can be a slottable.
        for (let slottable of slottables) {
          if (slottable.localName === 'slot') {
            result.push(...slottable.assignedNodes({ flatten: true }));
          } else {
            result.push(slottable);
          }
        }

        slottables = result;
      }

      // If no assigned nodes are found, it returns the slot's fallback content.
      return slottables.length ? slottables : [...this.childNodes];
    }

    assignedElements(options) {
      const slottables = this.assignedNodes(options).filter(n => n.nodeType === 1);

      // If no assigned elements are found, it returns the slot's fallback content.
      return slottables.length ? slottables : [...this.children];
    }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName$4, HTMLSlotElement);

  /**
   * @implements globalThis.HTMLFormElement
   */
  class HTMLFormElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'form') {
      super(ownerDocument, localName);
    }
  }

  const tagName$3 = 'img';

  /**
   * @implements globalThis.HTMLImageElement
   */
  let HTMLImageElement$1 = class HTMLImageElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$3) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get alt() { return stringAttribute.get(this, 'alt'); }
    set alt(value) { stringAttribute.set(this, 'alt', value); }

    get sizes() { return stringAttribute.get(this, 'sizes'); }
    set sizes(value) { stringAttribute.set(this, 'sizes', value); }

    get src() { return stringAttribute.get(this, 'src'); }
    set src(value) { stringAttribute.set(this, 'src', value); }

    get srcset() { return stringAttribute.get(this, 'srcset'); }
    set srcset(value) { stringAttribute.set(this, 'srcset', value); }

    get title() { return stringAttribute.get(this, 'title'); }
    set title(value) { stringAttribute.set(this, 'title', value); }

    get width() { return numericAttribute.get(this, 'width'); }
    set width(value) { numericAttribute.set(this, 'width', value); }

    get height() { return numericAttribute.get(this, 'height'); }
    set height(value) { numericAttribute.set(this, 'height', value); }
    /* c8 ignore stop */
  };

  registerHTMLClass(tagName$3, HTMLImageElement$1);

  /**
   * @implements globalThis.HTMLPreElement
   */
  class HTMLPreElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'pre') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLUListElement
   */
  class HTMLUListElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'ul') {
      super(ownerDocument, localName);
    }
  }

  const tagName$2 = 'meta';
  /**
   * @implements globalThis.HTMLMetaElement
   */
  class HTMLMetaElement extends HTMLElement$1 {
    constructor(ownerDocument, localName =tagName$2) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get name() { return stringAttribute.get(this, 'name'); }
    set name(value) { stringAttribute.set(this, 'name', value); }

    get httpEquiv() { return stringAttribute.get(this, 'http-equiv'); }
    set httpEquiv(value) { stringAttribute.set(this, 'http-equiv', value); }

    get content() { return stringAttribute.get(this, 'content'); }
    set content(value) { stringAttribute.set(this, 'content', value); }

    get charset() { return stringAttribute.get(this, 'charset'); }
    set charset(value) { stringAttribute.set(this, 'charset', value); }

    get media() { return stringAttribute.get(this, 'media'); }
    set media(value) { stringAttribute.set(this, 'media', value); }
    /* c8 ignore stop */

  }

  registerHTMLClass(tagName$2, HTMLMetaElement);

  /**
   * @implements globalThis.HTMLPictureElement
   */
  class HTMLPictureElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'picture') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLAreaElement
   */
  class HTMLAreaElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'area') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLOListElement
   */
  class HTMLOListElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'ol') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLTableCaptionElement
   */
  class HTMLTableCaptionElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'caption') {
      super(ownerDocument, localName);
    }
  }

  const tagName$1 = 'a';

  /**
   * @implements globalThis.HTMLAnchorElement
   */
  class HTMLAnchorElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName$1) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */ // copy paste from img.src, already covered
    get href() { return encodeURI(decodeURI(stringAttribute.get(this, 'href'))).trim(); }
    set href(value) { stringAttribute.set(this, 'href', decodeURI(value)); }

    get download() { return encodeURI(decodeURI(stringAttribute.get(this, 'download'))); }
    set download(value) { stringAttribute.set(this, 'download', decodeURI(value)); }

    get target() { return stringAttribute.get(this, 'target'); }
    set target(value) { stringAttribute.set(this, 'target', value); }

    get type() { return stringAttribute.get(this, 'type'); }
    set type(value) { stringAttribute.set(this, 'type', value); }

    get rel() { return stringAttribute.get(this, 'rel'); }
    set rel(value) { stringAttribute.set(this, 'rel', value); }
    /* c8 ignore stop */

  }

  registerHTMLClass(tagName$1, HTMLAnchorElement);

  /**
   * @implements globalThis.HTMLLabelElement
   */
  class HTMLLabelElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'label') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLUnknownElement
   */
  class HTMLUnknownElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'unknown') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLModElement
   */
  class HTMLModElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'mod') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLDetailsElement
   */
  class HTMLDetailsElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'details') {
      super(ownerDocument, localName);
    }
  }

  const tagName = 'source';

  /**
   * @implements globalThis.HTMLSourceElement
   */
  class HTMLSourceElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = tagName) {
      super(ownerDocument, localName);
    }

    /* c8 ignore start */
    get src() { return stringAttribute.get(this, 'src'); }
    set src(value) { stringAttribute.set(this, 'src', value); }

    get srcset() { return stringAttribute.get(this, 'srcset'); }
    set srcset(value) { stringAttribute.set(this, 'srcset', value); }

    get sizes() { return stringAttribute.get(this, 'sizes'); }
    set sizes(value) { stringAttribute.set(this, 'sizes', value); }

    get type() { return stringAttribute.get(this, 'type'); }
    set type(value) { stringAttribute.set(this, 'type', value); }
    /* c8 ignore stop */
  }

  registerHTMLClass(tagName, HTMLSourceElement);

  /**
   * @implements globalThis.HTMLTrackElement
   */
  class HTMLTrackElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'track') {
      super(ownerDocument, localName);
    }
  }

  /**
   * @implements globalThis.HTMLMarqueeElement
   */
  class HTMLMarqueeElement extends HTMLElement$1 {
    constructor(ownerDocument, localName = 'marquee') {
      super(ownerDocument, localName);
    }
  }

  const HTMLClasses = {
    HTMLElement: HTMLElement$1,
    HTMLTemplateElement,
    HTMLHtmlElement,
    HTMLScriptElement,
    HTMLFrameElement,
    HTMLIFrameElement,
    HTMLObjectElement,
    HTMLHeadElement,
    HTMLBodyElement,
    HTMLStyleElement,
    HTMLTimeElement,
    HTMLFieldSetElement,
    HTMLEmbedElement,
    HTMLHRElement,
    HTMLProgressElement,
    HTMLParagraphElement,
    HTMLTableElement,
    HTMLFrameSetElement,
    HTMLLIElement,
    HTMLBaseElement,
    HTMLDataListElement,
    HTMLInputElement,
    HTMLParamElement,
    HTMLMediaElement,
    HTMLAudioElement,
    HTMLHeadingElement,
    HTMLDirectoryElement,
    HTMLQuoteElement,
    HTMLCanvasElement: HTMLCanvasElement$1,
    HTMLLegendElement,
    HTMLOptionElement,
    HTMLSpanElement,
    HTMLMeterElement,
    HTMLVideoElement: HTMLVideoElement$1,
    HTMLTableCellElement,
    HTMLTitleElement,
    HTMLOutputElement,
    HTMLTableRowElement,
    HTMLDataElement,
    HTMLMenuElement,
    HTMLSelectElement,
    HTMLBRElement,
    HTMLButtonElement,
    HTMLMapElement,
    HTMLOptGroupElement,
    HTMLDListElement,
    HTMLTextAreaElement,
    HTMLFontElement,
    HTMLDivElement,
    HTMLLinkElement,
    HTMLSlotElement,
    HTMLFormElement,
    HTMLImageElement: HTMLImageElement$1,
    HTMLPreElement,
    HTMLUListElement,
    HTMLMetaElement,
    HTMLPictureElement,
    HTMLAreaElement,
    HTMLOListElement,
    HTMLTableCaptionElement,
    HTMLAnchorElement,
    HTMLLabelElement,
    HTMLUnknownElement,
    HTMLModElement,
    HTMLDetailsElement,
    HTMLSourceElement,
    HTMLTrackElement,
    HTMLMarqueeElement
  };

  // TODO: ensure all these are text only
  // /^(?:plaintext|script|style|textarea|title|xmp)$/i

  const voidElements = {test: () => true};
  const Mime = {
    'text/html': {
      docType: '<!DOCTYPE html>',
      ignoreCase: true,
      voidElements: /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i
    },
    'image/svg+xml': {
      docType: '<?xml version="1.0" encoding="utf-8"?>',
      ignoreCase: false,
      voidElements
    },
    'text/xml': {
      docType: '<?xml version="1.0" encoding="utf-8"?>',
      ignoreCase: false,
      voidElements
    },
    'application/xml': {
      docType: '<?xml version="1.0" encoding="utf-8"?>',
      ignoreCase: false,
      voidElements
    },
    'application/xhtml+xml': {
      docType: '<?xml version="1.0" encoding="utf-8"?>',
      ignoreCase: false,
      voidElements
    }
  };

  // https://dom.spec.whatwg.org/#interface-customevent


  /**
   * @implements globalThis.CustomEvent
   */
  let CustomEvent$1 = class CustomEvent extends GlobalEvent {
    constructor(type, eventInitDict = {}) {
      super(type, eventInitDict);
      this.detail = eventInitDict.detail;
    }
  };

  /* c8 ignore stop */

  // https://dom.spec.whatwg.org/#interface-customevent


  /**
   * @implements globalThis.InputEvent
   */
  class InputEvent extends GlobalEvent {
    constructor(type, inputEventInit = {}) {
      super(type, inputEventInit);
      this.inputType = inputEventInit.inputType;
      this.data = inputEventInit.data;
      this.dataTransfer = inputEventInit.dataTransfer;
      this.isComposing = inputEventInit.isComposing || false;
      this.ranges = inputEventInit.ranges;
    }
  }
  /* c8 ignore stop */

  const ImageClass = ownerDocument =>
  /**
   * @implements globalThis.Image
   */
  class Image extends HTMLImageElement$1 {
    constructor(width, height) {
      super(ownerDocument);
      switch (arguments.length) {
        case 1:
          this.height = width;
          this.width = width;
          break;
        case 2:
          this.height = height;
          this.width = width;
          break;
      }
    }
  };

  // https://dom.spec.whatwg.org/#concept-live-range


  const deleteContents = ({[START]: start, [END]: end}, fragment = null) => {
    setAdjacent(start[PREV], end[NEXT]);
    do {
      const after = getEnd(start);
      const next = after === end ? after : after[NEXT];
      if (fragment)
        fragment.insertBefore(start, fragment[END]);
      else
        start.remove();
      start = next;
    } while (start !== end);
  };

  /**
   * @implements globalThis.Range
   */
  class Range {
    constructor() {
      this[START] = null;
      this[END] = null;
      this.commonAncestorContainer = null;
    }

    /* TODO: this is more complicated than it looks
    setStart(node, offset) {
      this[START] = node.childNodes[offset];
    }

    setEnd(node, offset) {
      this[END] = getEnd(node.childNodes[offset]);
    }
    //*/

    insertNode(newNode) {
      this[END].parentNode.insertBefore(newNode, this[START]);
    }

    selectNode(node) {
      this[START] = node;
      this[END] = getEnd(node);
    }

    // TODO: SVG elements should then create contextual fragments
    //       that return SVG nodes
    selectNodeContents(node) {
      this.selectNode(node);
      this.commonAncestorContainer = node;
    }

    surroundContents(parentNode) {
      parentNode.replaceChildren(this.extractContents());
    }

    setStartBefore(node) {
      this[START] = node;
    }

    setStartAfter(node) {
      this[START] = node.nextSibling;
    }

    setEndBefore(node) {
      this[END] = getEnd(node.previousSibling);
    }

    setEndAfter(node) {
      this[END] = getEnd(node);
    }

    cloneContents() {
      let {[START]: start, [END]: end} = this;
      const fragment = start.ownerDocument.createDocumentFragment();
      while (start !== end) {
        fragment.insertBefore(start.cloneNode(true), fragment[END]);
        start = getEnd(start);
        if (start !== end)
          start = start[NEXT];
      }
      return fragment;
    }

    deleteContents() {
      deleteContents(this);
    }

    extractContents() {
      const fragment = this[START].ownerDocument.createDocumentFragment();
      deleteContents(this, fragment);
      return fragment;
    }

    createContextualFragment(html) {
      const { commonAncestorContainer: doc } = this;
      const isSVG = 'ownerSVGElement' in doc;
      const document = isSVG ? doc.ownerDocument : doc;
      let content = htmlToFragment(document, html);
      if (isSVG) {
        const childNodes = [...content.childNodes];
        content = document.createDocumentFragment();
        Object.setPrototypeOf(content, SVGElement$1.prototype);
        content.ownerSVGElement = document;
        for (const child of childNodes) {
          Object.setPrototypeOf(child, SVGElement$1.prototype);
          child.ownerSVGElement = document;
          content.appendChild(child);
        }
      }
      else
        this.selectNode(content);
      return content;
    }

    cloneRange() {
      const range = new Range;
      range[START] = this[START];
      range[END] = this[END];
      return range;
    }
  }

  const isOK = ({nodeType}, mask) => {
    switch (nodeType) {
      case ELEMENT_NODE:
        return mask & SHOW_ELEMENT;
      case TEXT_NODE:
        return mask & SHOW_TEXT;
      case COMMENT_NODE:
        return mask & SHOW_COMMENT;
      case CDATA_SECTION_NODE:
        return mask & SHOW_CDATA_SECTION;
    }
    return 0;
  };

  /**
   * @implements globalThis.TreeWalker
   */
  class TreeWalker {
    constructor(root, whatToShow = SHOW_ALL) {
      this.root = root;
      this.currentNode = root;
      this.whatToShow = whatToShow;
      let {[NEXT]: next, [END]: end} = root;
      if (root.nodeType === DOCUMENT_NODE) {
        const {documentElement} = root;
        next = documentElement;
        end = documentElement[END];
      }
      const nodes = [];
      while (next && next !== end) {
        if (isOK(next, whatToShow))
          nodes.push(next);
        next = next[NEXT];
      }
      this[PRIVATE] = {i: 0, nodes};
    }

    nextNode() {
      const $ = this[PRIVATE];
      this.currentNode = $.i < $.nodes.length ? $.nodes[$.i++] : null;
      return this.currentNode;
    }
  }

  const query = (method, ownerDocument, selectors) => {
    let {[NEXT]: next, [END]: end} = ownerDocument;
    return method.call({ownerDocument, [NEXT]: next, [END]: end}, selectors);
  };

  const globalExports = assign(
    {},
    Facades,
    HTMLClasses,
    {
      CustomEvent: CustomEvent$1,
      Event: GlobalEvent,
      EventTarget: DOMEventTarget,
      InputEvent,
      NamedNodeMap,
      NodeList
    }
  );

  const window$1 = new WeakMap;

  /**
   * @implements globalThis.Document
   */
  let Document$1 = class Document extends NonElementParentNode {
    constructor(type) {
      super(null, '#document', DOCUMENT_NODE);
      this[CUSTOM_ELEMENTS] = {active: false, registry: null};
      this[MUTATION_OBSERVER] = {active: false, class: null};
      this[MIME] = Mime[type];
      /** @type {DocumentType} */
      this[DOCTYPE] = null;
      this[DOM_PARSER] = null;
      this[GLOBALS] = null;
      this[IMAGE] = null;
      this[UPGRADE] = null;
    }

    /**
     * @type {globalThis.Document['defaultView']}
     */
    get defaultView() {
      if (!window$1.has(this))
        window$1.set(this, new Proxy(globalThis, {
          set: (target, name, value) => {
            switch (name) {
              case 'addEventListener':
              case 'removeEventListener':
              case 'dispatchEvent':
                this[EVENT_TARGET][name] = value;
                break;
              default:
                target[name] = value;
                break;
            }
            return true;
          },
          get: (globalThis, name) => {
            switch (name) {
              case 'addEventListener':
              case 'removeEventListener':
              case 'dispatchEvent':
                if (!this[EVENT_TARGET]) {
                  const et = this[EVENT_TARGET] = new DOMEventTarget;
                  et.dispatchEvent = et.dispatchEvent.bind(et);
                  et.addEventListener = et.addEventListener.bind(et);
                  et.removeEventListener = et.removeEventListener.bind(et);
                }
                return this[EVENT_TARGET][name];
              case 'document':
                return this;
              /* c8 ignore start */
              case 'navigator':
                return {
                  userAgent: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36'
                };
              /* c8 ignore stop */
              case 'window':
                return window$1.get(this);
              case 'customElements':
                if (!this[CUSTOM_ELEMENTS].registry)
                  this[CUSTOM_ELEMENTS] = new CustomElementRegistry(this);
                return this[CUSTOM_ELEMENTS];
              case 'performance':
                return globalThis.performance;
              case 'DOMParser':
                return this[DOM_PARSER];
              case 'Image':
                if (!this[IMAGE])
                  this[IMAGE] = ImageClass(this);
                return this[IMAGE];
              case 'MutationObserver':
                if (!this[MUTATION_OBSERVER].class)
                  this[MUTATION_OBSERVER] = new MutationObserverClass(this);
                return this[MUTATION_OBSERVER].class;
            }
            return (this[GLOBALS] && this[GLOBALS][name]) ||
                    globalExports[name] ||
                    globalThis[name];
          }
        }));
      return window$1.get(this);
    }

    get doctype() {
      const docType = this[DOCTYPE];
      if (docType)
        return docType;
      const {firstChild} = this;
      if (firstChild && firstChild.nodeType === DOCUMENT_TYPE_NODE)
        return (this[DOCTYPE] = firstChild);
      return null;
    }

    set doctype(value) {
      if (/^([a-z:]+)(\s+system|\s+public(\s+"([^"]+)")?)?(\s+"([^"]+)")?/i.test(value)) {
        const {$1: name, $4: publicId, $6: systemId} = RegExp;
        this[DOCTYPE] = new DocumentType$1(this, name, publicId, systemId);
        knownSiblings(this, this[DOCTYPE], this[NEXT]);
      }
    }

    get documentElement() {
      return this.firstElementChild;
    }

    get isConnected() { return true; }

    /**
     * @protected
     */
     _getParent() {
      return this[EVENT_TARGET];
    }

    createAttribute(name) { return new Attr$1(this, name); }
    createCDATASection(data) { return new CDATASection$1(this, data); }
    createComment(textContent) { return new Comment$1(this, textContent); }
    createDocumentFragment() { return new DocumentFragment$1(this); }
    createDocumentType(name, publicId, systemId) { return new DocumentType$1(this, name, publicId, systemId); }
    createElement(localName) { return new Element$2(this, localName); }
    createRange() {
      const range = new Range;
      range.commonAncestorContainer = this;
      return range;
    }
    createTextNode(textContent) { return new Text$1(this, textContent); }
    createTreeWalker(root, whatToShow = -1) { return new TreeWalker(root, whatToShow); }
    createNodeIterator(root, whatToShow = -1) { return this.createTreeWalker(root, whatToShow); }

    createEvent(name) {
      const event = create$1(name === 'Event' ? new GlobalEvent('') : new CustomEvent$1(''));
      event.initEvent = event.initCustomEvent = (
        type,
        canBubble = false,
        cancelable = false,
        detail
      ) => {
        event.bubbles = !!canBubble;

        defineProperties(event, {
          type: {value: type},
          canBubble: {value: canBubble},
          cancelable: {value: cancelable},
          detail: {value: detail}
        });
      };
      return event;
    }

    cloneNode(deep = false) {
      const {
        constructor,
        [CUSTOM_ELEMENTS]: customElements,
        [DOCTYPE]: doctype
      } = this;
      const document = new constructor();
      document[CUSTOM_ELEMENTS] = customElements;
      if (deep) {
        const end = document[END];
        const {childNodes} = this;
        for (let {length} = childNodes, i = 0; i < length; i++)
          document.insertBefore(childNodes[i].cloneNode(true), end);
        if (doctype)
          document[DOCTYPE] = childNodes[0];
      }
      return document;
    }

    importNode(externalNode) {
      // important: keep the signature length as *one*
      // or it would behave like old IE or Edge with polyfills
      const deep = 1 < arguments.length && !!arguments[1];
      const node = externalNode.cloneNode(deep);
      const {[CUSTOM_ELEMENTS]: customElements} = this;
      const {active} = customElements;
      const upgrade = element => {
        const {ownerDocument, nodeType} = element;
        element.ownerDocument = this;
        if (active && ownerDocument !== this && nodeType === ELEMENT_NODE)
          customElements.upgrade(element);
      };
      upgrade(node);
      if (deep) {
        switch (node.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE: {
            let {[NEXT]: next, [END]: end} = node;
            while (next !== end) {
              if (next.nodeType === ELEMENT_NODE)
                upgrade(next);
              next = next[NEXT];
            }
            break;
          }
        }
      }
      return node;
    }

    toString() { return this.childNodes.join(''); }

    querySelector(selectors) {
      return query(super.querySelector, this, selectors);
    }

    querySelectorAll(selectors) {
      return query(super.querySelectorAll, this, selectors);
    }

    /* c8 ignore start */
    getElementsByTagNameNS(_, name) {
      return this.getElementsByTagName(name);
    }
    createAttributeNS(_, name) {
      return this.createAttribute(name);
    }
    createElementNS(nsp, localName, options) {
      return nsp === SVG_NAMESPACE ?
              new SVGElement$1(this, localName, null) :
              this.createElement(localName, options);
    }
    /* c8 ignore stop */
  };

  setPrototypeOf(
    globalExports.Document = function Document() {
      illegalConstructor();
    },
    Document$1
  ).prototype = Document$1.prototype;

  const createHTMLElement = (ownerDocument, builtin, localName, options) => {
    if (!builtin && htmlClasses.has(localName)) {
      const Class = htmlClasses.get(localName);
      return new Class(ownerDocument, localName);
    }
    const {[CUSTOM_ELEMENTS]: {active, registry}} = ownerDocument;
    if (active) {
      const ce = builtin ? options.is : localName;
      if (registry.has(ce)) {
        const {Class} = registry.get(ce);
        const element = new Class(ownerDocument, localName);
        customElements.set(element, {connected: false});
        return element;
      }
    }
    return new HTMLElement$1(ownerDocument, localName);
  };

  /**
   * @implements globalThis.HTMLDocument
   */
  class HTMLDocument extends Document$1 {
    constructor() { super('text/html'); }

    get all() {
      const nodeList = new NodeList;
      let {[NEXT]: next, [END]: end} = this;
      while (next !== end) {
        switch (next.nodeType) {
          case ELEMENT_NODE:
            nodeList.push(next);
            break;
        }
        next = next[NEXT];
      }
      return nodeList;
    }

    /**
     * @type HTMLHeadElement
     */
    get head() {
      const {documentElement} = this;
      let {firstElementChild} = documentElement;
      if (!firstElementChild || firstElementChild.tagName !== 'HEAD') {
        firstElementChild = this.createElement('head');
        documentElement.prepend(firstElementChild);
      }
      return firstElementChild;
    }

    /**
     * @type HTMLBodyElement
     */
    get body() {
      const {head} = this;
      let {nextElementSibling} = head;
      if (!nextElementSibling || nextElementSibling.tagName !== 'BODY') {
        nextElementSibling = this.createElement('body');
        head.after(nextElementSibling);
      }
      return nextElementSibling;
    }

    /**
     * @type HTMLTitleElement
     */
    get title() {
      const {head} = this;
      return head.getElementsByTagName('title').at(0)?.textContent || '';
    }

    set title(textContent) {
      const {head} = this;
      let title = head.getElementsByTagName('title').at(0);
      if (title)
        title.textContent = textContent;
      else {
        head.insertBefore(
          this.createElement('title'),
          head.firstChild
        ).textContent = textContent;
      }
    }

    createElement(localName, options) {
      const builtin = !!(options && options.is);
      const element = createHTMLElement(this, builtin, localName, options);
      if (builtin)
        element.setAttribute('is', options.is);
      return element;
    }
  }

  /**
   * @implements globalThis.Document
   */
  class SVGDocument extends Document$1 {
    constructor() { super('image/svg+xml'); }
    toString() {
      return this[MIME].docType + super.toString();
    }
  }

  /**
   * @implements globalThis.XMLDocument
   */
  class XMLDocument extends Document$1 {
    constructor() { super('text/xml'); }
    toString() {
      return this[MIME].docType + super.toString();
    }
  }

  /**
   * @implements globalThis.DOMParser
   */
  let DOMParser$1 = class DOMParser {

    /** @typedef {{ "text/html": HTMLDocument, "image/svg+xml": SVGDocument, "text/xml": XMLDocument }} MimeToDoc */
    /**
     * @template {keyof MimeToDoc} MIME
     * @param {string} markupLanguage
     * @param {MIME} mimeType
     * @returns {MimeToDoc[MIME]}
     */
    parseFromString(markupLanguage, mimeType, globals = null) {
      let isHTML = false, document;
      if (mimeType === 'text/html') {
        isHTML = true;
        document = new HTMLDocument;
      }
      else if (mimeType === 'image/svg+xml')
        document = new SVGDocument;
      else
        document = new XMLDocument;
      document[DOM_PARSER] = DOMParser;
      if (globals)
        document[GLOBALS] = globals;
      if (isHTML && markupLanguage === '...')
        markupLanguage = '<!doctype html><html><head></head><body></body></html>';
      return markupLanguage ?
              parseFromString$1(document, isHTML, markupLanguage) :
              document;
    }
  };

  function Document() {
    illegalConstructor();
  }

  setPrototypeOf(Document, Document$1).prototype = Document$1.prototype;

  /**
   * @license
   * Copyright 2021 Google LLC
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Parses an html string and returns a parsed html document.
   * @param html An HTML string.
   * @return A Document.
   */
  const parseFromString = (html) => {
      return new DOMParser$1().parseFromString(`<!doctype html><html><body>${html}</body></html>`, 'text/html');
  };

  /**
   * @license
   * Copyright 2021 Google LLC
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Base BudouX parser.
   */
  class Parser {
      /**
       * Constructs a BudouX parser.
       * @param model A model data.
       */
      constructor(model) {
          this.model = new Map(Object.entries(model).map(([k, v]) => [k, new Map(Object.entries(v))]));
          this.baseScore =
              -0.5 *
                  [...this.model.values()]
                      .map(group => [...group.values()])
                      .flat()
                      .reduce((prev, curr) => prev + curr, 0);
      }
      /**
       * Parses the input sentence and returns a list of semantic chunks.
       *
       * @param sentence An input sentence.
       * @return The retrieved chunks.
       */
      parse(sentence) {
          if (sentence === '')
              return [];
          const boundaries = this.parseBoundaries(sentence);
          const result = [];
          let start = 0;
          for (const boundary of boundaries) {
              result.push(sentence.slice(start, boundary));
              start = boundary;
          }
          result.push(sentence.slice(start));
          return result;
      }
      /**
       * Parses the input sentence and returns a list of boundaries.
       *
       * @param sentence An input sentence.
       * @return The list of boundaries.
       */
      parseBoundaries(sentence) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
          const result = [];
          for (let i = 1; i < sentence.length; i++) {
              let score = this.baseScore;
              // NOTE: Score values in models may be negative.
              /* eslint-disable */
              score += ((_a = this.model.get('UW1')) === null || _a === void 0 ? void 0 : _a.get(sentence.substring(i - 3, i - 2))) || 0;
              score += ((_b = this.model.get('UW2')) === null || _b === void 0 ? void 0 : _b.get(sentence.substring(i - 2, i - 1))) || 0;
              score += ((_c = this.model.get('UW3')) === null || _c === void 0 ? void 0 : _c.get(sentence.substring(i - 1, i))) || 0;
              score += ((_d = this.model.get('UW4')) === null || _d === void 0 ? void 0 : _d.get(sentence.substring(i, i + 1))) || 0;
              score += ((_e = this.model.get('UW5')) === null || _e === void 0 ? void 0 : _e.get(sentence.substring(i + 1, i + 2))) || 0;
              score += ((_f = this.model.get('UW6')) === null || _f === void 0 ? void 0 : _f.get(sentence.substring(i + 2, i + 3))) || 0;
              score += ((_g = this.model.get('BW1')) === null || _g === void 0 ? void 0 : _g.get(sentence.substring(i - 2, i))) || 0;
              score += ((_h = this.model.get('BW2')) === null || _h === void 0 ? void 0 : _h.get(sentence.substring(i - 1, i + 1))) || 0;
              score += ((_j = this.model.get('BW3')) === null || _j === void 0 ? void 0 : _j.get(sentence.substring(i, i + 2))) || 0;
              score += ((_k = this.model.get('TW1')) === null || _k === void 0 ? void 0 : _k.get(sentence.substring(i - 3, i))) || 0;
              score += ((_l = this.model.get('TW2')) === null || _l === void 0 ? void 0 : _l.get(sentence.substring(i - 2, i + 1))) || 0;
              score += ((_m = this.model.get('TW3')) === null || _m === void 0 ? void 0 : _m.get(sentence.substring(i - 1, i + 2))) || 0;
              score += ((_o = this.model.get('TW4')) === null || _o === void 0 ? void 0 : _o.get(sentence.substring(i, i + 3))) || 0;
              /* eslint-enable */
              if (score > 0)
                  result.push(i);
          }
          return result;
      }
  }

  /**
   * @license
   * Copyright 2021 Google LLC
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const assert = console.assert;
  const ZWSP_CODEPOINT = 0x200b; // U+200B ZERO WIDTH SPACE
  const ZWSP = String.fromCharCode(ZWSP_CODEPOINT);
  // We could use `Node.TEXT_NODE` and `Node.ELEMENT_NODE` in a browser context,
  // but we define the same here for Node.js environments.
  const NodeType = {
      ELEMENT_NODE: 1,
      TEXT_NODE: 3,
  };
  const DomAction = {
      Inline: 0, // An inline content, becomes a part of a paragraph.
      Block: 1, // A nested paragraph.
      Skip: 2, // Skip the content. The content before and after are connected.
      Break: 3, // A forced break. The content before and after become paragraphs.
      NoBreak: 4, // The content provides context, but it's not breakable.
      BreakOpportunity: 5, // Force a break opportunity.
  };
  /**
   * Determines the action from an element name, as defined in
   * {@link https://html.spec.whatwg.org/multipage/rendering.html HTML Rendering}.
   * See also {@link actionForElement}.
   */
  const domActions = {
      // Hidden elements
      // https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements
      AREA: DomAction.Skip,
      BASE: DomAction.Skip,
      BASEFONT: DomAction.Skip,
      DATALIST: DomAction.Skip,
      HEAD: DomAction.Skip,
      LINK: DomAction.Skip,
      META: DomAction.Skip,
      NOEMBED: DomAction.Skip,
      NOFRAMES: DomAction.Skip,
      PARAM: DomAction.Skip,
      RP: DomAction.Skip,
      SCRIPT: DomAction.Skip,
      STYLE: DomAction.Skip,
      TEMPLATE: DomAction.Skip,
      TITLE: DomAction.Skip,
      NOSCRIPT: DomAction.Skip,
      // Flow content
      // https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3
      HR: DomAction.Break,
      // Disable if `white-space: pre`.
      LISTING: DomAction.Skip,
      PLAINTEXT: DomAction.Skip,
      PRE: DomAction.Skip,
      XMP: DomAction.Skip,
      // Phrasing content
      // https://html.spec.whatwg.org/multipage/rendering.html#phrasing-content-3
      BR: DomAction.Break,
      RT: DomAction.Skip,
      WBR: DomAction.BreakOpportunity,
      // Form controls
      // https://html.spec.whatwg.org/multipage/rendering.html#form-controls
      INPUT: DomAction.Skip,
      SELECT: DomAction.Skip,
      BUTTON: DomAction.Skip,
      TEXTAREA: DomAction.Skip,
      // Other elements where the phrase-based line breaking should be disabled.
      // https://github.com/google/budoux/blob/main/budoux/skip_nodes.json
      ABBR: DomAction.Skip,
      CODE: DomAction.Skip,
      IFRAME: DomAction.Skip,
      TIME: DomAction.Skip,
      VAR: DomAction.Skip,
      // Deprecated, but supported in all browsers.
      // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nobr
      NOBR: DomAction.NoBreak,
  };
  const defaultBlockElements = new Set([
      // 15.3.2 The page
      'HTML',
      'BODY',
      // 15.3.3 Flow content
      'ADDRESS',
      'BLOCKQUOTE',
      'CENTER',
      'DIALOG',
      'DIV',
      'FIGURE',
      'FIGCAPTION',
      'FOOTER',
      'FORM',
      'HEADER',
      'LEGEND',
      'LISTING',
      'MAIN',
      'P',
      // 15.3.6 Sections and headings
      'ARTICLE',
      'ASIDE',
      'H1',
      'H2',
      'H3',
      'H4',
      'H5',
      'H6',
      'HGROUP',
      'NAV',
      'SECTION',
      // 15.3.7 Lists
      'DIR',
      'DD',
      'DL',
      'DT',
      'MENU',
      'OL',
      'UL',
      'LI',
      // 15.3.8 Tables
      'TABLE',
      'CAPTION',
      'COL',
      'TR',
      'TD',
      'TH',
      // 15.3.12 The fieldset and legend elements
      'FIELDSET',
      // 15.5.4 The details and summary elements
      'DETAILS',
      'SUMMARY',
      // 15.5.12 The marquee element
      'MARQUEE',
  ]);
  /**
   * Determine the action for a CSS `display` property value.
   * @param display The value of the CSS `display` property.
   * @return The {@link domActions} for the value.
   */
  function actionForDisplay(display) {
      // Handle common cases first.
      if (display === 'inline')
          return DomAction.Inline;
      if (display === 'block')
          return DomAction.Block;
      // Handle Ruby base as in-flow.
      if (display.startsWith('ruby')) {
          if (display === 'ruby-text')
              return DomAction.Skip;
          return DomAction.Inline;
      }
      // Handle other values including multi-value syntax as blocks.
      // https://drafts.csswg.org/css-display/#the-display-properties
      return DomAction.Block;
  }
  /**
   * Determine the action for an element.
   * @param element An element to determine the action for.
   * @return The {@link domActions} for the element.
   */
  function actionForElement(element) {
      const nodeName = element.nodeName;
      const action = domActions[nodeName];
      if (action !== undefined)
          return action;
      if (typeof globalThis.getComputedStyle === 'function') {
          const style = globalThis.getComputedStyle(element);
          switch (style.whiteSpace) {
              case 'nowrap':
              case 'pre':
                  return DomAction.NoBreak;
          }
          const display = style.display;
          if (display)
              return actionForDisplay(display);
          // `display` is an empty string if the element is not connected.
      }
      // Use the built-in rules if the `display` property is empty, or if
      // `getComputedStyle` is missing (e.g., jsdom.)
      return defaultBlockElements.has(nodeName)
          ? DomAction.Block
          : DomAction.Inline;
  }
  /**
   * Applies wrapping styles to make linebreak controls work in children.
   * @param element A parent element to apply the styles.
   */
  const applyWrapStyle = (element) => {
      element.style.wordBreak = 'keep-all';
      element.style.overflowWrap = 'anywhere';
  };
  /**
   * Represents a node in {@link Paragraph}.
   *
   * It wraps a {@link Text} or a {@link string}.
   *
   * A {@link string} provides the context for the parser, but it can't be split.
   */
  class NodeOrText {
      constructor(nodeOrText) {
          this.chunks = [];
          this.hasBreakOpportunityAfter = false;
          this.nodeOrText = nodeOrText;
      }
      static isString(value) {
          return typeof value === 'string';
      }
      get canSplit() {
          return !NodeOrText.isString(this.nodeOrText);
      }
      get text() {
          return NodeOrText.isString(this.nodeOrText)
              ? this.nodeOrText
              : this.nodeOrText.nodeValue;
      }
      get length() {
          var _a, _b;
          return (_b = (_a = this.text) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      }
      /**
       * Split the {@link Text} in the same way as the {@link chunks}.
       * Joining all {@link chunks} must be equal to {@link text}.
       */
      split(separator) {
          const chunks = this.chunks;
          assert(chunks.length === 0 || chunks.join('') === this.text);
          if (chunks.length <= 1)
              return;
          if (NodeOrText.isString(this.nodeOrText))
              return;
          const node = this.nodeOrText;
          if (typeof separator === 'string') {
              // If the `separator` is a string, insert it at each boundary.
              node.nodeValue = chunks.join(separator);
              return;
          }
          // Otherwise create a `Text` node for each chunk, with the separator node
          // between them, and replace the `node` with them.
          const document = node.ownerDocument;
          let nodes = [];
          for (const chunk of chunks) {
              if (chunk)
                  nodes.push(document.createTextNode(chunk));
              // Add a separator between chunks. To simplify the logic, add a separator
              // after each chunk, then remove the last one.
              // To avoid `cloneNode` for the temporary one that is going to be removed,
              // add `null` as a marker, then replace them with `cloneNode` later.
              nodes.push(null);
          }
          nodes.pop();
          nodes = nodes.map(n => (n ? n : separator.cloneNode(true)));
          node.replaceWith(...nodes);
      }
  }
  /**
   * Represents a "paragraph", broken by block boundaries or forced breaks.
   *
   * A CSS
   * {@link https://drafts.csswg.org/css2/#inline-formatting inline formatting context}
   * is usually a "paragraph", but it can be broken into multiple paragraphs by
   * forced breaks such as `<br>`.
   */
  class Paragraph {
      constructor(element) {
          this.nodes = [];
          this.element = element;
      }
      isEmpty() {
          return this.nodes.length === 0;
      }
      get text() {
          return this.nodes.map(node => node.text).join('');
      }
      get lastNode() {
          return this.nodes.length ? this.nodes[this.nodes.length - 1] : undefined;
      }
      setHasBreakOpportunityAfter() {
          const lastNode = this.lastNode;
          if (lastNode)
              lastNode.hasBreakOpportunityAfter = true;
      }
      /**
       * @return Indices of forced break opportunities in the source.
       * They can be created by `<wbr>` tag or `&ZeroWidthSpace;`.
       */
      getForcedOpportunities() {
          const opportunities = [];
          let len = 0;
          for (const node of this.nodes) {
              if (node.canSplit) {
                  const text = node.text;
                  if (text) {
                      for (let i = 0; i < text.length; ++i) {
                          if (text.charCodeAt(i) === ZWSP_CODEPOINT) {
                              opportunities.push(len + i + 1);
                          }
                      }
                  }
              }
              len += node.length;
              if (node.hasBreakOpportunityAfter) {
                  opportunities.push(len);
              }
          }
          return opportunities;
      }
      /**
       * @return Filtered {@param boundaries} by excluding
       * {@link getForcedOpportunities} if it's not empty.
       * Otherwise {@param boundaries}.
       */
      excludeForcedOpportunities(boundaries) {
          const forcedOpportunities = this.getForcedOpportunities();
          if (!forcedOpportunities.length)
              return boundaries;
          const set = new Set(forcedOpportunities);
          return boundaries.filter(i => !set.has(i));
      }
  }
  /**
   * Adds HTML processing support to a BudouX {@link Parser}.
   */
  class HTMLProcessor {
      /**
       * @param parser A BudouX {@link Parser} to compute semantic line breaks.
       */
      constructor(parser, options) {
          /** See {@link HTMLProcessorOptions.separator}. */
          this.separator = ZWSP;
          this.parser_ = parser;
          if (options !== undefined) {
              if (options.className !== undefined)
                  this.className = options.className;
              if (options.separator !== undefined)
                  this.separator = options.separator;
          }
      }
      /**
       * Checks if the given element has a text node in its children.
       *
       * @param ele An element to be checked.
       * @return Whether the element has a child text node.
       */
      static hasChildTextNode(ele) {
          for (const child of ele.childNodes) {
              if (child.nodeType === NodeType.TEXT_NODE)
                  return true;
          }
          return false;
      }
      /**
       * Applies markups for semantic line breaks to the given HTML element.
       *
       * It breaks descendant nodes into paragraphs,
       * and applies the BudouX to each paragraph.
       * @param element The input element.
       */
      applyToElement(element) {
          for (const block of this.getBlocks(element)) {
              assert(!block.isEmpty());
              this.applyToParagraph(block);
          }
      }
      /**
       * Find paragraphs from a given HTML element.
       * @param element The root element to find paragraphs.
       * @param parent The parent {@link Paragraph} if any.
       * @return A list of {@link Paragraph}s.
       */
      *getBlocks(element, parent) {
          assert(element.nodeType === NodeType.ELEMENT_NODE);
          // Skip if it was once applied to this element.
          if (this.className && element.classList.contains(this.className))
              return;
          const action = actionForElement(element);
          if (action === DomAction.Skip)
              return;
          if (action === DomAction.Break) {
              if (parent && !parent.isEmpty()) {
                  parent.setHasBreakOpportunityAfter();
                  yield parent;
                  parent.nodes = [];
              }
              assert(!element.firstChild);
              return;
          }
          if (action === DomAction.BreakOpportunity) {
              if (parent)
                  parent.setHasBreakOpportunityAfter();
              return;
          }
          // Determine if this element creates a new inline formatting context, or if
          // this element belongs to the parent inline formatting context.
          assert(action === DomAction.Block ||
              action === DomAction.Inline ||
              action === DomAction.NoBreak);
          const isNewBlock = !parent || action === DomAction.Block;
          const block = isNewBlock ? new Paragraph(element) : parent;
          // Collect all text nodes in this inline formatting context, while searching
          // descendant elements recursively.
          for (const child of element.childNodes) {
              switch (child.nodeType) {
                  case NodeType.ELEMENT_NODE:
                      for (const childBlock of this.getBlocks(child, block))
                          yield childBlock;
                      break;
                  case NodeType.TEXT_NODE:
                      if (action === DomAction.NoBreak) {
                          const text = child.nodeValue;
                          if (text) {
                              block.nodes.push(new NodeOrText(text));
                          }
                          break;
                      }
                      block.nodes.push(new NodeOrText(child));
                      break;
              }
          }
          // Apply if this is an inline formatting context.
          if (isNewBlock && !block.isEmpty())
              yield block;
      }
      /**
       * Apply the BudouX to the given {@link Paragraph}.
       * @param paragraph The {@link Paragraph} to apply.
       */
      applyToParagraph(paragraph) {
          assert(paragraph.nodes.length > 0);
          if (!paragraph.nodes.some(node => node.canSplit))
              return;
          const text = paragraph.text;
          // No changes if whitespace-only.
          if (/^\s*$/.test(text))
              return;
          // Compute the phrase boundaries.
          const boundaries = this.parser_.parseBoundaries(text);
          // No changes if single phrase.
          if (boundaries.length <= 0)
              return;
          // The boundaries should be between 1 and `text.length - 1` in the
          // ascending order.
          assert(boundaries[0] > 0);
          assert(boundaries.every((x, i) => i === 0 || x > boundaries[i - 1]));
          assert(boundaries[boundaries.length - 1] < text.length);
          const adjustedBoundaries = paragraph.excludeForcedOpportunities(boundaries);
          // Add a sentinel to help iterating.
          adjustedBoundaries.push(text.length + 1);
          this.splitNodes(paragraph.nodes, adjustedBoundaries);
          this.applyBlockStyle(paragraph.element);
      }
      /**
       * Split {@link NodeOrText} at the specified boundaries.
       * @param nodes A list of {@link NodeOrText}.
       * @param boundaries A list of indices of the text to split at.
       */
      splitNodes(nodes, boundaries) {
          var _a;
          assert(boundaries.length > 0);
          assert(boundaries.every((x, i) => i === 0 || x > boundaries[i - 1]));
          const textLen = nodes.reduce((sum, node) => sum + node.length, 0);
          // The last boundary must be a sentinel.
          assert(boundaries[boundaries.length - 1] > textLen);
          // Distribute `boundaries` to `node.chunks`.
          let boundary_index = 0;
          let boundary = boundaries[0];
          assert(boundary > 0);
          let nodeStart = 0; // the start index of the `nodeText` in the whole text.
          let lastNode = null;
          for (const node of nodes) {
              assert(boundary >= nodeStart);
              assert(node.chunks.length === 0);
              const nodeText = node.text;
              if (!nodeText)
                  continue;
              const nodeLength = nodeText.length;
              const nodeEnd = nodeStart + nodeLength;
              assert(!lastNode || lastNode.canSplit);
              if (!node.canSplit) {
                  // If there's a boundary between nodes and `lastNode.canSplit`, add a
                  // boundary to the end of the `lastNode`.
                  if (lastNode && boundary === nodeStart) {
                      if (lastNode.chunks.length === 0)
                          lastNode.chunks.push((_a = lastNode.text) !== null && _a !== void 0 ? _a : '');
                      lastNode.chunks.push('');
                  }
                  while (boundary < nodeEnd) {
                      boundary = boundaries[++boundary_index];
                  }
                  lastNode = null;
                  nodeStart = nodeEnd;
                  continue;
              }
              // Check if the next boundary is in this `node`.
              lastNode = node;
              if (boundary >= nodeEnd) {
                  nodeStart = nodeEnd;
                  continue;
              }
              // Compute the boundary indices in the `node`.
              const chunks = node.chunks;
              let chunkStartInNode = 0;
              while (boundary < nodeEnd) {
                  const boundaryInNode = boundary - nodeStart;
                  assert(boundaryInNode >= chunkStartInNode);
                  chunks.push(nodeText.slice(chunkStartInNode, boundaryInNode));
                  chunkStartInNode = boundaryInNode;
                  boundary = boundaries[++boundary_index];
              }
              // Add the rest of the `nodeText`.
              assert(chunkStartInNode < nodeLength);
              chunks.push(nodeText.slice(chunkStartInNode));
              nodeStart = nodeEnd;
          }
          // Check if all nodes and boundaries are consumed.
          assert(nodeStart === textLen);
          assert(boundary_index < boundaries.length);
          assert(boundaries[boundary_index] >= textLen);
          // `node.chunks` are finalized. Split them.
          for (const node of nodes) {
              node.split(this.separator);
          }
      }
      /**
       * Applies the block style to the given element.
       * @param element The element to apply the block style.
       */
      applyBlockStyle(element) {
          if (this.className) {
              element.classList.add(this.className);
              return;
          }
          applyWrapStyle(element);
      }
  }
  /**
   * BudouX {@link Parser} with HTML processing support.
   */
  class HTMLProcessingParser extends Parser {
      constructor(model, htmlProcessorOptions = {
          separator: ZWSP,
      }) {
          super(model);
          this.htmlProcessor = new HTMLProcessor(this, htmlProcessorOptions);
      }
      /**
       * Applies markups for semantic line breaks to the given HTML element.
       * @param parentElement The input element.
       */
      applyToElement(parentElement) {
          this.htmlProcessor.applyToElement(parentElement);
      }
      /**
       * Translates the given HTML string to another HTML string with markups
       * for semantic line breaks.
       * @param html An input html string.
       * @return The translated HTML string.
       */
      translateHTMLString(html) {
          if (html === '')
              return html;
          const doc = parseFromString(html);
          if (HTMLProcessor.hasChildTextNode(doc.body)) {
              const wrapper = doc.createElement('span');
              wrapper.append(...doc.body.childNodes);
              doc.body.append(wrapper);
          }
          this.applyToElement(doc.body.childNodes[0]);
          return doc.body.innerHTML;
      }
  }

  /**
   * @license
   * Copyright 2021 Google LLC
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Loads a parser equipped with the default Japanese model.
   * @return A parser with the default Japanese model.
   */
  const loadDefaultJapaneseParser = () => {
      return new HTMLProcessingParser(model);
  };

  // import barba from "@barba/core";
  var parser = loadDefaultJapaneseParser();
  var BudouX = /*#__PURE__*/function () {
    function BudouX() {
      _classCallCheck(this, BudouX);
      this.load();
      // barba.hooks.beforeOnce((data) => {
      //     this.load();
      // })
      // barba.hooks.after((data) => {
      //     this.load();
      // });
    }
    return _createClass$1(BudouX, [{
      key: "load",
      value: function load() {
        var elms = document.querySelectorAll('[data-budoux]');
        if (elms.length) {
          var _iterator = _createForOfIteratorHelper(elms),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var elm = _step.value;
              parser.applyElement(elm);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }
    }]);
  }();

  /**
   * Returns a new indexed geometry based on `TrianglesDrawMode` draw mode.
   * This mode corresponds to the `gl.TRIANGLES` primitive in WebGL.
   *
   * @param {BufferGeometry} geometry - The geometry to convert.
   * @param {number} drawMode - The current draw mode.
   * @return {BufferGeometry} The new geometry using `TrianglesDrawMode`.
   */
  function toTrianglesDrawMode( geometry, drawMode ) {

  	if ( drawMode === TrianglesDrawMode ) {

  		console.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );
  		return geometry;

  	}

  	if ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {

  		let index = geometry.getIndex();

  		// generate index if not present

  		if ( index === null ) {

  			const indices = [];

  			const position = geometry.getAttribute( 'position' );

  			if ( position !== undefined ) {

  				for ( let i = 0; i < position.count; i ++ ) {

  					indices.push( i );

  				}

  				geometry.setIndex( indices );
  				index = geometry.getIndex();

  			} else {

  				console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
  				return geometry;

  			}

  		}

  		//

  		const numberOfTriangles = index.count - 2;
  		const newIndices = [];

  		if ( drawMode === TriangleFanDrawMode ) {

  			// gl.TRIANGLE_FAN

  			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

  				newIndices.push( index.getX( 0 ) );
  				newIndices.push( index.getX( i ) );
  				newIndices.push( index.getX( i + 1 ) );

  			}

  		} else {

  			// gl.TRIANGLE_STRIP

  			for ( let i = 0; i < numberOfTriangles; i ++ ) {

  				if ( i % 2 === 0 ) {

  					newIndices.push( index.getX( i ) );
  					newIndices.push( index.getX( i + 1 ) );
  					newIndices.push( index.getX( i + 2 ) );

  				} else {

  					newIndices.push( index.getX( i + 2 ) );
  					newIndices.push( index.getX( i + 1 ) );
  					newIndices.push( index.getX( i ) );

  				}

  			}

  		}

  		if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

  			console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

  		}

  		// build final geometry

  		const newGeometry = geometry.clone();
  		newGeometry.setIndex( newIndices );
  		newGeometry.clearGroups();

  		return newGeometry;

  	} else {

  		console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );
  		return geometry;

  	}

  }

  /**
   * A loader for the glTF 2.0 format.
   *
   * [glTF]{@link https://www.khronos.org/gltf/} (GL Transmission Format) is an [open format specification]{@link https://github.com/KhronosGroup/glTF/tree/main/specification/2.0}
   * for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf) or binary (.glb)
   * format. External files store textures (.jpg, .png) and additional binary data (.bin). A glTF asset may deliver
   * one or more scenes, including meshes, materials, textures, skins, skeletons, morph targets, animations, lights,
   * and/or cameras.
   *
   * `GLTFLoader` uses {@link ImageBitmapLoader} whenever possible. Be advised that image bitmaps are not
   * automatically GC-collected when they are no longer referenced, and they require special handling during
   * the disposal process.
   *
   * `GLTFLoader` supports the following glTF 2.0 extensions:
   * - KHR_draco_mesh_compression
   * - KHR_materials_clearcoat
   * - KHR_materials_dispersion
   * - KHR_materials_ior
   * - KHR_materials_specular
   * - KHR_materials_transmission
   * - KHR_materials_iridescence
   * - KHR_materials_unlit
   * - KHR_materials_volume
   * - KHR_mesh_quantization
   * - KHR_lights_punctual
   * - KHR_texture_basisu
   * - KHR_texture_transform
   * - EXT_texture_webp
   * - EXT_meshopt_compression
   * - EXT_mesh_gpu_instancing
   *
   * The following glTF 2.0 extension is supported by an external user plugin:
   * - [KHR_materials_variants]{@link https://github.com/takahirox/three-gltf-extensions}
   * - [MSFT_texture_dds]{@link https://github.com/takahirox/three-gltf-extensions}
   *
   * ```js
   * const loader = new GLTFLoader();
   *
   * // Optional: Provide a DRACOLoader instance to decode compressed mesh data
   * const dracoLoader = new DRACOLoader();
   * dracoLoader.setDecoderPath( '/examples/jsm/libs/draco/' );
   * loader.setDRACOLoader( dracoLoader );
   *
   * const gltf = await loader.loadAsync( 'models/gltf/duck/duck.gltf' );
   * scene.add( gltf.scene );
   * ```
   *
   * @augments Loader
   * @three_import import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
   */
  class GLTFLoader extends Loader {

  	/**
  	 * Constructs a new glTF loader.
  	 *
  	 * @param {LoadingManager} [manager] - The loading manager.
  	 */
  	constructor( manager ) {

  		super( manager );

  		this.dracoLoader = null;
  		this.ktx2Loader = null;
  		this.meshoptDecoder = null;

  		this.pluginCallbacks = [];

  		this.register( function ( parser ) {

  			return new GLTFMaterialsClearcoatExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsDispersionExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFTextureBasisUExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFTextureWebPExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFTextureAVIFExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsSheenExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsTransmissionExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsVolumeExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsIorExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsEmissiveStrengthExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsSpecularExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsIridescenceExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsAnisotropyExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMaterialsBumpExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFLightsExtension( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMeshoptCompression( parser );

  		} );

  		this.register( function ( parser ) {

  			return new GLTFMeshGpuInstancing( parser );

  		} );

  	}

  	/**
  	 * Starts loading from the given URL and passes the loaded glTF asset
  	 * to the `onLoad()` callback.
  	 *
  	 * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
  	 * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.
  	 * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
  	 * @param {onErrorCallback} onError - Executed when errors occur.
  	 */
  	load( url, onLoad, onProgress, onError ) {

  		const scope = this;

  		let resourcePath;

  		if ( this.resourcePath !== '' ) {

  			resourcePath = this.resourcePath;

  		} else if ( this.path !== '' ) {

  			// If a base path is set, resources will be relative paths from that plus the relative path of the gltf file
  			// Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'
  			// resourcePath = 'https://my-cnd-server.com/assets/models/'
  			// referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'
  			// referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'
  			const relativeUrl = LoaderUtils.extractUrlBase( url );
  			resourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );

  		} else {

  			resourcePath = LoaderUtils.extractUrlBase( url );

  		}

  		// Tells the LoadingManager to track an extra item, which resolves after
  		// the model is fully loaded. This means the count of items loaded will
  		// be incorrect, but ensures manager.onLoad() does not fire early.
  		this.manager.itemStart( url );

  		const _onError = function ( e ) {

  			if ( onError ) {

  				onError( e );

  			} else {

  				console.error( e );

  			}

  			scope.manager.itemError( url );
  			scope.manager.itemEnd( url );

  		};

  		const loader = new FileLoader( this.manager );

  		loader.setPath( this.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.setRequestHeader( this.requestHeader );
  		loader.setWithCredentials( this.withCredentials );

  		loader.load( url, function ( data ) {

  			try {

  				scope.parse( data, resourcePath, function ( gltf ) {

  					onLoad( gltf );

  					scope.manager.itemEnd( url );

  				}, _onError );

  			} catch ( e ) {

  				_onError( e );

  			}

  		}, onProgress, _onError );

  	}

  	/**
  	 * Sets the given Draco loader to this loader. Required for decoding assets
  	 * compressed with the `KHR_draco_mesh_compression` extension.
  	 *
  	 * @param {DRACOLoader} dracoLoader - The Draco loader to set.
  	 * @return {GLTFLoader} A reference to this loader.
  	 */
  	setDRACOLoader( dracoLoader ) {

  		this.dracoLoader = dracoLoader;
  		return this;

  	}

  	/**
  	 * Sets the given KTX2 loader to this loader. Required for loading KTX2
  	 * compressed textures.
  	 *
  	 * @param {KTX2Loader} ktx2Loader - The KTX2 loader to set.
  	 * @return {GLTFLoader} A reference to this loader.
  	 */
  	setKTX2Loader( ktx2Loader ) {

  		this.ktx2Loader = ktx2Loader;
  		return this;

  	}

  	/**
  	 * Sets the given meshopt decoder. Required for decoding assets
  	 * compressed with the `EXT_meshopt_compression` extension.
  	 *
  	 * @param {Object} meshoptDecoder - The meshopt decoder to set.
  	 * @return {GLTFLoader} A reference to this loader.
  	 */
  	setMeshoptDecoder( meshoptDecoder ) {

  		this.meshoptDecoder = meshoptDecoder;
  		return this;

  	}

  	/**
  	 * Registers a plugin callback. This API is internally used to implement the various
  	 * glTF extensions but can also used by third-party code to add additional logic
  	 * to the loader.
  	 *
  	 * @param {function(parser:GLTFParser)} callback - The callback function to register.
  	 * @return {GLTFLoader} A reference to this loader.
  	 */
  	register( callback ) {

  		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

  			this.pluginCallbacks.push( callback );

  		}

  		return this;

  	}

  	/**
  	 * Unregisters a plugin callback.
  	 *
  	 * @param {Function} callback - The callback function to unregister.
  	 * @return {GLTFLoader} A reference to this loader.
  	 */
  	unregister( callback ) {

  		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

  			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

  		}

  		return this;

  	}

  	/**
  	 * Parses the given FBX data and returns the resulting group.
  	 *
  	 * @param {string|ArrayBuffer} data - The raw glTF data.
  	 * @param {string} path - The URL base path.
  	 * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.
  	 * @param {onErrorCallback} onError - Executed when errors occur.
  	 */
  	parse( data, path, onLoad, onError ) {

  		let json;
  		const extensions = {};
  		const plugins = {};
  		const textDecoder = new TextDecoder();

  		if ( typeof data === 'string' ) {

  			json = JSON.parse( data );

  		} else if ( data instanceof ArrayBuffer ) {

  			const magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );

  			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

  				try {

  					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

  				} catch ( error ) {

  					if ( onError ) onError( error );
  					return;

  				}

  				json = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );

  			} else {

  				json = JSON.parse( textDecoder.decode( data ) );

  			}

  		} else {

  			json = data;

  		}

  		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

  			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
  			return;

  		}

  		const parser = new GLTFParser( json, {

  			path: path || this.resourcePath || '',
  			crossOrigin: this.crossOrigin,
  			requestHeader: this.requestHeader,
  			manager: this.manager,
  			ktx2Loader: this.ktx2Loader,
  			meshoptDecoder: this.meshoptDecoder

  		} );

  		parser.fileLoader.setRequestHeader( this.requestHeader );

  		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

  			const plugin = this.pluginCallbacks[ i ]( parser );

  			if ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );

  			plugins[ plugin.name ] = plugin;

  			// Workaround to avoid determining as unknown extension
  			// in addUnknownExtensionsToUserData().
  			// Remove this workaround if we move all the existing
  			// extension handlers to plugin system
  			extensions[ plugin.name ] = true;

  		}

  		if ( json.extensionsUsed ) {

  			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

  				const extensionName = json.extensionsUsed[ i ];
  				const extensionsRequired = json.extensionsRequired || [];

  				switch ( extensionName ) {

  					case EXTENSIONS.KHR_MATERIALS_UNLIT:
  						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
  						break;

  					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
  						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
  						break;

  					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
  						extensions[ extensionName ] = new GLTFTextureTransformExtension();
  						break;

  					case EXTENSIONS.KHR_MESH_QUANTIZATION:
  						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
  						break;

  					default:

  						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

  							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

  						}

  				}

  			}

  		}

  		parser.setExtensions( extensions );
  		parser.setPlugins( plugins );
  		parser.parse( onLoad, onError );

  	}

  	/**
  	 * Async version of {@link GLTFLoader#parse}.
  	 *
  	 * @async
  	 * @param {string|ArrayBuffer} data - The raw glTF data.
  	 * @param {string} path - The URL base path.
  	 * @return {Promise<GLTFLoader~LoadObject>} A Promise that resolves with the loaded glTF when the parsing has been finished.
  	 */
  	parseAsync( data, path ) {

  		const scope = this;

  		return new Promise( function ( resolve, reject ) {

  			scope.parse( data, path, resolve, reject );

  		} );

  	}

  }

  /* GLTFREGISTRY */

  function GLTFRegistry() {

  	let objects = {};

  	return	{

  		get: function ( key ) {

  			return objects[ key ];

  		},

  		add: function ( key, object ) {

  			objects[ key ] = object;

  		},

  		remove: function ( key ) {

  			delete objects[ key ];

  		},

  		removeAll: function () {

  			objects = {};

  		}

  	};

  }

  /*********************************/
  /********** EXTENSIONS ***********/
  /*********************************/

  const EXTENSIONS = {
  	KHR_BINARY_GLTF: 'KHR_binary_glTF',
  	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  	KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',
  	KHR_MATERIALS_IOR: 'KHR_materials_ior',
  	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
  	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
  	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
  	KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
  	KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
  	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
  	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
  	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  	KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
  	EXT_MATERIALS_BUMP: 'EXT_materials_bump',
  	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
  	EXT_TEXTURE_AVIF: 'EXT_texture_avif',
  	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
  	EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
  };

  /**
   * Punctual Lights Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
   *
   * @private
   */
  class GLTFLightsExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

  		// Object3D instance caches
  		this.cache = { refs: {}, uses: {} };

  	}

  	_markDefs() {

  		const parser = this.parser;
  		const nodeDefs = this.parser.json.nodes || [];

  		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

  			const nodeDef = nodeDefs[ nodeIndex ];

  			if ( nodeDef.extensions
  					&& nodeDef.extensions[ this.name ]
  					&& nodeDef.extensions[ this.name ].light !== undefined ) {

  				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

  			}

  		}

  	}

  	_loadLight( lightIndex ) {

  		const parser = this.parser;
  		const cacheKey = 'light:' + lightIndex;
  		let dependency = parser.cache.get( cacheKey );

  		if ( dependency ) return dependency;

  		const json = parser.json;
  		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
  		const lightDefs = extensions.lights || [];
  		const lightDef = lightDefs[ lightIndex ];
  		let lightNode;

  		const color = new Color( 0xffffff );

  		if ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );

  		const range = lightDef.range !== undefined ? lightDef.range : 0;

  		switch ( lightDef.type ) {

  			case 'directional':
  				lightNode = new DirectionalLight( color );
  				lightNode.target.position.set( 0, 0, - 1 );
  				lightNode.add( lightNode.target );
  				break;

  			case 'point':
  				lightNode = new PointLight( color );
  				lightNode.distance = range;
  				break;

  			case 'spot':
  				lightNode = new SpotLight( color );
  				lightNode.distance = range;
  				// Handle spotlight properties.
  				lightDef.spot = lightDef.spot || {};
  				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
  				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
  				lightNode.angle = lightDef.spot.outerConeAngle;
  				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
  				lightNode.target.position.set( 0, 0, - 1 );
  				lightNode.add( lightNode.target );
  				break;

  			default:
  				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

  		}

  		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
  		// here, because node-level parsing will only override position if explicitly specified.
  		lightNode.position.set( 0, 0, 0 );

  		assignExtrasToUserData( lightNode, lightDef );

  		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

  		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

  		dependency = Promise.resolve( lightNode );

  		parser.cache.add( cacheKey, dependency );

  		return dependency;

  	}

  	getDependency( type, index ) {

  		if ( type !== 'light' ) return;

  		return this._loadLight( index );

  	}

  	createNodeAttachment( nodeIndex ) {

  		const self = this;
  		const parser = this.parser;
  		const json = parser.json;
  		const nodeDef = json.nodes[ nodeIndex ];
  		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
  		const lightIndex = lightDef.light;

  		if ( lightIndex === undefined ) return null;

  		return this._loadLight( lightIndex ).then( function ( light ) {

  			return parser._getNodeRef( self.cache, lightIndex, light );

  		} );

  	}

  }

  /**
   * Unlit Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
   *
   * @private
   */
  class GLTFMaterialsUnlitExtension {

  	constructor() {

  		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

  	}

  	getMaterialType() {

  		return MeshBasicMaterial;

  	}

  	extendParams( materialParams, materialDef, parser ) {

  		const pending = [];

  		materialParams.color = new Color( 1.0, 1.0, 1.0 );
  		materialParams.opacity = 1.0;

  		const metallicRoughness = materialDef.pbrMetallicRoughness;

  		if ( metallicRoughness ) {

  			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

  				const array = metallicRoughness.baseColorFactor;

  				materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );
  				materialParams.opacity = array[ 3 ];

  			}

  			if ( metallicRoughness.baseColorTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

  			}

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Materials Emissive Strength Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
   *
   * @private
   */
  class GLTFMaterialsEmissiveStrengthExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;

  		if ( emissiveStrength !== undefined ) {

  			materialParams.emissiveIntensity = emissiveStrength;

  		}

  		return Promise.resolve();

  	}

  }

  /**
   * Clearcoat Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
   *
   * @private
   */
  class GLTFMaterialsClearcoatExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		if ( extension.clearcoatFactor !== undefined ) {

  			materialParams.clearcoat = extension.clearcoatFactor;

  		}

  		if ( extension.clearcoatTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

  		}

  		if ( extension.clearcoatRoughnessFactor !== undefined ) {

  			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

  		}

  		if ( extension.clearcoatRoughnessTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

  		}

  		if ( extension.clearcoatNormalTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

  			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

  				const scale = extension.clearcoatNormalTexture.scale;

  				materialParams.clearcoatNormalScale = new Vector2( scale, scale );

  			}

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Materials dispersion Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion
   *
   * @private
   */
  class GLTFMaterialsDispersionExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const extension = materialDef.extensions[ this.name ];

  		materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;

  		return Promise.resolve();

  	}

  }

  /**
   * Iridescence Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
   *
   * @private
   */
  class GLTFMaterialsIridescenceExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		if ( extension.iridescenceFactor !== undefined ) {

  			materialParams.iridescence = extension.iridescenceFactor;

  		}

  		if ( extension.iridescenceTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );

  		}

  		if ( extension.iridescenceIor !== undefined ) {

  			materialParams.iridescenceIOR = extension.iridescenceIor;

  		}

  		if ( materialParams.iridescenceThicknessRange === undefined ) {

  			materialParams.iridescenceThicknessRange = [ 100, 400 ];

  		}

  		if ( extension.iridescenceThicknessMinimum !== undefined ) {

  			materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;

  		}

  		if ( extension.iridescenceThicknessMaximum !== undefined ) {

  			materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;

  		}

  		if ( extension.iridescenceThicknessTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Sheen Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
   *
   * @private
   */
  class GLTFMaterialsSheenExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		materialParams.sheenColor = new Color( 0, 0, 0 );
  		materialParams.sheenRoughness = 0;
  		materialParams.sheen = 1;

  		const extension = materialDef.extensions[ this.name ];

  		if ( extension.sheenColorFactor !== undefined ) {

  			const colorFactor = extension.sheenColorFactor;
  			materialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );

  		}

  		if ( extension.sheenRoughnessFactor !== undefined ) {

  			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

  		}

  		if ( extension.sheenColorTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );

  		}

  		if ( extension.sheenRoughnessTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Transmission Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
   * Draft: https://github.com/KhronosGroup/glTF/pull/1698
   *
   * @private
   */
  class GLTFMaterialsTransmissionExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		if ( extension.transmissionFactor !== undefined ) {

  			materialParams.transmission = extension.transmissionFactor;

  		}

  		if ( extension.transmissionTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Materials Volume Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
   *
   * @private
   */
  class GLTFMaterialsVolumeExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

  		if ( extension.thicknessTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

  		}

  		materialParams.attenuationDistance = extension.attenuationDistance || Infinity;

  		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
  		materialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );

  		return Promise.all( pending );

  	}

  }

  /**
   * Materials ior Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
   *
   * @private
   */
  class GLTFMaterialsIorExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const extension = materialDef.extensions[ this.name ];

  		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

  		return Promise.resolve();

  	}

  }

  /**
   * Materials specular Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
   *
   * @private
   */
  class GLTFMaterialsSpecularExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

  		if ( extension.specularTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

  		}

  		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
  		materialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );

  		if ( extension.specularColorTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );

  		}

  		return Promise.all( pending );

  	}

  }


  /**
   * Materials bump Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump
   *
   * @private
   */
  class GLTFMaterialsBumpExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.EXT_MATERIALS_BUMP;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;

  		if ( extension.bumpTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * Materials anisotropy Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy
   *
   * @private
   */
  class GLTFMaterialsAnisotropyExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;

  	}

  	getMaterialType( materialIndex ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

  		return MeshPhysicalMaterial;

  	}

  	extendMaterialParams( materialIndex, materialParams ) {

  		const parser = this.parser;
  		const materialDef = parser.json.materials[ materialIndex ];

  		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

  			return Promise.resolve();

  		}

  		const pending = [];

  		const extension = materialDef.extensions[ this.name ];

  		if ( extension.anisotropyStrength !== undefined ) {

  			materialParams.anisotropy = extension.anisotropyStrength;

  		}

  		if ( extension.anisotropyRotation !== undefined ) {

  			materialParams.anisotropyRotation = extension.anisotropyRotation;

  		}

  		if ( extension.anisotropyTexture !== undefined ) {

  			pending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );

  		}

  		return Promise.all( pending );

  	}

  }

  /**
   * BasisU Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
   *
   * @private
   */
  class GLTFTextureBasisUExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

  	}

  	loadTexture( textureIndex ) {

  		const parser = this.parser;
  		const json = parser.json;

  		const textureDef = json.textures[ textureIndex ];

  		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

  			return null;

  		}

  		const extension = textureDef.extensions[ this.name ];
  		const loader = parser.options.ktx2Loader;

  		if ( ! loader ) {

  			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

  				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

  			} else {

  				// Assumes that the extension is optional and that a fallback texture is present
  				return null;

  			}

  		}

  		return parser.loadTextureImage( textureIndex, extension.source, loader );

  	}

  }

  /**
   * WebP Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
   *
   * @private
   */
  class GLTFTextureWebPExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;

  	}

  	loadTexture( textureIndex ) {

  		const name = this.name;
  		const parser = this.parser;
  		const json = parser.json;

  		const textureDef = json.textures[ textureIndex ];

  		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

  			return null;

  		}

  		const extension = textureDef.extensions[ name ];
  		const source = json.images[ extension.source ];

  		let loader = parser.textureLoader;
  		if ( source.uri ) {

  			const handler = parser.options.manager.getHandler( source.uri );
  			if ( handler !== null ) loader = handler;

  		}

  		return parser.loadTextureImage( textureIndex, extension.source, loader );

  	}

  }

  /**
   * AVIF Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif
   *
   * @private
   */
  class GLTFTextureAVIFExtension {

  	constructor( parser ) {

  		this.parser = parser;
  		this.name = EXTENSIONS.EXT_TEXTURE_AVIF;

  	}

  	loadTexture( textureIndex ) {

  		const name = this.name;
  		const parser = this.parser;
  		const json = parser.json;

  		const textureDef = json.textures[ textureIndex ];

  		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

  			return null;

  		}

  		const extension = textureDef.extensions[ name ];
  		const source = json.images[ extension.source ];

  		let loader = parser.textureLoader;
  		if ( source.uri ) {

  			const handler = parser.options.manager.getHandler( source.uri );
  			if ( handler !== null ) loader = handler;

  		}

  		return parser.loadTextureImage( textureIndex, extension.source, loader );

  	}

  }

  /**
   * meshopt BufferView Compression Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
   *
   * @private
   */
  class GLTFMeshoptCompression {

  	constructor( parser ) {

  		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
  		this.parser = parser;

  	}

  	loadBufferView( index ) {

  		const json = this.parser.json;
  		const bufferView = json.bufferViews[ index ];

  		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

  			const extensionDef = bufferView.extensions[ this.name ];

  			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
  			const decoder = this.parser.options.meshoptDecoder;

  			if ( ! decoder || ! decoder.supported ) {

  				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

  					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

  				} else {

  					// Assumes that the extension is optional and that fallback buffer data is present
  					return null;

  				}

  			}

  			return buffer.then( function ( res ) {

  				const byteOffset = extensionDef.byteOffset || 0;
  				const byteLength = extensionDef.byteLength || 0;

  				const count = extensionDef.count;
  				const stride = extensionDef.byteStride;

  				const source = new Uint8Array( res, byteOffset, byteLength );

  				if ( decoder.decodeGltfBufferAsync ) {

  					return decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {

  						return res.buffer;

  					} );

  				} else {

  					// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync
  					return decoder.ready.then( function () {

  						const result = new ArrayBuffer( count * stride );
  						decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
  						return result;

  					} );

  				}

  			} );

  		} else {

  			return null;

  		}

  	}

  }

  /**
   * GPU Instancing Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
   *
   * @private
   */
  class GLTFMeshGpuInstancing {

  	constructor( parser ) {

  		this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
  		this.parser = parser;

  	}

  	createNodeMesh( nodeIndex ) {

  		const json = this.parser.json;
  		const nodeDef = json.nodes[ nodeIndex ];

  		if ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||
  			nodeDef.mesh === undefined ) {

  			return null;

  		}

  		const meshDef = json.meshes[ nodeDef.mesh ];

  		// No Points or Lines + Instancing support yet

  		for ( const primitive of meshDef.primitives ) {

  			if ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&
  				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&
  				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&
  				 primitive.mode !== undefined ) {

  				return null;

  			}

  		}

  		const extensionDef = nodeDef.extensions[ this.name ];
  		const attributesDef = extensionDef.attributes;

  		// @TODO: Can we support InstancedMesh + SkinnedMesh?

  		const pending = [];
  		const attributes = {};

  		for ( const key in attributesDef ) {

  			pending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {

  				attributes[ key ] = accessor;
  				return attributes[ key ];

  			} ) );

  		}

  		if ( pending.length < 1 ) {

  			return null;

  		}

  		pending.push( this.parser.createNodeMesh( nodeIndex ) );

  		return Promise.all( pending ).then( results => {

  			const nodeObject = results.pop();
  			const meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];
  			const count = results[ 0 ].count; // All attribute counts should be same
  			const instancedMeshes = [];

  			for ( const mesh of meshes ) {

  				// Temporal variables
  				const m = new Matrix4();
  				const p = new Vector3();
  				const q = new Quaternion();
  				const s = new Vector3( 1, 1, 1 );

  				const instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );

  				for ( let i = 0; i < count; i ++ ) {

  					if ( attributes.TRANSLATION ) {

  						p.fromBufferAttribute( attributes.TRANSLATION, i );

  					}

  					if ( attributes.ROTATION ) {

  						q.fromBufferAttribute( attributes.ROTATION, i );

  					}

  					if ( attributes.SCALE ) {

  						s.fromBufferAttribute( attributes.SCALE, i );

  					}

  					instancedMesh.setMatrixAt( i, m.compose( p, q, s ) );

  				}

  				// Add instance attributes to the geometry, excluding TRS.
  				for ( const attributeName in attributes ) {

  					if ( attributeName === '_COLOR_0' ) {

  						const attr = attributes[ attributeName ];
  						instancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );

  					} else if ( attributeName !== 'TRANSLATION' &&
  						 attributeName !== 'ROTATION' &&
  						 attributeName !== 'SCALE' ) {

  						mesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );

  					}

  				}

  				// Just in case
  				Object3D.prototype.copy.call( instancedMesh, mesh );

  				this.parser.assignFinalMaterial( instancedMesh );

  				instancedMeshes.push( instancedMesh );

  			}

  			if ( nodeObject.isGroup ) {

  				nodeObject.clear();

  				nodeObject.add( ... instancedMeshes );

  				return nodeObject;

  			}

  			return instancedMeshes[ 0 ];

  		} );

  	}

  }

  /* BINARY EXTENSION */
  const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
  const BINARY_EXTENSION_HEADER_LENGTH = 12;
  const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

  class GLTFBinaryExtension {

  	constructor( data ) {

  		this.name = EXTENSIONS.KHR_BINARY_GLTF;
  		this.content = null;
  		this.body = null;

  		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );
  		const textDecoder = new TextDecoder();

  		this.header = {
  			magic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),
  			version: headerView.getUint32( 4, true ),
  			length: headerView.getUint32( 8, true )
  		};

  		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

  			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

  		} else if ( this.header.version < 2.0 ) {

  			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

  		}

  		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
  		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
  		let chunkIndex = 0;

  		while ( chunkIndex < chunkContentsLength ) {

  			const chunkLength = chunkView.getUint32( chunkIndex, true );
  			chunkIndex += 4;

  			const chunkType = chunkView.getUint32( chunkIndex, true );
  			chunkIndex += 4;

  			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

  				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
  				this.content = textDecoder.decode( contentArray );

  			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

  				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
  				this.body = data.slice( byteOffset, byteOffset + chunkLength );

  			}

  			// Clients must ignore chunks with unknown types.

  			chunkIndex += chunkLength;

  		}

  		if ( this.content === null ) {

  			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

  		}

  	}

  }

  /**
   * DRACO Mesh Compression Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
   *
   * @private
   */
  class GLTFDracoMeshCompressionExtension {

  	constructor( json, dracoLoader ) {

  		if ( ! dracoLoader ) {

  			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

  		}

  		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
  		this.json = json;
  		this.dracoLoader = dracoLoader;
  		this.dracoLoader.preload();

  	}

  	decodePrimitive( primitive, parser ) {

  		const json = this.json;
  		const dracoLoader = this.dracoLoader;
  		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
  		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
  		const threeAttributeMap = {};
  		const attributeNormalizedMap = {};
  		const attributeTypeMap = {};

  		for ( const attributeName in gltfAttributeMap ) {

  			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

  			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

  		}

  		for ( const attributeName in primitive.attributes ) {

  			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

  			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

  				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
  				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

  				attributeTypeMap[ threeAttributeName ] = componentType.name;
  				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

  			}

  		}

  		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

  			return new Promise( function ( resolve, reject ) {

  				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

  					for ( const attributeName in geometry.attributes ) {

  						const attribute = geometry.attributes[ attributeName ];
  						const normalized = attributeNormalizedMap[ attributeName ];

  						if ( normalized !== undefined ) attribute.normalized = normalized;

  					}

  					resolve( geometry );

  				}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );

  			} );

  		} );

  	}

  }

  /**
   * Texture Transform Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
   *
   * @private
   */
  class GLTFTextureTransformExtension {

  	constructor() {

  		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

  	}

  	extendTexture( texture, transform ) {

  		if ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )
  			&& transform.offset === undefined
  			&& transform.rotation === undefined
  			&& transform.scale === undefined ) {

  			// See https://github.com/mrdoob/three.js/issues/21819.
  			return texture;

  		}

  		texture = texture.clone();

  		if ( transform.texCoord !== undefined ) {

  			texture.channel = transform.texCoord;

  		}

  		if ( transform.offset !== undefined ) {

  			texture.offset.fromArray( transform.offset );

  		}

  		if ( transform.rotation !== undefined ) {

  			texture.rotation = transform.rotation;

  		}

  		if ( transform.scale !== undefined ) {

  			texture.repeat.fromArray( transform.scale );

  		}

  		texture.needsUpdate = true;

  		return texture;

  	}

  }

  /**
   * Mesh Quantization Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
   *
   * @private
   */
  class GLTFMeshQuantizationExtension {

  	constructor() {

  		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

  	}

  }

  /*********************************/
  /********** INTERPOLATION ********/
  /*********************************/

  // Spline Interpolation
  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
  class GLTFCubicSplineInterpolant extends Interpolant {

  	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	copySampleValue_( index ) {

  		// Copies a sample value to the result buffer. See description of glTF
  		// CUBICSPLINE values layout in interpolate_() function below.

  		const result = this.resultBuffer,
  			values = this.sampleValues,
  			valueSize = this.valueSize,
  			offset = index * valueSize * 3 + valueSize;

  		for ( let i = 0; i !== valueSize; i ++ ) {

  			result[ i ] = values[ offset + i ];

  		}

  		return result;

  	}

  	interpolate_( i1, t0, t, t1 ) {

  		const result = this.resultBuffer;
  		const values = this.sampleValues;
  		const stride = this.valueSize;

  		const stride2 = stride * 2;
  		const stride3 = stride * 3;

  		const td = t1 - t0;

  		const p = ( t - t0 ) / td;
  		const pp = p * p;
  		const ppp = pp * p;

  		const offset1 = i1 * stride3;
  		const offset0 = offset1 - stride3;

  		const s2 = - 2 * ppp + 3 * pp;
  		const s3 = ppp - pp;
  		const s0 = 1 - s2;
  		const s1 = s3 - pp + p;

  		// Layout of keyframe output values for CUBICSPLINE animations:
  		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
  		for ( let i = 0; i !== stride; i ++ ) {

  			const p0 = values[ offset0 + i + stride ]; // splineVertex_k
  			const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
  			const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
  			const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

  			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

  		}

  		return result;

  	}

  }

  const _quaternion = new Quaternion();

  class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

  	interpolate_( i1, t0, t, t1 ) {

  		const result = super.interpolate_( i1, t0, t, t1 );

  		_quaternion.fromArray( result ).normalize().toArray( result );

  		return result;

  	}

  }


  /*********************************/
  /********** INTERNALS ************/
  /*********************************/

  /* CONSTANTS */

  const WEBGL_CONSTANTS = {
  	FLOAT: 5126,
  	//FLOAT_MAT2: 35674,
  	FLOAT_MAT3: 35675,
  	FLOAT_MAT4: 35676,
  	FLOAT_VEC2: 35664,
  	FLOAT_VEC3: 35665,
  	FLOAT_VEC4: 35666,
  	LINEAR: 9729,
  	REPEAT: 10497,
  	SAMPLER_2D: 35678,
  	POINTS: 0,
  	LINES: 1,
  	LINE_LOOP: 2,
  	LINE_STRIP: 3,
  	TRIANGLES: 4,
  	TRIANGLE_STRIP: 5,
  	TRIANGLE_FAN: 6,
  	UNSIGNED_BYTE: 5121,
  	UNSIGNED_SHORT: 5123
  };

  const WEBGL_COMPONENT_TYPES = {
  	5120: Int8Array,
  	5121: Uint8Array,
  	5122: Int16Array,
  	5123: Uint16Array,
  	5125: Uint32Array,
  	5126: Float32Array
  };

  const WEBGL_FILTERS = {
  	9728: NearestFilter,
  	9729: LinearFilter,
  	9984: NearestMipmapNearestFilter,
  	9985: LinearMipmapNearestFilter,
  	9986: NearestMipmapLinearFilter,
  	9987: LinearMipmapLinearFilter
  };

  const WEBGL_WRAPPINGS = {
  	33071: ClampToEdgeWrapping,
  	33648: MirroredRepeatWrapping,
  	10497: RepeatWrapping
  };

  const WEBGL_TYPE_SIZES = {
  	'SCALAR': 1,
  	'VEC2': 2,
  	'VEC3': 3,
  	'VEC4': 4,
  	'MAT2': 4,
  	'MAT3': 9,
  	'MAT4': 16
  };

  const ATTRIBUTES = {
  	POSITION: 'position',
  	NORMAL: 'normal',
  	TANGENT: 'tangent',
  	TEXCOORD_0: 'uv',
  	TEXCOORD_1: 'uv1',
  	TEXCOORD_2: 'uv2',
  	TEXCOORD_3: 'uv3',
  	COLOR_0: 'color',
  	WEIGHTS_0: 'skinWeight',
  	JOINTS_0: 'skinIndex',
  };

  const PATH_PROPERTIES = {
  	scale: 'scale',
  	translation: 'position',
  	rotation: 'quaternion',
  	weights: 'morphTargetInfluences'
  };

  const INTERPOLATION = {
  	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  		                        // keyframe track will be initialized with a default interpolation type, then modified.
  	LINEAR: InterpolateLinear,
  	STEP: InterpolateDiscrete
  };

  const ALPHA_MODES = {
  	OPAQUE: 'OPAQUE',
  	MASK: 'MASK',
  	BLEND: 'BLEND'
  };

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
   *
   * @private
   * @param {Object<string, Material>} cache
   * @return {Material}
   */
  function createDefaultMaterial( cache ) {

  	if ( cache[ 'DefaultMaterial' ] === undefined ) {

  		cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
  			color: 0xFFFFFF,
  			emissive: 0x000000,
  			metalness: 1,
  			roughness: 1,
  			transparent: false,
  			depthTest: true,
  			side: FrontSide
  		} );

  	}

  	return cache[ 'DefaultMaterial' ];

  }

  function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

  	// Add unknown glTF extensions to an object's userData.

  	for ( const name in objectDef.extensions ) {

  		if ( knownExtensions[ name ] === undefined ) {

  			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
  			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

  		}

  	}

  }

  /**
   *
   * @private
   * @param {Object3D|Material|BufferGeometry|Object|AnimationClip} object
   * @param {GLTF.definition} gltfDef
   */
  function assignExtrasToUserData( object, gltfDef ) {

  	if ( gltfDef.extras !== undefined ) {

  		if ( typeof gltfDef.extras === 'object' ) {

  			Object.assign( object.userData, gltfDef.extras );

  		} else {

  			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

  		}

  	}

  }

  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
   *
   * @private
   * @param {BufferGeometry} geometry
   * @param {Array<GLTF.Target>} targets
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */
  function addMorphTargets( geometry, targets, parser ) {

  	let hasMorphPosition = false;
  	let hasMorphNormal = false;
  	let hasMorphColor = false;

  	for ( let i = 0, il = targets.length; i < il; i ++ ) {

  		const target = targets[ i ];

  		if ( target.POSITION !== undefined ) hasMorphPosition = true;
  		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
  		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

  		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

  	}

  	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

  	const pendingPositionAccessors = [];
  	const pendingNormalAccessors = [];
  	const pendingColorAccessors = [];

  	for ( let i = 0, il = targets.length; i < il; i ++ ) {

  		const target = targets[ i ];

  		if ( hasMorphPosition ) {

  			const pendingAccessor = target.POSITION !== undefined
  				? parser.getDependency( 'accessor', target.POSITION )
  				: geometry.attributes.position;

  			pendingPositionAccessors.push( pendingAccessor );

  		}

  		if ( hasMorphNormal ) {

  			const pendingAccessor = target.NORMAL !== undefined
  				? parser.getDependency( 'accessor', target.NORMAL )
  				: geometry.attributes.normal;

  			pendingNormalAccessors.push( pendingAccessor );

  		}

  		if ( hasMorphColor ) {

  			const pendingAccessor = target.COLOR_0 !== undefined
  				? parser.getDependency( 'accessor', target.COLOR_0 )
  				: geometry.attributes.color;

  			pendingColorAccessors.push( pendingAccessor );

  		}

  	}

  	return Promise.all( [
  		Promise.all( pendingPositionAccessors ),
  		Promise.all( pendingNormalAccessors ),
  		Promise.all( pendingColorAccessors )
  	] ).then( function ( accessors ) {

  		const morphPositions = accessors[ 0 ];
  		const morphNormals = accessors[ 1 ];
  		const morphColors = accessors[ 2 ];

  		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
  		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
  		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
  		geometry.morphTargetsRelative = true;

  		return geometry;

  	} );

  }

  /**
   *
   * @private
   * @param {Mesh} mesh
   * @param {GLTF.Mesh} meshDef
   */
  function updateMorphTargets( mesh, meshDef ) {

  	mesh.updateMorphTargets();

  	if ( meshDef.weights !== undefined ) {

  		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

  			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

  		}

  	}

  	// .extras has user-defined data, so check that .extras.targetNames is an array.
  	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

  		const targetNames = meshDef.extras.targetNames;

  		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

  			mesh.morphTargetDictionary = {};

  			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

  				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

  			}

  		} else {

  			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

  		}

  	}

  }

  function createPrimitiveKey( primitiveDef ) {

  	let geometryKey;

  	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];

  	if ( dracoExtension ) {

  		geometryKey = 'draco:' + dracoExtension.bufferView
  				+ ':' + dracoExtension.indices
  				+ ':' + createAttributesKey( dracoExtension.attributes );

  	} else {

  		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

  	}

  	if ( primitiveDef.targets !== undefined ) {

  		for ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {

  			geometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );

  		}

  	}

  	return geometryKey;

  }

  function createAttributesKey( attributes ) {

  	let attributesKey = '';

  	const keys = Object.keys( attributes ).sort();

  	for ( let i = 0, il = keys.length; i < il; i ++ ) {

  		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

  	}

  	return attributesKey;

  }

  function getNormalizedComponentScale( constructor ) {

  	// Reference:
  	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

  	switch ( constructor ) {

  		case Int8Array:
  			return 1 / 127;

  		case Uint8Array:
  			return 1 / 255;

  		case Int16Array:
  			return 1 / 32767;

  		case Uint16Array:
  			return 1 / 65535;

  		default:
  			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

  	}

  }

  function getImageURIMimeType( uri ) {

  	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
  	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';
  	if ( uri.search( /\.ktx2($|\?)/i ) > 0 || uri.search( /^data\:image\/ktx2/ ) === 0 ) return 'image/ktx2';

  	return 'image/png';

  }

  const _identityMatrix = new Matrix4();

  /* GLTF PARSER */

  class GLTFParser {

  	constructor( json = {}, options = {} ) {

  		this.json = json;
  		this.extensions = {};
  		this.plugins = {};
  		this.options = options;

  		// loader object cache
  		this.cache = new GLTFRegistry();

  		// associations between Three.js objects and glTF elements
  		this.associations = new Map();

  		// BufferGeometry caching
  		this.primitiveCache = {};

  		// Node cache
  		this.nodeCache = {};

  		// Object3D instance caches
  		this.meshCache = { refs: {}, uses: {} };
  		this.cameraCache = { refs: {}, uses: {} };
  		this.lightCache = { refs: {}, uses: {} };

  		this.sourceCache = {};
  		this.textureCache = {};

  		// Track node names, to ensure no duplicates
  		this.nodeNamesUsed = {};

  		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
  		// expensive work of uploading a texture to the GPU off the main thread.

  		let isSafari = false;
  		let safariVersion = - 1;
  		let isFirefox = false;
  		let firefoxVersion = - 1;

  		if ( typeof navigator !== 'undefined' ) {

  			const userAgent = navigator.userAgent;

  			isSafari = /^((?!chrome|android).)*safari/i.test( userAgent ) === true;
  			const safariMatch = userAgent.match( /Version\/(\d+)/ );
  			safariVersion = isSafari && safariMatch ? parseInt( safariMatch[ 1 ], 10 ) : - 1;

  			isFirefox = userAgent.indexOf( 'Firefox' ) > - 1;
  			firefoxVersion = isFirefox ? userAgent.match( /Firefox\/([0-9]+)\./ )[ 1 ] : - 1;

  		}

  		if ( typeof createImageBitmap === 'undefined' || ( isSafari && safariVersion < 17 ) || ( isFirefox && firefoxVersion < 98 ) ) {

  			this.textureLoader = new TextureLoader( this.options.manager );

  		} else {

  			this.textureLoader = new ImageBitmapLoader( this.options.manager );

  		}

  		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
  		this.textureLoader.setRequestHeader( this.options.requestHeader );

  		this.fileLoader = new FileLoader( this.options.manager );
  		this.fileLoader.setResponseType( 'arraybuffer' );

  		if ( this.options.crossOrigin === 'use-credentials' ) {

  			this.fileLoader.setWithCredentials( true );

  		}

  	}

  	setExtensions( extensions ) {

  		this.extensions = extensions;

  	}

  	setPlugins( plugins ) {

  		this.plugins = plugins;

  	}

  	parse( onLoad, onError ) {

  		const parser = this;
  		const json = this.json;
  		const extensions = this.extensions;

  		// Clear the loader cache
  		this.cache.removeAll();
  		this.nodeCache = {};

  		// Mark the special nodes/meshes in json for efficient parse
  		this._invokeAll( function ( ext ) {

  			return ext._markDefs && ext._markDefs();

  		} );

  		Promise.all( this._invokeAll( function ( ext ) {

  			return ext.beforeRoot && ext.beforeRoot();

  		} ) ).then( function () {

  			return Promise.all( [

  				parser.getDependencies( 'scene' ),
  				parser.getDependencies( 'animation' ),
  				parser.getDependencies( 'camera' ),

  			] );

  		} ).then( function ( dependencies ) {

  			const result = {
  				scene: dependencies[ 0 ][ json.scene || 0 ],
  				scenes: dependencies[ 0 ],
  				animations: dependencies[ 1 ],
  				cameras: dependencies[ 2 ],
  				asset: json.asset,
  				parser: parser,
  				userData: {}
  			};

  			addUnknownExtensionsToUserData( extensions, result, json );

  			assignExtrasToUserData( result, json );

  			return Promise.all( parser._invokeAll( function ( ext ) {

  				return ext.afterRoot && ext.afterRoot( result );

  			} ) ).then( function () {

  				for ( const scene of result.scenes ) {

  					scene.updateMatrixWorld();

  				}

  				onLoad( result );

  			} );

  		} ).catch( onError );

  	}

  	/**
  	 * Marks the special nodes/meshes in json for efficient parse.
  	 *
  	 * @private
  	 */
  	_markDefs() {

  		const nodeDefs = this.json.nodes || [];
  		const skinDefs = this.json.skins || [];
  		const meshDefs = this.json.meshes || [];

  		// Nothing in the node definition indicates whether it is a Bone or an
  		// Object3D. Use the skins' joint references to mark bones.
  		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

  			const joints = skinDefs[ skinIndex ].joints;

  			for ( let i = 0, il = joints.length; i < il; i ++ ) {

  				nodeDefs[ joints[ i ] ].isBone = true;

  			}

  		}

  		// Iterate over all nodes, marking references to shared resources,
  		// as well as skeleton joints.
  		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

  			const nodeDef = nodeDefs[ nodeIndex ];

  			if ( nodeDef.mesh !== undefined ) {

  				this._addNodeRef( this.meshCache, nodeDef.mesh );

  				// Nothing in the mesh definition indicates whether it is
  				// a SkinnedMesh or Mesh. Use the node's mesh reference
  				// to mark SkinnedMesh if node has skin.
  				if ( nodeDef.skin !== undefined ) {

  					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

  				}

  			}

  			if ( nodeDef.camera !== undefined ) {

  				this._addNodeRef( this.cameraCache, nodeDef.camera );

  			}

  		}

  	}

  	/**
  	 * Counts references to shared node / Object3D resources. These resources
  	 * can be reused, or "instantiated", at multiple nodes in the scene
  	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
  	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
  	 * Textures) can be reused directly and are not marked here.
  	 *
  	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
  	 *
  	 * @private
  	 * @param {Object} cache
  	 * @param {Object3D} index
  	 */
  	_addNodeRef( cache, index ) {

  		if ( index === undefined ) return;

  		if ( cache.refs[ index ] === undefined ) {

  			cache.refs[ index ] = cache.uses[ index ] = 0;

  		}

  		cache.refs[ index ] ++;

  	}

  	/**
  	 * Returns a reference to a shared resource, cloning it if necessary.
  	 *
  	 * @private
  	 * @param {Object} cache
  	 * @param {number} index
  	 * @param {Object} object
  	 * @return {Object}
  	 */
  	_getNodeRef( cache, index, object ) {

  		if ( cache.refs[ index ] <= 1 ) return object;

  		const ref = object.clone();

  		// Propagates mappings to the cloned object, prevents mappings on the
  		// original object from being lost.
  		const updateMappings = ( original, clone ) => {

  			const mappings = this.associations.get( original );
  			if ( mappings != null ) {

  				this.associations.set( clone, mappings );

  			}

  			for ( const [ i, child ] of original.children.entries() ) {

  				updateMappings( child, clone.children[ i ] );

  			}

  		};

  		updateMappings( object, ref );

  		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

  		return ref;

  	}

  	_invokeOne( func ) {

  		const extensions = Object.values( this.plugins );
  		extensions.push( this );

  		for ( let i = 0; i < extensions.length; i ++ ) {

  			const result = func( extensions[ i ] );

  			if ( result ) return result;

  		}

  		return null;

  	}

  	_invokeAll( func ) {

  		const extensions = Object.values( this.plugins );
  		extensions.unshift( this );

  		const pending = [];

  		for ( let i = 0; i < extensions.length; i ++ ) {

  			const result = func( extensions[ i ] );

  			if ( result ) pending.push( result );

  		}

  		return pending;

  	}

  	/**
  	 * Requests the specified dependency asynchronously, with caching.
  	 *
  	 * @private
  	 * @param {string} type
  	 * @param {number} index
  	 * @return {Promise<Object3D|Material|Texture|AnimationClip|ArrayBuffer|Object>}
  	 */
  	getDependency( type, index ) {

  		const cacheKey = type + ':' + index;
  		let dependency = this.cache.get( cacheKey );

  		if ( ! dependency ) {

  			switch ( type ) {

  				case 'scene':
  					dependency = this.loadScene( index );
  					break;

  				case 'node':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadNode && ext.loadNode( index );

  					} );
  					break;

  				case 'mesh':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadMesh && ext.loadMesh( index );

  					} );
  					break;

  				case 'accessor':
  					dependency = this.loadAccessor( index );
  					break;

  				case 'bufferView':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadBufferView && ext.loadBufferView( index );

  					} );
  					break;

  				case 'buffer':
  					dependency = this.loadBuffer( index );
  					break;

  				case 'material':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadMaterial && ext.loadMaterial( index );

  					} );
  					break;

  				case 'texture':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadTexture && ext.loadTexture( index );

  					} );
  					break;

  				case 'skin':
  					dependency = this.loadSkin( index );
  					break;

  				case 'animation':
  					dependency = this._invokeOne( function ( ext ) {

  						return ext.loadAnimation && ext.loadAnimation( index );

  					} );
  					break;

  				case 'camera':
  					dependency = this.loadCamera( index );
  					break;

  				default:
  					dependency = this._invokeOne( function ( ext ) {

  						return ext != this && ext.getDependency && ext.getDependency( type, index );

  					} );

  					if ( ! dependency ) {

  						throw new Error( 'Unknown type: ' + type );

  					}

  					break;

  			}

  			this.cache.add( cacheKey, dependency );

  		}

  		return dependency;

  	}

  	/**
  	 * Requests all dependencies of the specified type asynchronously, with caching.
  	 *
  	 * @private
  	 * @param {string} type
  	 * @return {Promise<Array<Object>>}
  	 */
  	getDependencies( type ) {

  		let dependencies = this.cache.get( type );

  		if ( ! dependencies ) {

  			const parser = this;
  			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

  			dependencies = Promise.all( defs.map( function ( def, index ) {

  				return parser.getDependency( type, index );

  			} ) );

  			this.cache.add( type, dependencies );

  		}

  		return dependencies;

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
  	 *
  	 * @private
  	 * @param {number} bufferIndex
  	 * @return {Promise<ArrayBuffer>}
  	 */
  	loadBuffer( bufferIndex ) {

  		const bufferDef = this.json.buffers[ bufferIndex ];
  		const loader = this.fileLoader;

  		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

  			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

  		}

  		// If present, GLB container is required to be the first buffer.
  		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

  			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

  		}

  		const options = this.options;

  		return new Promise( function ( resolve, reject ) {

  			loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

  				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

  			} );

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
  	 *
  	 * @private
  	 * @param {number} bufferViewIndex
  	 * @return {Promise<ArrayBuffer>}
  	 */
  	loadBufferView( bufferViewIndex ) {

  		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

  		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

  			const byteLength = bufferViewDef.byteLength || 0;
  			const byteOffset = bufferViewDef.byteOffset || 0;
  			return buffer.slice( byteOffset, byteOffset + byteLength );

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
  	 *
  	 * @private
  	 * @param {number} accessorIndex
  	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
  	 */
  	loadAccessor( accessorIndex ) {

  		const parser = this;
  		const json = this.json;

  		const accessorDef = this.json.accessors[ accessorIndex ];

  		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

  			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
  			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];
  			const normalized = accessorDef.normalized === true;

  			const array = new TypedArray( accessorDef.count * itemSize );
  			return Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );

  		}

  		const pendingBufferViews = [];

  		if ( accessorDef.bufferView !== undefined ) {

  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

  		} else {

  			pendingBufferViews.push( null );

  		}

  		if ( accessorDef.sparse !== undefined ) {

  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

  		}

  		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

  			const bufferView = bufferViews[ 0 ];

  			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
  			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

  			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
  			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
  			const itemBytes = elementBytes * itemSize;
  			const byteOffset = accessorDef.byteOffset || 0;
  			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
  			const normalized = accessorDef.normalized === true;
  			let array, bufferAttribute;

  			// The buffer is not interleaved if the stride is the item size in bytes.
  			if ( byteStride && byteStride !== itemBytes ) {

  				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
  				// This makes sure that IBA.count reflects accessor.count properly
  				const ibSlice = Math.floor( byteOffset / byteStride );
  				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
  				let ib = parser.cache.get( ibCacheKey );

  				if ( ! ib ) {

  					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

  					// Integer parameters to IB/IBA are in array elements, not bytes.
  					ib = new InterleavedBuffer( array, byteStride / elementBytes );

  					parser.cache.add( ibCacheKey, ib );

  				}

  				bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

  			} else {

  				if ( bufferView === null ) {

  					array = new TypedArray( accessorDef.count * itemSize );

  				} else {

  					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

  				}

  				bufferAttribute = new BufferAttribute( array, itemSize, normalized );

  			}

  			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
  			if ( accessorDef.sparse !== undefined ) {

  				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
  				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

  				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
  				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

  				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
  				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

  				if ( bufferView !== null ) {

  					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
  					bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

  				}

  				// Ignore normalized since we copy from sparse
  				bufferAttribute.normalized = false;

  				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

  					const index = sparseIndices[ i ];

  					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
  					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
  					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
  					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
  					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

  				}

  				bufferAttribute.normalized = normalized;

  			}

  			return bufferAttribute;

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
  	 *
  	 * @private
  	 * @param {number} textureIndex
  	 * @return {Promise<?Texture>}
  	 */
  	loadTexture( textureIndex ) {

  		const json = this.json;
  		const options = this.options;
  		const textureDef = json.textures[ textureIndex ];
  		const sourceIndex = textureDef.source;
  		const sourceDef = json.images[ sourceIndex ];

  		let loader = this.textureLoader;

  		if ( sourceDef.uri ) {

  			const handler = options.manager.getHandler( sourceDef.uri );
  			if ( handler !== null ) loader = handler;

  		}

  		return this.loadTextureImage( textureIndex, sourceIndex, loader );

  	}

  	loadTextureImage( textureIndex, sourceIndex, loader ) {

  		const parser = this;
  		const json = this.json;

  		const textureDef = json.textures[ textureIndex ];
  		const sourceDef = json.images[ sourceIndex ];

  		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

  		if ( this.textureCache[ cacheKey ] ) {

  			// See https://github.com/mrdoob/three.js/issues/21559.
  			return this.textureCache[ cacheKey ];

  		}

  		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

  			texture.flipY = false;

  			texture.name = textureDef.name || sourceDef.name || '';

  			if ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {

  				texture.name = sourceDef.uri;

  			}

  			const samplers = json.samplers || {};
  			const sampler = samplers[ textureDef.sampler ] || {};

  			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
  			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
  			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
  			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;
  			texture.generateMipmaps = ! texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

  			parser.associations.set( texture, { textures: textureIndex } );

  			return texture;

  		} ).catch( function () {

  			return null;

  		} );

  		this.textureCache[ cacheKey ] = promise;

  		return promise;

  	}

  	loadImageSource( sourceIndex, loader ) {

  		const parser = this;
  		const json = this.json;
  		const options = this.options;

  		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

  			return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

  		}

  		const sourceDef = json.images[ sourceIndex ];

  		const URL = self.URL || self.webkitURL;

  		let sourceURI = sourceDef.uri || '';
  		let isObjectURL = false;

  		if ( sourceDef.bufferView !== undefined ) {

  			// Load binary image data from bufferView, if provided.

  			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

  				isObjectURL = true;
  				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
  				sourceURI = URL.createObjectURL( blob );
  				return sourceURI;

  			} );

  		} else if ( sourceDef.uri === undefined ) {

  			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

  		}

  		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

  			return new Promise( function ( resolve, reject ) {

  				let onLoad = resolve;

  				if ( loader.isImageBitmapLoader === true ) {

  					onLoad = function ( imageBitmap ) {

  						const texture = new Texture( imageBitmap );
  						texture.needsUpdate = true;

  						resolve( texture );

  					};

  				}

  				loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

  			} );

  		} ).then( function ( texture ) {

  			// Clean up resources and configure Texture.

  			if ( isObjectURL === true ) {

  				URL.revokeObjectURL( sourceURI );

  			}

  			assignExtrasToUserData( texture, sourceDef );

  			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

  			return texture;

  		} ).catch( function ( error ) {

  			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
  			throw error;

  		} );

  		this.sourceCache[ sourceIndex ] = promise;
  		return promise;

  	}

  	/**
  	 * Asynchronously assigns a texture to the given material parameters.
  	 *
  	 * @private
  	 * @param {Object} materialParams
  	 * @param {string} mapName
  	 * @param {Object} mapDef
  	 * @param {string} [colorSpace]
  	 * @return {Promise<Texture>}
  	 */
  	assignTexture( materialParams, mapName, mapDef, colorSpace ) {

  		const parser = this;

  		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

  			if ( ! texture ) return null;

  			if ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {

  				texture = texture.clone();
  				texture.channel = mapDef.texCoord;

  			}

  			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

  				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

  				if ( transform ) {

  					const gltfReference = parser.associations.get( texture );
  					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
  					parser.associations.set( texture, gltfReference );

  				}

  			}

  			if ( colorSpace !== undefined ) {

  				texture.colorSpace = colorSpace;

  			}

  			materialParams[ mapName ] = texture;

  			return texture;

  		} );

  	}

  	/**
  	 * Assigns final material to a Mesh, Line, or Points instance. The instance
  	 * already has a material (generated from the glTF material options alone)
  	 * but reuse of the same glTF material may require multiple threejs materials
  	 * to accommodate different primitive types, defines, etc. New materials will
  	 * be created if necessary, and reused from a cache.
  	 *
  	 * @private
  	 * @param {Object3D} mesh Mesh, Line, or Points instance.
  	 */
  	assignFinalMaterial( mesh ) {

  		const geometry = mesh.geometry;
  		let material = mesh.material;

  		const useDerivativeTangents = geometry.attributes.tangent === undefined;
  		const useVertexColors = geometry.attributes.color !== undefined;
  		const useFlatShading = geometry.attributes.normal === undefined;

  		if ( mesh.isPoints ) {

  			const cacheKey = 'PointsMaterial:' + material.uuid;

  			let pointsMaterial = this.cache.get( cacheKey );

  			if ( ! pointsMaterial ) {

  				pointsMaterial = new PointsMaterial();
  				Material.prototype.copy.call( pointsMaterial, material );
  				pointsMaterial.color.copy( material.color );
  				pointsMaterial.map = material.map;
  				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

  				this.cache.add( cacheKey, pointsMaterial );

  			}

  			material = pointsMaterial;

  		} else if ( mesh.isLine ) {

  			const cacheKey = 'LineBasicMaterial:' + material.uuid;

  			let lineMaterial = this.cache.get( cacheKey );

  			if ( ! lineMaterial ) {

  				lineMaterial = new LineBasicMaterial();
  				Material.prototype.copy.call( lineMaterial, material );
  				lineMaterial.color.copy( material.color );
  				lineMaterial.map = material.map;

  				this.cache.add( cacheKey, lineMaterial );

  			}

  			material = lineMaterial;

  		}

  		// Clone the material if it will be modified
  		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

  			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

  			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
  			if ( useVertexColors ) cacheKey += 'vertex-colors:';
  			if ( useFlatShading ) cacheKey += 'flat-shading:';

  			let cachedMaterial = this.cache.get( cacheKey );

  			if ( ! cachedMaterial ) {

  				cachedMaterial = material.clone();

  				if ( useVertexColors ) cachedMaterial.vertexColors = true;
  				if ( useFlatShading ) cachedMaterial.flatShading = true;

  				if ( useDerivativeTangents ) {

  					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
  					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
  					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

  				}

  				this.cache.add( cacheKey, cachedMaterial );

  				this.associations.set( cachedMaterial, this.associations.get( material ) );

  			}

  			material = cachedMaterial;

  		}

  		mesh.material = material;

  	}

  	getMaterialType( /* materialIndex */ ) {

  		return MeshStandardMaterial;

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
  	 *
  	 * @private
  	 * @param {number} materialIndex
  	 * @return {Promise<Material>}
  	 */
  	loadMaterial( materialIndex ) {

  		const parser = this;
  		const json = this.json;
  		const extensions = this.extensions;
  		const materialDef = json.materials[ materialIndex ];

  		let materialType;
  		const materialParams = {};
  		const materialExtensions = materialDef.extensions || {};

  		const pending = [];

  		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

  			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
  			materialType = kmuExtension.getMaterialType();
  			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

  		} else {

  			// Specification:
  			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

  			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

  			materialParams.color = new Color( 1.0, 1.0, 1.0 );
  			materialParams.opacity = 1.0;

  			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

  				const array = metallicRoughness.baseColorFactor;

  				materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );
  				materialParams.opacity = array[ 3 ];

  			}

  			if ( metallicRoughness.baseColorTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

  			}

  			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
  			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

  			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
  				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

  			}

  			materialType = this._invokeOne( function ( ext ) {

  				return ext.getMaterialType && ext.getMaterialType( materialIndex );

  			} );

  			pending.push( Promise.all( this._invokeAll( function ( ext ) {

  				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

  			} ) ) );

  		}

  		if ( materialDef.doubleSided === true ) {

  			materialParams.side = DoubleSide;

  		}

  		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

  		if ( alphaMode === ALPHA_MODES.BLEND ) {

  			materialParams.transparent = true;

  			// See: https://github.com/mrdoob/three.js/issues/17706
  			materialParams.depthWrite = false;

  		} else {

  			materialParams.transparent = false;

  			if ( alphaMode === ALPHA_MODES.MASK ) {

  				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

  			}

  		}

  		if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

  			materialParams.normalScale = new Vector2( 1, 1 );

  			if ( materialDef.normalTexture.scale !== undefined ) {

  				const scale = materialDef.normalTexture.scale;

  				materialParams.normalScale.set( scale, scale );

  			}

  		}

  		if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

  			if ( materialDef.occlusionTexture.strength !== undefined ) {

  				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

  			}

  		}

  		if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

  			const emissiveFactor = materialDef.emissiveFactor;
  			materialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );

  		}

  		if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );

  		}

  		return Promise.all( pending ).then( function () {

  			const material = new materialType( materialParams );

  			if ( materialDef.name ) material.name = materialDef.name;

  			assignExtrasToUserData( material, materialDef );

  			parser.associations.set( material, { materials: materialIndex } );

  			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

  			return material;

  		} );

  	}

  	/**
  	 * When Object3D instances are targeted by animation, they need unique names.
  	 *
  	 * @private
  	 * @param {string} originalName
  	 * @return {string}
  	 */
  	createUniqueName( originalName ) {

  		const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );

  		if ( sanitizedName in this.nodeNamesUsed ) {

  			return sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );

  		} else {

  			this.nodeNamesUsed[ sanitizedName ] = 0;

  			return sanitizedName;

  		}

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
  	 *
  	 * Creates BufferGeometries from primitives.
  	 *
  	 * @private
  	 * @param {Array<GLTF.Primitive>} primitives
  	 * @return {Promise<Array<BufferGeometry>>}
  	 */
  	loadGeometries( primitives ) {

  		const parser = this;
  		const extensions = this.extensions;
  		const cache = this.primitiveCache;

  		function createDracoPrimitive( primitive ) {

  			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
  				.decodePrimitive( primitive, parser )
  				.then( function ( geometry ) {

  					return addPrimitiveAttributes( geometry, primitive, parser );

  				} );

  		}

  		const pending = [];

  		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

  			const primitive = primitives[ i ];
  			const cacheKey = createPrimitiveKey( primitive );

  			// See if we've already created this geometry
  			const cached = cache[ cacheKey ];

  			if ( cached ) {

  				// Use the cached geometry if it exists
  				pending.push( cached.promise );

  			} else {

  				let geometryPromise;

  				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

  					// Use DRACO geometry if available
  					geometryPromise = createDracoPrimitive( primitive );

  				} else {

  					// Otherwise create a new geometry
  					geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

  				}

  				// Cache this geometry
  				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

  				pending.push( geometryPromise );

  			}

  		}

  		return Promise.all( pending );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
  	 *
  	 * @private
  	 * @param {number} meshIndex
  	 * @return {Promise<Group|Mesh|SkinnedMesh|Line|Points>}
  	 */
  	loadMesh( meshIndex ) {

  		const parser = this;
  		const json = this.json;
  		const extensions = this.extensions;

  		const meshDef = json.meshes[ meshIndex ];
  		const primitives = meshDef.primitives;

  		const pending = [];

  		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

  			const material = primitives[ i ].material === undefined
  				? createDefaultMaterial( this.cache )
  				: this.getDependency( 'material', primitives[ i ].material );

  			pending.push( material );

  		}

  		pending.push( parser.loadGeometries( primitives ) );

  		return Promise.all( pending ).then( function ( results ) {

  			const materials = results.slice( 0, results.length - 1 );
  			const geometries = results[ results.length - 1 ];

  			const meshes = [];

  			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

  				const geometry = geometries[ i ];
  				const primitive = primitives[ i ];

  				// 1. create Mesh

  				let mesh;

  				const material = materials[ i ];

  				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
  						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
  						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
  						primitive.mode === undefined ) {

  					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
  					mesh = meshDef.isSkinnedMesh === true
  						? new SkinnedMesh( geometry, material )
  						: new Mesh( geometry, material );

  					if ( mesh.isSkinnedMesh === true ) {

  						// normalize skin weights to fix malformed assets (see #15319)
  						mesh.normalizeSkinWeights();

  					}

  					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

  						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

  					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

  						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

  					}

  				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

  					mesh = new LineSegments( geometry, material );

  				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

  					mesh = new Line( geometry, material );

  				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

  					mesh = new LineLoop( geometry, material );

  				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

  					mesh = new Points( geometry, material );

  				} else {

  					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

  				}

  				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

  					updateMorphTargets( mesh, meshDef );

  				}

  				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

  				assignExtrasToUserData( mesh, meshDef );

  				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

  				parser.assignFinalMaterial( mesh );

  				meshes.push( mesh );

  			}

  			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

  				parser.associations.set( meshes[ i ], {
  					meshes: meshIndex,
  					primitives: i
  				} );

  			}

  			if ( meshes.length === 1 ) {

  				if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );

  				return meshes[ 0 ];

  			}

  			const group = new Group();

  			if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );

  			parser.associations.set( group, { meshes: meshIndex } );

  			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

  				group.add( meshes[ i ] );

  			}

  			return group;

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
  	 *
  	 * @private
  	 * @param {number} cameraIndex
  	 * @return {Promise<Camera>|undefined}
  	 */
  	loadCamera( cameraIndex ) {

  		let camera;
  		const cameraDef = this.json.cameras[ cameraIndex ];
  		const params = cameraDef[ cameraDef.type ];

  		if ( ! params ) {

  			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
  			return;

  		}

  		if ( cameraDef.type === 'perspective' ) {

  			camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

  		} else if ( cameraDef.type === 'orthographic' ) {

  			camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

  		}

  		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

  		assignExtrasToUserData( camera, cameraDef );

  		return Promise.resolve( camera );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
  	 *
  	 * @private
  	 * @param {number} skinIndex
  	 * @return {Promise<Skeleton>}
  	 */
  	loadSkin( skinIndex ) {

  		const skinDef = this.json.skins[ skinIndex ];

  		const pending = [];

  		for ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {

  			pending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );

  		}

  		if ( skinDef.inverseBindMatrices !== undefined ) {

  			pending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );

  		} else {

  			pending.push( null );

  		}

  		return Promise.all( pending ).then( function ( results ) {

  			const inverseBindMatrices = results.pop();
  			const jointNodes = results;

  			// Note that bones (joint nodes) may or may not be in the
  			// scene graph at this time.

  			const bones = [];
  			const boneInverses = [];

  			for ( let i = 0, il = jointNodes.length; i < il; i ++ ) {

  				const jointNode = jointNodes[ i ];

  				if ( jointNode ) {

  					bones.push( jointNode );

  					const mat = new Matrix4();

  					if ( inverseBindMatrices !== null ) {

  						mat.fromArray( inverseBindMatrices.array, i * 16 );

  					}

  					boneInverses.push( mat );

  				} else {

  					console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[ i ] );

  				}

  			}

  			return new Skeleton( bones, boneInverses );

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
  	 *
  	 * @private
  	 * @param {number} animationIndex
  	 * @return {Promise<AnimationClip>}
  	 */
  	loadAnimation( animationIndex ) {

  		const json = this.json;
  		const parser = this;

  		const animationDef = json.animations[ animationIndex ];
  		const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

  		const pendingNodes = [];
  		const pendingInputAccessors = [];
  		const pendingOutputAccessors = [];
  		const pendingSamplers = [];
  		const pendingTargets = [];

  		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

  			const channel = animationDef.channels[ i ];
  			const sampler = animationDef.samplers[ channel.sampler ];
  			const target = channel.target;
  			const name = target.node;
  			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
  			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

  			if ( target.node === undefined ) continue;

  			pendingNodes.push( this.getDependency( 'node', name ) );
  			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
  			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
  			pendingSamplers.push( sampler );
  			pendingTargets.push( target );

  		}

  		return Promise.all( [

  			Promise.all( pendingNodes ),
  			Promise.all( pendingInputAccessors ),
  			Promise.all( pendingOutputAccessors ),
  			Promise.all( pendingSamplers ),
  			Promise.all( pendingTargets )

  		] ).then( function ( dependencies ) {

  			const nodes = dependencies[ 0 ];
  			const inputAccessors = dependencies[ 1 ];
  			const outputAccessors = dependencies[ 2 ];
  			const samplers = dependencies[ 3 ];
  			const targets = dependencies[ 4 ];

  			const tracks = [];

  			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

  				const node = nodes[ i ];
  				const inputAccessor = inputAccessors[ i ];
  				const outputAccessor = outputAccessors[ i ];
  				const sampler = samplers[ i ];
  				const target = targets[ i ];

  				if ( node === undefined ) continue;

  				if ( node.updateMatrix ) {

  					node.updateMatrix();

  				}

  				const createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );

  				if ( createdTracks ) {

  					for ( let k = 0; k < createdTracks.length; k ++ ) {

  						tracks.push( createdTracks[ k ] );

  					}

  				}

  			}

  			const animation = new AnimationClip( animationName, undefined, tracks );

  			assignExtrasToUserData( animation, animationDef );

  			return animation;

  		} );

  	}

  	createNodeMesh( nodeIndex ) {

  		const json = this.json;
  		const parser = this;
  		const nodeDef = json.nodes[ nodeIndex ];

  		if ( nodeDef.mesh === undefined ) return null;

  		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

  			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

  			// if weights are provided on the node, override weights on the mesh.
  			if ( nodeDef.weights !== undefined ) {

  				node.traverse( function ( o ) {

  					if ( ! o.isMesh ) return;

  					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

  						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

  					}

  				} );

  			}

  			return node;

  		} );

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
  	 *
  	 * @private
  	 * @param {number} nodeIndex
  	 * @return {Promise<Object3D>}
  	 */
  	loadNode( nodeIndex ) {

  		const json = this.json;
  		const parser = this;

  		const nodeDef = json.nodes[ nodeIndex ];

  		const nodePending = parser._loadNodeShallow( nodeIndex );

  		const childPending = [];
  		const childrenDef = nodeDef.children || [];

  		for ( let i = 0, il = childrenDef.length; i < il; i ++ ) {

  			childPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );

  		}

  		const skeletonPending = nodeDef.skin === undefined
  			? Promise.resolve( null )
  			: parser.getDependency( 'skin', nodeDef.skin );

  		return Promise.all( [
  			nodePending,
  			Promise.all( childPending ),
  			skeletonPending
  		] ).then( function ( results ) {

  			const node = results[ 0 ];
  			const children = results[ 1 ];
  			const skeleton = results[ 2 ];

  			if ( skeleton !== null ) {

  				// This full traverse should be fine because
  				// child glTF nodes have not been added to this node yet.
  				node.traverse( function ( mesh ) {

  					if ( ! mesh.isSkinnedMesh ) return;

  					mesh.bind( skeleton, _identityMatrix );

  				} );

  			}

  			for ( let i = 0, il = children.length; i < il; i ++ ) {

  				node.add( children[ i ] );

  			}

  			return node;

  		} );

  	}

  	// ._loadNodeShallow() parses a single node.
  	// skin and child nodes are created and added in .loadNode() (no '_' prefix).
  	_loadNodeShallow( nodeIndex ) {

  		const json = this.json;
  		const extensions = this.extensions;
  		const parser = this;

  		// This method is called from .loadNode() and .loadSkin().
  		// Cache a node to avoid duplication.

  		if ( this.nodeCache[ nodeIndex ] !== undefined ) {

  			return this.nodeCache[ nodeIndex ];

  		}

  		const nodeDef = json.nodes[ nodeIndex ];

  		// reserve node's name before its dependencies, so the root has the intended name.
  		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

  		const pending = [];

  		const meshPromise = parser._invokeOne( function ( ext ) {

  			return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

  		} );

  		if ( meshPromise ) {

  			pending.push( meshPromise );

  		}

  		if ( nodeDef.camera !== undefined ) {

  			pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

  				return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

  			} ) );

  		}

  		parser._invokeAll( function ( ext ) {

  			return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

  		} ).forEach( function ( promise ) {

  			pending.push( promise );

  		} );

  		this.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {

  			let node;

  			// .isBone isn't in glTF spec. See ._markDefs
  			if ( nodeDef.isBone === true ) {

  				node = new Bone();

  			} else if ( objects.length > 1 ) {

  				node = new Group();

  			} else if ( objects.length === 1 ) {

  				node = objects[ 0 ];

  			} else {

  				node = new Object3D();

  			}

  			if ( node !== objects[ 0 ] ) {

  				for ( let i = 0, il = objects.length; i < il; i ++ ) {

  					node.add( objects[ i ] );

  				}

  			}

  			if ( nodeDef.name ) {

  				node.userData.name = nodeDef.name;
  				node.name = nodeName;

  			}

  			assignExtrasToUserData( node, nodeDef );

  			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

  			if ( nodeDef.matrix !== undefined ) {

  				const matrix = new Matrix4();
  				matrix.fromArray( nodeDef.matrix );
  				node.applyMatrix4( matrix );

  			} else {

  				if ( nodeDef.translation !== undefined ) {

  					node.position.fromArray( nodeDef.translation );

  				}

  				if ( nodeDef.rotation !== undefined ) {

  					node.quaternion.fromArray( nodeDef.rotation );

  				}

  				if ( nodeDef.scale !== undefined ) {

  					node.scale.fromArray( nodeDef.scale );

  				}

  			}

  			if ( ! parser.associations.has( node ) ) {

  				parser.associations.set( node, {} );

  			} else if ( nodeDef.mesh !== undefined && parser.meshCache.refs[ nodeDef.mesh ] > 1 ) {

  				const mapping = parser.associations.get( node );
  				parser.associations.set( node, { ...mapping } );

  			}

  			parser.associations.get( node ).nodes = nodeIndex;

  			return node;

  		} );

  		return this.nodeCache[ nodeIndex ];

  	}

  	/**
  	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
  	 *
  	 * @private
  	 * @param {number} sceneIndex
  	 * @return {Promise<Group>}
  	 */
  	loadScene( sceneIndex ) {

  		const extensions = this.extensions;
  		const sceneDef = this.json.scenes[ sceneIndex ];
  		const parser = this;

  		// Loader returns Group, not Scene.
  		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
  		const scene = new Group();
  		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

  		assignExtrasToUserData( scene, sceneDef );

  		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

  		const nodeIds = sceneDef.nodes || [];

  		const pending = [];

  		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

  			pending.push( parser.getDependency( 'node', nodeIds[ i ] ) );

  		}

  		return Promise.all( pending ).then( function ( nodes ) {

  			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

  				scene.add( nodes[ i ] );

  			}

  			// Removes dangling associations, associations that reference a node that
  			// didn't make it into the scene.
  			const reduceAssociations = ( node ) => {

  				const reducedAssociations = new Map();

  				for ( const [ key, value ] of parser.associations ) {

  					if ( key instanceof Material || key instanceof Texture ) {

  						reducedAssociations.set( key, value );

  					}

  				}

  				node.traverse( ( node ) => {

  					const mappings = parser.associations.get( node );

  					if ( mappings != null ) {

  						reducedAssociations.set( node, mappings );

  					}

  				} );

  				return reducedAssociations;

  			};

  			parser.associations = reduceAssociations( scene );

  			return scene;

  		} );

  	}

  	_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {

  		const tracks = [];

  		const targetName = node.name ? node.name : node.uuid;
  		const targetNames = [];

  		if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

  			node.traverse( function ( object ) {

  				if ( object.morphTargetInfluences ) {

  					targetNames.push( object.name ? object.name : object.uuid );

  				}

  			} );

  		} else {

  			targetNames.push( targetName );

  		}

  		let TypedKeyframeTrack;

  		switch ( PATH_PROPERTIES[ target.path ] ) {

  			case PATH_PROPERTIES.weights:

  				TypedKeyframeTrack = NumberKeyframeTrack;
  				break;

  			case PATH_PROPERTIES.rotation:

  				TypedKeyframeTrack = QuaternionKeyframeTrack;
  				break;

  			case PATH_PROPERTIES.translation:
  			case PATH_PROPERTIES.scale:

  				TypedKeyframeTrack = VectorKeyframeTrack;
  				break;

  			default:

  				switch ( outputAccessor.itemSize ) {

  					case 1:
  						TypedKeyframeTrack = NumberKeyframeTrack;
  						break;
  					case 2:
  					case 3:
  					default:
  						TypedKeyframeTrack = VectorKeyframeTrack;
  						break;

  				}

  				break;

  		}

  		const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;


  		const outputArray = this._getArrayFromAccessor( outputAccessor );

  		for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

  			const track = new TypedKeyframeTrack(
  				targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
  				inputAccessor.array,
  				outputArray,
  				interpolation
  			);

  			// Override interpolation with custom factory method.
  			if ( sampler.interpolation === 'CUBICSPLINE' ) {

  				this._createCubicSplineTrackInterpolant( track );

  			}

  			tracks.push( track );

  		}

  		return tracks;

  	}

  	_getArrayFromAccessor( accessor ) {

  		let outputArray = accessor.array;

  		if ( accessor.normalized ) {

  			const scale = getNormalizedComponentScale( outputArray.constructor );
  			const scaled = new Float32Array( outputArray.length );

  			for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

  				scaled[ j ] = outputArray[ j ] * scale;

  			}

  			outputArray = scaled;

  		}

  		return outputArray;

  	}

  	_createCubicSplineTrackInterpolant( track ) {

  		track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

  			// A CUBICSPLINE keyframe in glTF has three output values for each input value,
  			// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
  			// must be divided by three to get the interpolant's sampleSize argument.

  			const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

  			return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

  		};

  		// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
  		track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

  	}

  }

  /**
   *
   * @private
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   */
  function computeBounds( geometry, primitiveDef, parser ) {

  	const attributes = primitiveDef.attributes;

  	const box = new Box3();

  	if ( attributes.POSITION !== undefined ) {

  		const accessor = parser.json.accessors[ attributes.POSITION ];

  		const min = accessor.min;
  		const max = accessor.max;

  		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

  		if ( min !== undefined && max !== undefined ) {

  			box.set(
  				new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
  				new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
  			);

  			if ( accessor.normalized ) {

  				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
  				box.min.multiplyScalar( boxScale );
  				box.max.multiplyScalar( boxScale );

  			}

  		} else {

  			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

  			return;

  		}

  	} else {

  		return;

  	}

  	const targets = primitiveDef.targets;

  	if ( targets !== undefined ) {

  		const maxDisplacement = new Vector3();
  		const vector = new Vector3();

  		for ( let i = 0, il = targets.length; i < il; i ++ ) {

  			const target = targets[ i ];

  			if ( target.POSITION !== undefined ) {

  				const accessor = parser.json.accessors[ target.POSITION ];
  				const min = accessor.min;
  				const max = accessor.max;

  				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

  				if ( min !== undefined && max !== undefined ) {

  					// we need to get max of absolute components because target weight is [-1,1]
  					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
  					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
  					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


  					if ( accessor.normalized ) {

  						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
  						vector.multiplyScalar( boxScale );

  					}

  					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
  					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
  					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
  					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
  					maxDisplacement.max( vector );

  				} else {

  					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

  				}

  			}

  		}

  		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
  		box.expandByVector( maxDisplacement );

  	}

  	geometry.boundingBox = box;

  	const sphere = new Sphere();

  	box.getCenter( sphere.center );
  	sphere.radius = box.min.distanceTo( box.max ) / 2;

  	geometry.boundingSphere = sphere;

  }

  /**
   *
   * @private
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */
  function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

  	const attributes = primitiveDef.attributes;

  	const pending = [];

  	function assignAttributeAccessor( accessorIndex, attributeName ) {

  		return parser.getDependency( 'accessor', accessorIndex )
  			.then( function ( accessor ) {

  				geometry.setAttribute( attributeName, accessor );

  			} );

  	}

  	for ( const gltfAttributeName in attributes ) {

  		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

  		// Skip attributes already provided by e.g. Draco extension.
  		if ( threeAttributeName in geometry.attributes ) continue;

  		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

  	}

  	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

  		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

  			geometry.setIndex( accessor );

  		} );

  		pending.push( accessor );

  	}

  	if ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {

  		console.warn( `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.` );

  	}

  	assignExtrasToUserData( geometry, primitiveDef );

  	computeBounds( geometry, primitiveDef, parser );

  	return Promise.all( pending ).then( function () {

  		return primitiveDef.targets !== undefined
  			? addMorphTargets( geometry, primitiveDef.targets, parser )
  			: geometry;

  	} );

  }

  /**
   * Fires when the camera has been transformed by the controls.
   *
   * @event OrbitControls#change
   * @type {Object}
   */
  const _changeEvent = { type: 'change' };

  /**
   * Fires when an interaction was initiated.
   *
   * @event OrbitControls#start
   * @type {Object}
   */
  const _startEvent = { type: 'start' };

  /**
   * Fires when an interaction has finished.
   *
   * @event OrbitControls#end
   * @type {Object}
   */
  const _endEvent = { type: 'end' };

  const _ray = new Ray();
  const _plane = new Plane();
  const _TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );

  const _v = new Vector3();
  const _twoPI = 2 * Math.PI;

  const _STATE = {
  	NONE: - 1,
  	ROTATE: 0,
  	DOLLY: 1,
  	PAN: 2,
  	TOUCH_ROTATE: 3,
  	TOUCH_PAN: 4,
  	TOUCH_DOLLY_PAN: 5,
  	TOUCH_DOLLY_ROTATE: 6
  };
  const _EPS = 0.000001;


  /**
   * Orbit controls allow the camera to orbit around a target.
   *
   * OrbitControls performs orbiting, dollying (zooming), and panning. Unlike {@link TrackballControls},
   * it maintains the "up" direction `object.up` (+Y by default).
   *
   * - Orbit: Left mouse / touch: one-finger move.
   * - Zoom: Middle mouse, or mousewheel / touch: two-finger spread or squish.
   * - Pan: Right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move.
   *
   * ```js
   * const controls = new OrbitControls( camera, renderer.domElement );
   *
   * // controls.update() must be called after any manual changes to the camera's transform
   * camera.position.set( 0, 20, 100 );
   * controls.update();
   *
   * function animate() {
   *
   * 	// required if controls.enableDamping or controls.autoRotate are set to true
   * 	controls.update();
   *
   * 	renderer.render( scene, camera );
   *
   * }
   * ```
   *
   * @augments Controls
   * @three_import import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
   */
  class OrbitControls extends Controls {

  	/**
  	 * Constructs a new controls instance.
  	 *
  	 * @param {Object3D} object - The object that is managed by the controls.
  	 * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
  	 */
  	constructor( object, domElement = null ) {

  		super( object, domElement );

  		this.state = _STATE.NONE;

  		/**
  		 * The focus point of the controls, the `object` orbits around this.
  		 * It can be updated manually at any point to change the focus of the controls.
  		 *
  		 * @type {Vector3}
  		 */
  		this.target = new Vector3();

  		/**
  		 * The focus point of the `minTargetRadius` and `maxTargetRadius` limits.
  		 * It can be updated manually at any point to change the center of interest
  		 * for the `target`.
  		 *
  		 * @type {Vector3}
  		 */
  		this.cursor = new Vector3();

  		/**
  		 * How far you can dolly in (perspective camera only).
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.minDistance = 0;

  		/**
  		 * How far you can dolly out (perspective camera only).
  		 *
  		 * @type {number}
  		 * @default Infinity
  		 */
  		this.maxDistance = Infinity;

  		/**
  		 * How far you can zoom in (orthographic camera only).
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.minZoom = 0;

  		/**
  		 * How far you can zoom out (orthographic camera only).
  		 *
  		 * @type {number}
  		 * @default Infinity
  		 */
  		this.maxZoom = Infinity;

  		/**
  		 * How close you can get the target to the 3D `cursor`.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.minTargetRadius = 0;

  		/**
  		 * How far you can move the target from the 3D `cursor`.
  		 *
  		 * @type {number}
  		 * @default Infinity
  		 */
  		this.maxTargetRadius = Infinity;

  		/**
  		 * How far you can orbit vertically, lower limit. Range is `[0, Math.PI]` radians.
  		 *
  		 * @type {number}
  		 * @default 0
  		 */
  		this.minPolarAngle = 0;

  		/**
  		 * How far you can orbit vertically, upper limit. Range is `[0, Math.PI]` radians.
  		 *
  		 * @type {number}
  		 * @default Math.PI
  		 */
  		this.maxPolarAngle = Math.PI;

  		/**
  		 * How far you can orbit horizontally, lower limit. If set, the interval `[ min, max ]`
  		 * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.
  		 *
  		 * @type {number}
  		 * @default -Infinity
  		 */
  		this.minAzimuthAngle = - Infinity;

  		/**
  		 * How far you can orbit horizontally, upper limit. If set, the interval `[ min, max ]`
  		 * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.
  		 *
  		 * @type {number}
  		 * @default -Infinity
  		 */
  		this.maxAzimuthAngle = Infinity;

  		/**
  		 * Set to `true` to enable damping (inertia), which can be used to give a sense of weight
  		 * to the controls. Note that if this is enabled, you must call `update()` in your animation
  		 * loop.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.enableDamping = false;

  		/**
  		 * The damping inertia used if `enableDamping` is set to `true`.
  		 *
  		 * Note that for this to work, you must call `update()` in your animation loop.
  		 *
  		 * @type {number}
  		 * @default 0.05
  		 */
  		this.dampingFactor = 0.05;

  		/**
  		 * Enable or disable zooming (dollying) of the camera.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.enableZoom = true;

  		/**
  		 * Speed of zooming / dollying.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.zoomSpeed = 1.0;

  		/**
  		 * Enable or disable horizontal and vertical rotation of the camera.
  		 *
  		 * Note that it is possible to disable a single axis by setting the min and max of the
  		 * `minPolarAngle` or `minAzimuthAngle` to the same value, which will cause the vertical
  		 * or horizontal rotation to be fixed at that value.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.enableRotate = true;

  		/**
  		 * Speed of rotation.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.rotateSpeed = 1.0;

  		/**
  		 * How fast to rotate the camera when the keyboard is used.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.keyRotateSpeed = 1.0;

  		/**
  		 * Enable or disable camera panning.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.enablePan = true;

  		/**
  		 * Speed of panning.
  		 *
  		 * @type {number}
  		 * @default 1
  		 */
  		this.panSpeed = 1.0;

  		/**
  		 * Defines how the camera's position is translated when panning. If `true`, the camera pans
  		 * in screen space. Otherwise, the camera pans in the plane orthogonal to the camera's up
  		 * direction.
  		 *
  		 * @type {boolean}
  		 * @default true
  		 */
  		this.screenSpacePanning = true;

  		/**
  		 * How fast to pan the camera when the keyboard is used in
  		 * pixels per keypress.
  		 *
  		 * @type {number}
  		 * @default 7
  		 */
  		this.keyPanSpeed = 7.0;

  		/**
  		 * Setting this property to `true` allows to zoom to the cursor's position.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.zoomToCursor = false;

  		/**
  		 * Set to true to automatically rotate around the target
  		 *
  		 * Note that if this is enabled, you must call `update()` in your animation loop.
  		 * If you want the auto-rotate speed to be independent of the frame rate (the refresh
  		 * rate of the display), you must pass the time `deltaTime`, in seconds, to `update()`.
  		 *
  		 * @type {boolean}
  		 * @default false
  		 */
  		this.autoRotate = false;

  		/**
  		 * How fast to rotate around the target if `autoRotate` is `true`. The default  equates to 30 seconds
  		 * per orbit at 60fps.
  		 *
  		 * Note that if `autoRotate` is enabled, you must call `update()` in your animation loop.
  		 *
  		 * @type {number}
  		 * @default 2
  		 */
  		this.autoRotateSpeed = 2.0;

  		/**
  		 * This object contains references to the keycodes for controlling camera panning.
  		 *
  		 * ```js
  		 * controls.keys = {
  		 * 	LEFT: 'ArrowLeft', //left arrow
  		 * 	UP: 'ArrowUp', // up arrow
  		 * 	RIGHT: 'ArrowRight', // right arrow
  		 * 	BOTTOM: 'ArrowDown' // down arrow
  		 * }
  		 * ```
  		 * @type {Object}
  		 */
  		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

  		/**
  		 * This object contains references to the mouse actions used by the controls.
  		 *
  		 * ```js
  		 * controls.mouseButtons = {
  		 * 	LEFT: THREE.MOUSE.ROTATE,
  		 * 	MIDDLE: THREE.MOUSE.DOLLY,
  		 * 	RIGHT: THREE.MOUSE.PAN
  		 * }
  		 * ```
  		 * @type {Object}
  		 */
  		this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

  		/**
  		 * This object contains references to the touch actions used by the controls.
  		 *
  		 * ```js
  		 * controls.mouseButtons = {
  		 * 	ONE: THREE.TOUCH.ROTATE,
  		 * 	TWO: THREE.TOUCH.DOLLY_PAN
  		 * }
  		 * ```
  		 * @type {Object}
  		 */
  		this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

  		/**
  		 * Used internally by `saveState()` and `reset()`.
  		 *
  		 * @type {Vector3}
  		 */
  		this.target0 = this.target.clone();

  		/**
  		 * Used internally by `saveState()` and `reset()`.
  		 *
  		 * @type {Vector3}
  		 */
  		this.position0 = this.object.position.clone();

  		/**
  		 * Used internally by `saveState()` and `reset()`.
  		 *
  		 * @type {number}
  		 */
  		this.zoom0 = this.object.zoom;

  		// the target DOM element for key events
  		this._domElementKeyEvents = null;

  		// internals

  		this._lastPosition = new Vector3();
  		this._lastQuaternion = new Quaternion();
  		this._lastTargetPosition = new Vector3();

  		// so camera.up is the orbit axis
  		this._quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
  		this._quatInverse = this._quat.clone().invert();

  		// current position in spherical coordinates
  		this._spherical = new Spherical();
  		this._sphericalDelta = new Spherical();

  		this._scale = 1;
  		this._panOffset = new Vector3();

  		this._rotateStart = new Vector2();
  		this._rotateEnd = new Vector2();
  		this._rotateDelta = new Vector2();

  		this._panStart = new Vector2();
  		this._panEnd = new Vector2();
  		this._panDelta = new Vector2();

  		this._dollyStart = new Vector2();
  		this._dollyEnd = new Vector2();
  		this._dollyDelta = new Vector2();

  		this._dollyDirection = new Vector3();
  		this._mouse = new Vector2();
  		this._performCursorZoom = false;

  		this._pointers = [];
  		this._pointerPositions = {};

  		this._controlActive = false;

  		// event listeners

  		this._onPointerMove = onPointerMove.bind( this );
  		this._onPointerDown = onPointerDown.bind( this );
  		this._onPointerUp = onPointerUp.bind( this );
  		this._onContextMenu = onContextMenu.bind( this );
  		this._onMouseWheel = onMouseWheel.bind( this );
  		this._onKeyDown = onKeyDown.bind( this );

  		this._onTouchStart = onTouchStart.bind( this );
  		this._onTouchMove = onTouchMove.bind( this );

  		this._onMouseDown = onMouseDown.bind( this );
  		this._onMouseMove = onMouseMove.bind( this );

  		this._interceptControlDown = interceptControlDown.bind( this );
  		this._interceptControlUp = interceptControlUp.bind( this );

  		//

  		if ( this.domElement !== null ) {

  			this.connect( this.domElement );

  		}

  		this.update();

  	}

  	connect( element ) {

  		super.connect( element );

  		this.domElement.addEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.addEventListener( 'pointercancel', this._onPointerUp );

  		this.domElement.addEventListener( 'contextmenu', this._onContextMenu );
  		this.domElement.addEventListener( 'wheel', this._onMouseWheel, { passive: false } );

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility
  		document.addEventListener( 'keydown', this._interceptControlDown, { passive: true, capture: true } );

  		this.domElement.style.touchAction = 'none'; // disable touch scroll

  	}

  	disconnect() {

  		this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );
  		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );
  		this.domElement.removeEventListener( 'pointercancel', this._onPointerUp );

  		this.domElement.removeEventListener( 'wheel', this._onMouseWheel );
  		this.domElement.removeEventListener( 'contextmenu', this._onContextMenu );

  		this.stopListenToKeyEvents();

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility
  		document.removeEventListener( 'keydown', this._interceptControlDown, { capture: true } );

  		this.domElement.style.touchAction = 'auto';

  	}

  	dispose() {

  		this.disconnect();

  	}

  	/**
  	 * Get the current vertical rotation, in radians.
  	 *
  	 * @return {number} The current vertical rotation, in radians.
  	 */
  	getPolarAngle() {

  		return this._spherical.phi;

  	}

  	/**
  	 * Get the current horizontal rotation, in radians.
  	 *
  	 * @return {number} The current horizontal rotation, in radians.
  	 */
  	getAzimuthalAngle() {

  		return this._spherical.theta;

  	}

  	/**
  	 * Returns the distance from the camera to the target.
  	 *
  	 * @return {number} The distance from the camera to the target.
  	 */
  	getDistance() {

  		return this.object.position.distanceTo( this.target );

  	}

  	/**
  	 * Adds key event listeners to the given DOM element.
  	 * `window` is a recommended argument for using this method.
  	 *
  	 * @param {HTMLDOMElement} domElement - The DOM element
  	 */
  	listenToKeyEvents( domElement ) {

  		domElement.addEventListener( 'keydown', this._onKeyDown );
  		this._domElementKeyEvents = domElement;

  	}

  	/**
  	 * Removes the key event listener previously defined with `listenToKeyEvents()`.
  	 */
  	stopListenToKeyEvents() {

  		if ( this._domElementKeyEvents !== null ) {

  			this._domElementKeyEvents.removeEventListener( 'keydown', this._onKeyDown );
  			this._domElementKeyEvents = null;

  		}

  	}

  	/**
  	 * Save the current state of the controls. This can later be recovered with `reset()`.
  	 */
  	saveState() {

  		this.target0.copy( this.target );
  		this.position0.copy( this.object.position );
  		this.zoom0 = this.object.zoom;

  	}

  	/**
  	 * Reset the controls to their state from either the last time the `saveState()`
  	 * was called, or the initial state.
  	 */
  	reset() {

  		this.target.copy( this.target0 );
  		this.object.position.copy( this.position0 );
  		this.object.zoom = this.zoom0;

  		this.object.updateProjectionMatrix();
  		this.dispatchEvent( _changeEvent );

  		this.update();

  		this.state = _STATE.NONE;

  	}

  	update( deltaTime = null ) {

  		const position = this.object.position;

  		_v.copy( position ).sub( this.target );

  		// rotate offset to "y-axis-is-up" space
  		_v.applyQuaternion( this._quat );

  		// angle from z-axis around y-axis
  		this._spherical.setFromVector3( _v );

  		if ( this.autoRotate && this.state === _STATE.NONE ) {

  			this._rotateLeft( this._getAutoRotationAngle( deltaTime ) );

  		}

  		if ( this.enableDamping ) {

  			this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
  			this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;

  		} else {

  			this._spherical.theta += this._sphericalDelta.theta;
  			this._spherical.phi += this._sphericalDelta.phi;

  		}

  		// restrict theta to be between desired limits

  		let min = this.minAzimuthAngle;
  		let max = this.maxAzimuthAngle;

  		if ( isFinite( min ) && isFinite( max ) ) {

  			if ( min < - Math.PI ) min += _twoPI; else if ( min > Math.PI ) min -= _twoPI;

  			if ( max < - Math.PI ) max += _twoPI; else if ( max > Math.PI ) max -= _twoPI;

  			if ( min <= max ) {

  				this._spherical.theta = Math.max( min, Math.min( max, this._spherical.theta ) );

  			} else {

  				this._spherical.theta = ( this._spherical.theta > ( min + max ) / 2 ) ?
  					Math.max( min, this._spherical.theta ) :
  					Math.min( max, this._spherical.theta );

  			}

  		}

  		// restrict phi to be between desired limits
  		this._spherical.phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, this._spherical.phi ) );

  		this._spherical.makeSafe();


  		// move target to panned location

  		if ( this.enableDamping === true ) {

  			this.target.addScaledVector( this._panOffset, this.dampingFactor );

  		} else {

  			this.target.add( this._panOffset );

  		}

  		// Limit the target distance from the cursor to create a sphere around the center of interest
  		this.target.sub( this.cursor );
  		this.target.clampLength( this.minTargetRadius, this.maxTargetRadius );
  		this.target.add( this.cursor );

  		let zoomChanged = false;
  		// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
  		// we adjust zoom later in these cases
  		if ( this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera ) {

  			this._spherical.radius = this._clampDistance( this._spherical.radius );

  		} else {

  			const prevRadius = this._spherical.radius;
  			this._spherical.radius = this._clampDistance( this._spherical.radius * this._scale );
  			zoomChanged = prevRadius != this._spherical.radius;

  		}

  		_v.setFromSpherical( this._spherical );

  		// rotate offset back to "camera-up-vector-is-up" space
  		_v.applyQuaternion( this._quatInverse );

  		position.copy( this.target ).add( _v );

  		this.object.lookAt( this.target );

  		if ( this.enableDamping === true ) {

  			this._sphericalDelta.theta *= ( 1 - this.dampingFactor );
  			this._sphericalDelta.phi *= ( 1 - this.dampingFactor );

  			this._panOffset.multiplyScalar( 1 - this.dampingFactor );

  		} else {

  			this._sphericalDelta.set( 0, 0, 0 );

  			this._panOffset.set( 0, 0, 0 );

  		}

  		// adjust camera position
  		if ( this.zoomToCursor && this._performCursorZoom ) {

  			let newRadius = null;
  			if ( this.object.isPerspectiveCamera ) {

  				// move the camera down the pointer ray
  				// this method avoids floating point error
  				const prevRadius = _v.length();
  				newRadius = this._clampDistance( prevRadius * this._scale );

  				const radiusDelta = prevRadius - newRadius;
  				this.object.position.addScaledVector( this._dollyDirection, radiusDelta );
  				this.object.updateMatrixWorld();

  				zoomChanged = !! radiusDelta;

  			} else if ( this.object.isOrthographicCamera ) {

  				// adjust the ortho camera position based on zoom changes
  				const mouseBefore = new Vector3( this._mouse.x, this._mouse.y, 0 );
  				mouseBefore.unproject( this.object );

  				const prevZoom = this.object.zoom;
  				this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );
  				this.object.updateProjectionMatrix();

  				zoomChanged = prevZoom !== this.object.zoom;

  				const mouseAfter = new Vector3( this._mouse.x, this._mouse.y, 0 );
  				mouseAfter.unproject( this.object );

  				this.object.position.sub( mouseAfter ).add( mouseBefore );
  				this.object.updateMatrixWorld();

  				newRadius = _v.length();

  			} else {

  				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );
  				this.zoomToCursor = false;

  			}

  			// handle the placement of the target
  			if ( newRadius !== null ) {

  				if ( this.screenSpacePanning ) {

  					// position the orbit target in front of the new camera position
  					this.target.set( 0, 0, - 1 )
  						.transformDirection( this.object.matrix )
  						.multiplyScalar( newRadius )
  						.add( this.object.position );

  				} else {

  					// get the ray and translation plane to compute target
  					_ray.origin.copy( this.object.position );
  					_ray.direction.set( 0, 0, - 1 ).transformDirection( this.object.matrix );

  					// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
  					// extremely large values
  					if ( Math.abs( this.object.up.dot( _ray.direction ) ) < _TILT_LIMIT ) {

  						this.object.lookAt( this.target );

  					} else {

  						_plane.setFromNormalAndCoplanarPoint( this.object.up, this.target );
  						_ray.intersectPlane( _plane, this.target );

  					}

  				}

  			}

  		} else if ( this.object.isOrthographicCamera ) {

  			const prevZoom = this.object.zoom;
  			this.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );

  			if ( prevZoom !== this.object.zoom ) {

  				this.object.updateProjectionMatrix();
  				zoomChanged = true;

  			}

  		}

  		this._scale = 1;
  		this._performCursorZoom = false;

  		// update condition is:
  		// min(camera displacement, camera rotation in radians)^2 > EPS
  		// using small-angle approximation cos(x/2) = 1 - x^2 / 8

  		if ( zoomChanged ||
  			this._lastPosition.distanceToSquared( this.object.position ) > _EPS ||
  			8 * ( 1 - this._lastQuaternion.dot( this.object.quaternion ) ) > _EPS ||
  			this._lastTargetPosition.distanceToSquared( this.target ) > _EPS ) {

  			this.dispatchEvent( _changeEvent );

  			this._lastPosition.copy( this.object.position );
  			this._lastQuaternion.copy( this.object.quaternion );
  			this._lastTargetPosition.copy( this.target );

  			return true;

  		}

  		return false;

  	}

  	_getAutoRotationAngle( deltaTime ) {

  		if ( deltaTime !== null ) {

  			return ( _twoPI / 60 * this.autoRotateSpeed ) * deltaTime;

  		} else {

  			return _twoPI / 60 / 60 * this.autoRotateSpeed;

  		}

  	}

  	_getZoomScale( delta ) {

  		const normalizedDelta = Math.abs( delta * 0.01 );
  		return Math.pow( 0.95, this.zoomSpeed * normalizedDelta );

  	}

  	_rotateLeft( angle ) {

  		this._sphericalDelta.theta -= angle;

  	}

  	_rotateUp( angle ) {

  		this._sphericalDelta.phi -= angle;

  	}

  	_panLeft( distance, objectMatrix ) {

  		_v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
  		_v.multiplyScalar( - distance );

  		this._panOffset.add( _v );

  	}

  	_panUp( distance, objectMatrix ) {

  		if ( this.screenSpacePanning === true ) {

  			_v.setFromMatrixColumn( objectMatrix, 1 );

  		} else {

  			_v.setFromMatrixColumn( objectMatrix, 0 );
  			_v.crossVectors( this.object.up, _v );

  		}

  		_v.multiplyScalar( distance );

  		this._panOffset.add( _v );

  	}

  	// deltaX and deltaY are in pixels; right and down are positive
  	_pan( deltaX, deltaY ) {

  		const element = this.domElement;

  		if ( this.object.isPerspectiveCamera ) {

  			// perspective
  			const position = this.object.position;
  			_v.copy( position ).sub( this.target );
  			let targetDistance = _v.length();

  			// half of the fov is center to top of screen
  			targetDistance *= Math.tan( ( this.object.fov / 2 ) * Math.PI / 180.0 );

  			// we use only clientHeight here so aspect ratio does not distort speed
  			this._panLeft( 2 * deltaX * targetDistance / element.clientHeight, this.object.matrix );
  			this._panUp( 2 * deltaY * targetDistance / element.clientHeight, this.object.matrix );

  		} else if ( this.object.isOrthographicCamera ) {

  			// orthographic
  			this._panLeft( deltaX * ( this.object.right - this.object.left ) / this.object.zoom / element.clientWidth, this.object.matrix );
  			this._panUp( deltaY * ( this.object.top - this.object.bottom ) / this.object.zoom / element.clientHeight, this.object.matrix );

  		} else {

  			// camera neither orthographic nor perspective
  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
  			this.enablePan = false;

  		}

  	}

  	_dollyOut( dollyScale ) {

  		if ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {

  			this._scale /= dollyScale;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			this.enableZoom = false;

  		}

  	}

  	_dollyIn( dollyScale ) {

  		if ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {

  			this._scale *= dollyScale;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			this.enableZoom = false;

  		}

  	}

  	_updateZoomParameters( x, y ) {

  		if ( ! this.zoomToCursor ) {

  			return;

  		}

  		this._performCursorZoom = true;

  		const rect = this.domElement.getBoundingClientRect();
  		const dx = x - rect.left;
  		const dy = y - rect.top;
  		const w = rect.width;
  		const h = rect.height;

  		this._mouse.x = ( dx / w ) * 2 - 1;
  		this._mouse.y = - ( dy / h ) * 2 + 1;

  		this._dollyDirection.set( this._mouse.x, this._mouse.y, 1 ).unproject( this.object ).sub( this.object.position ).normalize();

  	}

  	_clampDistance( dist ) {

  		return Math.max( this.minDistance, Math.min( this.maxDistance, dist ) );

  	}

  	//
  	// event callbacks - update the object state
  	//

  	_handleMouseDownRotate( event ) {

  		this._rotateStart.set( event.clientX, event.clientY );

  	}

  	_handleMouseDownDolly( event ) {

  		this._updateZoomParameters( event.clientX, event.clientX );
  		this._dollyStart.set( event.clientX, event.clientY );

  	}

  	_handleMouseDownPan( event ) {

  		this._panStart.set( event.clientX, event.clientY );

  	}

  	_handleMouseMoveRotate( event ) {

  		this._rotateEnd.set( event.clientX, event.clientY );

  		this._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );

  		const element = this.domElement;

  		this._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height

  		this._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );

  		this._rotateStart.copy( this._rotateEnd );

  		this.update();

  	}

  	_handleMouseMoveDolly( event ) {

  		this._dollyEnd.set( event.clientX, event.clientY );

  		this._dollyDelta.subVectors( this._dollyEnd, this._dollyStart );

  		if ( this._dollyDelta.y > 0 ) {

  			this._dollyOut( this._getZoomScale( this._dollyDelta.y ) );

  		} else if ( this._dollyDelta.y < 0 ) {

  			this._dollyIn( this._getZoomScale( this._dollyDelta.y ) );

  		}

  		this._dollyStart.copy( this._dollyEnd );

  		this.update();

  	}

  	_handleMouseMovePan( event ) {

  		this._panEnd.set( event.clientX, event.clientY );

  		this._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );

  		this._pan( this._panDelta.x, this._panDelta.y );

  		this._panStart.copy( this._panEnd );

  		this.update();

  	}

  	_handleMouseWheel( event ) {

  		this._updateZoomParameters( event.clientX, event.clientY );

  		if ( event.deltaY < 0 ) {

  			this._dollyIn( this._getZoomScale( event.deltaY ) );

  		} else if ( event.deltaY > 0 ) {

  			this._dollyOut( this._getZoomScale( event.deltaY ) );

  		}

  		this.update();

  	}

  	_handleKeyDown( event ) {

  		let needsUpdate = false;

  		switch ( event.code ) {

  			case this.keys.UP:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( this.enableRotate ) {

  						this._rotateUp( _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

  					}

  				} else {

  					if ( this.enablePan ) {

  						this._pan( 0, this.keyPanSpeed );

  					}

  				}

  				needsUpdate = true;
  				break;

  			case this.keys.BOTTOM:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( this.enableRotate ) {

  						this._rotateUp( - _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

  					}

  				} else {

  					if ( this.enablePan ) {

  						this._pan( 0, - this.keyPanSpeed );

  					}

  				}

  				needsUpdate = true;
  				break;

  			case this.keys.LEFT:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( this.enableRotate ) {

  						this._rotateLeft( _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

  					}

  				} else {

  					if ( this.enablePan ) {

  						this._pan( this.keyPanSpeed, 0 );

  					}

  				}

  				needsUpdate = true;
  				break;

  			case this.keys.RIGHT:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( this.enableRotate ) {

  						this._rotateLeft( - _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );

  					}

  				} else {

  					if ( this.enablePan ) {

  						this._pan( - this.keyPanSpeed, 0 );

  					}

  				}

  				needsUpdate = true;
  				break;

  		}

  		if ( needsUpdate ) {

  			// prevent the browser from scrolling on cursor keys
  			event.preventDefault();

  			this.update();

  		}


  	}

  	_handleTouchStartRotate( event ) {

  		if ( this._pointers.length === 1 ) {

  			this._rotateStart.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._rotateStart.set( x, y );

  		}

  	}

  	_handleTouchStartPan( event ) {

  		if ( this._pointers.length === 1 ) {

  			this._panStart.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._panStart.set( x, y );

  		}

  	}

  	_handleTouchStartDolly( event ) {

  		const position = this._getSecondPointerPosition( event );

  		const dx = event.pageX - position.x;
  		const dy = event.pageY - position.y;

  		const distance = Math.sqrt( dx * dx + dy * dy );

  		this._dollyStart.set( 0, distance );

  	}

  	_handleTouchStartDollyPan( event ) {

  		if ( this.enableZoom ) this._handleTouchStartDolly( event );

  		if ( this.enablePan ) this._handleTouchStartPan( event );

  	}

  	_handleTouchStartDollyRotate( event ) {

  		if ( this.enableZoom ) this._handleTouchStartDolly( event );

  		if ( this.enableRotate ) this._handleTouchStartRotate( event );

  	}

  	_handleTouchMoveRotate( event ) {

  		if ( this._pointers.length == 1 ) {

  			this._rotateEnd.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._rotateEnd.set( x, y );

  		}

  		this._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );

  		const element = this.domElement;

  		this._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height

  		this._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );

  		this._rotateStart.copy( this._rotateEnd );

  	}

  	_handleTouchMovePan( event ) {

  		if ( this._pointers.length === 1 ) {

  			this._panEnd.set( event.pageX, event.pageY );

  		} else {

  			const position = this._getSecondPointerPosition( event );

  			const x = 0.5 * ( event.pageX + position.x );
  			const y = 0.5 * ( event.pageY + position.y );

  			this._panEnd.set( x, y );

  		}

  		this._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );

  		this._pan( this._panDelta.x, this._panDelta.y );

  		this._panStart.copy( this._panEnd );

  	}

  	_handleTouchMoveDolly( event ) {

  		const position = this._getSecondPointerPosition( event );

  		const dx = event.pageX - position.x;
  		const dy = event.pageY - position.y;

  		const distance = Math.sqrt( dx * dx + dy * dy );

  		this._dollyEnd.set( 0, distance );

  		this._dollyDelta.set( 0, Math.pow( this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed ) );

  		this._dollyOut( this._dollyDelta.y );

  		this._dollyStart.copy( this._dollyEnd );

  		const centerX = ( event.pageX + position.x ) * 0.5;
  		const centerY = ( event.pageY + position.y ) * 0.5;

  		this._updateZoomParameters( centerX, centerY );

  	}

  	_handleTouchMoveDollyPan( event ) {

  		if ( this.enableZoom ) this._handleTouchMoveDolly( event );

  		if ( this.enablePan ) this._handleTouchMovePan( event );

  	}

  	_handleTouchMoveDollyRotate( event ) {

  		if ( this.enableZoom ) this._handleTouchMoveDolly( event );

  		if ( this.enableRotate ) this._handleTouchMoveRotate( event );

  	}

  	// pointers

  	_addPointer( event ) {

  		this._pointers.push( event.pointerId );

  	}

  	_removePointer( event ) {

  		delete this._pointerPositions[ event.pointerId ];

  		for ( let i = 0; i < this._pointers.length; i ++ ) {

  			if ( this._pointers[ i ] == event.pointerId ) {

  				this._pointers.splice( i, 1 );
  				return;

  			}

  		}

  	}

  	_isTrackingPointer( event ) {

  		for ( let i = 0; i < this._pointers.length; i ++ ) {

  			if ( this._pointers[ i ] == event.pointerId ) return true;

  		}

  		return false;

  	}

  	_trackPointer( event ) {

  		let position = this._pointerPositions[ event.pointerId ];

  		if ( position === undefined ) {

  			position = new Vector2();
  			this._pointerPositions[ event.pointerId ] = position;

  		}

  		position.set( event.pageX, event.pageY );

  	}

  	_getSecondPointerPosition( event ) {

  		const pointerId = ( event.pointerId === this._pointers[ 0 ] ) ? this._pointers[ 1 ] : this._pointers[ 0 ];

  		return this._pointerPositions[ pointerId ];

  	}

  	//

  	_customWheelEvent( event ) {

  		const mode = event.deltaMode;

  		// minimal wheel event altered to meet delta-zoom demand
  		const newEvent = {
  			clientX: event.clientX,
  			clientY: event.clientY,
  			deltaY: event.deltaY,
  		};

  		switch ( mode ) {

  			case 1: // LINE_MODE
  				newEvent.deltaY *= 16;
  				break;

  			case 2: // PAGE_MODE
  				newEvent.deltaY *= 100;
  				break;

  		}

  		// detect if event was triggered by pinching
  		if ( event.ctrlKey && ! this._controlActive ) {

  			newEvent.deltaY *= 10;

  		}

  		return newEvent;

  	}

  }

  function onPointerDown( event ) {

  	if ( this.enabled === false ) return;

  	if ( this._pointers.length === 0 ) {

  		this.domElement.setPointerCapture( event.pointerId );

  		this.domElement.addEventListener( 'pointermove', this._onPointerMove );
  		this.domElement.addEventListener( 'pointerup', this._onPointerUp );

  	}

  	//

  	if ( this._isTrackingPointer( event ) ) return;

  	//

  	this._addPointer( event );

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchStart( event );

  	} else {

  		this._onMouseDown( event );

  	}

  }

  function onPointerMove( event ) {

  	if ( this.enabled === false ) return;

  	if ( event.pointerType === 'touch' ) {

  		this._onTouchMove( event );

  	} else {

  		this._onMouseMove( event );

  	}

  }

  function onPointerUp( event ) {

  	this._removePointer( event );

  	switch ( this._pointers.length ) {

  		case 0:

  			this.domElement.releasePointerCapture( event.pointerId );

  			this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
  			this.domElement.removeEventListener( 'pointerup', this._onPointerUp );

  			this.dispatchEvent( _endEvent );

  			this.state = _STATE.NONE;

  			break;

  		case 1:

  			const pointerId = this._pointers[ 0 ];
  			const position = this._pointerPositions[ pointerId ];

  			// minimal placeholder event - allows state correction on pointer-up
  			this._onTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );

  			break;

  	}

  }

  function onMouseDown( event ) {

  	let mouseAction;

  	switch ( event.button ) {

  		case 0:

  			mouseAction = this.mouseButtons.LEFT;
  			break;

  		case 1:

  			mouseAction = this.mouseButtons.MIDDLE;
  			break;

  		case 2:

  			mouseAction = this.mouseButtons.RIGHT;
  			break;

  		default:

  			mouseAction = - 1;

  	}

  	switch ( mouseAction ) {

  		case MOUSE.DOLLY:

  			if ( this.enableZoom === false ) return;

  			this._handleMouseDownDolly( event );

  			this.state = _STATE.DOLLY;

  			break;

  		case MOUSE.ROTATE:

  			if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  				if ( this.enablePan === false ) return;

  				this._handleMouseDownPan( event );

  				this.state = _STATE.PAN;

  			} else {

  				if ( this.enableRotate === false ) return;

  				this._handleMouseDownRotate( event );

  				this.state = _STATE.ROTATE;

  			}

  			break;

  		case MOUSE.PAN:

  			if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  				if ( this.enableRotate === false ) return;

  				this._handleMouseDownRotate( event );

  				this.state = _STATE.ROTATE;

  			} else {

  				if ( this.enablePan === false ) return;

  				this._handleMouseDownPan( event );

  				this.state = _STATE.PAN;

  			}

  			break;

  		default:

  			this.state = _STATE.NONE;

  	}

  	if ( this.state !== _STATE.NONE ) {

  		this.dispatchEvent( _startEvent );

  	}

  }

  function onMouseMove( event ) {

  	switch ( this.state ) {

  		case _STATE.ROTATE:

  			if ( this.enableRotate === false ) return;

  			this._handleMouseMoveRotate( event );

  			break;

  		case _STATE.DOLLY:

  			if ( this.enableZoom === false ) return;

  			this._handleMouseMoveDolly( event );

  			break;

  		case _STATE.PAN:

  			if ( this.enablePan === false ) return;

  			this._handleMouseMovePan( event );

  			break;

  	}

  }

  function onMouseWheel( event ) {

  	if ( this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE ) return;

  	event.preventDefault();

  	this.dispatchEvent( _startEvent );

  	this._handleMouseWheel( this._customWheelEvent( event ) );

  	this.dispatchEvent( _endEvent );

  }

  function onKeyDown( event ) {

  	if ( this.enabled === false ) return;

  	this._handleKeyDown( event );

  }

  function onTouchStart( event ) {

  	this._trackPointer( event );

  	switch ( this._pointers.length ) {

  		case 1:

  			switch ( this.touches.ONE ) {

  				case TOUCH.ROTATE:

  					if ( this.enableRotate === false ) return;

  					this._handleTouchStartRotate( event );

  					this.state = _STATE.TOUCH_ROTATE;

  					break;

  				case TOUCH.PAN:

  					if ( this.enablePan === false ) return;

  					this._handleTouchStartPan( event );

  					this.state = _STATE.TOUCH_PAN;

  					break;

  				default:

  					this.state = _STATE.NONE;

  			}

  			break;

  		case 2:

  			switch ( this.touches.TWO ) {

  				case TOUCH.DOLLY_PAN:

  					if ( this.enableZoom === false && this.enablePan === false ) return;

  					this._handleTouchStartDollyPan( event );

  					this.state = _STATE.TOUCH_DOLLY_PAN;

  					break;

  				case TOUCH.DOLLY_ROTATE:

  					if ( this.enableZoom === false && this.enableRotate === false ) return;

  					this._handleTouchStartDollyRotate( event );

  					this.state = _STATE.TOUCH_DOLLY_ROTATE;

  					break;

  				default:

  					this.state = _STATE.NONE;

  			}

  			break;

  		default:

  			this.state = _STATE.NONE;

  	}

  	if ( this.state !== _STATE.NONE ) {

  		this.dispatchEvent( _startEvent );

  	}

  }

  function onTouchMove( event ) {

  	this._trackPointer( event );

  	switch ( this.state ) {

  		case _STATE.TOUCH_ROTATE:

  			if ( this.enableRotate === false ) return;

  			this._handleTouchMoveRotate( event );

  			this.update();

  			break;

  		case _STATE.TOUCH_PAN:

  			if ( this.enablePan === false ) return;

  			this._handleTouchMovePan( event );

  			this.update();

  			break;

  		case _STATE.TOUCH_DOLLY_PAN:

  			if ( this.enableZoom === false && this.enablePan === false ) return;

  			this._handleTouchMoveDollyPan( event );

  			this.update();

  			break;

  		case _STATE.TOUCH_DOLLY_ROTATE:

  			if ( this.enableZoom === false && this.enableRotate === false ) return;

  			this._handleTouchMoveDollyRotate( event );

  			this.update();

  			break;

  		default:

  			this.state = _STATE.NONE;

  	}

  }

  function onContextMenu( event ) {

  	if ( this.enabled === false ) return;

  	event.preventDefault();

  }

  function interceptControlDown( event ) {

  	if ( event.key === 'Control' ) {

  		this._controlActive = true;

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility

  		document.addEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );

  	}

  }

  function interceptControlUp( event ) {

  	if ( event.key === 'Control' ) {

  		this._controlActive = false;

  		const document = this.domElement.getRootNode(); // offscreen canvas compatibility

  		document.removeEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );

  	}

  }

  class GridViewer {
      container = null;
      renderer;
      camera;
      scene;
      controls;
      shaderMaterials = [];
      modelSize;
      modelGroups = [];
      gui;
      params = {
          noiseStrength: 0, // 0.05,
          noiseDark: 0, // 0.8,
          scanWidth: 1.2,
          baseSpeed: 0.4,
          scrollSpeed: 0.2,
      };
      constructor(selector = "#mv") {
          this.container = document.querySelector(selector);
          if (!this.container)
              return;
          this.init();
      }
      init() {
          const container = this.container;
          this.scene = new Scene();
          // this.scene.background = new THREE.Color(0xf1f1f4);
          const aspect = container.clientWidth / container.clientHeight;
          const frustumSize = 1;
          this.camera = new OrthographicCamera((frustumSize * aspect) / -2, (frustumSize * aspect) / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
          this.camera.position.set(0, 1, 1);
          this.camera.lookAt(0, 0, 0);
          this.renderer = new WebGLRenderer({ antialias: true, alpha: true });
          this.renderer.setSize(container.clientWidth, container.clientHeight);
          this.renderer.setPixelRatio(window.devicePixelRatio);
          this.renderer.outputColorSpace = LinearSRGBColorSpace;
          this.renderer.toneMapping = NoToneMapping;
          container.appendChild(this.renderer.domElement);
          // Lights
          const ambientLight = new AmbientLight(0xffffff, 1.0);
          this.scene.add(ambientLight);
          const directionalLight = new DirectionalLight(0xffffff, 1.0);
          directionalLight.position.set(10, 10, 5);
          this.scene.add(directionalLight);
          // Controls
          this.controls = new OrbitControls(this.camera, this.renderer.domElement);
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          // GUI setup
          this.initGUI();
          // Load model
          this.loadModel(aspect);
          // Event
          window.addEventListener("resize", this.handleResize);
      }
      initGUI() {
          this.gui = new GUI();
          this.gui
              .add(this.params, "noiseStrength", 0, 1, 0.01)
              .name("Noise Strength")
              .onChange((v) => {
              this.shaderMaterials.forEach((m) => (m.uniforms.noiseStrength.value = v));
          });
          this.gui
              .add(this.params, "noiseDark", 0, 1, 0.05)
              .name("Noise Dark")
              .onChange((v) => {
              this.shaderMaterials.forEach((m) => (m.uniforms.noiseDark.value = v));
          });
          this.gui
              .add(this.params, "scanWidth", 0.1, 3.0, 0.01)
              .name("Gradient Width")
              .onChange((v) => {
              this.shaderMaterials.forEach((m) => (m.uniforms.scanWidth.value = v));
          });
          this.gui
              .add(this.params, "baseSpeed", 0.1, 2.0, 0.01)
              .name("Base Speed")
              .onChange((v) => {
              this.shaderMaterials.forEach((m, i) => {
                  const planeName = Object.keys(this.speedMultipliers)[i % Object.keys(this.speedMultipliers).length];
                  const speedMultiplier = this.speedMultipliers[planeName] || 1;
                  m.uniforms.scanSpeed.value = v * speedMultiplier;
              });
          });
          this.gui.add(this.params, "scrollSpeed", 0, 1, 0.01).name("Scroll Speed");
      }
      speedMultipliers = {
          plane1: 10 / 6,
          plane2: 10 / 1.5,
          plane3: 10 / 1,
          plane4: 10 / 2,
          plane5: 10 / 4,
      };
      createGradientShader(minX, maxX, speedMultiplier) {
          return new ShaderMaterial({
              uniforms: {
                  uTime: { value: 0 },
                  baseColor: { value: new Vector3(1.0, 85.0 / 255.0, 43.0 / 255.0) },
                  scanSpeed: { value: this.params.baseSpeed * speedMultiplier },
                  scanWidth: { value: this.params.scanWidth },
                  minX: { value: minX },
                  maxX: { value: maxX },
                  noiseStrength: { value: this.params.noiseStrength },
                  noiseDark: { value: this.params.noiseDark },
              },
              vertexShader: `
        varying vec3 vPosition;
        void main() {
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
              fragmentShader: `
        uniform float uTime;
        uniform vec3 baseColor;
        uniform float scanSpeed;
        uniform float scanWidth;
        uniform float minX;
        uniform float maxX;
        uniform float noiseStrength;
        uniform float noiseDark;
        varying vec3 vPosition;
        float random(vec2 st){
          return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }
        void main(){
          float normalizedX=((vPosition.x-minX)/(maxX-minX))*2.0-1.0;
          float scanPosition1=mod(uTime*scanSpeed,2.0+scanWidth*2.0)-1.0-scanWidth;
          float scanPosition2=scanPosition1+2.0+scanWidth*2.0;
          float distance1=abs(normalizedX-scanPosition1);
          float distance2=abs(normalizedX-scanPosition2);
          float distance=min(distance1,distance2);
          float alpha=smoothstep(0.0,scanWidth,distance);
          
          vec2 noiseCoord=gl_FragCoord.xy+uTime*10.0;
          // float noise=random(noiseCoord)*noiseStrength;
          // vec3 finalColor=baseColor+vec3(noise);
          
          float noise = (random(noiseCoord) - noiseDark) * 2.0 * noiseStrength;
          vec3 finalColor = baseColor + vec3(noise);
          gl_FragColor=vec4(finalColor,alpha);
        }
      `,
              side: DoubleSide,
              transparent: true,
              depthWrite: false,
          });
      }
      applyMaterialsToModel(model) {
          const planeNames = Object.keys(this.speedMultipliers);
          const gridColor = new Color(0xff552b);
          model.traverse((child) => {
              if (!(child instanceof Mesh))
                  return;
              const matchedPlane = planeNames.find((n) => child.name.toLowerCase().includes(n));
              if (matchedPlane) {
                  const geo = child.geometry;
                  geo.computeBoundingBox();
                  const bbox = geo.boundingBox;
                  const speed = this.speedMultipliers[matchedPlane] || 1;
                  const mat = this.createGradientShader(bbox.min.x, bbox.max.x, speed);
                  child.material = mat;
                  this.shaderMaterials.push(mat);
                  child.renderOrder = 1;
              }
              else {
                  const materials = Array.isArray(child.material) ? child.material : [child.material];
                  materials.forEach((m) => {
                      if (m.color) {
                          m.color.copy(gridColor);
                          if ("emissive" in m) {
                              m.emissive = gridColor.clone();
                              m.emissiveIntensity = 0.5;
                          }
                      }
                  });
              }
          });
      }
      updateCameraForCover(modelSize, windowAspect) {
          const modelAspect = modelSize.x / modelSize.y;
          let frustumWidth;
          let frustumHeight;
          if (modelAspect > windowAspect) {
              frustumHeight = modelSize.y;
              frustumWidth = frustumHeight * windowAspect;
          }
          else {
              frustumWidth = modelSize.x;
              frustumHeight = frustumWidth / windowAspect;
          }
          this.camera.left = frustumWidth / -2;
          this.camera.right = frustumWidth / 2;
          this.camera.top = frustumHeight / 2;
          this.camera.bottom = frustumHeight / -2;
          this.camera.updateProjectionMatrix();
      }
      loadModel(aspect) {
          const loader = new GLTFLoader();
          const clock = new Clock();
          loader.load(document.body.getAttribute('data-src') + '/assets/model/grid.glb', (gltf) => {
              const temp = gltf.scene.clone();
              const box = new Box3().setFromObject(temp);
              const size = box.getSize(new Vector3());
              const center = box.getCenter(new Vector3());
              const spacing = size.z;
              const positions = [-spacing, 0, spacing];
              const directions = [1, -1, 1];
              positions.forEach((zOffset, modelIndex) => {
                  const instances = [];
                  const direction = directions[modelIndex];
                  for (let i = 0; i < 2; i++) {
                      const group = new Group();
                      const model = gltf.scene.clone();
                      model.position.sub(center);
                      group.add(model);
                      if (modelIndex === 1) {
                          group.rotation.y = Math.PI;
                      }
                      group.position.z = zOffset;
                      group.position.x = i * size.x * direction;
                      group.position.y = modelIndex * 0.001;
                      // console.log(group.position.y)
                      this.applyMaterialsToModel(model);
                      this.scene.add(group);
                      instances.push(group);
                  }
                  this.modelGroups.push({ group: instances[0], direction, instances });
              });
              const totalHeight = spacing * 2 + size.y;
              this.modelSize = new Vector3(size.x, totalHeight, size.z);
              this.updateCameraForCover(this.modelSize, aspect);
              const maxDim = Math.max(size.x, totalHeight, size.z);
              const distance = maxDim * 2;
              this.camera.position.set(0, distance, distance);
              this.camera.lookAt(0, 0, 0);
              this.controls.target.set(0, 0, 0);
              this.controls.update();
              this.animate(clock);
          }, undefined, (e) => console.error("Error loading model:", e));
      }
      animate(clock) {
          const loop = () => {
              requestAnimationFrame(loop);
              const time = clock.getElapsedTime();
              this.shaderMaterials.forEach((m) => (m.uniforms.uTime.value = time));
              if (this.modelSize) {
                  this.modelGroups.forEach(({ direction, instances }) => {
                      instances.forEach((instance) => {
                          instance.position.x += direction * this.params.scrollSpeed * 0.001;
                          if (direction > 0 && instance.position.x > this.modelSize.x) {
                              instance.position.x -= this.modelSize.x * 2;
                          }
                          else if (direction < 0 && instance.position.x < -this.modelSize.x) {
                              instance.position.x += this.modelSize.x * 2;
                          }
                      });
                  });
              }
              this.controls.update();
              this.renderer.render(this.scene, this.camera);
          };
          loop();
      }
      handleResize = () => {
          if (!this.container || !this.modelSize)
              return;
          const aspect = this.container.clientWidth / this.container.clientHeight;
          this.updateCameraForCover(this.modelSize, aspect);
          this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
      };
      destroy() {
          window.removeEventListener("resize", this.handleResize);
          if (this.gui)
              this.gui.destroy();
          this.shaderMaterials.forEach((m) => m.dispose());
          this.renderer.dispose();
          if (this.container && this.renderer.domElement.parentNode === this.container) {
              this.container.removeChild(this.renderer.domElement);
          }
      }
  }

  // @ts-ignore
  // import { RepeatTextScrollFx } from './repeatTextScrollFx';
  class APP {
      constructor() {
          const common = new common$1();
          common.load();
          // new Barba();
          new Page();
          new BudouX();
          if (document.querySelector('#mv')) {
              new GridViewer();
          }
          // new RepeatTextScrollFx();
          // new VFX();
          new GlitchText();
          new Glitch();
      }
  }
  new APP();

})();
